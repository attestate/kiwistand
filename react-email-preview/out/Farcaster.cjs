var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name2 in all2)
    __defProp(target, name2, { get: all2[name2], enumerable: true });
};
var __copyProps = (to4, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to4, key) && key !== except)
        __defProp(to4, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to4;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/react/cjs/react.production.js
var require_react_production = __commonJS({
  "node_modules/react/cjs/react.production.js"(exports2) {
    "use strict";
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    };
    var assign = Object.assign;
    var emptyObject = {};
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {
    }
    ComponentDummy.prototype = Component.prototype;
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl = Array.isArray;
    var ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function ReactElement(type, key, self2, source, owner, props) {
      self2 = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== self2 ? self2 : null,
        props
      };
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(
        oldElement.type,
        newKey,
        void 0,
        void 0,
        void 0,
        oldElement.props
      );
    }
    function isValidElement2(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape3(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index) {
      return "object" === typeof element && null !== element && null != element.key ? escape3("" + element.key) : index.toString(36);
    }
    function noop$1() {
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
            function(fulfilledValue) {
              "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
            },
            function(error) {
              "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
            }
          )), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = false;
      if (null === children) invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(
                  invokeCallback(children._payload),
                  array,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
            }
        }
      if (invokeCallback)
        return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c2) {
          return c2;
        })) : null != callback && (isValidElement2(callback) && (callback = cloneAndReplaceKey(
          callback,
          escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
            userProvidedKeyEscapeRegex,
            "$&/"
          ) + "/") + invokeCallback
        )), array.push(callback)), 1;
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if (i = getIteratorFn(children), "function" === typeof i)
        for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function(moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 1, payload._result = moduleObject;
          },
          function(error) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 2, payload._result = error;
          }
        );
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return payload._result.default;
      throw payload._result;
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    };
    function noop() {
    }
    exports2.Children = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function() {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function(children) {
        var n2 = 0;
        mapChildren(children, function() {
          n2++;
        });
        return n2;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement2(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    exports2.Component = Component;
    exports2.Fragment = REACT_FRAGMENT_TYPE;
    exports2.Profiler = REACT_PROFILER_TYPE;
    exports2.PureComponent = PureComponent;
    exports2.StrictMode = REACT_STRICT_MODE_TYPE;
    exports2.Suspense = REACT_SUSPENSE_TYPE;
    exports2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports2.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function(size) {
        return ReactSharedInternals.H.useMemoCache(size);
      }
    };
    exports2.cache = function(fn4) {
      return function() {
        return fn4.apply(null, arguments);
      };
    };
    exports2.cloneElement = function(element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " + element + "."
        );
      var props = assign({}, element.props), key = element.key, owner = void 0;
      if (null != config)
        for (propName in void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key = "" + config.key), config)
          !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i = 0; i < propName; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      return ReactElement(element.type, key, void 0, void 0, owner, props);
    };
    exports2.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      return defaultValue;
    };
    exports2.createElement = function(type, config, children) {
      var propName, props = {}, key = null;
      if (null != config)
        for (propName in void 0 !== config.key && (key = "" + config.key), config)
          hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) props.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          void 0 === props[propName] && (props[propName] = childrenLength[propName]);
      return ReactElement(type, key, void 0, void 0, null, props);
    };
    exports2.createRef = function() {
      return { current: null };
    };
    exports2.forwardRef = function(render3) {
      return { $$typeof: REACT_FORWARD_REF_TYPE, render: render3 };
    };
    exports2.isValidElement = isValidElement2;
    exports2.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    exports2.memo = function(type, compare) {
      return {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: void 0 === compare ? null : compare
      };
    };
    exports2.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        ReactSharedInternals.T = prevTransition;
      }
    };
    exports2.unstable_useCacheRefresh = function() {
      return ReactSharedInternals.H.useCacheRefresh();
    };
    exports2.use = function(usable) {
      return ReactSharedInternals.H.use(usable);
    };
    exports2.useActionState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useActionState(action, initialState, permalink);
    };
    exports2.useCallback = function(callback, deps) {
      return ReactSharedInternals.H.useCallback(callback, deps);
    };
    exports2.useContext = function(Context) {
      return ReactSharedInternals.H.useContext(Context);
    };
    exports2.useDebugValue = function() {
    };
    exports2.useDeferredValue = function(value, initialValue) {
      return ReactSharedInternals.H.useDeferredValue(value, initialValue);
    };
    exports2.useEffect = function(create, createDeps, update) {
      var dispatcher = ReactSharedInternals.H;
      if ("function" === typeof update)
        throw Error(
          "useEffect CRUD overload is not enabled in this build of React."
        );
      return dispatcher.useEffect(create, createDeps);
    };
    exports2.useId = function() {
      return ReactSharedInternals.H.useId();
    };
    exports2.useImperativeHandle = function(ref, create, deps) {
      return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
    };
    exports2.useInsertionEffect = function(create, deps) {
      return ReactSharedInternals.H.useInsertionEffect(create, deps);
    };
    exports2.useLayoutEffect = function(create, deps) {
      return ReactSharedInternals.H.useLayoutEffect(create, deps);
    };
    exports2.useMemo = function(create, deps) {
      return ReactSharedInternals.H.useMemo(create, deps);
    };
    exports2.useOptimistic = function(passthrough, reducer) {
      return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
    };
    exports2.useReducer = function(reducer, initialArg, init) {
      return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
    };
    exports2.useRef = function(initialValue) {
      return ReactSharedInternals.H.useRef(initialValue);
    };
    exports2.useState = function(initialState) {
      return ReactSharedInternals.H.useState(initialState);
    };
    exports2.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return ReactSharedInternals.H.useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    exports2.useTransition = function() {
      return ReactSharedInternals.H.useTransition();
    };
    exports2.version = "19.1.1";
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports2, module2) {
    "use strict";
    "production" !== process.env.NODE_ENV && (function() {
      function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              info[0],
              info[1]
            );
          }
        });
      }
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          callerName,
          publicInstance
        ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
      }
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function ComponentDummy() {
      }
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e2) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name2 = getComponentNameFromType(type);
          return name2 ? "<" + name2 + ">" : "<...>";
        } catch (x) {
          return "<...>";
        }
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement(type, key, self2, source, owner, props, debugStack, debugTask) {
        self2 = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        newKey = ReactElement(
          oldElement.type,
          newKey,
          void 0,
          void 0,
          oldElement._owner,
          oldElement.props,
          oldElement._debugStack,
          oldElement._debugTask
        );
        oldElement._store && (newKey._store.validated = oldElement._store.validated);
        return newKey;
      }
      function isValidElement2(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape3(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape3("" + element.key)) : index.toString(36);
      }
      function noop$1() {
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback) {
          invokeCallback = children;
          callback = callback(invokeCallback);
          var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
          isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c2) {
            return c2;
          })) : null != callback && (isValidElement2(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + childKey
          ), "" !== nameSoFar && null != invokeCallback && isValidElement2(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
          return 1;
        }
        invokeCallback = 0;
        childKey = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (i === children.entries && (didWarnAboutMaps || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status)
          return ctor = payload._result, void 0 === ctor && console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
            ctor
          ), "default" in ctor || console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
            ctor
          ), ctor.default;
        throw payload._result;
      }
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      function noop() {
      }
      function enqueueTask(task) {
        if (null === enqueueTaskImpl)
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            enqueueTaskImpl = (module2 && module2[requireString]).call(
              module2,
              "timers"
            ).setImmediate;
          } catch (_err) {
            enqueueTaskImpl = function(callback) {
              false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var channel = new MessageChannel();
              channel.port1.onmessage = callback;
              channel.port2.postMessage(void 0);
            };
          }
        return enqueueTaskImpl(task);
      }
      function aggregateErrors(errors) {
        return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
      }
      function popActScope(prevActQueue, prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        );
        actScopeDepth = prevActScopeDepth;
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        var queue = ReactSharedInternals.actQueue;
        if (null !== queue)
          if (0 !== queue.length)
            try {
              flushActQueue(queue);
              enqueueTask(function() {
                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              });
              return;
            } catch (error) {
              ReactSharedInternals.thrownErrors.push(error);
            }
          else ReactSharedInternals.actQueue = null;
        0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
      }
      function flushActQueue(queue) {
        if (!isFlushing) {
          isFlushing = true;
          var i = 0;
          try {
            for (; i < queue.length; i++) {
              var callback = queue[i];
              do {
                ReactSharedInternals.didUsePromise = false;
                var continuation = callback(false);
                if (null !== continuation) {
                  if (ReactSharedInternals.didUsePromise) {
                    queue[i] = callback;
                    queue.splice(0, i);
                    return;
                  }
                  callback = continuation;
                } else break;
              } while (1);
            }
            queue.length = 0;
          } catch (error) {
            queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
          } finally {
            isFlushing = false;
          }
        }
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function(publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      }, assign = Object.assign, emptyObject = {};
      Object.freeze(emptyObject);
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      var deprecatedAPIs = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      }, fnName;
      for (fnName in deprecatedAPIs)
        deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      ComponentDummy.prototype = Component.prototype;
      deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
      deprecatedAPIs.constructor = PureComponent;
      assign(deprecatedAPIs, Component.prototype);
      deprecatedAPIs.isPureReactComponent = true;
      var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null,
        actQueue: null,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false,
        didUsePromise: false,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      deprecatedAPIs = {
        react_stack_bottom_frame: function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
        deprecatedAPIs,
        UnknownOwner
      )();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
        queueMicrotask(function() {
          return queueMicrotask(callback);
        });
      } : enqueueTask;
      deprecatedAPIs = Object.freeze({
        __proto__: null,
        c: function(size) {
          return resolveDispatcher().useMemoCache(size);
        }
      });
      exports2.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n2 = 0;
          mapChildren(children, function() {
            n2++;
          });
          return n2;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement2(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports2.Component = Component;
      exports2.Fragment = REACT_FRAGMENT_TYPE;
      exports2.Profiler = REACT_PROFILER_TYPE;
      exports2.PureComponent = PureComponent;
      exports2.StrictMode = REACT_STRICT_MODE_TYPE;
      exports2.Suspense = REACT_SUSPENSE_TYPE;
      exports2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports2.__COMPILER_RUNTIME = deprecatedAPIs;
      exports2.act = function(callback) {
        var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
        actScopeDepth++;
        var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
        try {
          var result = callback();
        } catch (error) {
          ReactSharedInternals.thrownErrors.push(error);
        }
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        if (null !== result && "object" === typeof result && "function" === typeof result.then) {
          var thenable = result;
          queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          });
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              thenable.then(
                function(returnValue) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  if (0 === prevActScopeDepth) {
                    try {
                      flushActQueue(queue), enqueueTask(function() {
                        return recursivelyFlushAsyncActWork(
                          returnValue,
                          resolve,
                          reject
                        );
                      });
                    } catch (error$0) {
                      ReactSharedInternals.thrownErrors.push(error$0);
                    }
                    if (0 < ReactSharedInternals.thrownErrors.length) {
                      var _thrownError = aggregateErrors(
                        ReactSharedInternals.thrownErrors
                      );
                      ReactSharedInternals.thrownErrors.length = 0;
                      reject(_thrownError);
                    }
                  } else resolve(returnValue);
                },
                function(error) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                    ReactSharedInternals.thrownErrors
                  ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                }
              );
            }
          };
        }
        var returnValue$jscomp$0 = result;
        popActScope(prevActQueue, prevActScopeDepth);
        0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), ReactSharedInternals.actQueue = null);
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        return {
          then: function(resolve, reject) {
            didAwaitActCall = true;
            0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
              return recursivelyFlushAsyncActWork(
                returnValue$jscomp$0,
                resolve,
                reject
              );
            })) : resolve(returnValue$jscomp$0);
          }
        };
      };
      exports2.cache = function(fn4) {
        return function() {
          return fn4.apply(null, arguments);
        };
      };
      exports2.captureOwnerStack = function() {
        var getCurrentStack = ReactSharedInternals.getCurrentStack;
        return null === getCurrentStack ? null : getCurrentStack();
      };
      exports2.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key, owner = element._owner;
        if (null != config) {
          var JSCompiler_inline_result;
          a: {
            if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
              config,
              "ref"
            ).get) && JSCompiler_inline_result.isReactWarning) {
              JSCompiler_inline_result = false;
              break a;
            }
            JSCompiler_inline_result = void 0 !== config.ref;
          }
          JSCompiler_inline_result && (owner = getOwner());
          hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
          for (propName in config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        }
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          JSCompiler_inline_result = Array(propName);
          for (var i = 0; i < propName; i++)
            JSCompiler_inline_result[i] = arguments[i + 2];
          props.children = JSCompiler_inline_result;
        }
        props = ReactElement(
          element.type,
          key,
          void 0,
          void 0,
          owner,
          props,
          element._debugStack,
          element._debugTask
        );
        for (key = 2; key < arguments.length; key++)
          owner = arguments[key], isValidElement2(owner) && owner._store && (owner._store.validated = 1);
        return props;
      };
      exports2.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        defaultValue._currentRenderer = null;
        defaultValue._currentRenderer2 = null;
        return defaultValue;
      };
      exports2.createElement = function(type, config, children) {
        for (var i = 2; i < arguments.length; i++) {
          var node = arguments[i];
          isValidElement2(node) && node._store && (node._store.validated = 1);
        }
        i = {};
        node = null;
        if (null != config)
          for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), hasValidKey(config) && (checkKeyStringCoercion(config.key), node = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) i.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), _i3 = 0; _i3 < childrenLength; _i3++)
            childArray[_i3] = arguments[_i3 + 2];
          Object.freeze && Object.freeze(childArray);
          i.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === i[propName] && (i[propName] = childrenLength[propName]);
        node && defineKeyPropWarningGetter(
          i,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return ReactElement(
          type,
          node,
          void 0,
          void 0,
          getOwner(),
          i,
          propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
      exports2.createRef = function() {
        var refObject = { current: null };
        Object.seal(refObject);
        return refObject;
      };
      exports2.forwardRef = function(render3) {
        null != render3 && render3.$$typeof === REACT_MEMO_TYPE ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : "function" !== typeof render3 ? console.error(
          "forwardRef requires a render function but was given %s.",
          null === render3 ? "null" : typeof render3
        ) : 0 !== render3.length && 2 !== render3.length && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          1 === render3.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        );
        null != render3 && null != render3.defaultProps && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render: render3 }, ownName;
        Object.defineProperty(elementType, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name2) {
            ownName = name2;
            render3.name || render3.displayName || (Object.defineProperty(render3, "name", { value: name2 }), render3.displayName = name2);
          }
        });
        return elementType;
      };
      exports2.isValidElement = isValidElement2;
      exports2.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports2.memo = function(type, compare) {
        null == type && console.error(
          "memo: The first argument must be a component. Instead received: %s",
          null === type ? "null" : typeof type
        );
        compare = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
        var ownName;
        Object.defineProperty(compare, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name2) {
            ownName = name2;
            type.name || type.displayName || (Object.defineProperty(type, "name", { value: name2 }), type.displayName = name2);
          }
        });
        return compare;
      };
      exports2.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        currentTransition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), ReactSharedInternals.T = prevTransition;
        }
      };
      exports2.unstable_useCacheRefresh = function() {
        return resolveDispatcher().useCacheRefresh();
      };
      exports2.use = function(usable) {
        return resolveDispatcher().use(usable);
      };
      exports2.useActionState = function(action, initialState, permalink) {
        return resolveDispatcher().useActionState(
          action,
          initialState,
          permalink
        );
      };
      exports2.useCallback = function(callback, deps) {
        return resolveDispatcher().useCallback(callback, deps);
      };
      exports2.useContext = function(Context) {
        var dispatcher = resolveDispatcher();
        Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        );
        return dispatcher.useContext(Context);
      };
      exports2.useDebugValue = function(value, formatterFn) {
        return resolveDispatcher().useDebugValue(value, formatterFn);
      };
      exports2.useDeferredValue = function(value, initialValue) {
        return resolveDispatcher().useDeferredValue(value, initialValue);
      };
      exports2.useEffect = function(create, createDeps, update) {
        null == create && console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        var dispatcher = resolveDispatcher();
        if ("function" === typeof update)
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return dispatcher.useEffect(create, createDeps);
      };
      exports2.useId = function() {
        return resolveDispatcher().useId();
      };
      exports2.useImperativeHandle = function(ref, create, deps) {
        return resolveDispatcher().useImperativeHandle(ref, create, deps);
      };
      exports2.useInsertionEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useInsertionEffect(create, deps);
      };
      exports2.useLayoutEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useLayoutEffect(create, deps);
      };
      exports2.useMemo = function(create, deps) {
        return resolveDispatcher().useMemo(create, deps);
      };
      exports2.useOptimistic = function(passthrough, reducer) {
        return resolveDispatcher().useOptimistic(passthrough, reducer);
      };
      exports2.useReducer = function(reducer, initialArg, init) {
        return resolveDispatcher().useReducer(reducer, initialArg, init);
      };
      exports2.useRef = function(initialValue) {
        return resolveDispatcher().useRef(initialValue);
      };
      exports2.useState = function(initialState) {
        return resolveDispatcher().useState(initialState);
      };
      exports2.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return resolveDispatcher().useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports2.useTransition = function() {
        return resolveDispatcher().useTransition();
      };
      exports2.version = "19.1.1";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_production();
    } else {
      module2.exports = require_react_development();
    }
  }
});

// node_modules/react/cjs/react-jsx-runtime.production.js
var require_react_jsx_runtime_production = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.production.js"(exports2) {
    "use strict";
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    function jsxProd(type, config, maybeKey) {
      var key = null;
      void 0 !== maybeKey && (key = "" + maybeKey);
      void 0 !== config.key && (key = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      config = maybeKey.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== config ? config : null,
        props: maybeKey
      };
    }
    exports2.Fragment = REACT_FRAGMENT_TYPE;
    exports2.jsx = jsxProd;
    exports2.jsxs = jsxProd;
  }
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports2) {
    "use strict";
    "production" !== process.env.NODE_ENV && (function() {
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e2) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name2 = getComponentNameFromType(type);
          return name2 ? "<" + name2 + ">" : "<...>";
        } catch (x) {
          return "<...>";
        }
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement(type, key, self2, source, owner, props, debugStack, debugTask) {
        self2 = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self2, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children)
          if (isStaticChildren)
            if (isArrayImpl(children)) {
              for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                validateChildKeys(children[isStaticChildren]);
              Object.freeze && Object.freeze(children);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
          children = getComponentNameFromType(type);
          var keys = Object.keys(config).filter(function(k3) {
            return "key" !== k3;
          });
          isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
          didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
            isStaticChildren,
            children,
            keys,
            children
          ), didWarnAboutKeySpread[children + isStaticChildren] = true);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(
          maybeKey,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        return ReactElement(
          type,
          children,
          self2,
          source,
          getOwner(),
          maybeKey,
          debugStack,
          debugTask
        );
      }
      function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
      }
      var React12 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React12.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      React12 = {
        react_stack_bottom_frame: function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = React12.react_stack_bottom_frame.bind(
        React12,
        UnknownOwner
      )();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutKeySpread = {};
      exports2.Fragment = REACT_FRAGMENT_TYPE;
      exports2.jsx = function(type, config, maybeKey, source, self2) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type,
          config,
          maybeKey,
          false,
          source,
          self2,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
      exports2.jsxs = function(type, config, maybeKey, source, self2) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type,
          config,
          maybeKey,
          true,
          source,
          self2,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
    })();
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_jsx_runtime_production();
    } else {
      module2.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports2, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_3) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module2.exports = deepmerge_1;
  }
});

// node_modules/react-dom/cjs/react-dom.production.js
var require_react_dom_production = __commonJS({
  "node_modules/react-dom/cjs/react-dom.production.js"(exports2) {
    "use strict";
    var React12 = require_react();
    function formatProdErrorMessage(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i = 2; i < arguments.length; i++)
          url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function noop() {
    }
    var Internals = {
      d: {
        f: noop,
        r: function() {
          throw Error(formatProdErrorMessage(522));
        },
        D: noop,
        C: noop,
        L: noop,
        m: noop,
        X: noop,
        S: noop,
        M: noop
      },
      p: 0,
      findDOMNode: null
    };
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    var ReactSharedInternals = React12.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function getCrossOriginStringAs(as3, input) {
      if ("font" === as3) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    exports2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    exports2.createPortal = function(children, container2) {
      var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!container2 || 1 !== container2.nodeType && 9 !== container2.nodeType && 11 !== container2.nodeType)
        throw Error(formatProdErrorMessage(299));
      return createPortal$1(children, container2, null, key);
    };
    exports2.flushSync = function(fn4) {
      var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn4) return fn4();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
      }
    };
    exports2.preconnect = function(href, options) {
      "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
    };
    exports2.prefetchDNS = function(href) {
      "string" === typeof href && Internals.d.D(href);
    };
    exports2.preinit = function(href, options) {
      if ("string" === typeof href && options && "string" === typeof options.as) {
        var as3 = options.as, crossOrigin = getCrossOriginStringAs(as3, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
        "style" === as3 ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin,
            integrity,
            fetchPriority
          }
        ) : "script" === as3 && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    };
    exports2.preinitModule = function(href, options) {
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as) {
            var crossOrigin = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            );
            Internals.d.M(href, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        } else null == options && Internals.d.M(href);
    };
    exports2.preload = function(href, options) {
      if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
        var as3 = options.as, crossOrigin = getCrossOriginStringAs(as3, options.crossOrigin);
        Internals.d.L(href, as3, {
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
          referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
          imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
          imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    exports2.preloadModule = function(href, options) {
      if ("string" === typeof href)
        if (options) {
          var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
          Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          });
        } else Internals.d.m(href);
    };
    exports2.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    exports2.unstable_batchedUpdates = function(fn4, a) {
      return fn4(a);
    };
    exports2.useFormState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useFormState(action, initialState, permalink);
    };
    exports2.useFormStatus = function() {
      return ReactSharedInternals.H.useHostTransitionStatus();
    };
    exports2.version = "19.1.1";
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom.development.js"(exports2) {
    "use strict";
    "production" !== process.env.NODE_ENV && (function() {
      function noop() {
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        try {
          testStringCoercion(key);
          var JSCompiler_inline_result = false;
        } catch (e2) {
          JSCompiler_inline_result = true;
        }
        JSCompiler_inline_result && (console.error(
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
        ), testStringCoercion(key));
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      function getCrossOriginStringAs(as3, input) {
        if ("font" === as3) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      function getValueDescriptorExpectingObjectForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
      }
      function getValueDescriptorExpectingEnumForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
      }
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React12 = require_react(), Internals = {
        d: {
          f: noop,
          r: function() {
            throw Error(
              "Invalid form element. requestFormReset must be passed a form that was rendered by React."
            );
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React12.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
      );
      exports2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports2.createPortal = function(children, container2) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container2 || 1 !== container2.nodeType && 9 !== container2.nodeType && 11 !== container2.nodeType)
          throw Error("Target container is not a DOM element.");
        return createPortal$1(children, container2, null, key);
      };
      exports2.flushSync = function(fn4) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn4)
            return fn4();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
            "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
          );
        }
      };
      exports2.preconnect = function(href, options) {
        "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
          "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
          getValueDescriptorExpectingEnumForWarning(options)
        ) : null != options && "string" !== typeof options.crossOrigin && console.error(
          "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
          getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
        ) : console.error(
          "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      exports2.prefetchDNS = function(href) {
        if ("string" !== typeof href || !href)
          console.error(
            "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
        else if (1 < arguments.length) {
          var options = arguments[1];
          "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options)
          );
        }
        "string" === typeof href && Internals.d.D(href);
      };
      exports2.preinit = function(href, options) {
        "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
          "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
          getValueDescriptorExpectingEnumForWarning(options)
        ) : "style" !== options.as && "script" !== options.as && console.error(
          'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
          getValueDescriptorExpectingEnumForWarning(options.as)
        ) : console.error(
          "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as3 = options.as, crossOrigin = getCrossOriginStringAs(as3, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as3 ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as3 && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      exports2.preinitModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
        if (encountered)
          console.error(
            "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
            encountered
          );
        else
          switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
            case "script":
              break;
            default:
              encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                encountered,
                href
              );
          }
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as)
              encountered = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              ), Internals.d.M(href, {
                crossOrigin: encountered,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
          } else null == options && Internals.d.M(href);
      };
      exports2.preload = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error(
          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
          encountered
        );
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          encountered = options.as;
          var crossOrigin = getCrossOriginStringAs(
            encountered,
            options.crossOrigin
          );
          Internals.d.L(href, encountered, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      exports2.preloadModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error(
          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
          encountered
        );
        "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
          options.as,
          options.crossOrigin
        ), Internals.d.m(href, {
          as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
          crossOrigin: encountered,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0
        })) : Internals.d.m(href));
      };
      exports2.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports2.unstable_batchedUpdates = function(fn4, a) {
        return fn4(a);
      };
      exports2.useFormState = function(action, initialState, permalink) {
        return resolveDispatcher().useFormState(action, initialState, permalink);
      };
      exports2.useFormStatus = function() {
        return resolveDispatcher().useHostTransitionStatus();
      };
      exports2.version = "19.1.1";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports2, module2) {
    "use strict";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      if (process.env.NODE_ENV !== "production") {
        throw new Error("^_^");
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    if (process.env.NODE_ENV === "production") {
      checkDCE();
      module2.exports = require_react_dom_production();
    } else {
      module2.exports = require_react_dom_development();
    }
  }
});

// node_modules/react-dom/cjs/react-dom-server-legacy.node.production.js
var require_react_dom_server_legacy_node_production = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server-legacy.node.production.js"(exports2) {
    "use strict";
    var React12 = require_react();
    var ReactDOM = require_react_dom();
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_SCOPE_TYPE = Symbol.for("react.scope");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    var REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    var isArrayImpl = Array.isArray;
    function murmurhash3_32_gc(key, seed) {
      var remainder = key.length & 3;
      var bytes = key.length - remainder;
      var h1 = seed;
      for (seed = 0; seed < bytes; ) {
        var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
        ++seed;
        k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
        h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
        case 2:
          k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
        case 1:
          k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
      }
      h1 ^= key.length;
      h1 ^= h1 >>> 16;
      h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
      h1 ^= h1 >>> 13;
      h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
      return (h1 ^ h1 >>> 16) >>> 0;
    }
    var assign = Object.assign;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    );
    var illegalAttributeNameCache = {};
    var validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
        return true;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return validatedAttributeNameCache[attributeName] = true;
      illegalAttributeNameCache[attributeName] = true;
      return false;
    }
    var unitlessNumbers = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    );
    var aliases = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]);
    var matchHtmlRegExp = /["'&<>]/;
    function escapeTextForBrowser(text) {
      if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text)
        return "" + text;
      text = "" + text;
      var match = matchHtmlRegExp.exec(text);
      if (match) {
        var html = "", index, lastIndex = 0;
        for (index = match.index; index < text.length; index++) {
          switch (text.charCodeAt(index)) {
            case 34:
              match = "&quot;";
              break;
            case 38:
              match = "&amp;";
              break;
            case 39:
              match = "&#x27;";
              break;
            case 60:
              match = "&lt;";
              break;
            case 62:
              match = "&gt;";
              break;
            default:
              continue;
          }
          lastIndex !== index && (html += text.slice(lastIndex, index));
          lastIndex = index + 1;
          html += match;
        }
        text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
      }
      return text;
    }
    var uppercasePattern = /([A-Z])/g;
    var msPattern = /^ms-/;
    var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
    }
    var ReactSharedInternals = React12.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    var ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    var sharedNotPendingObject = {
      pending: false,
      data: null,
      method: null,
      action: null
    };
    var previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: previousDispatcher.f,
      r: previousDispatcher.r,
      D: prefetchDNS,
      C: preconnect,
      L: preload,
      m: preloadModule,
      X: preinitScript,
      S: preinitStyle,
      M: preinitModuleScript
    };
    var PRELOAD_NO_CREDS = [];
    var scriptRegex = /(<\/|<)(s)(cript)/gi;
    function scriptReplacer(match, prefix2, s2, suffix2) {
      return "" + prefix2 + ("s" === s2 ? "\\u0073" : "\\u0053") + suffix2;
    }
    function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
      return {
        idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
        nextFormID: 0,
        streamingFormat: 0,
        bootstrapScriptContent,
        bootstrapScripts,
        bootstrapModules,
        instructions: 0,
        hasBody: false,
        hasHtml: false,
        unknownResources: {},
        dnsResources: {},
        connectResources: { default: {}, anonymous: {}, credentials: {} },
        imageResources: {},
        styleResources: {},
        scriptResources: {},
        moduleUnknownResources: {},
        moduleScriptResources: {}
      };
    }
    function createPreambleState() {
      return {
        htmlChunks: null,
        headChunks: null,
        bodyChunks: null,
        contribution: 0
      };
    }
    function createFormatContext(insertionMode, selectedValue, tagScope) {
      return {
        insertionMode,
        selectedValue,
        tagScope
      };
    }
    function getChildFormatContext(parentContext, type, props) {
      switch (type) {
        case "noscript":
          return createFormatContext(2, null, parentContext.tagScope | 1);
        case "select":
          return createFormatContext(
            2,
            null != props.value ? props.value : props.defaultValue,
            parentContext.tagScope
          );
        case "svg":
          return createFormatContext(4, null, parentContext.tagScope);
        case "picture":
          return createFormatContext(2, null, parentContext.tagScope | 2);
        case "math":
          return createFormatContext(5, null, parentContext.tagScope);
        case "foreignObject":
          return createFormatContext(2, null, parentContext.tagScope);
        case "table":
          return createFormatContext(6, null, parentContext.tagScope);
        case "thead":
        case "tbody":
        case "tfoot":
          return createFormatContext(7, null, parentContext.tagScope);
        case "colgroup":
          return createFormatContext(9, null, parentContext.tagScope);
        case "tr":
          return createFormatContext(8, null, parentContext.tagScope);
        case "head":
          if (2 > parentContext.insertionMode)
            return createFormatContext(3, null, parentContext.tagScope);
          break;
        case "html":
          if (0 === parentContext.insertionMode)
            return createFormatContext(1, null, parentContext.tagScope);
      }
      return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode ? createFormatContext(2, null, parentContext.tagScope) : parentContext;
    }
    var styleNameCache = /* @__PURE__ */ new Map();
    function pushStyleAttribute(target, style) {
      if ("object" !== typeof style)
        throw Error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      var isFirst = true, styleName;
      for (styleName in style)
        if (hasOwnProperty.call(style, styleName)) {
          var styleValue = style[styleName];
          if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
            if (0 === styleName.indexOf("--")) {
              var nameChunk = escapeTextForBrowser(styleName);
              styleValue = escapeTextForBrowser(("" + styleValue).trim());
            } else
              nameChunk = styleNameCache.get(styleName), void 0 === nameChunk && (nameChunk = escapeTextForBrowser(
                styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")
              ), styleNameCache.set(styleName, nameChunk)), styleValue = "number" === typeof styleValue ? 0 === styleValue || unitlessNumbers.has(styleName) ? "" + styleValue : styleValue + "px" : escapeTextForBrowser(("" + styleValue).trim());
            isFirst ? (isFirst = false, target.push(' style="', nameChunk, ":", styleValue)) : target.push(";", nameChunk, ":", styleValue);
          }
        }
      isFirst || target.push('"');
    }
    function pushBooleanAttribute(target, name2, value) {
      value && "function" !== typeof value && "symbol" !== typeof value && target.push(" ", name2, '=""');
    }
    function pushStringAttribute(target, name2, value) {
      "function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(" ", name2, '="', escapeTextForBrowser(value), '"');
    }
    var actionJavaScriptURL = escapeTextForBrowser(
      "javascript:throw new Error('React form unexpectedly submitted.')"
    );
    function pushAdditionalFormField(value, key) {
      this.push('<input type="hidden"');
      validateAdditionalFormField(value);
      pushStringAttribute(this, "name", key);
      pushStringAttribute(this, "value", value);
      this.push("/>");
    }
    function validateAdditionalFormField(value) {
      if ("string" !== typeof value)
        throw Error(
          "File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration."
        );
    }
    function getCustomFormFields(resumableState, formAction) {
      if ("function" === typeof formAction.$$FORM_ACTION) {
        var id = resumableState.nextFormID++;
        resumableState = resumableState.idPrefix + id;
        try {
          var customFields = formAction.$$FORM_ACTION(resumableState);
          if (customFields) {
            var formData = customFields.data;
            null != formData && formData.forEach(validateAdditionalFormField);
          }
          return customFields;
        } catch (x) {
          if ("object" === typeof x && null !== x && "function" === typeof x.then)
            throw x;
        }
      }
      return null;
    }
    function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name2) {
      var formData = null;
      if ("function" === typeof formAction) {
        var customFields = getCustomFormFields(resumableState, formAction);
        null !== customFields ? (name2 = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(" ", "formAction", '="', actionJavaScriptURL, '"'), formTarget = formMethod = formEncType = formAction = name2 = null, injectFormReplayingRuntime(resumableState, renderState));
      }
      null != name2 && pushAttribute(target, "name", name2);
      null != formAction && pushAttribute(target, "formAction", formAction);
      null != formEncType && pushAttribute(target, "formEncType", formEncType);
      null != formMethod && pushAttribute(target, "formMethod", formMethod);
      null != formTarget && pushAttribute(target, "formTarget", formTarget);
      return formData;
    }
    function pushAttribute(target, name2, value) {
      switch (name2) {
        case "className":
          pushStringAttribute(target, "class", value);
          break;
        case "tabIndex":
          pushStringAttribute(target, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          pushStringAttribute(target, name2, value);
          break;
        case "style":
          pushStyleAttribute(target, value);
          break;
        case "src":
        case "href":
          if ("" === value) break;
        case "action":
        case "formAction":
          if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
            break;
          value = sanitizeURL("" + value);
          target.push(" ", name2, '="', escapeTextForBrowser(value), '"');
          break;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "ref":
          break;
        case "autoFocus":
        case "multiple":
        case "muted":
          pushBooleanAttribute(target, name2.toLowerCase(), value);
          break;
        case "xlinkHref":
          if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
            break;
          value = sanitizeURL("" + value);
          target.push(" ", "xlink:href", '="', escapeTextForBrowser(value), '"');
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          "function" !== typeof value && "symbol" !== typeof value && target.push(" ", name2, '="', escapeTextForBrowser(value), '"');
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value && target.push(" ", name2, '=""');
          break;
        case "capture":
        case "download":
          true === value ? target.push(" ", name2, '=""') : false !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(" ", name2, '="', escapeTextForBrowser(value), '"');
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(" ", name2, '="', escapeTextForBrowser(value), '"');
          break;
        case "rowSpan":
        case "start":
          "function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(" ", name2, '="', escapeTextForBrowser(value), '"');
          break;
        case "xlinkActuate":
          pushStringAttribute(target, "xlink:actuate", value);
          break;
        case "xlinkArcrole":
          pushStringAttribute(target, "xlink:arcrole", value);
          break;
        case "xlinkRole":
          pushStringAttribute(target, "xlink:role", value);
          break;
        case "xlinkShow":
          pushStringAttribute(target, "xlink:show", value);
          break;
        case "xlinkTitle":
          pushStringAttribute(target, "xlink:title", value);
          break;
        case "xlinkType":
          pushStringAttribute(target, "xlink:type", value);
          break;
        case "xmlBase":
          pushStringAttribute(target, "xml:base", value);
          break;
        case "xmlLang":
          pushStringAttribute(target, "xml:lang", value);
          break;
        case "xmlSpace":
          pushStringAttribute(target, "xml:space", value);
          break;
        default:
          if (!(2 < name2.length) || "o" !== name2[0] && "O" !== name2[0] || "n" !== name2[1] && "N" !== name2[1]) {
            if (name2 = aliases.get(name2) || name2, isAttributeNameSafe(name2)) {
              switch (typeof value) {
                case "function":
                case "symbol":
                  return;
                case "boolean":
                  var prefix$8 = name2.toLowerCase().slice(0, 5);
                  if ("data-" !== prefix$8 && "aria-" !== prefix$8) return;
              }
              target.push(" ", name2, '="', escapeTextForBrowser(value), '"');
            }
          }
      }
    }
    function pushInnerHTML(target, innerHTML, children) {
      if (null != innerHTML) {
        if (null != children)
          throw Error(
            "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
          );
        if ("object" !== typeof innerHTML || !("__html" in innerHTML))
          throw Error(
            "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
          );
        innerHTML = innerHTML.__html;
        null !== innerHTML && void 0 !== innerHTML && target.push("" + innerHTML);
      }
    }
    function flattenOptionChildren(children) {
      var content = "";
      React12.Children.forEach(children, function(child) {
        null != child && (content += child);
      });
      return content;
    }
    function injectFormReplayingRuntime(resumableState, renderState) {
      0 === (resumableState.instructions & 16) && (resumableState.instructions |= 16, renderState.bootstrapChunks.unshift(
        renderState.startInlineScript,
        `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`,
        "</script>"
      ));
    }
    function pushLinkImpl(target, props) {
      target.push(startChunkForTag("link"));
      for (var propKey in props)
        if (hasOwnProperty.call(props, propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(
                  "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                );
              default:
                pushAttribute(target, propKey, propValue);
            }
        }
      target.push("/>");
      return null;
    }
    var styleRegex = /(<\/|<)(s)(tyle)/gi;
    function styleReplacer(match, prefix2, s2, suffix2) {
      return "" + prefix2 + ("s" === s2 ? "\\73 " : "\\53 ") + suffix2;
    }
    function pushSelfClosing(target, props, tag) {
      target.push(startChunkForTag(tag));
      for (var propKey in props)
        if (hasOwnProperty.call(props, propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(
                  tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                );
              default:
                pushAttribute(target, propKey, propValue);
            }
        }
      target.push("/>");
      return null;
    }
    function pushTitleImpl(target, props) {
      target.push(startChunkForTag("title"));
      var children = null, innerHTML = null, propKey;
      for (propKey in props)
        if (hasOwnProperty.call(props, propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, propKey, propValue);
            }
        }
      target.push(">");
      props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
      "function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(escapeTextForBrowser("" + props));
      pushInnerHTML(target, innerHTML, children);
      target.push(endChunkForTag("title"));
      return null;
    }
    function pushScriptImpl(target, props) {
      target.push(startChunkForTag("script"));
      var children = null, innerHTML = null, propKey;
      for (propKey in props)
        if (hasOwnProperty.call(props, propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, propKey, propValue);
            }
        }
      target.push(">");
      pushInnerHTML(target, innerHTML, children);
      "string" === typeof children && target.push(("" + children).replace(scriptRegex, scriptReplacer));
      target.push(endChunkForTag("script"));
      return null;
    }
    function pushStartSingletonElement(target, props, tag) {
      target.push(startChunkForTag(tag));
      var innerHTML = tag = null, propKey;
      for (propKey in props)
        if (hasOwnProperty.call(props, propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "children":
                tag = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, propKey, propValue);
            }
        }
      target.push(">");
      pushInnerHTML(target, innerHTML, tag);
      return tag;
    }
    function pushStartGenericElement(target, props, tag) {
      target.push(startChunkForTag(tag));
      var innerHTML = tag = null, propKey;
      for (propKey in props)
        if (hasOwnProperty.call(props, propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "children":
                tag = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, propKey, propValue);
            }
        }
      target.push(">");
      pushInnerHTML(target, innerHTML, tag);
      return "string" === typeof tag ? (target.push(escapeTextForBrowser(tag)), null) : tag;
    }
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var validatedTagCache = /* @__PURE__ */ new Map();
    function startChunkForTag(tag) {
      var tagStartChunk = validatedTagCache.get(tag);
      if (void 0 === tagStartChunk) {
        if (!VALID_TAG_REGEX.test(tag)) throw Error("Invalid tag: " + tag);
        tagStartChunk = "<" + tag;
        validatedTagCache.set(tag, tagStartChunk);
      }
      return tagStartChunk;
    }
    function pushStartInstance(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded, isFallback) {
      switch (type) {
        case "div":
        case "span":
        case "svg":
        case "path":
          break;
        case "a":
          target$jscomp$0.push(startChunkForTag("a"));
          var children = null, innerHTML = null, propKey;
          for (propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "href":
                    "" === propValue ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                    break;
                  default:
                    pushAttribute(target$jscomp$0, propKey, propValue);
                }
            }
          target$jscomp$0.push(">");
          pushInnerHTML(target$jscomp$0, innerHTML, children);
          if ("string" === typeof children) {
            target$jscomp$0.push(escapeTextForBrowser(children));
            var JSCompiler_inline_result = null;
          } else JSCompiler_inline_result = children;
          return JSCompiler_inline_result;
        case "g":
        case "p":
        case "li":
          break;
        case "select":
          target$jscomp$0.push(startChunkForTag("select"));
          var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
          for (propKey$jscomp$0 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$0)) {
              var propValue$jscomp$0 = props[propKey$jscomp$0];
              if (null != propValue$jscomp$0)
                switch (propKey$jscomp$0) {
                  case "children":
                    children$jscomp$0 = propValue$jscomp$0;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$0 = propValue$jscomp$0;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$0,
                      propValue$jscomp$0
                    );
                }
            }
          target$jscomp$0.push(">");
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
          return children$jscomp$0;
        case "option":
          var selectedValue = formatContext.selectedValue;
          target$jscomp$0.push(startChunkForTag("option"));
          var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
          for (propKey$jscomp$1 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$1)) {
              var propValue$jscomp$1 = props[propKey$jscomp$1];
              if (null != propValue$jscomp$1)
                switch (propKey$jscomp$1) {
                  case "children":
                    children$jscomp$1 = propValue$jscomp$1;
                    break;
                  case "selected":
                    selected = propValue$jscomp$1;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$1 = propValue$jscomp$1;
                    break;
                  case "value":
                    value = propValue$jscomp$1;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$1,
                      propValue$jscomp$1
                    );
                }
            }
          if (null != selectedValue) {
            var stringValue = null !== value ? "" + value : flattenOptionChildren(children$jscomp$1);
            if (isArrayImpl(selectedValue))
              for (var i = 0; i < selectedValue.length; i++) {
                if ("" + selectedValue[i] === stringValue) {
                  target$jscomp$0.push(' selected=""');
                  break;
                }
              }
            else
              "" + selectedValue === stringValue && target$jscomp$0.push(' selected=""');
          } else selected && target$jscomp$0.push(' selected=""');
          target$jscomp$0.push(">");
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
          return children$jscomp$1;
        case "textarea":
          target$jscomp$0.push(startChunkForTag("textarea"));
          var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
          for (propKey$jscomp$2 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$2)) {
              var propValue$jscomp$2 = props[propKey$jscomp$2];
              if (null != propValue$jscomp$2)
                switch (propKey$jscomp$2) {
                  case "children":
                    children$jscomp$2 = propValue$jscomp$2;
                    break;
                  case "value":
                    value$jscomp$0 = propValue$jscomp$2;
                    break;
                  case "defaultValue":
                    defaultValue = propValue$jscomp$2;
                    break;
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$2,
                      propValue$jscomp$2
                    );
                }
            }
          null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
          target$jscomp$0.push(">");
          if (null != children$jscomp$2) {
            if (null != value$jscomp$0)
              throw Error(
                "If you supply `defaultValue` on a <textarea>, do not pass children."
              );
            if (isArrayImpl(children$jscomp$2)) {
              if (1 < children$jscomp$2.length)
                throw Error("<textarea> can only have at most one child.");
              value$jscomp$0 = "" + children$jscomp$2[0];
            }
            value$jscomp$0 = "" + children$jscomp$2;
          }
          "string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push("\n");
          null !== value$jscomp$0 && target$jscomp$0.push(escapeTextForBrowser("" + value$jscomp$0));
          return null;
        case "input":
          target$jscomp$0.push(startChunkForTag("input"));
          var name2 = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
          for (propKey$jscomp$3 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$3)) {
              var propValue$jscomp$3 = props[propKey$jscomp$3];
              if (null != propValue$jscomp$3)
                switch (propKey$jscomp$3) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      "input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  case "name":
                    name2 = propValue$jscomp$3;
                    break;
                  case "formAction":
                    formAction = propValue$jscomp$3;
                    break;
                  case "formEncType":
                    formEncType = propValue$jscomp$3;
                    break;
                  case "formMethod":
                    formMethod = propValue$jscomp$3;
                    break;
                  case "formTarget":
                    formTarget = propValue$jscomp$3;
                    break;
                  case "defaultChecked":
                    defaultChecked = propValue$jscomp$3;
                    break;
                  case "defaultValue":
                    defaultValue$jscomp$0 = propValue$jscomp$3;
                    break;
                  case "checked":
                    checked = propValue$jscomp$3;
                    break;
                  case "value":
                    value$jscomp$1 = propValue$jscomp$3;
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$3,
                      propValue$jscomp$3
                    );
                }
            }
          var formData = pushFormActionAttribute(
            target$jscomp$0,
            resumableState,
            renderState,
            formAction,
            formEncType,
            formMethod,
            formTarget,
            name2
          );
          null !== checked ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
          null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
          target$jscomp$0.push("/>");
          null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);
          return null;
        case "button":
          target$jscomp$0.push(startChunkForTag("button"));
          var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
          for (propKey$jscomp$4 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$4)) {
              var propValue$jscomp$4 = props[propKey$jscomp$4];
              if (null != propValue$jscomp$4)
                switch (propKey$jscomp$4) {
                  case "children":
                    children$jscomp$3 = propValue$jscomp$4;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$2 = propValue$jscomp$4;
                    break;
                  case "name":
                    name$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formAction":
                    formAction$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formEncType":
                    formEncType$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formMethod":
                    formMethod$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formTarget":
                    formTarget$jscomp$0 = propValue$jscomp$4;
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$4,
                      propValue$jscomp$4
                    );
                }
            }
          var formData$jscomp$0 = pushFormActionAttribute(
            target$jscomp$0,
            resumableState,
            renderState,
            formAction$jscomp$0,
            formEncType$jscomp$0,
            formMethod$jscomp$0,
            formTarget$jscomp$0,
            name$jscomp$0
          );
          target$jscomp$0.push(">");
          null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
          if ("string" === typeof children$jscomp$3) {
            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));
            var JSCompiler_inline_result$jscomp$0 = null;
          } else JSCompiler_inline_result$jscomp$0 = children$jscomp$3;
          return JSCompiler_inline_result$jscomp$0;
        case "form":
          target$jscomp$0.push(startChunkForTag("form"));
          var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
          for (propKey$jscomp$5 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$5)) {
              var propValue$jscomp$5 = props[propKey$jscomp$5];
              if (null != propValue$jscomp$5)
                switch (propKey$jscomp$5) {
                  case "children":
                    children$jscomp$4 = propValue$jscomp$5;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$3 = propValue$jscomp$5;
                    break;
                  case "action":
                    formAction$jscomp$1 = propValue$jscomp$5;
                    break;
                  case "encType":
                    formEncType$jscomp$1 = propValue$jscomp$5;
                    break;
                  case "method":
                    formMethod$jscomp$1 = propValue$jscomp$5;
                    break;
                  case "target":
                    formTarget$jscomp$1 = propValue$jscomp$5;
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$5,
                      propValue$jscomp$5
                    );
                }
            }
          var formData$jscomp$1 = null, formActionName = null;
          if ("function" === typeof formAction$jscomp$1) {
            var customFields = getCustomFormFields(
              resumableState,
              formAction$jscomp$1
            );
            null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(
              " ",
              "action",
              '="',
              actionJavaScriptURL,
              '"'
            ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
          }
          null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
          null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
          null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
          null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
          target$jscomp$0.push(">");
          null !== formActionName && (target$jscomp$0.push('<input type="hidden"'), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push("/>"), null != formData$jscomp$1 && formData$jscomp$1.forEach(pushAdditionalFormField, target$jscomp$0));
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
          if ("string" === typeof children$jscomp$4) {
            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));
            var JSCompiler_inline_result$jscomp$1 = null;
          } else JSCompiler_inline_result$jscomp$1 = children$jscomp$4;
          return JSCompiler_inline_result$jscomp$1;
        case "menuitem":
          target$jscomp$0.push(startChunkForTag("menuitem"));
          for (var propKey$jscomp$6 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$6)) {
              var propValue$jscomp$6 = props[propKey$jscomp$6];
              if (null != propValue$jscomp$6)
                switch (propKey$jscomp$6) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      "menuitems cannot have `children` nor `dangerouslySetInnerHTML`."
                    );
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$6,
                      propValue$jscomp$6
                    );
                }
            }
          target$jscomp$0.push(">");
          return null;
        case "object":
          target$jscomp$0.push(startChunkForTag("object"));
          var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
          for (propKey$jscomp$7 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$7)) {
              var propValue$jscomp$7 = props[propKey$jscomp$7];
              if (null != propValue$jscomp$7)
                switch (propKey$jscomp$7) {
                  case "children":
                    children$jscomp$5 = propValue$jscomp$7;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$4 = propValue$jscomp$7;
                    break;
                  case "data":
                    var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                    if ("" === sanitizedValue) break;
                    target$jscomp$0.push(
                      " ",
                      "data",
                      '="',
                      escapeTextForBrowser(sanitizedValue),
                      '"'
                    );
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$7,
                      propValue$jscomp$7
                    );
                }
            }
          target$jscomp$0.push(">");
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
          if ("string" === typeof children$jscomp$5) {
            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));
            var JSCompiler_inline_result$jscomp$2 = null;
          } else JSCompiler_inline_result$jscomp$2 = children$jscomp$5;
          return JSCompiler_inline_result$jscomp$2;
        case "title":
          if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp)
            var JSCompiler_inline_result$jscomp$3 = pushTitleImpl(
              target$jscomp$0,
              props
            );
          else
            isFallback ? JSCompiler_inline_result$jscomp$3 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$3 = void 0);
          return JSCompiler_inline_result$jscomp$3;
        case "link":
          var rel = props.rel, href = props.href, precedence = props.precedence;
          if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
            pushLinkImpl(target$jscomp$0, props);
            var JSCompiler_inline_result$jscomp$4 = null;
          } else if ("stylesheet" === props.rel)
            if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError)
              JSCompiler_inline_result$jscomp$4 = pushLinkImpl(
                target$jscomp$0,
                props
              );
            else {
              var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
              if (null !== resourceState) {
                resumableState.styleResources[href] = null;
                styleQueue || (styleQueue = {
                  precedence: escapeTextForBrowser(precedence),
                  rules: [],
                  hrefs: [],
                  sheets: /* @__PURE__ */ new Map()
                }, renderState.styles.set(precedence, styleQueue));
                var resource = {
                  state: 0,
                  props: assign({}, props, {
                    "data-precedence": props.precedence,
                    precedence: null
                  })
                };
                if (resourceState) {
                  2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);
                  var preloadResource = renderState.preloads.stylesheets.get(href);
                  preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = 1;
                }
                styleQueue.sheets.set(href, resource);
                hoistableState && hoistableState.stylesheets.add(resource);
              } else if (styleQueue) {
                var resource$9 = styleQueue.sheets.get(href);
                resource$9 && hoistableState && hoistableState.stylesheets.add(resource$9);
              }
              textEmbedded && target$jscomp$0.push("<!-- -->");
              JSCompiler_inline_result$jscomp$4 = null;
            }
          else
            props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$4 = pushLinkImpl(
              target$jscomp$0,
              props
            ) : (textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$4 = isFallback ? null : pushLinkImpl(renderState.hoistableChunks, props));
          return JSCompiler_inline_result$jscomp$4;
        case "script":
          var asyncProp = props.async;
          if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || 4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp)
            var JSCompiler_inline_result$jscomp$5 = pushScriptImpl(
              target$jscomp$0,
              props
            );
          else {
            var key = props.src;
            if ("module" === props.type) {
              var resources = resumableState.moduleScriptResources;
              var preloads = renderState.preloads.moduleScripts;
            } else
              resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
            var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
            if (null !== resourceState$jscomp$0) {
              resources[key] = null;
              var scriptProps = props;
              if (resourceState$jscomp$0) {
                2 === resourceState$jscomp$0.length && (scriptProps = assign({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
                var preloadResource$jscomp$0 = preloads.get(key);
                preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
              }
              var resource$jscomp$0 = [];
              renderState.scripts.add(resource$jscomp$0);
              pushScriptImpl(resource$jscomp$0, scriptProps);
            }
            textEmbedded && target$jscomp$0.push("<!-- -->");
            JSCompiler_inline_result$jscomp$5 = null;
          }
          return JSCompiler_inline_result$jscomp$5;
        case "style":
          var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href;
          if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
            target$jscomp$0.push(startChunkForTag("style"));
            var children$jscomp$6 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
            for (propKey$jscomp$8 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$8)) {
                var propValue$jscomp$8 = props[propKey$jscomp$8];
                if (null != propValue$jscomp$8)
                  switch (propKey$jscomp$8) {
                    case "children":
                      children$jscomp$6 = propValue$jscomp$8;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$5 = propValue$jscomp$8;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$8,
                        propValue$jscomp$8
                      );
                  }
              }
            target$jscomp$0.push(">");
            var child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
            "function" !== typeof child && "symbol" !== typeof child && null !== child && void 0 !== child && target$jscomp$0.push(("" + child).replace(styleRegex, styleReplacer));
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$6);
            target$jscomp$0.push(endChunkForTag("style"));
            var JSCompiler_inline_result$jscomp$6 = null;
          } else {
            var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0);
            if (null !== (resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0)) {
              resumableState.styleResources[href$jscomp$0] = null;
              styleQueue$jscomp$0 ? styleQueue$jscomp$0.hrefs.push(
                escapeTextForBrowser(href$jscomp$0)
              ) : (styleQueue$jscomp$0 = {
                precedence: escapeTextForBrowser(precedence$jscomp$0),
                rules: [],
                hrefs: [escapeTextForBrowser(href$jscomp$0)],
                sheets: /* @__PURE__ */ new Map()
              }, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));
              var target = styleQueue$jscomp$0.rules, children$jscomp$7 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
              for (propKey$jscomp$9 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$9)) {
                  var propValue$jscomp$9 = props[propKey$jscomp$9];
                  if (null != propValue$jscomp$9)
                    switch (propKey$jscomp$9) {
                      case "children":
                        children$jscomp$7 = propValue$jscomp$9;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$6 = propValue$jscomp$9;
                    }
                }
              var child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
              "function" !== typeof child$jscomp$0 && "symbol" !== typeof child$jscomp$0 && null !== child$jscomp$0 && void 0 !== child$jscomp$0 && target.push(
                ("" + child$jscomp$0).replace(styleRegex, styleReplacer)
              );
              pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$7);
            }
            styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
            textEmbedded && target$jscomp$0.push("<!-- -->");
            JSCompiler_inline_result$jscomp$6 = void 0;
          }
          return JSCompiler_inline_result$jscomp$6;
        case "meta":
          if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp)
            var JSCompiler_inline_result$jscomp$7 = pushSelfClosing(
              target$jscomp$0,
              props,
              "meta"
            );
          else
            textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$7 = isFallback ? null : "string" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(renderState.hoistableChunks, props, "meta");
          return JSCompiler_inline_result$jscomp$7;
        case "listing":
        case "pre":
          target$jscomp$0.push(startChunkForTag(type));
          var children$jscomp$8 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
          for (propKey$jscomp$10 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$10)) {
              var propValue$jscomp$10 = props[propKey$jscomp$10];
              if (null != propValue$jscomp$10)
                switch (propKey$jscomp$10) {
                  case "children":
                    children$jscomp$8 = propValue$jscomp$10;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$7 = propValue$jscomp$10;
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$10,
                      propValue$jscomp$10
                    );
                }
            }
          target$jscomp$0.push(">");
          if (null != innerHTML$jscomp$7) {
            if (null != children$jscomp$8)
              throw Error(
                "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
              );
            if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            var html = innerHTML$jscomp$7.__html;
            null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push("\n", html) : target$jscomp$0.push("" + html));
          }
          "string" === typeof children$jscomp$8 && "\n" === children$jscomp$8[0] && target$jscomp$0.push("\n");
          return children$jscomp$8;
        case "img":
          var src = props.src, srcSet = props.srcSet;
          if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet) && "low" !== props.fetchPriority && false === !!(formatContext.tagScope & 3) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
            var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
            if (resource$jscomp$1) {
              if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size)
                promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
            } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
              resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
              var input = props.crossOrigin;
              var JSCompiler_inline_result$jscomp$8 = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
              var headers = renderState.headers, header;
              headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
                imageSrcSet: props.srcSet,
                imageSizes: props.sizes,
                crossOrigin: JSCompiler_inline_result$jscomp$8,
                integrity: props.integrity,
                nonce: props.nonce,
                type: props.type,
                fetchPriority: props.fetchPriority,
                referrerPolicy: props.refererPolicy
              }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
                rel: "preload",
                as: "image",
                href: srcSet ? void 0 : src,
                imageSrcSet: srcSet,
                imageSizes: sizes,
                crossOrigin: JSCompiler_inline_result$jscomp$8,
                integrity: props.integrity,
                type: props.type,
                fetchPriority: props.fetchPriority,
                referrerPolicy: props.referrerPolicy
              }), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
            }
          }
          return pushSelfClosing(target$jscomp$0, props, "img");
        case "base":
        case "area":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return pushSelfClosing(target$jscomp$0, props, type);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          break;
        case "head":
          if (2 > formatContext.insertionMode) {
            var preamble = preambleState || renderState.preamble;
            if (preamble.headChunks)
              throw Error("The `<head>` tag may only be rendered once.");
            preamble.headChunks = [];
            var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(
              preamble.headChunks,
              props,
              "head"
            );
          } else
            JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
              target$jscomp$0,
              props,
              "head"
            );
          return JSCompiler_inline_result$jscomp$9;
        case "body":
          if (2 > formatContext.insertionMode) {
            var preamble$jscomp$0 = preambleState || renderState.preamble;
            if (preamble$jscomp$0.bodyChunks)
              throw Error("The `<body>` tag may only be rendered once.");
            preamble$jscomp$0.bodyChunks = [];
            var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(
              preamble$jscomp$0.bodyChunks,
              props,
              "body"
            );
          } else
            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
              target$jscomp$0,
              props,
              "body"
            );
          return JSCompiler_inline_result$jscomp$10;
        case "html":
          if (0 === formatContext.insertionMode) {
            var preamble$jscomp$1 = preambleState || renderState.preamble;
            if (preamble$jscomp$1.htmlChunks)
              throw Error("The `<html>` tag may only be rendered once.");
            preamble$jscomp$1.htmlChunks = [""];
            var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(
              preamble$jscomp$1.htmlChunks,
              props,
              "html"
            );
          } else
            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
              target$jscomp$0,
              props,
              "html"
            );
          return JSCompiler_inline_result$jscomp$11;
        default:
          if (-1 !== type.indexOf("-")) {
            target$jscomp$0.push(startChunkForTag(type));
            var children$jscomp$9 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
            for (propKey$jscomp$11 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$11)) {
                var propValue$jscomp$11 = props[propKey$jscomp$11];
                if (null != propValue$jscomp$11) {
                  var attributeName = propKey$jscomp$11;
                  switch (propKey$jscomp$11) {
                    case "children":
                      children$jscomp$9 = propValue$jscomp$11;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$8 = propValue$jscomp$11;
                      break;
                    case "style":
                      pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                      break;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "ref":
                      break;
                    case "className":
                      attributeName = "class";
                    default:
                      if (isAttributeNameSafe(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {
                        if (true === propValue$jscomp$11) propValue$jscomp$11 = "";
                        else if ("object" === typeof propValue$jscomp$11) continue;
                        target$jscomp$0.push(
                          " ",
                          attributeName,
                          '="',
                          escapeTextForBrowser(propValue$jscomp$11),
                          '"'
                        );
                      }
                  }
                }
              }
            target$jscomp$0.push(">");
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$9);
            return children$jscomp$9;
          }
      }
      return pushStartGenericElement(target$jscomp$0, props, type);
    }
    var endTagCache = /* @__PURE__ */ new Map();
    function endChunkForTag(tag) {
      var chunk = endTagCache.get(tag);
      void 0 === chunk && (chunk = "</" + tag + ">", endTagCache.set(tag, chunk));
      return chunk;
    }
    function hoistPreambleState(renderState, preambleState) {
      renderState = renderState.preamble;
      null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks, preambleState.contribution |= 1);
      null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks, preambleState.contribution |= 4);
      null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks, preambleState.contribution |= 2);
    }
    function writeBootstrap(destination, renderState) {
      renderState = renderState.bootstrapChunks;
      for (var i = 0; i < renderState.length - 1; i++)
        destination.push(renderState[i]);
      return i < renderState.length ? (i = renderState[i], renderState.length = 0, destination.push(i)) : true;
    }
    function writeStartPendingSuspenseBoundary(destination, renderState, id) {
      destination.push('<!--$?--><template id="');
      if (null === id)
        throw Error(
          "An ID must have been assigned before we can complete the boundary."
        );
      destination.push(renderState.boundaryPrefix);
      renderState = id.toString(16);
      destination.push(renderState);
      return destination.push('"></template>');
    }
    function writePreambleContribution(destination, preambleState) {
      preambleState = preambleState.contribution;
      0 !== preambleState && (destination.push("<!--"), destination.push("" + preambleState), destination.push("-->"));
    }
    function writeStartSegment(destination, renderState, formatContext, id) {
      switch (formatContext.insertionMode) {
        case 0:
        case 1:
        case 3:
        case 2:
          return destination.push('<div hidden id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
        case 4:
          return destination.push('<svg aria-hidden="true" style="display:none" id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
        case 5:
          return destination.push('<math aria-hidden="true" style="display:none" id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
        case 6:
          return destination.push('<table hidden id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
        case 7:
          return destination.push('<table hidden><tbody id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
        case 8:
          return destination.push('<table hidden><tr id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
        case 9:
          return destination.push('<table hidden><colgroup id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function writeEndSegment(destination, formatContext) {
      switch (formatContext.insertionMode) {
        case 0:
        case 1:
        case 3:
        case 2:
          return destination.push("</div>");
        case 4:
          return destination.push("</svg>");
        case 5:
          return destination.push("</math>");
        case 6:
          return destination.push("</table>");
        case 7:
          return destination.push("</tbody></table>");
        case 8:
          return destination.push("</tr></table>");
        case 9:
          return destination.push("</colgroup></table>");
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g;
    function escapeJSStringsForInstructionScripts(input) {
      return JSON.stringify(input).replace(
        regexForJSStringsInInstructionScripts,
        function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default:
              throw Error(
                "escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
              );
          }
        }
      );
    }
    var regexForJSStringsInScripts = /[&><\u2028\u2029]/g;
    function escapeJSObjectForInstructionScripts(input) {
      return JSON.stringify(input).replace(
        regexForJSStringsInScripts,
        function(match) {
          switch (match) {
            case "&":
              return "\\u0026";
            case ">":
              return "\\u003e";
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default:
              throw Error(
                "escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
              );
          }
        }
      );
    }
    var currentlyRenderingBoundaryHasStylesToHoist = false;
    var destinationHasCapacity = true;
    function flushStyleTagsLateForBoundary(styleQueue) {
      var rules = styleQueue.rules, hrefs = styleQueue.hrefs, i = 0;
      if (hrefs.length) {
        this.push('<style media="not all" data-precedence="');
        this.push(styleQueue.precedence);
        for (this.push('" data-href="'); i < hrefs.length - 1; i++)
          this.push(hrefs[i]), this.push(" ");
        this.push(hrefs[i]);
        this.push('">');
        for (i = 0; i < rules.length; i++) this.push(rules[i]);
        destinationHasCapacity = this.push("</style>");
        currentlyRenderingBoundaryHasStylesToHoist = true;
        rules.length = 0;
        hrefs.length = 0;
      }
    }
    function hasStylesToHoist(stylesheet) {
      return 2 !== stylesheet.state ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
    }
    function writeHoistablesForBoundary(destination, hoistableState, renderState) {
      currentlyRenderingBoundaryHasStylesToHoist = false;
      destinationHasCapacity = true;
      hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
      hoistableState.stylesheets.forEach(hasStylesToHoist);
      currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
      return destinationHasCapacity;
    }
    function flushResource(resource) {
      for (var i = 0; i < resource.length; i++) this.push(resource[i]);
      resource.length = 0;
    }
    var stylesheetFlushingQueue = [];
    function flushStyleInPreamble(stylesheet) {
      pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
      for (var i = 0; i < stylesheetFlushingQueue.length; i++)
        this.push(stylesheetFlushingQueue[i]);
      stylesheetFlushingQueue.length = 0;
      stylesheet.state = 2;
    }
    function flushStylesInPreamble(styleQueue) {
      var hasStylesheets = 0 < styleQueue.sheets.size;
      styleQueue.sheets.forEach(flushStyleInPreamble, this);
      styleQueue.sheets.clear();
      var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
      if (!hasStylesheets || hrefs.length) {
        this.push('<style data-precedence="');
        this.push(styleQueue.precedence);
        styleQueue = 0;
        if (hrefs.length) {
          for (this.push('" data-href="'); styleQueue < hrefs.length - 1; styleQueue++)
            this.push(hrefs[styleQueue]), this.push(" ");
          this.push(hrefs[styleQueue]);
        }
        this.push('">');
        for (styleQueue = 0; styleQueue < rules.length; styleQueue++)
          this.push(rules[styleQueue]);
        this.push("</style>");
        rules.length = 0;
        hrefs.length = 0;
      }
    }
    function preloadLateStyle(stylesheet) {
      if (0 === stylesheet.state) {
        stylesheet.state = 1;
        var props = stylesheet.props;
        pushLinkImpl(stylesheetFlushingQueue, {
          rel: "preload",
          as: "style",
          href: stylesheet.props.href,
          crossOrigin: props.crossOrigin,
          fetchPriority: props.fetchPriority,
          integrity: props.integrity,
          media: props.media,
          hrefLang: props.hrefLang,
          referrerPolicy: props.referrerPolicy
        });
        for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)
          this.push(stylesheetFlushingQueue[stylesheet]);
        stylesheetFlushingQueue.length = 0;
      }
    }
    function preloadLateStyles(styleQueue) {
      styleQueue.sheets.forEach(preloadLateStyle, this);
      styleQueue.sheets.clear();
    }
    function writeStyleResourceDependenciesInJS(destination, hoistableState) {
      destination.push("[");
      var nextArrayOpenBrackChunk = "[";
      hoistableState.stylesheets.forEach(function(resource) {
        if (2 !== resource.state)
          if (3 === resource.state)
            destination.push(nextArrayOpenBrackChunk), resource = escapeJSObjectForInstructionScripts(
              "" + resource.props.href
            ), destination.push(resource), destination.push("]"), nextArrayOpenBrackChunk = ",[";
          else {
            destination.push(nextArrayOpenBrackChunk);
            var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
            coercedHref = escapeJSObjectForInstructionScripts(coercedHref);
            destination.push(coercedHref);
            precedence = "" + precedence;
            destination.push(",");
            precedence = escapeJSObjectForInstructionScripts(precedence);
            destination.push(precedence);
            for (var propKey in props)
              if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], null != precedence))
                switch (propKey) {
                  case "href":
                  case "rel":
                  case "precedence":
                  case "data-precedence":
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    writeStyleResourceAttributeInJS(
                      destination,
                      propKey,
                      precedence
                    );
                }
            destination.push("]");
            nextArrayOpenBrackChunk = ",[";
            resource.state = 3;
          }
      });
      destination.push("]");
    }
    function writeStyleResourceAttributeInJS(destination, name2, value) {
      var attributeName = name2.toLowerCase();
      switch (typeof value) {
        case "function":
        case "symbol":
          return;
      }
      switch (name2) {
        case "innerHTML":
        case "dangerouslySetInnerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "style":
        case "ref":
          return;
        case "className":
          attributeName = "class";
          name2 = "" + value;
          break;
        case "hidden":
          if (false === value) return;
          name2 = "";
          break;
        case "src":
        case "href":
          value = sanitizeURL(value);
          name2 = "" + value;
          break;
        default:
          if (2 < name2.length && ("o" === name2[0] || "O" === name2[0]) && ("n" === name2[1] || "N" === name2[1]) || !isAttributeNameSafe(name2))
            return;
          name2 = "" + value;
      }
      destination.push(",");
      attributeName = escapeJSObjectForInstructionScripts(attributeName);
      destination.push(attributeName);
      destination.push(",");
      attributeName = escapeJSObjectForInstructionScripts(name2);
      destination.push(attributeName);
    }
    function createHoistableState() {
      return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set() };
    }
    function prefetchDNS(href) {
      var request = currentRequest ? currentRequest : null;
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if ("string" === typeof href && href) {
          if (!resumableState.dnsResources.hasOwnProperty(href)) {
            resumableState.dnsResources[href] = null;
            resumableState = renderState.headers;
            var header, JSCompiler_temp;
            if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
              JSCompiler_temp = (header = "<" + ("" + href).replace(
                regexForHrefInLinkHeaderURLContext,
                escapeHrefForLinkHeaderURLContextReplacer
              ) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
            JSCompiler_temp ? (renderState.resets.dns[href] = null, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
          }
          enqueueFlush(request);
        }
      } else previousDispatcher.D(href);
    }
    function preconnect(href, crossOrigin) {
      var request = currentRequest ? currentRequest : null;
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if ("string" === typeof href && href) {
          var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
          if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
            resumableState.connectResources[bucket][href] = null;
            resumableState = renderState.headers;
            var header, JSCompiler_temp;
            if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
              JSCompiler_temp = "<" + ("" + href).replace(
                regexForHrefInLinkHeaderURLContext,
                escapeHrefForLinkHeaderURLContextReplacer
              ) + ">; rel=preconnect";
              if ("string" === typeof crossOrigin) {
                var escapedCrossOrigin = ("" + crossOrigin).replace(
                  regexForLinkHeaderQuotedParamValueContext,
                  escapeStringForLinkHeaderQuotedParamValueContextReplacer
                );
                JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
              }
              JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
            }
            JSCompiler_temp ? (renderState.resets.connect[bucket][href] = null, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
              rel: "preconnect",
              href,
              crossOrigin
            }), renderState.preconnects.add(bucket));
          }
          enqueueFlush(request);
        }
      } else previousDispatcher.C(href, crossOrigin);
    }
    function preload(href, as3, options) {
      var request = currentRequest ? currentRequest : null;
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if (as3 && href) {
          switch (as3) {
            case "image":
              if (options) {
                var imageSrcSet = options.imageSrcSet;
                var imageSizes = options.imageSizes;
                var fetchPriority = options.fetchPriority;
              }
              var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
              if (resumableState.imageResources.hasOwnProperty(key)) return;
              resumableState.imageResources[key] = PRELOAD_NO_CREDS;
              resumableState = renderState.headers;
              var header;
              resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader(href, as3, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(
                resumableState,
                assign(
                  { rel: "preload", href: imageSrcSet ? void 0 : href, as: as3 },
                  options
                )
              ), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
              break;
            case "style":
              if (resumableState.styleResources.hasOwnProperty(href)) return;
              imageSrcSet = [];
              pushLinkImpl(
                imageSrcSet,
                assign({ rel: "preload", href, as: as3 }, options)
              );
              resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
              renderState.preloads.stylesheets.set(href, imageSrcSet);
              renderState.bulkPreloads.add(imageSrcSet);
              break;
            case "script":
              if (resumableState.scriptResources.hasOwnProperty(href)) return;
              imageSrcSet = [];
              renderState.preloads.scripts.set(href, imageSrcSet);
              renderState.bulkPreloads.add(imageSrcSet);
              pushLinkImpl(
                imageSrcSet,
                assign({ rel: "preload", href, as: as3 }, options)
              );
              resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
              break;
            default:
              if (resumableState.unknownResources.hasOwnProperty(as3)) {
                if (imageSrcSet = resumableState.unknownResources[as3], imageSrcSet.hasOwnProperty(href))
                  return;
              } else
                imageSrcSet = {}, resumableState.unknownResources[as3] = imageSrcSet;
              imageSrcSet[href] = PRELOAD_NO_CREDS;
              if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as3 && (key = getPreloadAsHeader(href, as3, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
                renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
              else
                switch (resumableState = [], href = assign({ rel: "preload", href, as: as3 }, options), pushLinkImpl(resumableState, href), as3) {
                  case "font":
                    renderState.fontPreloads.add(resumableState);
                    break;
                  default:
                    renderState.bulkPreloads.add(resumableState);
                }
          }
          enqueueFlush(request);
        }
      } else previousDispatcher.L(href, as3, options);
    }
    function preloadModule(href, options) {
      var request = currentRequest ? currentRequest : null;
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if (href) {
          var as3 = options && "string" === typeof options.as ? options.as : "script";
          switch (as3) {
            case "script":
              if (resumableState.moduleScriptResources.hasOwnProperty(href)) return;
              as3 = [];
              resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
              renderState.preloads.moduleScripts.set(href, as3);
              break;
            default:
              if (resumableState.moduleUnknownResources.hasOwnProperty(as3)) {
                var resources = resumableState.unknownResources[as3];
                if (resources.hasOwnProperty(href)) return;
              } else
                resources = {}, resumableState.moduleUnknownResources[as3] = resources;
              as3 = [];
              resources[href] = PRELOAD_NO_CREDS;
          }
          pushLinkImpl(as3, assign({ rel: "modulepreload", href }, options));
          renderState.bulkPreloads.add(as3);
          enqueueFlush(request);
        }
      } else previousDispatcher.m(href, options);
    }
    function preinitStyle(href, precedence, options) {
      var request = currentRequest ? currentRequest : null;
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if (href) {
          precedence = precedence || "default";
          var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
          null !== resourceState && (resumableState.styleResources[href] = null, styleQueue || (styleQueue = {
            precedence: escapeTextForBrowser(precedence),
            rules: [],
            hrefs: [],
            sheets: /* @__PURE__ */ new Map()
          }, renderState.styles.set(precedence, styleQueue)), precedence = {
            state: 0,
            props: assign(
              { rel: "stylesheet", href, "data-precedence": precedence },
              options
            )
          }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = 1), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
        }
      } else previousDispatcher.S(href, precedence, options);
    }
    function preinitScript(src, options) {
      var request = currentRequest ? currentRequest : null;
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if (src) {
          var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : void 0;
          null !== resourceState && (resumableState.scriptResources[src] = null, options = assign({ src, async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
        }
      } else previousDispatcher.X(src, options);
    }
    function preinitModuleScript(src, options) {
      var request = currentRequest ? currentRequest : null;
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if (src) {
          var resourceState = resumableState.moduleScriptResources.hasOwnProperty(
            src
          ) ? resumableState.moduleScriptResources[src] : void 0;
          null !== resourceState && (resumableState.moduleScriptResources[src] = null, options = assign({ src, type: "module", async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
        }
      } else previousDispatcher.M(src, options);
    }
    function adoptPreloadCredentials(target, preloadState) {
      null == target.crossOrigin && (target.crossOrigin = preloadState[0]);
      null == target.integrity && (target.integrity = preloadState[1]);
    }
    function getPreloadAsHeader(href, as3, params) {
      href = ("" + href).replace(
        regexForHrefInLinkHeaderURLContext,
        escapeHrefForLinkHeaderURLContextReplacer
      );
      as3 = ("" + as3).replace(
        regexForLinkHeaderQuotedParamValueContext,
        escapeStringForLinkHeaderQuotedParamValueContextReplacer
      );
      as3 = "<" + href + '>; rel=preload; as="' + as3 + '"';
      for (var paramName in params)
        hasOwnProperty.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as3 += "; " + paramName.toLowerCase() + '="' + ("" + href).replace(
          regexForLinkHeaderQuotedParamValueContext,
          escapeStringForLinkHeaderQuotedParamValueContextReplacer
        ) + '"'));
      return as3;
    }
    var regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g;
    function escapeHrefForLinkHeaderURLContextReplacer(match) {
      switch (match) {
        case "<":
          return "%3C";
        case ">":
          return "%3E";
        case "\n":
          return "%0A";
        case "\r":
          return "%0D";
        default:
          throw Error(
            "escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
          );
      }
    }
    var regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g;
    function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {
      switch (match) {
        case '"':
          return "%22";
        case "'":
          return "%27";
        case ";":
          return "%3B";
        case ",":
          return "%2C";
        case "\n":
          return "%0A";
        case "\r":
          return "%0D";
        default:
          throw Error(
            "escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
          );
      }
    }
    function hoistStyleQueueDependency(styleQueue) {
      this.styles.add(styleQueue);
    }
    function hoistStylesheetDependency(stylesheet) {
      this.stylesheets.add(stylesheet);
    }
    function createRenderState(resumableState, generateStaticMarkup) {
      var idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
      void 0 !== bootstrapScriptContent && bootstrapChunks.push(
        "<script>",
        ("" + bootstrapScriptContent).replace(scriptRegex, scriptReplacer),
        "</script>"
      );
      bootstrapScriptContent = idPrefix + "P:";
      var JSCompiler_object_inline_segmentPrefix_1542 = idPrefix + "S:";
      idPrefix += "B:";
      var JSCompiler_object_inline_preamble_1545 = createPreambleState(), JSCompiler_object_inline_preconnects_1555 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_fontPreloads_1556 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_highImagePreloads_1557 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_styles_1558 = /* @__PURE__ */ new Map(), JSCompiler_object_inline_bootstrapScripts_1559 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_scripts_1560 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_bulkPreloads_1561 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_preloads_1562 = {
        images: /* @__PURE__ */ new Map(),
        stylesheets: /* @__PURE__ */ new Map(),
        scripts: /* @__PURE__ */ new Map(),
        moduleScripts: /* @__PURE__ */ new Map()
      };
      if (void 0 !== bootstrapScripts)
        for (var i = 0; i < bootstrapScripts.length; i++) {
          var scriptConfig = bootstrapScripts[i], src, crossOrigin = void 0, integrity = void 0, props = {
            rel: "preload",
            as: "script",
            fetchPriority: "low",
            nonce: void 0
          };
          "string" === typeof scriptConfig ? props.href = src = scriptConfig : (props.href = src = scriptConfig.src, props.integrity = integrity = "string" === typeof scriptConfig.integrity ? scriptConfig.integrity : void 0, props.crossOrigin = crossOrigin = "string" === typeof scriptConfig || null == scriptConfig.crossOrigin ? void 0 : "use-credentials" === scriptConfig.crossOrigin ? "use-credentials" : "");
          scriptConfig = resumableState;
          var href = src;
          scriptConfig.scriptResources[href] = null;
          scriptConfig.moduleScriptResources[href] = null;
          scriptConfig = [];
          pushLinkImpl(scriptConfig, props);
          JSCompiler_object_inline_bootstrapScripts_1559.add(scriptConfig);
          bootstrapChunks.push('<script src="', escapeTextForBrowser(src));
          "string" === typeof integrity && bootstrapChunks.push('" integrity="', escapeTextForBrowser(integrity));
          "string" === typeof crossOrigin && bootstrapChunks.push(
            '" crossorigin="',
            escapeTextForBrowser(crossOrigin)
          );
          bootstrapChunks.push('" async=""></script>');
        }
      if (void 0 !== bootstrapModules)
        for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++)
          props = bootstrapModules[bootstrapScripts], crossOrigin = src = void 0, integrity = {
            rel: "modulepreload",
            fetchPriority: "low",
            nonce: void 0
          }, "string" === typeof props ? integrity.href = i = props : (integrity.href = i = props.src, integrity.integrity = crossOrigin = "string" === typeof props.integrity ? props.integrity : void 0, integrity.crossOrigin = src = "string" === typeof props || null == props.crossOrigin ? void 0 : "use-credentials" === props.crossOrigin ? "use-credentials" : ""), props = resumableState, scriptConfig = i, props.scriptResources[scriptConfig] = null, props.moduleScriptResources[scriptConfig] = null, props = [], pushLinkImpl(props, integrity), JSCompiler_object_inline_bootstrapScripts_1559.add(props), bootstrapChunks.push(
            '<script type="module" src="',
            escapeTextForBrowser(i)
          ), "string" === typeof crossOrigin && bootstrapChunks.push(
            '" integrity="',
            escapeTextForBrowser(crossOrigin)
          ), "string" === typeof src && bootstrapChunks.push('" crossorigin="', escapeTextForBrowser(src)), bootstrapChunks.push('" async=""></script>');
      return {
        placeholderPrefix: bootstrapScriptContent,
        segmentPrefix: JSCompiler_object_inline_segmentPrefix_1542,
        boundaryPrefix: idPrefix,
        startInlineScript: "<script>",
        preamble: JSCompiler_object_inline_preamble_1545,
        externalRuntimeScript: null,
        bootstrapChunks,
        importMapChunks: [],
        onHeaders: void 0,
        headers: null,
        resets: {
          font: {},
          dns: {},
          connect: { default: {}, anonymous: {}, credentials: {} },
          image: {},
          style: {}
        },
        charsetChunks: [],
        viewportChunks: [],
        hoistableChunks: [],
        preconnects: JSCompiler_object_inline_preconnects_1555,
        fontPreloads: JSCompiler_object_inline_fontPreloads_1556,
        highImagePreloads: JSCompiler_object_inline_highImagePreloads_1557,
        styles: JSCompiler_object_inline_styles_1558,
        bootstrapScripts: JSCompiler_object_inline_bootstrapScripts_1559,
        scripts: JSCompiler_object_inline_scripts_1560,
        bulkPreloads: JSCompiler_object_inline_bulkPreloads_1561,
        preloads: JSCompiler_object_inline_preloads_1562,
        stylesToHoist: false,
        generateStaticMarkup
      };
    }
    function pushTextInstance(target, text, renderState, textEmbedded) {
      if (renderState.generateStaticMarkup)
        return target.push(escapeTextForBrowser(text)), false;
      "" === text ? target = textEmbedded : (textEmbedded && target.push("<!-- -->"), target.push(escapeTextForBrowser(text)), target = true);
      return target;
    }
    function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {
      renderState.generateStaticMarkup || lastPushedText && textEmbedded && target.push("<!-- -->");
    }
    var bind = Function.prototype.bind;
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {
            }
        }
      return null;
    }
    var emptyContextObject = {};
    var currentActiveSnapshot = null;
    function popToNearestCommonAncestor(prev, next) {
      if (prev !== next) {
        prev.context._currentValue2 = prev.parentValue;
        prev = prev.parent;
        var parentNext = next.parent;
        if (null === prev) {
          if (null !== parentNext)
            throw Error(
              "The stacks must reach the root at the same time. This is a bug in React."
            );
        } else {
          if (null === parentNext)
            throw Error(
              "The stacks must reach the root at the same time. This is a bug in React."
            );
          popToNearestCommonAncestor(prev, parentNext);
        }
        next.context._currentValue2 = next.value;
      }
    }
    function popAllPrevious(prev) {
      prev.context._currentValue2 = prev.parentValue;
      prev = prev.parent;
      null !== prev && popAllPrevious(prev);
    }
    function pushAllNext(next) {
      var parentNext = next.parent;
      null !== parentNext && pushAllNext(parentNext);
      next.context._currentValue2 = next.value;
    }
    function popPreviousToCommonLevel(prev, next) {
      prev.context._currentValue2 = prev.parentValue;
      prev = prev.parent;
      if (null === prev)
        throw Error(
          "The depth must equal at least at zero before reaching the root. This is a bug in React."
        );
      prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
    }
    function popNextToCommonLevel(prev, next) {
      var parentNext = next.parent;
      if (null === parentNext)
        throw Error(
          "The depth must equal at least at zero before reaching the root. This is a bug in React."
        );
      prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
      next.context._currentValue2 = next.value;
    }
    function switchContext(newSnapshot) {
      var prev = currentActiveSnapshot;
      prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
    }
    var classComponentUpdater = {
      enqueueSetState: function(inst, payload) {
        inst = inst._reactInternals;
        null !== inst.queue && inst.queue.push(payload);
      },
      enqueueReplaceState: function(inst, payload) {
        inst = inst._reactInternals;
        inst.replace = true;
        inst.queue = [payload];
      },
      enqueueForceUpdate: function() {
      }
    };
    var emptyTreeContext = { id: 1, overflow: "" };
    function pushTreeContext(baseContext, totalChildren, index) {
      var baseIdWithLeadingBit = baseContext.id;
      baseContext = baseContext.overflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        return {
          id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
          overflow: length + baseContext
        };
      }
      return {
        id: 1 << length | index << baseLength | baseIdWithLeadingBit,
        overflow: baseContext
      };
    }
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
    var log = Math.log;
    var LN2 = Math.LN2;
    function clz32Fallback(x) {
      x >>>= 0;
      return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
    }
    var SuspenseException = Error(
      "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
    );
    function noop$2() {
    }
    function trackUsedThenable(thenableState2, thenable, index) {
      index = thenableState2[index];
      void 0 === index ? thenableState2.push(thenable) : index !== thenable && (thenable.then(noop$2, noop$2), thenable = index);
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          "string" === typeof thenable.status ? thenable.then(noop$2, noop$2) : (thenableState2 = thenable, thenableState2.status = "pending", thenableState2.then(
            function(fulfilledValue) {
              if ("pending" === thenable.status) {
                var fulfilledThenable = thenable;
                fulfilledThenable.status = "fulfilled";
                fulfilledThenable.value = fulfilledValue;
              }
            },
            function(error) {
              if ("pending" === thenable.status) {
                var rejectedThenable = thenable;
                rejectedThenable.status = "rejected";
                rejectedThenable.reason = error;
              }
            }
          ));
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
          suspendedThenable = thenable;
          throw SuspenseException;
      }
    }
    var suspendedThenable = null;
    function getSuspendedThenable() {
      if (null === suspendedThenable)
        throw Error(
          "Expected a suspended thenable. This is a bug in React. Please file an issue."
        );
      var thenable = suspendedThenable;
      suspendedThenable = null;
      return thenable;
    }
    function is3(x, y2) {
      return x === y2 && (0 !== x || 1 / x === 1 / y2) || x !== x && y2 !== y2;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is3;
    var currentlyRenderingComponent = null;
    var currentlyRenderingTask = null;
    var currentlyRenderingRequest = null;
    var currentlyRenderingKeyPath = null;
    var firstWorkInProgressHook = null;
    var workInProgressHook = null;
    var isReRender = false;
    var didScheduleRenderPhaseUpdate = false;
    var localIdCounter = 0;
    var actionStateCounter = 0;
    var actionStateMatchingIndex = -1;
    var thenableIndexCounter = 0;
    var thenableState = null;
    var renderPhaseUpdates = null;
    var numberOfReRenders = 0;
    function resolveCurrentlyRenderingComponent() {
      if (null === currentlyRenderingComponent)
        throw Error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
      return currentlyRenderingComponent;
    }
    function createHook() {
      if (0 < numberOfReRenders)
        throw Error("Rendered more hooks than during the previous render");
      return { memoizedState: null, queue: null, next: null };
    }
    function createWorkInProgressHook() {
      null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
      return workInProgressHook;
    }
    function getThenableStateAfterSuspending() {
      var state = thenableState;
      thenableState = null;
      return state;
    }
    function resetHooksState() {
      currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
      didScheduleRenderPhaseUpdate = false;
      firstWorkInProgressHook = null;
      numberOfReRenders = 0;
      workInProgressHook = renderPhaseUpdates = null;
    }
    function basicStateReducer(state, action) {
      return "function" === typeof action ? action(state) : action;
    }
    function useReducer(reducer, initialArg, init) {
      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
      workInProgressHook = createWorkInProgressHook();
      if (isReRender) {
        var queue = workInProgressHook.queue;
        initialArg = queue.dispatch;
        if (null !== renderPhaseUpdates && (init = renderPhaseUpdates.get(queue), void 0 !== init)) {
          renderPhaseUpdates.delete(queue);
          queue = workInProgressHook.memoizedState;
          do
            queue = reducer(queue, init.action), init = init.next;
          while (null !== init);
          workInProgressHook.memoizedState = queue;
          return [queue, initialArg];
        }
        return [workInProgressHook.memoizedState, initialArg];
      }
      reducer = reducer === basicStateReducer ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init ? init(initialArg) : initialArg;
      workInProgressHook.memoizedState = reducer;
      reducer = workInProgressHook.queue = { last: null, dispatch: null };
      reducer = reducer.dispatch = dispatchAction.bind(
        null,
        currentlyRenderingComponent,
        reducer
      );
      return [workInProgressHook.memoizedState, reducer];
    }
    function useMemo(nextCreate, deps) {
      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
      workInProgressHook = createWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      if (null !== workInProgressHook) {
        var prevState = workInProgressHook.memoizedState;
        if (null !== prevState && null !== deps) {
          var prevDeps = prevState[1];
          a: if (null === prevDeps) prevDeps = false;
          else {
            for (var i = 0; i < prevDeps.length && i < deps.length; i++)
              if (!objectIs(deps[i], prevDeps[i])) {
                prevDeps = false;
                break a;
              }
            prevDeps = true;
          }
          if (prevDeps) return prevState[0];
        }
      }
      nextCreate = nextCreate();
      workInProgressHook.memoizedState = [nextCreate, deps];
      return nextCreate;
    }
    function dispatchAction(componentIdentity, queue, action) {
      if (25 <= numberOfReRenders)
        throw Error(
          "Too many re-renders. React limits the number of renders to prevent an infinite loop."
        );
      if (componentIdentity === currentlyRenderingComponent)
        if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)
          renderPhaseUpdates.set(queue, componentIdentity);
        else {
          for (queue = action; null !== queue.next; ) queue = queue.next;
          queue.next = componentIdentity;
        }
    }
    function unsupportedStartTransition() {
      throw Error("startTransition cannot be called during server rendering.");
    }
    function unsupportedSetOptimisticState() {
      throw Error("Cannot update optimistic state while rendering.");
    }
    function useActionState(action, initialState, permalink) {
      resolveCurrentlyRenderingComponent();
      var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
      if ("function" === typeof action.$$FORM_ACTION) {
        var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
        request = request.formState;
        var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
        if (null !== request && "function" === typeof isSignatureEqual) {
          var postbackKey = request[1];
          isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
            JSON.stringify([componentKeyPath, null, actionStateHookIndex]),
            0
          ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
        }
        var boundAction = action.bind(null, initialState);
        action = function(payload) {
          boundAction(payload);
        };
        "function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix2) {
          prefix2 = boundAction.$$FORM_ACTION(prefix2);
          void 0 !== permalink && (permalink += "", prefix2.action = permalink);
          var formData = prefix2.data;
          formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
            JSON.stringify([
              componentKeyPath,
              null,
              actionStateHookIndex
            ]),
            0
          )), formData.append("$ACTION_KEY", nextPostbackStateKey));
          return prefix2;
        });
        return [initialState, action, false];
      }
      var boundAction$22 = action.bind(null, initialState);
      return [
        initialState,
        function(payload) {
          boundAction$22(payload);
        },
        false
      ];
    }
    function unwrapThenable(thenable) {
      var index = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = []);
      return trackUsedThenable(thenableState, thenable, index);
    }
    function unsupportedRefresh() {
      throw Error("Cache cannot be refreshed during server rendering.");
    }
    function noop$1() {
    }
    var HooksDispatcher = {
      readContext: function(context) {
        return context._currentValue2;
      },
      use: function(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return unwrapThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE)
            return usable._currentValue2;
        }
        throw Error("An unsupported type was passed to use(): " + String(usable));
      },
      useContext: function(context) {
        resolveCurrentlyRenderingComponent();
        return context._currentValue2;
      },
      useMemo,
      useReducer,
      useRef: function(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        return null === previousRef ? (initialValue = { current: initialValue }, workInProgressHook.memoizedState = initialValue) : previousRef;
      },
      useState: function(initialState) {
        return useReducer(basicStateReducer, initialState);
      },
      useInsertionEffect: noop$1,
      useLayoutEffect: noop$1,
      useCallback: function(callback, deps) {
        return useMemo(function() {
          return callback;
        }, deps);
      },
      useImperativeHandle: noop$1,
      useEffect: noop$1,
      useDebugValue: noop$1,
      useDeferredValue: function(value, initialValue) {
        resolveCurrentlyRenderingComponent();
        return void 0 !== initialValue ? initialValue : value;
      },
      useTransition: function() {
        resolveCurrentlyRenderingComponent();
        return [false, unsupportedStartTransition];
      },
      useId: function() {
        var JSCompiler_inline_result = currentlyRenderingTask.treeContext;
        var overflow = JSCompiler_inline_result.overflow;
        JSCompiler_inline_result = JSCompiler_inline_result.id;
        JSCompiler_inline_result = (JSCompiler_inline_result & ~(1 << 32 - clz32(JSCompiler_inline_result) - 1)).toString(32) + overflow;
        var resumableState = currentResumableState;
        if (null === resumableState)
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component."
          );
        overflow = localIdCounter++;
        JSCompiler_inline_result = "\xAB" + resumableState.idPrefix + "R" + JSCompiler_inline_result;
        0 < overflow && (JSCompiler_inline_result += "H" + overflow.toString(32));
        return JSCompiler_inline_result + "\xBB";
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        if (void 0 === getServerSnapshot)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        return getServerSnapshot();
      },
      useOptimistic: function(passthrough) {
        resolveCurrentlyRenderingComponent();
        return [passthrough, unsupportedSetOptimisticState];
      },
      useActionState,
      useFormState: useActionState,
      useHostTransitionStatus: function() {
        resolveCurrentlyRenderingComponent();
        return sharedNotPendingObject;
      },
      useMemoCache: function(size) {
        for (var data = Array(size), i = 0; i < size; i++)
          data[i] = REACT_MEMO_CACHE_SENTINEL;
        return data;
      },
      useCacheRefresh: function() {
        return unsupportedRefresh;
      }
    };
    var currentResumableState = null;
    var DefaultAsyncDispatcher = {
      getCacheForType: function() {
        throw Error("Not implemented.");
      }
    };
    var prefix;
    var suffix;
    function describeBuiltInComponentFrame(name2) {
      if (void 0 === prefix)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = match && match[1] || "";
          suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return "\n" + prefix + name2 + suffix;
    }
    var reentry = false;
    function describeNativeComponentFrame(fn4, construct) {
      if (!fn4 || reentry) return "";
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn4, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$24) {
                    control = x$24;
                  }
                  fn4.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$25) {
                  control = x$25;
                }
                (Fake = fn4()) && "function" === typeof Fake.catch && Fake.catch(function() {
                });
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
          for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
            RunInRootFrame++;
          for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
            "DetermineComponentFrameRoot"
          ); )
            namePropDescriptor++;
          if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
            for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
              namePropDescriptor--;
          for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
            if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
              if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                do
                  if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                    var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                    fn4.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn4.displayName));
                    return frame;
                  }
                while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
              }
              break;
            }
        }
      } finally {
        reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
      }
      return (previousPrepareStackTrace = fn4 ? fn4.displayName || fn4.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
    }
    function describeComponentStackByType(type) {
      if ("string" === typeof type) return describeBuiltInComponentFrame(type);
      if ("function" === typeof type)
        return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame(type, true) : describeNativeComponentFrame(type, false);
      if ("object" === typeof type && null !== type) {
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return describeNativeComponentFrame(type.render, false);
          case REACT_MEMO_TYPE:
            return describeNativeComponentFrame(type.type, false);
          case REACT_LAZY_TYPE:
            var lazyComponent = type, payload = lazyComponent._payload;
            lazyComponent = lazyComponent._init;
            try {
              type = lazyComponent(payload);
            } catch (x) {
              return describeBuiltInComponentFrame("Lazy");
            }
            return describeComponentStackByType(type);
        }
        if ("string" === typeof type.name)
          return payload = type.env, describeBuiltInComponentFrame(
            type.name + (payload ? " [" + payload + "]" : "")
          );
      }
      switch (type) {
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame("SuspenseList");
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame("Suspense");
      }
      return "";
    }
    function defaultErrorHandler(error) {
      if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
        var JSCompiler_inline_result = error.environmentName;
        error = [error].slice(0);
        "string" === typeof error[0] ? error.splice(
          0,
          1,
          "[%s] " + error[0],
          " " + JSCompiler_inline_result + " "
        ) : error.splice(0, 0, "[%s] ", " " + JSCompiler_inline_result + " ");
        error.unshift(console);
        JSCompiler_inline_result = bind.apply(console.error, error);
        JSCompiler_inline_result();
      } else console.error(error);
      return null;
    }
    function noop() {
    }
    function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
      var abortSet = /* @__PURE__ */ new Set();
      this.destination = null;
      this.flushScheduled = false;
      this.resumableState = resumableState;
      this.renderState = renderState;
      this.rootFormatContext = rootFormatContext;
      this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
      this.status = 10;
      this.fatalError = null;
      this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
      this.completedPreambleSegments = this.completedRootSegment = null;
      this.abortableTasks = abortSet;
      this.pingedTasks = [];
      this.clientRenderedBoundaries = [];
      this.completedBoundaries = [];
      this.partialBoundaries = [];
      this.trackedPostpones = null;
      this.onError = void 0 === onError2 ? defaultErrorHandler : onError2;
      this.onPostpone = void 0 === onPostpone ? noop : onPostpone;
      this.onAllReady = void 0 === onAllReady ? noop : onAllReady;
      this.onShellReady = void 0 === onShellReady ? noop : onShellReady;
      this.onShellError = void 0 === onShellError ? noop : onShellError;
      this.onFatalError = void 0 === onFatalError ? noop : onFatalError;
      this.formState = void 0 === formState ? null : formState;
    }
    function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
      resumableState = new RequestInstance(
        resumableState,
        renderState,
        rootFormatContext,
        progressiveChunkSize,
        onError2,
        onAllReady,
        onShellReady,
        onShellError,
        onFatalError,
        onPostpone,
        formState
      );
      renderState = createPendingSegment(
        resumableState,
        0,
        null,
        rootFormatContext,
        false,
        false
      );
      renderState.parentFlushed = true;
      children = createRenderTask(
        resumableState,
        null,
        children,
        -1,
        null,
        renderState,
        null,
        null,
        resumableState.abortableTasks,
        null,
        rootFormatContext,
        null,
        emptyTreeContext,
        null,
        false
      );
      pushComponentStack(children);
      resumableState.pingedTasks.push(children);
      return resumableState;
    }
    var currentRequest = null;
    function pingTask(request, task) {
      request.pingedTasks.push(task);
      1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, performWork(request));
    }
    function createSuspenseBoundary(request, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
      return {
        status: 0,
        rootSegmentID: -1,
        parentFlushed: false,
        pendingTasks: 0,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks,
        errorDigest: null,
        contentState: createHoistableState(),
        fallbackState: createHoistableState(),
        contentPreamble,
        fallbackPreamble,
        trackedContentKeyPath: null,
        trackedFallbackNode: null
      };
    }
    function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback) {
      request.allPendingTasks++;
      null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
      var task = {
        replay: null,
        node,
        childIndex,
        ping: function() {
          return pingTask(request, task);
        },
        blockedBoundary,
        blockedSegment,
        blockedPreamble,
        hoistableState,
        abortSet,
        keyPath,
        formatContext,
        context,
        treeContext,
        componentStack,
        thenableState: thenableState2,
        isFallback
      };
      abortSet.add(task);
      return task;
    }
    function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback) {
      request.allPendingTasks++;
      null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
      replay.pendingTasks++;
      var task = {
        replay,
        node,
        childIndex,
        ping: function() {
          return pingTask(request, task);
        },
        blockedBoundary,
        blockedSegment: null,
        blockedPreamble: null,
        hoistableState,
        abortSet,
        keyPath,
        formatContext,
        context,
        treeContext,
        componentStack,
        thenableState: thenableState2,
        isFallback
      };
      abortSet.add(task);
      return task;
    }
    function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
      return {
        status: 0,
        parentFlushed: false,
        id: -1,
        index,
        chunks: [],
        children: [],
        preambleChildren: [],
        parentFormatContext,
        boundary,
        lastPushedText,
        textEmbedded
      };
    }
    function pushComponentStack(task) {
      var node = task.node;
      if ("object" === typeof node && null !== node)
        switch (node.$$typeof) {
          case REACT_ELEMENT_TYPE:
            task.componentStack = { parent: task.componentStack, type: node.type };
        }
    }
    function getThrownInfo(node$jscomp$0) {
      var errorInfo = {};
      node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
        configurable: true,
        enumerable: true,
        get: function() {
          try {
            var info = "", node = node$jscomp$0;
            do
              info += describeComponentStackByType(node.type), node = node.parent;
            while (node);
            var JSCompiler_inline_result = info;
          } catch (x) {
            JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
          }
          Object.defineProperty(errorInfo, "componentStack", {
            value: JSCompiler_inline_result
          });
          return JSCompiler_inline_result;
        }
      });
      return errorInfo;
    }
    function logRecoverableError(request, error, errorInfo) {
      request = request.onError;
      error = request(error, errorInfo);
      if (null == error || "string" === typeof error) return error;
    }
    function fatalError(request, error) {
      var onShellError = request.onShellError, onFatalError = request.onFatalError;
      onShellError(error);
      onFatalError(error);
      null !== request.destination ? (request.status = 14, request.destination.destroy(error)) : (request.status = 13, request.fatalError = error);
    }
    function renderWithHooks(request, task, keyPath, Component, props, secondArg) {
      var prevThenableState = task.thenableState;
      task.thenableState = null;
      currentlyRenderingComponent = {};
      currentlyRenderingTask = task;
      currentlyRenderingRequest = request;
      currentlyRenderingKeyPath = keyPath;
      actionStateCounter = localIdCounter = 0;
      actionStateMatchingIndex = -1;
      thenableIndexCounter = 0;
      thenableState = prevThenableState;
      for (request = Component(props, secondArg); didScheduleRenderPhaseUpdate; )
        didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);
      resetHooksState();
      return request;
    }
    function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
      var didEmitActionStateMarkers = false;
      if (0 !== actionStateCount && null !== request.formState) {
        var segment = task.blockedSegment;
        if (null !== segment) {
          didEmitActionStateMarkers = true;
          segment = segment.chunks;
          for (var i = 0; i < actionStateCount; i++)
            i === actionStateMatchingIndex2 ? segment.push("<!--F!-->") : segment.push("<!--F-->");
        }
      }
      actionStateCount = task.keyPath;
      task.keyPath = keyPath;
      hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode2(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode2(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
      task.keyPath = actionStateCount;
    }
    function renderElement(request, task, keyPath, type, props, ref) {
      if ("function" === typeof type)
        if (type.prototype && type.prototype.isReactComponent) {
          var newProps = props;
          if ("ref" in props) {
            newProps = {};
            for (var propName in props)
              "ref" !== propName && (newProps[propName] = props[propName]);
          }
          var defaultProps = type.defaultProps;
          if (defaultProps) {
            newProps === props && (newProps = assign({}, newProps, props));
            for (var propName$33 in defaultProps)
              void 0 === newProps[propName$33] && (newProps[propName$33] = defaultProps[propName$33]);
          }
          props = newProps;
          newProps = emptyContextObject;
          defaultProps = type.contextType;
          "object" === typeof defaultProps && null !== defaultProps && (newProps = defaultProps._currentValue2);
          newProps = new type(props, newProps);
          var initialState = void 0 !== newProps.state ? newProps.state : null;
          newProps.updater = classComponentUpdater;
          newProps.props = props;
          newProps.state = initialState;
          defaultProps = { queue: [], replace: false };
          newProps._reactInternals = defaultProps;
          ref = type.contextType;
          newProps.context = "object" === typeof ref && null !== ref ? ref._currentValue2 : emptyContextObject;
          ref = type.getDerivedStateFromProps;
          "function" === typeof ref && (ref = ref(props, initialState), initialState = null === ref || void 0 === ref ? initialState : assign({}, initialState, ref), newProps.state = initialState);
          if ("function" !== typeof type.getDerivedStateFromProps && "function" !== typeof newProps.getSnapshotBeforeUpdate && ("function" === typeof newProps.UNSAFE_componentWillMount || "function" === typeof newProps.componentWillMount))
            if (type = newProps.state, "function" === typeof newProps.componentWillMount && newProps.componentWillMount(), "function" === typeof newProps.UNSAFE_componentWillMount && newProps.UNSAFE_componentWillMount(), type !== newProps.state && classComponentUpdater.enqueueReplaceState(
              newProps,
              newProps.state,
              null
            ), null !== defaultProps.queue && 0 < defaultProps.queue.length)
              if (type = defaultProps.queue, ref = defaultProps.replace, defaultProps.queue = null, defaultProps.replace = false, ref && 1 === type.length)
                newProps.state = type[0];
              else {
                defaultProps = ref ? type[0] : newProps.state;
                initialState = true;
                for (ref = ref ? 1 : 0; ref < type.length; ref++)
                  propName$33 = type[ref], propName$33 = "function" === typeof propName$33 ? propName$33.call(newProps, defaultProps, props, void 0) : propName$33, null != propName$33 && (initialState ? (initialState = false, defaultProps = assign({}, defaultProps, propName$33)) : assign(defaultProps, propName$33));
                newProps.state = defaultProps;
              }
            else defaultProps.queue = null;
          type = newProps.render();
          if (12 === request.status) throw null;
          props = task.keyPath;
          task.keyPath = keyPath;
          renderNodeDestructive(request, task, type, -1);
          task.keyPath = props;
        } else {
          type = renderWithHooks(request, task, keyPath, type, props, void 0);
          if (12 === request.status) throw null;
          finishFunctionComponent(
            request,
            task,
            keyPath,
            type,
            0 !== localIdCounter,
            actionStateCounter,
            actionStateMatchingIndex
          );
        }
      else if ("string" === typeof type)
        if (newProps = task.blockedSegment, null === newProps)
          newProps = props.children, defaultProps = task.formatContext, initialState = task.keyPath, task.formatContext = getChildFormatContext(defaultProps, type, props), task.keyPath = keyPath, renderNode2(request, task, newProps, -1), task.formatContext = defaultProps, task.keyPath = initialState;
        else {
          ref = pushStartInstance(
            newProps.chunks,
            type,
            props,
            request.resumableState,
            request.renderState,
            task.blockedPreamble,
            task.hoistableState,
            task.formatContext,
            newProps.lastPushedText,
            task.isFallback
          );
          newProps.lastPushedText = false;
          defaultProps = task.formatContext;
          initialState = task.keyPath;
          task.keyPath = keyPath;
          3 === (task.formatContext = getChildFormatContext(defaultProps, type, props)).insertionMode ? (keyPath = createPendingSegment(
            request,
            0,
            null,
            task.formatContext,
            false,
            false
          ), newProps.preambleChildren.push(keyPath), keyPath = createRenderTask(
            request,
            null,
            ref,
            -1,
            task.blockedBoundary,
            keyPath,
            task.blockedPreamble,
            task.hoistableState,
            request.abortableTasks,
            task.keyPath,
            task.formatContext,
            task.context,
            task.treeContext,
            task.componentStack,
            task.isFallback
          ), pushComponentStack(keyPath), request.pingedTasks.push(keyPath)) : renderNode2(request, task, ref, -1);
          task.formatContext = defaultProps;
          task.keyPath = initialState;
          a: {
            task = newProps.chunks;
            request = request.resumableState;
            switch (type) {
              case "title":
              case "style":
              case "script":
              case "area":
              case "base":
              case "br":
              case "col":
              case "embed":
              case "hr":
              case "img":
              case "input":
              case "keygen":
              case "link":
              case "meta":
              case "param":
              case "source":
              case "track":
              case "wbr":
                break a;
              case "body":
                if (1 >= defaultProps.insertionMode) {
                  request.hasBody = true;
                  break a;
                }
                break;
              case "html":
                if (0 === defaultProps.insertionMode) {
                  request.hasHtml = true;
                  break a;
                }
                break;
              case "head":
                if (1 >= defaultProps.insertionMode) break a;
            }
            task.push(endChunkForTag(type));
          }
          newProps.lastPushedText = false;
        }
      else {
        switch (type) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE:
            type = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, props.children, -1);
            task.keyPath = type;
            return;
          case REACT_ACTIVITY_TYPE:
            "hidden" !== props.mode && (type = task.keyPath, task.keyPath = keyPath, renderNodeDestructive(request, task, props.children, -1), task.keyPath = type);
            return;
          case REACT_SUSPENSE_LIST_TYPE:
            type = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, props.children, -1);
            task.keyPath = type;
            return;
          case REACT_VIEW_TRANSITION_TYPE:
          case REACT_SCOPE_TYPE:
            throw Error("ReactDOMServer does not yet support scope components.");
          case REACT_SUSPENSE_TYPE:
            a: if (null !== task.replay) {
              type = task.keyPath;
              task.keyPath = keyPath;
              keyPath = props.children;
              try {
                renderNode2(request, task, keyPath, -1);
              } finally {
                task.keyPath = type;
              }
            } else {
              type = task.keyPath;
              var parentBoundary = task.blockedBoundary;
              ref = task.blockedPreamble;
              var parentHoistableState = task.hoistableState;
              propName$33 = task.blockedSegment;
              propName = props.fallback;
              props = props.children;
              var fallbackAbortSet = /* @__PURE__ */ new Set();
              var newBoundary = 2 > task.formatContext.insertionMode ? createSuspenseBoundary(
                request,
                fallbackAbortSet,
                createPreambleState(),
                createPreambleState()
              ) : createSuspenseBoundary(request, fallbackAbortSet, null, null);
              null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
              var boundarySegment = createPendingSegment(
                request,
                propName$33.chunks.length,
                newBoundary,
                task.formatContext,
                false,
                false
              );
              propName$33.children.push(boundarySegment);
              propName$33.lastPushedText = false;
              var contentRootSegment = createPendingSegment(
                request,
                0,
                null,
                task.formatContext,
                false,
                false
              );
              contentRootSegment.parentFlushed = true;
              if (null !== request.trackedPostpones) {
                newProps = [keyPath[0], "Suspense Fallback", keyPath[2]];
                defaultProps = [newProps[1], newProps[2], [], null];
                request.trackedPostpones.workingMap.set(newProps, defaultProps);
                newBoundary.trackedFallbackNode = defaultProps;
                task.blockedSegment = boundarySegment;
                task.blockedPreamble = newBoundary.fallbackPreamble;
                task.keyPath = newProps;
                boundarySegment.status = 6;
                try {
                  renderNode2(request, task, propName, -1), pushSegmentFinale(
                    boundarySegment.chunks,
                    request.renderState,
                    boundarySegment.lastPushedText,
                    boundarySegment.textEmbedded
                  ), boundarySegment.status = 1;
                } catch (thrownValue) {
                  throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;
                } finally {
                  task.blockedSegment = propName$33, task.blockedPreamble = ref, task.keyPath = type;
                }
                task = createRenderTask(
                  request,
                  null,
                  props,
                  -1,
                  newBoundary,
                  contentRootSegment,
                  newBoundary.contentPreamble,
                  newBoundary.contentState,
                  task.abortSet,
                  keyPath,
                  task.formatContext,
                  task.context,
                  task.treeContext,
                  task.componentStack,
                  task.isFallback
                );
                pushComponentStack(task);
                request.pingedTasks.push(task);
              } else {
                task.blockedBoundary = newBoundary;
                task.blockedPreamble = newBoundary.contentPreamble;
                task.hoistableState = newBoundary.contentState;
                task.blockedSegment = contentRootSegment;
                task.keyPath = keyPath;
                contentRootSegment.status = 6;
                try {
                  if (renderNode2(request, task, props, -1), pushSegmentFinale(
                    contentRootSegment.chunks,
                    request.renderState,
                    contentRootSegment.lastPushedText,
                    contentRootSegment.textEmbedded
                  ), contentRootSegment.status = 1, queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && 0 === newBoundary.status) {
                    newBoundary.status = 1;
                    0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);
                    break a;
                  }
                } catch (thrownValue$28) {
                  newBoundary.status = 4, 12 === request.status ? (contentRootSegment.status = 3, newProps = request.fatalError) : (contentRootSegment.status = 4, newProps = thrownValue$28), defaultProps = getThrownInfo(task.componentStack), initialState = logRecoverableError(
                    request,
                    newProps,
                    defaultProps
                  ), newBoundary.errorDigest = initialState, untrackBoundary(request, newBoundary);
                } finally {
                  task.blockedBoundary = parentBoundary, task.blockedPreamble = ref, task.hoistableState = parentHoistableState, task.blockedSegment = propName$33, task.keyPath = type;
                }
                task = createRenderTask(
                  request,
                  null,
                  propName,
                  -1,
                  parentBoundary,
                  boundarySegment,
                  newBoundary.fallbackPreamble,
                  newBoundary.fallbackState,
                  fallbackAbortSet,
                  [keyPath[0], "Suspense Fallback", keyPath[2]],
                  task.formatContext,
                  task.context,
                  task.treeContext,
                  task.componentStack,
                  true
                );
                pushComponentStack(task);
                request.pingedTasks.push(task);
              }
            }
            return;
        }
        if ("object" === typeof type && null !== type)
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              if ("ref" in props)
                for (newBoundary in newProps = {}, props)
                  "ref" !== newBoundary && (newProps[newBoundary] = props[newBoundary]);
              else newProps = props;
              type = renderWithHooks(
                request,
                task,
                keyPath,
                type.render,
                newProps,
                ref
              );
              finishFunctionComponent(
                request,
                task,
                keyPath,
                type,
                0 !== localIdCounter,
                actionStateCounter,
                actionStateMatchingIndex
              );
              return;
            case REACT_MEMO_TYPE:
              renderElement(request, task, keyPath, type.type, props, ref);
              return;
            case REACT_PROVIDER_TYPE:
            case REACT_CONTEXT_TYPE:
              defaultProps = props.children;
              newProps = task.keyPath;
              props = props.value;
              initialState = type._currentValue2;
              type._currentValue2 = props;
              ref = currentActiveSnapshot;
              currentActiveSnapshot = type = {
                parent: ref,
                depth: null === ref ? 0 : ref.depth + 1,
                context: type,
                parentValue: initialState,
                value: props
              };
              task.context = type;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, defaultProps, -1);
              request = currentActiveSnapshot;
              if (null === request)
                throw Error(
                  "Tried to pop a Context at the root of the app. This is a bug in React."
                );
              request.context._currentValue2 = request.parentValue;
              request = currentActiveSnapshot = request.parent;
              task.context = request;
              task.keyPath = newProps;
              return;
            case REACT_CONSUMER_TYPE:
              props = props.children;
              type = props(type._context._currentValue2);
              props = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, type, -1);
              task.keyPath = props;
              return;
            case REACT_LAZY_TYPE:
              newProps = type._init;
              type = newProps(type._payload);
              if (12 === request.status) throw null;
              renderElement(request, task, keyPath, type, props, ref);
              return;
          }
        throw Error(
          "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type ? type : typeof type) + ".")
        );
      }
    }
    function resumeNode(request, task, segmentId, node, childIndex) {
      var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(
        request,
        0,
        null,
        task.formatContext,
        false,
        false
      );
      resumedSegment.id = segmentId;
      resumedSegment.parentFlushed = true;
      try {
        task.replay = null, task.blockedSegment = resumedSegment, renderNode2(request, task, node, childIndex), resumedSegment.status = 1, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
      } finally {
        task.replay = prevReplay, task.blockedSegment = null;
      }
    }
    function renderNodeDestructive(request, task, node, childIndex) {
      null !== task.replay && "number" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, pushComponentStack(task), retryNode(request, task), task.componentStack = node);
    }
    function retryNode(request, task) {
      var node = task.node, childIndex = task.childIndex;
      if (null !== node) {
        if ("object" === typeof node) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = node.type, key = node.key, props = node.props;
              node = props.ref;
              var ref = void 0 !== node ? node : null, name2 = getComponentNameFromType(type), keyOrIndex = null == key ? -1 === childIndex ? 0 : childIndex : key;
              key = [task.keyPath, name2, keyOrIndex];
              if (null !== task.replay)
                a: {
                  var replay = task.replay;
                  childIndex = replay.nodes;
                  for (node = 0; node < childIndex.length; node++) {
                    var node$jscomp$0 = childIndex[node];
                    if (keyOrIndex === node$jscomp$0[1]) {
                      if (4 === node$jscomp$0.length) {
                        if (null !== name2 && name2 !== node$jscomp$0[0])
                          throw Error(
                            "Expected the resume to render <" + node$jscomp$0[0] + "> in this slot but instead it rendered <" + name2 + ">. The tree doesn't match so React will fallback to client rendering."
                          );
                        var childNodes = node$jscomp$0[2];
                        name2 = node$jscomp$0[3];
                        keyOrIndex = task.node;
                        task.replay = {
                          nodes: childNodes,
                          slots: name2,
                          pendingTasks: 1
                        };
                        try {
                          renderElement(request, task, key, type, props, ref);
                          if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                            throw Error(
                              "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                            );
                          task.replay.pendingTasks--;
                        } catch (x) {
                          if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                            throw task.node === keyOrIndex && (task.replay = replay), x;
                          task.replay.pendingTasks--;
                          props = getThrownInfo(task.componentStack);
                          key = task.blockedBoundary;
                          type = x;
                          props = logRecoverableError(request, type, props);
                          abortRemainingReplayNodes(
                            request,
                            key,
                            childNodes,
                            name2,
                            type,
                            props
                          );
                        }
                        task.replay = replay;
                      } else {
                        if (type !== REACT_SUSPENSE_TYPE)
                          throw Error(
                            "Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering."
                          );
                        b: {
                          replay = void 0;
                          type = node$jscomp$0[5];
                          ref = node$jscomp$0[2];
                          name2 = node$jscomp$0[3];
                          keyOrIndex = null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];
                          node$jscomp$0 = null === node$jscomp$0[4] ? null : node$jscomp$0[4][3];
                          var prevKeyPath = task.keyPath, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
                          props = 2 > task.formatContext.insertionMode ? createSuspenseBoundary(
                            request,
                            fallbackAbortSet,
                            createPreambleState(),
                            createPreambleState()
                          ) : createSuspenseBoundary(
                            request,
                            fallbackAbortSet,
                            null,
                            null
                          );
                          props.parentFlushed = true;
                          props.rootSegmentID = type;
                          task.blockedBoundary = props;
                          task.hoistableState = props.contentState;
                          task.keyPath = key;
                          task.replay = {
                            nodes: ref,
                            slots: name2,
                            pendingTasks: 1
                          };
                          try {
                            renderNode2(request, task, content, -1);
                            if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                              throw Error(
                                "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                              );
                            task.replay.pendingTasks--;
                            if (0 === props.pendingTasks && 0 === props.status) {
                              props.status = 1;
                              request.completedBoundaries.push(props);
                              break b;
                            }
                          } catch (error) {
                            props.status = 4, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(
                              request,
                              error,
                              childNodes
                            ), props.errorDigest = replay, task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
                          } finally {
                            task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath;
                          }
                          task = createReplayTask(
                            request,
                            null,
                            {
                              nodes: keyOrIndex,
                              slots: node$jscomp$0,
                              pendingTasks: 0
                            },
                            fallback,
                            -1,
                            parentBoundary,
                            props.fallbackState,
                            fallbackAbortSet,
                            [key[0], "Suspense Fallback", key[2]],
                            task.formatContext,
                            task.context,
                            task.treeContext,
                            task.componentStack,
                            true
                          );
                          pushComponentStack(task);
                          request.pingedTasks.push(task);
                        }
                      }
                      childIndex.splice(node, 1);
                      break a;
                    }
                  }
                }
              else renderElement(request, task, key, type, props, ref);
              return;
            case REACT_PORTAL_TYPE:
              throw Error(
                "Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render."
              );
            case REACT_LAZY_TYPE:
              childNodes = node._init;
              node = childNodes(node._payload);
              if (12 === request.status) throw null;
              renderNodeDestructive(request, task, node, childIndex);
              return;
          }
          if (isArrayImpl(node)) {
            renderChildrenArray(request, task, node, childIndex);
            return;
          }
          null === node || "object" !== typeof node ? childNodes = null : (childNodes = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], childNodes = "function" === typeof childNodes ? childNodes : null);
          if (childNodes && (childNodes = childNodes.call(node))) {
            node = childNodes.next();
            if (!node.done) {
              props = [];
              do
                props.push(node.value), node = childNodes.next();
              while (!node.done);
              renderChildrenArray(request, task, props, childIndex);
            }
            return;
          }
          if ("function" === typeof node.then)
            return task.thenableState = null, renderNodeDestructive(request, task, unwrapThenable(node), childIndex);
          if (node.$$typeof === REACT_CONTEXT_TYPE)
            return renderNodeDestructive(
              request,
              task,
              node._currentValue2,
              childIndex
            );
          childIndex = Object.prototype.toString.call(node);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === childIndex ? "object with keys {" + Object.keys(node).join(", ") + "}" : childIndex) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        if ("string" === typeof node)
          childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(
            childIndex.chunks,
            node,
            request.renderState,
            childIndex.lastPushedText
          ));
        else if ("number" === typeof node || "bigint" === typeof node)
          childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(
            childIndex.chunks,
            "" + node,
            request.renderState,
            childIndex.lastPushedText
          ));
      }
    }
    function renderChildrenArray(request, task, children, childIndex) {
      var prevKeyPath = task.keyPath;
      if (-1 !== childIndex && (task.keyPath = [task.keyPath, "Fragment", childIndex], null !== task.replay)) {
        for (var replay = task.replay, replayNodes = replay.nodes, j3 = 0; j3 < replayNodes.length; j3++) {
          var node = replayNodes[j3];
          if (node[1] === childIndex) {
            childIndex = node[2];
            node = node[3];
            task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
            try {
              renderChildrenArray(request, task, children, -1);
              if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                throw Error(
                  "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                );
              task.replay.pendingTasks--;
            } catch (x) {
              if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                throw x;
              task.replay.pendingTasks--;
              children = getThrownInfo(task.componentStack);
              var boundary = task.blockedBoundary, error = x;
              children = logRecoverableError(request, error, children);
              abortRemainingReplayNodes(
                request,
                boundary,
                childIndex,
                node,
                error,
                children
              );
            }
            task.replay = replay;
            replayNodes.splice(j3, 1);
            break;
          }
        }
        task.keyPath = prevKeyPath;
        return;
      }
      replay = task.treeContext;
      replayNodes = children.length;
      if (null !== task.replay && (j3 = task.replay.slots, null !== j3 && "object" === typeof j3)) {
        for (childIndex = 0; childIndex < replayNodes; childIndex++)
          node = children[childIndex], task.treeContext = pushTreeContext(replay, replayNodes, childIndex), boundary = j3[childIndex], "number" === typeof boundary ? (resumeNode(request, task, boundary, node, childIndex), delete j3[childIndex]) : renderNode2(request, task, node, childIndex);
        task.treeContext = replay;
        task.keyPath = prevKeyPath;
        return;
      }
      for (j3 = 0; j3 < replayNodes; j3++)
        childIndex = children[j3], task.treeContext = pushTreeContext(replay, replayNodes, j3), renderNode2(request, task, childIndex, j3);
      task.treeContext = replay;
      task.keyPath = prevKeyPath;
    }
    function untrackBoundary(request, boundary) {
      request = request.trackedPostpones;
      null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
    }
    function spawnNewSuspendedReplayTask(request, task, thenableState2) {
      return createReplayTask(
        request,
        thenableState2,
        task.replay,
        task.node,
        task.childIndex,
        task.blockedBoundary,
        task.hoistableState,
        task.abortSet,
        task.keyPath,
        task.formatContext,
        task.context,
        task.treeContext,
        task.componentStack,
        task.isFallback
      );
    }
    function spawnNewSuspendedRenderTask(request, task, thenableState2) {
      var segment = task.blockedSegment, newSegment = createPendingSegment(
        request,
        segment.chunks.length,
        null,
        task.formatContext,
        segment.lastPushedText,
        true
      );
      segment.children.push(newSegment);
      segment.lastPushedText = false;
      return createRenderTask(
        request,
        thenableState2,
        task.node,
        task.childIndex,
        task.blockedBoundary,
        newSegment,
        task.blockedPreamble,
        task.hoistableState,
        task.abortSet,
        task.keyPath,
        task.formatContext,
        task.context,
        task.treeContext,
        task.componentStack,
        task.isFallback
      );
    }
    function renderNode2(request, task, node, childIndex) {
      var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, segment = task.blockedSegment;
      if (null === segment)
        try {
          return renderNodeDestructive(request, task, node, childIndex);
        } catch (thrownValue) {
          if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, "object" === typeof node && null !== node) {
            if ("function" === typeof node.then) {
              childIndex = getThenableStateAfterSuspending();
              request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
              node.then(request, request);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              switchContext(previousContext);
              return;
            }
            if ("Maximum call stack size exceeded" === node.message) {
              node = getThenableStateAfterSuspending();
              node = spawnNewSuspendedReplayTask(request, task, node);
              request.pingedTasks.push(node);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              switchContext(previousContext);
              return;
            }
          }
        }
      else {
        var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
        try {
          return renderNodeDestructive(request, task, node, childIndex);
        } catch (thrownValue$48) {
          if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$48 === SuspenseException ? getSuspendedThenable() : thrownValue$48, "object" === typeof node && null !== node) {
            if ("function" === typeof node.then) {
              childIndex = getThenableStateAfterSuspending();
              request = spawnNewSuspendedRenderTask(request, task, childIndex).ping;
              node.then(request, request);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              switchContext(previousContext);
              return;
            }
            if ("Maximum call stack size exceeded" === node.message) {
              node = getThenableStateAfterSuspending();
              node = spawnNewSuspendedRenderTask(request, task, node);
              request.pingedTasks.push(node);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              switchContext(previousContext);
              return;
            }
          }
        }
      }
      task.formatContext = previousFormatContext;
      task.context = previousContext;
      task.keyPath = previousKeyPath;
      task.treeContext = previousTreeContext;
      switchContext(previousContext);
      throw node;
    }
    function abortTaskSoft(task) {
      var boundary = task.blockedBoundary;
      task = task.blockedSegment;
      null !== task && (task.status = 3, finishedTask(this, boundary, task));
    }
    function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error, errorDigest$jscomp$0) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (4 === node.length)
          abortRemainingReplayNodes(
            request$jscomp$0,
            boundary,
            node[2],
            node[3],
            error,
            errorDigest$jscomp$0
          );
        else {
          node = node[5];
          var request = request$jscomp$0, errorDigest = errorDigest$jscomp$0, resumedBoundary = createSuspenseBoundary(
            request,
            /* @__PURE__ */ new Set(),
            null,
            null
          );
          resumedBoundary.parentFlushed = true;
          resumedBoundary.rootSegmentID = node;
          resumedBoundary.status = 4;
          resumedBoundary.errorDigest = errorDigest;
          resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
        }
      }
      nodes.length = 0;
      if (null !== slots) {
        if (null === boundary)
          throw Error(
            "We should not have any resumable nodes in the shell. This is a bug in React."
          );
        4 !== boundary.status && (boundary.status = 4, boundary.errorDigest = errorDigest$jscomp$0, boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
        if ("object" === typeof slots) for (var index in slots) delete slots[index];
      }
    }
    function abortTask(task, request, error) {
      var boundary = task.blockedBoundary, segment = task.blockedSegment;
      if (null !== segment) {
        if (6 === segment.status) return;
        segment.status = 3;
      }
      segment = getThrownInfo(task.componentStack);
      if (null === boundary) {
        if (13 !== request.status && 14 !== request.status) {
          boundary = task.replay;
          if (null === boundary) {
            logRecoverableError(request, error, segment);
            fatalError(request, error);
            return;
          }
          boundary.pendingTasks--;
          0 === boundary.pendingTasks && 0 < boundary.nodes.length && (task = logRecoverableError(request, error, segment), abortRemainingReplayNodes(
            request,
            null,
            boundary.nodes,
            boundary.slots,
            error,
            task
          ));
          request.pendingRootTasks--;
          0 === request.pendingRootTasks && completeShell(request);
        }
      } else
        boundary.pendingTasks--, 4 !== boundary.status && (boundary.status = 4, task = logRecoverableError(request, error, segment), boundary.status = 4, boundary.errorDigest = task, untrackBoundary(request, boundary), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary)), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
          return abortTask(fallbackTask, request, error);
        }), boundary.fallbackAbortableTasks.clear();
      request.allPendingTasks--;
      0 === request.allPendingTasks && completeAll(request);
    }
    function safelyEmitEarlyPreloads(request, shellComplete) {
      try {
        var renderState = request.renderState, onHeaders = renderState.onHeaders;
        if (onHeaders) {
          var headers = renderState.headers;
          if (headers) {
            renderState.headers = null;
            var linkHeader = headers.preconnects;
            headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
            headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
            if (!shellComplete) {
              var queueIter = renderState.styles.values(), queueStep = queueIter.next();
              b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
                for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                  var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props, header = getPreloadAsHeader(props$jscomp$0.href, "style", {
                    crossOrigin: props$jscomp$0.crossOrigin,
                    integrity: props$jscomp$0.integrity,
                    nonce: props$jscomp$0.nonce,
                    type: props$jscomp$0.type,
                    fetchPriority: props$jscomp$0.fetchPriority,
                    referrerPolicy: props$jscomp$0.referrerPolicy,
                    media: props$jscomp$0.media
                  });
                  if (0 <= (headers.remainingCapacity -= header.length + 2))
                    renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                  else break b;
                }
            }
            linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
          }
        }
      } catch (error) {
        logRecoverableError(request, error, {});
      }
    }
    function completeShell(request) {
      null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);
      null === request.trackedPostpones && preparePreamble(request);
      request.onShellError = noop;
      request = request.onShellReady;
      request();
    }
    function completeAll(request) {
      safelyEmitEarlyPreloads(
        request,
        null === request.trackedPostpones ? true : null === request.completedRootSegment || 5 !== request.completedRootSegment.status
      );
      preparePreamble(request);
      request = request.onAllReady;
      request();
    }
    function queueCompletedSegment(boundary, segment) {
      if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
        var childSegment = segment.children[0];
        childSegment.id = segment.id;
        childSegment.parentFlushed = true;
        1 === childSegment.status && queueCompletedSegment(boundary, childSegment);
      } else boundary.completedSegments.push(segment);
    }
    function finishedTask(request, boundary, segment) {
      if (null === boundary) {
        if (null !== segment && segment.parentFlushed) {
          if (null !== request.completedRootSegment)
            throw Error(
              "There can only be one root segment. This is a bug in React."
            );
          request.completedRootSegment = segment;
        }
        request.pendingRootTasks--;
        0 === request.pendingRootTasks && completeShell(request);
      } else
        boundary.pendingTasks--, 4 !== boundary.status && (0 === boundary.pendingTasks ? (0 === boundary.status && (boundary.status = 1), null !== segment && segment.parentFlushed && 1 === segment.status && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), 1 === boundary.status && (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request), boundary.fallbackAbortableTasks.clear(), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request))) : null !== segment && segment.parentFlushed && 1 === segment.status && (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)));
      request.allPendingTasks--;
      0 === request.allPendingTasks && completeAll(request);
    }
    function performWork(request$jscomp$2) {
      if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {
        var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = HooksDispatcher;
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        var prevRequest = currentRequest;
        currentRequest = request$jscomp$2;
        var prevResumableState = currentResumableState;
        currentResumableState = request$jscomp$2.resumableState;
        try {
          var pingedTasks = request$jscomp$2.pingedTasks, i;
          for (i = 0; i < pingedTasks.length; i++) {
            var task = pingedTasks[i], request = request$jscomp$2, segment = task.blockedSegment;
            if (null === segment) {
              var request$jscomp$0 = request;
              if (0 !== task.replay.pendingTasks) {
                switchContext(task.context);
                try {
                  "number" === typeof task.replay.slots ? resumeNode(
                    request$jscomp$0,
                    task,
                    task.replay.slots,
                    task.node,
                    task.childIndex
                  ) : retryNode(request$jscomp$0, task);
                  if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                    throw Error(
                      "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                    );
                  task.replay.pendingTasks--;
                  task.abortSet.delete(task);
                  finishedTask(request$jscomp$0, task.blockedBoundary, null);
                } catch (thrownValue) {
                  resetHooksState();
                  var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                  if ("object" === typeof x && null !== x && "function" === typeof x.then) {
                    var ping = task.ping;
                    x.then(ping, ping);
                    task.thenableState = getThenableStateAfterSuspending();
                  } else {
                    task.replay.pendingTasks--;
                    task.abortSet.delete(task);
                    var errorInfo = getThrownInfo(task.componentStack);
                    request = void 0;
                    var request$jscomp$1 = request$jscomp$0, boundary = task.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, replayNodes = task.replay.nodes, resumeSlots = task.replay.slots;
                    request = logRecoverableError(
                      request$jscomp$1,
                      error$jscomp$0,
                      errorInfo
                    );
                    abortRemainingReplayNodes(
                      request$jscomp$1,
                      boundary,
                      replayNodes,
                      resumeSlots,
                      error$jscomp$0,
                      request
                    );
                    request$jscomp$0.pendingRootTasks--;
                    0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);
                    request$jscomp$0.allPendingTasks--;
                    0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);
                  }
                } finally {
                }
              }
            } else if (request$jscomp$0 = void 0, request$jscomp$1 = segment, 0 === request$jscomp$1.status) {
              request$jscomp$1.status = 6;
              switchContext(task.context);
              var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
              try {
                retryNode(request, task), pushSegmentFinale(
                  request$jscomp$1.chunks,
                  request.renderState,
                  request$jscomp$1.lastPushedText,
                  request$jscomp$1.textEmbedded
                ), task.abortSet.delete(task), request$jscomp$1.status = 1, finishedTask(request, task.blockedBoundary, request$jscomp$1);
              } catch (thrownValue) {
                resetHooksState();
                request$jscomp$1.children.length = childrenLength;
                request$jscomp$1.chunks.length = chunkLength;
                var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;
                if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
                  request$jscomp$1.status = 0;
                  task.thenableState = getThenableStateAfterSuspending();
                  var ping$jscomp$0 = task.ping;
                  x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
                } else {
                  var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
                  task.abortSet.delete(task);
                  request$jscomp$1.status = 4;
                  var boundary$jscomp$0 = task.blockedBoundary;
                  request$jscomp$0 = logRecoverableError(
                    request,
                    x$jscomp$0,
                    errorInfo$jscomp$0
                  );
                  null === boundary$jscomp$0 ? fatalError(request, x$jscomp$0) : (boundary$jscomp$0.pendingTasks--, 4 !== boundary$jscomp$0.status && (boundary$jscomp$0.status = 4, boundary$jscomp$0.errorDigest = request$jscomp$0, untrackBoundary(request, boundary$jscomp$0), boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request)));
                  request.allPendingTasks--;
                  0 === request.allPendingTasks && completeAll(request);
                }
              } finally {
              }
            }
          }
          pingedTasks.splice(0, i);
          null !== request$jscomp$2.destination && flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);
        } catch (error) {
          logRecoverableError(request$jscomp$2, error, {}), fatalError(request$jscomp$2, error);
        } finally {
          currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
        }
      }
    }
    function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
      segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
      for (var pendingPreambles = false, i = 0; i < segment.children.length; i++)
        pendingPreambles = preparePreambleFromSegment(
          request,
          segment.children[i],
          collectedPreambleSegments
        ) || pendingPreambles;
      return pendingPreambles;
    }
    function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
      var boundary = segment.boundary;
      if (null === boundary)
        return preparePreambleFromSubtree(
          request,
          segment,
          collectedPreambleSegments
        );
      var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
      if (null === preamble || null === fallbackPreamble) return false;
      switch (boundary.status) {
        case 1:
          hoistPreambleState(request.renderState, preamble);
          segment = boundary.completedSegments[0];
          if (!segment)
            throw Error(
              "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
            );
          return preparePreambleFromSubtree(
            request,
            segment,
            collectedPreambleSegments
          );
        case 5:
          if (null !== request.trackedPostpones) return true;
        case 4:
          if (1 === segment.status)
            return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(
              request,
              segment,
              collectedPreambleSegments
            );
        default:
          return true;
      }
    }
    function preparePreamble(request) {
      if (request.completedRootSegment && null === request.completedPreambleSegments) {
        var collectedPreambleSegments = [], hasPendingPreambles = preparePreambleFromSegment(
          request,
          request.completedRootSegment,
          collectedPreambleSegments
        ), preamble = request.renderState.preamble;
        if (false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks)
          request.completedPreambleSegments = collectedPreambleSegments;
      }
    }
    function flushSubtree(request, destination, segment, hoistableState) {
      segment.parentFlushed = true;
      switch (segment.status) {
        case 0:
          segment.id = request.nextSegmentId++;
        case 5:
          return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, destination.push('<template id="'), destination.push(request.placeholderPrefix), request = hoistableState.toString(16), destination.push(request), destination.push('"></template>');
        case 1:
          segment.status = 2;
          var r2 = true, chunks = segment.chunks, chunkIdx = 0;
          segment = segment.children;
          for (var childIdx = 0; childIdx < segment.length; childIdx++) {
            for (r2 = segment[childIdx]; chunkIdx < r2.index; chunkIdx++)
              destination.push(chunks[chunkIdx]);
            r2 = flushSegment(request, destination, r2, hoistableState);
          }
          for (; chunkIdx < chunks.length - 1; chunkIdx++)
            destination.push(chunks[chunkIdx]);
          chunkIdx < chunks.length && (r2 = destination.push(chunks[chunkIdx]));
          return r2;
        default:
          throw Error(
            "Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React."
          );
      }
    }
    function flushSegment(request, destination, segment, hoistableState) {
      var boundary = segment.boundary;
      if (null === boundary)
        return flushSubtree(request, destination, segment, hoistableState);
      boundary.parentFlushed = true;
      if (4 === boundary.status) {
        if (!request.renderState.generateStaticMarkup) {
          var errorDigest = boundary.errorDigest;
          destination.push("<!--$!-->");
          destination.push("<template");
          errorDigest && (destination.push(' data-dgst="'), errorDigest = escapeTextForBrowser(errorDigest), destination.push(errorDigest), destination.push('"'));
          destination.push("></template>");
        }
        flushSubtree(request, destination, segment, hoistableState);
        request.renderState.generateStaticMarkup ? destination = true : ((request = boundary.fallbackPreamble) && writePreambleContribution(destination, request), destination = destination.push("<!--/$-->"));
        return destination;
      }
      if (1 !== boundary.status)
        return 0 === boundary.status && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
          destination,
          request.renderState,
          boundary.rootSegmentID
        ), hoistableState && (boundary = boundary.fallbackState, boundary.styles.forEach(hoistStyleQueueDependency, hoistableState), boundary.stylesheets.forEach(
          hoistStylesheetDependency,
          hoistableState
        )), flushSubtree(request, destination, segment, hoistableState), destination.push("<!--/$-->");
      if (boundary.byteSize > request.progressiveChunkSize)
        return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
          destination,
          request.renderState,
          boundary.rootSegmentID
        ), flushSubtree(request, destination, segment, hoistableState), destination.push("<!--/$-->");
      hoistableState && (segment = boundary.contentState, segment.styles.forEach(hoistStyleQueueDependency, hoistableState), segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));
      request.renderState.generateStaticMarkup || destination.push("<!--$-->");
      segment = boundary.completedSegments;
      if (1 !== segment.length)
        throw Error(
          "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
        );
      flushSegment(request, destination, segment[0], hoistableState);
      request.renderState.generateStaticMarkup ? destination = true : ((request = boundary.contentPreamble) && writePreambleContribution(destination, request), destination = destination.push("<!--/$-->"));
      return destination;
    }
    function flushSegmentContainer(request, destination, segment, hoistableState) {
      writeStartSegment(
        destination,
        request.renderState,
        segment.parentFormatContext,
        segment.id
      );
      flushSegment(request, destination, segment, hoistableState);
      return writeEndSegment(destination, segment.parentFormatContext);
    }
    function flushCompletedBoundary(request, destination, boundary) {
      for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++)
        flushPartiallyCompletedSegment(
          request,
          destination,
          boundary,
          completedSegments[i]
        );
      completedSegments.length = 0;
      writeHoistablesForBoundary(
        destination,
        boundary.contentState,
        request.renderState
      );
      completedSegments = request.resumableState;
      request = request.renderState;
      i = boundary.rootSegmentID;
      boundary = boundary.contentState;
      var requiresStyleInsertion = request.stylesToHoist;
      request.stylesToHoist = false;
      destination.push(request.startInlineScript);
      requiresStyleInsertion ? 0 === (completedSegments.instructions & 2) ? (completedSegments.instructions |= 10, destination.push(
        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
      )) : 0 === (completedSegments.instructions & 8) ? (completedSegments.instructions |= 8, destination.push(
        '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
      )) : destination.push('$RR("') : 0 === (completedSegments.instructions & 2) ? (completedSegments.instructions |= 2, destination.push(
        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
      )) : destination.push('$RC("');
      completedSegments = i.toString(16);
      destination.push(request.boundaryPrefix);
      destination.push(completedSegments);
      destination.push('","');
      destination.push(request.segmentPrefix);
      destination.push(completedSegments);
      requiresStyleInsertion ? (destination.push('",'), writeStyleResourceDependenciesInJS(destination, boundary)) : destination.push('"');
      boundary = destination.push(")</script>");
      return writeBootstrap(destination, request) && boundary;
    }
    function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
      if (2 === segment.status) return true;
      var hoistableState = boundary.contentState, segmentID = segment.id;
      if (-1 === segmentID) {
        if (-1 === (segment.id = boundary.rootSegmentID))
          throw Error(
            "A root segment ID must have been assigned by now. This is a bug in React."
          );
        return flushSegmentContainer(request, destination, segment, hoistableState);
      }
      if (segmentID === boundary.rootSegmentID)
        return flushSegmentContainer(request, destination, segment, hoistableState);
      flushSegmentContainer(request, destination, segment, hoistableState);
      boundary = request.resumableState;
      request = request.renderState;
      destination.push(request.startInlineScript);
      0 === (boundary.instructions & 1) ? (boundary.instructions |= 1, destination.push(
        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
      )) : destination.push('$RS("');
      destination.push(request.segmentPrefix);
      segmentID = segmentID.toString(16);
      destination.push(segmentID);
      destination.push('","');
      destination.push(request.placeholderPrefix);
      destination.push(segmentID);
      destination = destination.push('")</script>');
      return destination;
    }
    function flushCompletedQueues(request, destination) {
      try {
        if (!(0 < request.pendingRootTasks)) {
          var i, completedRootSegment = request.completedRootSegment;
          if (null !== completedRootSegment) {
            if (5 === completedRootSegment.status) return;
            var completedPreambleSegments = request.completedPreambleSegments;
            if (null === completedPreambleSegments) return;
            var renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
            if (htmlChunks) {
              for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
                destination.push(htmlChunks[i$jscomp$0]);
              if (headChunks)
                for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                  destination.push(headChunks[i$jscomp$0]);
              else {
                var chunk = startChunkForTag("head");
                destination.push(chunk);
                destination.push(">");
              }
            } else if (headChunks)
              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                destination.push(headChunks[i$jscomp$0]);
            var charsetChunks = renderState.charsetChunks;
            for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
              destination.push(charsetChunks[i$jscomp$0]);
            charsetChunks.length = 0;
            renderState.preconnects.forEach(flushResource, destination);
            renderState.preconnects.clear();
            var viewportChunks = renderState.viewportChunks;
            for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
              destination.push(viewportChunks[i$jscomp$0]);
            viewportChunks.length = 0;
            renderState.fontPreloads.forEach(flushResource, destination);
            renderState.fontPreloads.clear();
            renderState.highImagePreloads.forEach(flushResource, destination);
            renderState.highImagePreloads.clear();
            renderState.styles.forEach(flushStylesInPreamble, destination);
            var importMapChunks = renderState.importMapChunks;
            for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
              destination.push(importMapChunks[i$jscomp$0]);
            importMapChunks.length = 0;
            renderState.bootstrapScripts.forEach(flushResource, destination);
            renderState.scripts.forEach(flushResource, destination);
            renderState.scripts.clear();
            renderState.bulkPreloads.forEach(flushResource, destination);
            renderState.bulkPreloads.clear();
            var hoistableChunks = renderState.hoistableChunks;
            for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
              destination.push(hoistableChunks[i$jscomp$0]);
            for (renderState = hoistableChunks.length = 0; renderState < completedPreambleSegments.length; renderState++) {
              var segments = completedPreambleSegments[renderState];
              for (preamble = 0; preamble < segments.length; preamble++)
                flushSegment(request, destination, segments[preamble], null);
            }
            var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
            if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
              var chunk$jscomp$0 = endChunkForTag("head");
              destination.push(chunk$jscomp$0);
            }
            var bodyChunks = preamble$jscomp$0.bodyChunks;
            if (bodyChunks)
              for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
                destination.push(bodyChunks[completedPreambleSegments]);
            flushSegment(request, destination, completedRootSegment, null);
            request.completedRootSegment = null;
            writeBootstrap(destination, request.renderState);
          }
          var renderState$jscomp$0 = request.renderState;
          completedRootSegment = 0;
          var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;
          for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
            destination.push(viewportChunks$jscomp$0[completedRootSegment]);
          viewportChunks$jscomp$0.length = 0;
          renderState$jscomp$0.preconnects.forEach(flushResource, destination);
          renderState$jscomp$0.preconnects.clear();
          renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);
          renderState$jscomp$0.fontPreloads.clear();
          renderState$jscomp$0.highImagePreloads.forEach(
            flushResource,
            destination
          );
          renderState$jscomp$0.highImagePreloads.clear();
          renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);
          renderState$jscomp$0.scripts.forEach(flushResource, destination);
          renderState$jscomp$0.scripts.clear();
          renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);
          renderState$jscomp$0.bulkPreloads.clear();
          var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;
          for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
            destination.push(hoistableChunks$jscomp$0[completedRootSegment]);
          hoistableChunks$jscomp$0.length = 0;
          var clientRenderedBoundaries = request.clientRenderedBoundaries;
          for (i = 0; i < clientRenderedBoundaries.length; i++) {
            var boundary = clientRenderedBoundaries[i];
            renderState$jscomp$0 = destination;
            var resumableState = request.resumableState, renderState$jscomp$1 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest;
            renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript);
            0 === (resumableState.instructions & 4) ? (resumableState.instructions |= 4, renderState$jscomp$0.push(
              '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
            )) : renderState$jscomp$0.push('$RX("');
            renderState$jscomp$0.push(renderState$jscomp$1.boundaryPrefix);
            var chunk$jscomp$1 = id.toString(16);
            renderState$jscomp$0.push(chunk$jscomp$1);
            renderState$jscomp$0.push('"');
            if (errorDigest) {
              renderState$jscomp$0.push(",");
              var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(
                errorDigest || ""
              );
              renderState$jscomp$0.push(chunk$jscomp$2);
            }
            var JSCompiler_inline_result = renderState$jscomp$0.push(")</script>");
            if (!JSCompiler_inline_result) {
              request.destination = null;
              i++;
              clientRenderedBoundaries.splice(0, i);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i);
          var completedBoundaries = request.completedBoundaries;
          for (i = 0; i < completedBoundaries.length; i++)
            if (!flushCompletedBoundary(request, destination, completedBoundaries[i])) {
              request.destination = null;
              i++;
              completedBoundaries.splice(0, i);
              return;
            }
          completedBoundaries.splice(0, i);
          var partialBoundaries = request.partialBoundaries;
          for (i = 0; i < partialBoundaries.length; i++) {
            var boundary$51 = partialBoundaries[i];
            a: {
              clientRenderedBoundaries = request;
              boundary = destination;
              var completedSegments = boundary$51.completedSegments;
              for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
                if (!flushPartiallyCompletedSegment(
                  clientRenderedBoundaries,
                  boundary,
                  boundary$51,
                  completedSegments[JSCompiler_inline_result]
                )) {
                  JSCompiler_inline_result++;
                  completedSegments.splice(0, JSCompiler_inline_result);
                  var JSCompiler_inline_result$jscomp$0 = false;
                  break a;
                }
              completedSegments.splice(0, JSCompiler_inline_result);
              JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
                boundary,
                boundary$51.contentState,
                clientRenderedBoundaries.renderState
              );
            }
            if (!JSCompiler_inline_result$jscomp$0) {
              request.destination = null;
              i++;
              partialBoundaries.splice(0, i);
              return;
            }
          }
          partialBoundaries.splice(0, i);
          var largeBoundaries = request.completedBoundaries;
          for (i = 0; i < largeBoundaries.length; i++)
            if (!flushCompletedBoundary(request, destination, largeBoundaries[i])) {
              request.destination = null;
              i++;
              largeBoundaries.splice(0, i);
              return;
            }
          largeBoundaries.splice(0, i);
        }
      } finally {
        0 === request.allPendingTasks && 0 === request.pingedTasks.length && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length && (request.flushScheduled = false, i = request.resumableState, i.hasBody && (partialBoundaries = endChunkForTag("body"), destination.push(partialBoundaries)), i.hasHtml && (i = endChunkForTag("html"), destination.push(i)), request.status = 14, destination.push(null), request.destination = null);
      }
    }
    function enqueueFlush(request) {
      if (false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination) {
        request.flushScheduled = true;
        var destination = request.destination;
        destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
      }
    }
    function startFlowing(request, destination) {
      if (13 === request.status)
        request.status = 14, destination.destroy(request.fatalError);
      else if (14 !== request.status && null === request.destination) {
        request.destination = destination;
        try {
          flushCompletedQueues(request, destination);
        } catch (error) {
          logRecoverableError(request, error, {}), fatalError(request, error);
        }
      }
    }
    function abort(request, reason) {
      if (11 === request.status || 10 === request.status) request.status = 12;
      try {
        var abortableTasks = request.abortableTasks;
        if (0 < abortableTasks.size) {
          var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
          request.fatalError = error;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, error);
          });
          abortableTasks.clear();
        }
        null !== request.destination && flushCompletedQueues(request, request.destination);
      } catch (error$53) {
        logRecoverableError(request, error$53, {}), fatalError(request, error$53);
      }
    }
    function onError() {
    }
    function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
      var didFatal = false, fatalError2 = null, result = "", readyToStream = false;
      options = createResumableState(options ? options.identifierPrefix : void 0);
      children = createRequest(
        children,
        options,
        createRenderState(options, generateStaticMarkup),
        createFormatContext(0, null, 0),
        Infinity,
        onError,
        void 0,
        function() {
          readyToStream = true;
        },
        void 0,
        void 0,
        void 0
      );
      children.flushScheduled = null !== children.destination;
      performWork(children);
      10 === children.status && (children.status = 11);
      null === children.trackedPostpones && safelyEmitEarlyPreloads(children, 0 === children.pendingRootTasks);
      abort(children, abortReason);
      startFlowing(children, {
        push: function(chunk) {
          null !== chunk && (result += chunk);
          return true;
        },
        destroy: function(error) {
          didFatal = true;
          fatalError2 = error;
        }
      });
      if (didFatal && fatalError2 !== abortReason) throw fatalError2;
      if (!readyToStream)
        throw Error(
          "A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition."
        );
      return result;
    }
    exports2.renderToStaticMarkup = function(children, options) {
      return renderToStringImpl(
        children,
        options,
        true,
        'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server'
      );
    };
    exports2.renderToString = function(children, options) {
      return renderToStringImpl(
        children,
        options,
        false,
        'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server'
      );
    };
    exports2.version = "19.1.1";
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.production.js
var require_react_dom_server_node_production = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.production.js"(exports2) {
    "use strict";
    var util = require("util");
    var crypto = require("crypto");
    var async_hooks = require("async_hooks");
    var React12 = require_react();
    var ReactDOM = require_react_dom();
    var stream = require("stream");
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_SCOPE_TYPE = Symbol.for("react.scope");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    var REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    var isArrayImpl = Array.isArray;
    var scheduleMicrotask = queueMicrotask;
    function flushBuffered(destination) {
      "function" === typeof destination.flush && destination.flush();
    }
    var currentView = null;
    var writtenBytes = 0;
    var destinationHasCapacity$1 = true;
    function writeChunk(destination, chunk) {
      if ("string" === typeof chunk) {
        if (0 !== chunk.length)
          if (2048 < 3 * chunk.length)
            0 < writtenBytes && (writeToDestination(
              destination,
              currentView.subarray(0, writtenBytes)
            ), currentView = new Uint8Array(2048), writtenBytes = 0), writeToDestination(destination, chunk);
          else {
            var target = currentView;
            0 < writtenBytes && (target = currentView.subarray(writtenBytes));
            target = textEncoder.encodeInto(chunk, target);
            var read = target.read;
            writtenBytes += target.written;
            read < chunk.length && (writeToDestination(
              destination,
              currentView.subarray(0, writtenBytes)
            ), currentView = new Uint8Array(2048), writtenBytes = textEncoder.encodeInto(
              chunk.slice(read),
              currentView
            ).written);
            2048 === writtenBytes && (writeToDestination(destination, currentView), currentView = new Uint8Array(2048), writtenBytes = 0);
          }
      } else
        0 !== chunk.byteLength && (2048 < chunk.byteLength ? (0 < writtenBytes && (writeToDestination(
          destination,
          currentView.subarray(0, writtenBytes)
        ), currentView = new Uint8Array(2048), writtenBytes = 0), writeToDestination(destination, chunk)) : (target = currentView.length - writtenBytes, target < chunk.byteLength && (0 === target ? writeToDestination(destination, currentView) : (currentView.set(chunk.subarray(0, target), writtenBytes), writtenBytes += target, writeToDestination(destination, currentView), chunk = chunk.subarray(target)), currentView = new Uint8Array(2048), writtenBytes = 0), currentView.set(chunk, writtenBytes), writtenBytes += chunk.byteLength, 2048 === writtenBytes && (writeToDestination(destination, currentView), currentView = new Uint8Array(2048), writtenBytes = 0)));
    }
    function writeToDestination(destination, view) {
      destination = destination.write(view);
      destinationHasCapacity$1 = destinationHasCapacity$1 && destination;
    }
    function writeChunkAndReturn(destination, chunk) {
      writeChunk(destination, chunk);
      return destinationHasCapacity$1;
    }
    function completeWriting(destination) {
      currentView && 0 < writtenBytes && destination.write(currentView.subarray(0, writtenBytes));
      currentView = null;
      writtenBytes = 0;
      destinationHasCapacity$1 = true;
    }
    var textEncoder = new util.TextEncoder();
    function stringToPrecomputedChunk(content) {
      return textEncoder.encode(content);
    }
    var assign = Object.assign;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    );
    var illegalAttributeNameCache = {};
    var validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
        return true;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return validatedAttributeNameCache[attributeName] = true;
      illegalAttributeNameCache[attributeName] = true;
      return false;
    }
    var unitlessNumbers = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    );
    var aliases = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]);
    var matchHtmlRegExp = /["'&<>]/;
    function escapeTextForBrowser(text) {
      if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text)
        return "" + text;
      text = "" + text;
      var match = matchHtmlRegExp.exec(text);
      if (match) {
        var html = "", index, lastIndex = 0;
        for (index = match.index; index < text.length; index++) {
          switch (text.charCodeAt(index)) {
            case 34:
              match = "&quot;";
              break;
            case 38:
              match = "&amp;";
              break;
            case 39:
              match = "&#x27;";
              break;
            case 60:
              match = "&lt;";
              break;
            case 62:
              match = "&gt;";
              break;
            default:
              continue;
          }
          lastIndex !== index && (html += text.slice(lastIndex, index));
          lastIndex = index + 1;
          html += match;
        }
        text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
      }
      return text;
    }
    var uppercasePattern = /([A-Z])/g;
    var msPattern = /^ms-/;
    var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
    }
    var ReactSharedInternals = React12.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    var ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    var sharedNotPendingObject = {
      pending: false,
      data: null,
      method: null,
      action: null
    };
    var previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: previousDispatcher.f,
      r: previousDispatcher.r,
      D: prefetchDNS,
      C: preconnect,
      L: preload,
      m: preloadModule,
      X: preinitScript,
      S: preinitStyle,
      M: preinitModuleScript
    };
    var PRELOAD_NO_CREDS = [];
    stringToPrecomputedChunk('"></template>');
    var startInlineScript = stringToPrecomputedChunk("<script>");
    var endInlineScript = stringToPrecomputedChunk("</script>");
    var startScriptSrc = stringToPrecomputedChunk('<script src="');
    var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
    var scriptNonce = stringToPrecomputedChunk('" nonce="');
    var scriptIntegirty = stringToPrecomputedChunk('" integrity="');
    var scriptCrossOrigin = stringToPrecomputedChunk('" crossorigin="');
    var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
    var scriptRegex = /(<\/|<)(s)(cript)/gi;
    function scriptReplacer(match, prefix2, s2, suffix2) {
      return "" + prefix2 + ("s" === s2 ? "\\u0073" : "\\u0053") + suffix2;
    }
    var importMapScriptStart = stringToPrecomputedChunk(
      '<script type="importmap">'
    );
    var importMapScriptEnd = stringToPrecomputedChunk("</script>");
    function createRenderState(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {
      var inlineScriptWithNonce = void 0 === nonce ? startInlineScript : stringToPrecomputedChunk(
        '<script nonce="' + escapeTextForBrowser(nonce) + '">'
      ), idPrefix = resumableState.idPrefix;
      externalRuntimeConfig = [];
      var bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
      void 0 !== bootstrapScriptContent && externalRuntimeConfig.push(
        inlineScriptWithNonce,
        ("" + bootstrapScriptContent).replace(scriptRegex, scriptReplacer),
        endInlineScript
      );
      bootstrapScriptContent = [];
      void 0 !== importMap && (bootstrapScriptContent.push(importMapScriptStart), bootstrapScriptContent.push(
        ("" + JSON.stringify(importMap)).replace(scriptRegex, scriptReplacer)
      ), bootstrapScriptContent.push(importMapScriptEnd));
      importMap = onHeaders ? {
        preconnects: "",
        fontPreloads: "",
        highImagePreloads: "",
        remainingCapacity: 2 + ("number" === typeof maxHeadersLength ? maxHeadersLength : 2e3)
      } : null;
      onHeaders = {
        placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
        segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
        boundaryPrefix: stringToPrecomputedChunk(idPrefix + "B:"),
        startInlineScript: inlineScriptWithNonce,
        preamble: createPreambleState(),
        externalRuntimeScript: null,
        bootstrapChunks: externalRuntimeConfig,
        importMapChunks: bootstrapScriptContent,
        onHeaders,
        headers: importMap,
        resets: {
          font: {},
          dns: {},
          connect: { default: {}, anonymous: {}, credentials: {} },
          image: {},
          style: {}
        },
        charsetChunks: [],
        viewportChunks: [],
        hoistableChunks: [],
        preconnects: /* @__PURE__ */ new Set(),
        fontPreloads: /* @__PURE__ */ new Set(),
        highImagePreloads: /* @__PURE__ */ new Set(),
        styles: /* @__PURE__ */ new Map(),
        bootstrapScripts: /* @__PURE__ */ new Set(),
        scripts: /* @__PURE__ */ new Set(),
        bulkPreloads: /* @__PURE__ */ new Set(),
        preloads: {
          images: /* @__PURE__ */ new Map(),
          stylesheets: /* @__PURE__ */ new Map(),
          scripts: /* @__PURE__ */ new Map(),
          moduleScripts: /* @__PURE__ */ new Map()
        },
        nonce,
        hoistableState: null,
        stylesToHoist: false
      };
      if (void 0 !== bootstrapScripts)
        for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {
          var scriptConfig = bootstrapScripts[importMap];
          idPrefix = inlineScriptWithNonce = void 0;
          bootstrapScriptContent = {
            rel: "preload",
            as: "script",
            fetchPriority: "low",
            nonce
          };
          "string" === typeof scriptConfig ? bootstrapScriptContent.href = maxHeadersLength = scriptConfig : (bootstrapScriptContent.href = maxHeadersLength = scriptConfig.src, bootstrapScriptContent.integrity = idPrefix = "string" === typeof scriptConfig.integrity ? scriptConfig.integrity : void 0, bootstrapScriptContent.crossOrigin = inlineScriptWithNonce = "string" === typeof scriptConfig || null == scriptConfig.crossOrigin ? void 0 : "use-credentials" === scriptConfig.crossOrigin ? "use-credentials" : "");
          scriptConfig = resumableState;
          var href = maxHeadersLength;
          scriptConfig.scriptResources[href] = null;
          scriptConfig.moduleScriptResources[href] = null;
          scriptConfig = [];
          pushLinkImpl(scriptConfig, bootstrapScriptContent);
          onHeaders.bootstrapScripts.add(scriptConfig);
          externalRuntimeConfig.push(
            startScriptSrc,
            escapeTextForBrowser(maxHeadersLength)
          );
          nonce && externalRuntimeConfig.push(scriptNonce, escapeTextForBrowser(nonce));
          "string" === typeof idPrefix && externalRuntimeConfig.push(
            scriptIntegirty,
            escapeTextForBrowser(idPrefix)
          );
          "string" === typeof inlineScriptWithNonce && externalRuntimeConfig.push(
            scriptCrossOrigin,
            escapeTextForBrowser(inlineScriptWithNonce)
          );
          externalRuntimeConfig.push(endAsyncScript);
        }
      if (void 0 !== bootstrapModules)
        for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++)
          bootstrapScriptContent = bootstrapModules[bootstrapScripts], inlineScriptWithNonce = maxHeadersLength = void 0, idPrefix = {
            rel: "modulepreload",
            fetchPriority: "low",
            nonce
          }, "string" === typeof bootstrapScriptContent ? idPrefix.href = importMap = bootstrapScriptContent : (idPrefix.href = importMap = bootstrapScriptContent.src, idPrefix.integrity = inlineScriptWithNonce = "string" === typeof bootstrapScriptContent.integrity ? bootstrapScriptContent.integrity : void 0, idPrefix.crossOrigin = maxHeadersLength = "string" === typeof bootstrapScriptContent || null == bootstrapScriptContent.crossOrigin ? void 0 : "use-credentials" === bootstrapScriptContent.crossOrigin ? "use-credentials" : ""), bootstrapScriptContent = resumableState, scriptConfig = importMap, bootstrapScriptContent.scriptResources[scriptConfig] = null, bootstrapScriptContent.moduleScriptResources[scriptConfig] = null, bootstrapScriptContent = [], pushLinkImpl(bootstrapScriptContent, idPrefix), onHeaders.bootstrapScripts.add(bootstrapScriptContent), externalRuntimeConfig.push(
            startModuleSrc,
            escapeTextForBrowser(importMap)
          ), nonce && externalRuntimeConfig.push(scriptNonce, escapeTextForBrowser(nonce)), "string" === typeof inlineScriptWithNonce && externalRuntimeConfig.push(
            scriptIntegirty,
            escapeTextForBrowser(inlineScriptWithNonce)
          ), "string" === typeof maxHeadersLength && externalRuntimeConfig.push(
            scriptCrossOrigin,
            escapeTextForBrowser(maxHeadersLength)
          ), externalRuntimeConfig.push(endAsyncScript);
      return onHeaders;
    }
    function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
      return {
        idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
        nextFormID: 0,
        streamingFormat: 0,
        bootstrapScriptContent,
        bootstrapScripts,
        bootstrapModules,
        instructions: 0,
        hasBody: false,
        hasHtml: false,
        unknownResources: {},
        dnsResources: {},
        connectResources: { default: {}, anonymous: {}, credentials: {} },
        imageResources: {},
        styleResources: {},
        scriptResources: {},
        moduleUnknownResources: {},
        moduleScriptResources: {}
      };
    }
    function createPreambleState() {
      return {
        htmlChunks: null,
        headChunks: null,
        bodyChunks: null,
        contribution: 0
      };
    }
    function createFormatContext(insertionMode, selectedValue, tagScope) {
      return {
        insertionMode,
        selectedValue,
        tagScope
      };
    }
    function createRootFormatContext(namespaceURI) {
      return createFormatContext(
        "http://www.w3.org/2000/svg" === namespaceURI ? 4 : "http://www.w3.org/1998/Math/MathML" === namespaceURI ? 5 : 0,
        null,
        0
      );
    }
    function getChildFormatContext(parentContext, type, props) {
      switch (type) {
        case "noscript":
          return createFormatContext(2, null, parentContext.tagScope | 1);
        case "select":
          return createFormatContext(
            2,
            null != props.value ? props.value : props.defaultValue,
            parentContext.tagScope
          );
        case "svg":
          return createFormatContext(4, null, parentContext.tagScope);
        case "picture":
          return createFormatContext(2, null, parentContext.tagScope | 2);
        case "math":
          return createFormatContext(5, null, parentContext.tagScope);
        case "foreignObject":
          return createFormatContext(2, null, parentContext.tagScope);
        case "table":
          return createFormatContext(6, null, parentContext.tagScope);
        case "thead":
        case "tbody":
        case "tfoot":
          return createFormatContext(7, null, parentContext.tagScope);
        case "colgroup":
          return createFormatContext(9, null, parentContext.tagScope);
        case "tr":
          return createFormatContext(8, null, parentContext.tagScope);
        case "head":
          if (2 > parentContext.insertionMode)
            return createFormatContext(3, null, parentContext.tagScope);
          break;
        case "html":
          if (0 === parentContext.insertionMode)
            return createFormatContext(1, null, parentContext.tagScope);
      }
      return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode ? createFormatContext(2, null, parentContext.tagScope) : parentContext;
    }
    var textSeparator = stringToPrecomputedChunk("<!-- -->");
    function pushTextInstance(target, text, renderState, textEmbedded) {
      if ("" === text) return textEmbedded;
      textEmbedded && target.push(textSeparator);
      target.push(escapeTextForBrowser(text));
      return true;
    }
    var styleNameCache = /* @__PURE__ */ new Map();
    var styleAttributeStart = stringToPrecomputedChunk(' style="');
    var styleAssign = stringToPrecomputedChunk(":");
    var styleSeparator = stringToPrecomputedChunk(";");
    function pushStyleAttribute(target, style) {
      if ("object" !== typeof style)
        throw Error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      var isFirst = true, styleName;
      for (styleName in style)
        if (hasOwnProperty.call(style, styleName)) {
          var styleValue = style[styleName];
          if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
            if (0 === styleName.indexOf("--")) {
              var nameChunk = escapeTextForBrowser(styleName);
              styleValue = escapeTextForBrowser(("" + styleValue).trim());
            } else
              nameChunk = styleNameCache.get(styleName), void 0 === nameChunk && (nameChunk = stringToPrecomputedChunk(
                escapeTextForBrowser(
                  styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")
                )
              ), styleNameCache.set(styleName, nameChunk)), styleValue = "number" === typeof styleValue ? 0 === styleValue || unitlessNumbers.has(styleName) ? "" + styleValue : styleValue + "px" : escapeTextForBrowser(("" + styleValue).trim());
            isFirst ? (isFirst = false, target.push(
              styleAttributeStart,
              nameChunk,
              styleAssign,
              styleValue
            )) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);
          }
        }
      isFirst || target.push(attributeEnd);
    }
    var attributeSeparator = stringToPrecomputedChunk(" ");
    var attributeAssign = stringToPrecomputedChunk('="');
    var attributeEnd = stringToPrecomputedChunk('"');
    var attributeEmptyString = stringToPrecomputedChunk('=""');
    function pushBooleanAttribute(target, name2, value) {
      value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name2, attributeEmptyString);
    }
    function pushStringAttribute(target, name2, value) {
      "function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(
        attributeSeparator,
        name2,
        attributeAssign,
        escapeTextForBrowser(value),
        attributeEnd
      );
    }
    var actionJavaScriptURL = stringToPrecomputedChunk(
      escapeTextForBrowser(
        "javascript:throw new Error('React form unexpectedly submitted.')"
      )
    );
    var startHiddenInputChunk = stringToPrecomputedChunk('<input type="hidden"');
    function pushAdditionalFormField(value, key) {
      this.push(startHiddenInputChunk);
      validateAdditionalFormField(value);
      pushStringAttribute(this, "name", key);
      pushStringAttribute(this, "value", value);
      this.push(endOfStartTagSelfClosing);
    }
    function validateAdditionalFormField(value) {
      if ("string" !== typeof value)
        throw Error(
          "File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration."
        );
    }
    function getCustomFormFields(resumableState, formAction) {
      if ("function" === typeof formAction.$$FORM_ACTION) {
        var id = resumableState.nextFormID++;
        resumableState = resumableState.idPrefix + id;
        try {
          var customFields = formAction.$$FORM_ACTION(resumableState);
          if (customFields) {
            var formData = customFields.data;
            null != formData && formData.forEach(validateAdditionalFormField);
          }
          return customFields;
        } catch (x) {
          if ("object" === typeof x && null !== x && "function" === typeof x.then)
            throw x;
        }
      }
      return null;
    }
    function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name2) {
      var formData = null;
      if ("function" === typeof formAction) {
        var customFields = getCustomFormFields(resumableState, formAction);
        null !== customFields ? (name2 = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(
          attributeSeparator,
          "formAction",
          attributeAssign,
          actionJavaScriptURL,
          attributeEnd
        ), formTarget = formMethod = formEncType = formAction = name2 = null, injectFormReplayingRuntime(resumableState, renderState));
      }
      null != name2 && pushAttribute(target, "name", name2);
      null != formAction && pushAttribute(target, "formAction", formAction);
      null != formEncType && pushAttribute(target, "formEncType", formEncType);
      null != formMethod && pushAttribute(target, "formMethod", formMethod);
      null != formTarget && pushAttribute(target, "formTarget", formTarget);
      return formData;
    }
    function pushAttribute(target, name2, value) {
      switch (name2) {
        case "className":
          pushStringAttribute(target, "class", value);
          break;
        case "tabIndex":
          pushStringAttribute(target, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          pushStringAttribute(target, name2, value);
          break;
        case "style":
          pushStyleAttribute(target, value);
          break;
        case "src":
        case "href":
          if ("" === value) break;
        case "action":
        case "formAction":
          if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
            break;
          value = sanitizeURL("" + value);
          target.push(
            attributeSeparator,
            name2,
            attributeAssign,
            escapeTextForBrowser(value),
            attributeEnd
          );
          break;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "ref":
          break;
        case "autoFocus":
        case "multiple":
        case "muted":
          pushBooleanAttribute(target, name2.toLowerCase(), value);
          break;
        case "xlinkHref":
          if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
            break;
          value = sanitizeURL("" + value);
          target.push(
            attributeSeparator,
            "xlink:href",
            attributeAssign,
            escapeTextForBrowser(value),
            attributeEnd
          );
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          "function" !== typeof value && "symbol" !== typeof value && target.push(
            attributeSeparator,
            name2,
            attributeAssign,
            escapeTextForBrowser(value),
            attributeEnd
          );
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name2, attributeEmptyString);
          break;
        case "capture":
        case "download":
          true === value ? target.push(attributeSeparator, name2, attributeEmptyString) : false !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(
            attributeSeparator,
            name2,
            attributeAssign,
            escapeTextForBrowser(value),
            attributeEnd
          );
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(
            attributeSeparator,
            name2,
            attributeAssign,
            escapeTextForBrowser(value),
            attributeEnd
          );
          break;
        case "rowSpan":
        case "start":
          "function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(
            attributeSeparator,
            name2,
            attributeAssign,
            escapeTextForBrowser(value),
            attributeEnd
          );
          break;
        case "xlinkActuate":
          pushStringAttribute(target, "xlink:actuate", value);
          break;
        case "xlinkArcrole":
          pushStringAttribute(target, "xlink:arcrole", value);
          break;
        case "xlinkRole":
          pushStringAttribute(target, "xlink:role", value);
          break;
        case "xlinkShow":
          pushStringAttribute(target, "xlink:show", value);
          break;
        case "xlinkTitle":
          pushStringAttribute(target, "xlink:title", value);
          break;
        case "xlinkType":
          pushStringAttribute(target, "xlink:type", value);
          break;
        case "xmlBase":
          pushStringAttribute(target, "xml:base", value);
          break;
        case "xmlLang":
          pushStringAttribute(target, "xml:lang", value);
          break;
        case "xmlSpace":
          pushStringAttribute(target, "xml:space", value);
          break;
        default:
          if (!(2 < name2.length) || "o" !== name2[0] && "O" !== name2[0] || "n" !== name2[1] && "N" !== name2[1]) {
            if (name2 = aliases.get(name2) || name2, isAttributeNameSafe(name2)) {
              switch (typeof value) {
                case "function":
                case "symbol":
                  return;
                case "boolean":
                  var prefix$8 = name2.toLowerCase().slice(0, 5);
                  if ("data-" !== prefix$8 && "aria-" !== prefix$8) return;
              }
              target.push(
                attributeSeparator,
                name2,
                attributeAssign,
                escapeTextForBrowser(value),
                attributeEnd
              );
            }
          }
      }
    }
    var endOfStartTag = stringToPrecomputedChunk(">");
    var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
    function pushInnerHTML(target, innerHTML, children) {
      if (null != innerHTML) {
        if (null != children)
          throw Error(
            "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
          );
        if ("object" !== typeof innerHTML || !("__html" in innerHTML))
          throw Error(
            "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
          );
        innerHTML = innerHTML.__html;
        null !== innerHTML && void 0 !== innerHTML && target.push("" + innerHTML);
      }
    }
    function flattenOptionChildren(children) {
      var content = "";
      React12.Children.forEach(children, function(child) {
        null != child && (content += child);
      });
      return content;
    }
    var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
    var formReplayingRuntimeScript = stringToPrecomputedChunk(
      `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`
    );
    function injectFormReplayingRuntime(resumableState, renderState) {
      0 === (resumableState.instructions & 16) && (resumableState.instructions |= 16, renderState.bootstrapChunks.unshift(
        renderState.startInlineScript,
        formReplayingRuntimeScript,
        endInlineScript
      ));
    }
    var formStateMarkerIsMatching = stringToPrecomputedChunk("<!--F!-->");
    var formStateMarkerIsNotMatching = stringToPrecomputedChunk("<!--F-->");
    function pushLinkImpl(target, props) {
      target.push(startChunkForTag("link"));
      for (var propKey in props)
        if (hasOwnProperty.call(props, propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(
                  "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                );
              default:
                pushAttribute(target, propKey, propValue);
            }
        }
      target.push(endOfStartTagSelfClosing);
      return null;
    }
    var styleRegex = /(<\/|<)(s)(tyle)/gi;
    function styleReplacer(match, prefix2, s2, suffix2) {
      return "" + prefix2 + ("s" === s2 ? "\\73 " : "\\53 ") + suffix2;
    }
    function pushSelfClosing(target, props, tag) {
      target.push(startChunkForTag(tag));
      for (var propKey in props)
        if (hasOwnProperty.call(props, propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(
                  tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                );
              default:
                pushAttribute(target, propKey, propValue);
            }
        }
      target.push(endOfStartTagSelfClosing);
      return null;
    }
    function pushTitleImpl(target, props) {
      target.push(startChunkForTag("title"));
      var children = null, innerHTML = null, propKey;
      for (propKey in props)
        if (hasOwnProperty.call(props, propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, propKey, propValue);
            }
        }
      target.push(endOfStartTag);
      props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
      "function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(escapeTextForBrowser("" + props));
      pushInnerHTML(target, innerHTML, children);
      target.push(endChunkForTag("title"));
      return null;
    }
    function pushScriptImpl(target, props) {
      target.push(startChunkForTag("script"));
      var children = null, innerHTML = null, propKey;
      for (propKey in props)
        if (hasOwnProperty.call(props, propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, propKey, propValue);
            }
        }
      target.push(endOfStartTag);
      pushInnerHTML(target, innerHTML, children);
      "string" === typeof children && target.push(("" + children).replace(scriptRegex, scriptReplacer));
      target.push(endChunkForTag("script"));
      return null;
    }
    function pushStartSingletonElement(target, props, tag) {
      target.push(startChunkForTag(tag));
      var innerHTML = tag = null, propKey;
      for (propKey in props)
        if (hasOwnProperty.call(props, propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "children":
                tag = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, propKey, propValue);
            }
        }
      target.push(endOfStartTag);
      pushInnerHTML(target, innerHTML, tag);
      return tag;
    }
    function pushStartGenericElement(target, props, tag) {
      target.push(startChunkForTag(tag));
      var innerHTML = tag = null, propKey;
      for (propKey in props)
        if (hasOwnProperty.call(props, propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "children":
                tag = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, propKey, propValue);
            }
        }
      target.push(endOfStartTag);
      pushInnerHTML(target, innerHTML, tag);
      return "string" === typeof tag ? (target.push(escapeTextForBrowser(tag)), null) : tag;
    }
    var leadingNewline = stringToPrecomputedChunk("\n");
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var validatedTagCache = /* @__PURE__ */ new Map();
    function startChunkForTag(tag) {
      var tagStartChunk = validatedTagCache.get(tag);
      if (void 0 === tagStartChunk) {
        if (!VALID_TAG_REGEX.test(tag)) throw Error("Invalid tag: " + tag);
        tagStartChunk = stringToPrecomputedChunk("<" + tag);
        validatedTagCache.set(tag, tagStartChunk);
      }
      return tagStartChunk;
    }
    var doctypeChunk = stringToPrecomputedChunk("<!DOCTYPE html>");
    function pushStartInstance(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded, isFallback) {
      switch (type) {
        case "div":
        case "span":
        case "svg":
        case "path":
          break;
        case "a":
          target$jscomp$0.push(startChunkForTag("a"));
          var children = null, innerHTML = null, propKey;
          for (propKey in props)
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "href":
                    "" === propValue ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                    break;
                  default:
                    pushAttribute(target$jscomp$0, propKey, propValue);
                }
            }
          target$jscomp$0.push(endOfStartTag);
          pushInnerHTML(target$jscomp$0, innerHTML, children);
          if ("string" === typeof children) {
            target$jscomp$0.push(escapeTextForBrowser(children));
            var JSCompiler_inline_result = null;
          } else JSCompiler_inline_result = children;
          return JSCompiler_inline_result;
        case "g":
        case "p":
        case "li":
          break;
        case "select":
          target$jscomp$0.push(startChunkForTag("select"));
          var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
          for (propKey$jscomp$0 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$0)) {
              var propValue$jscomp$0 = props[propKey$jscomp$0];
              if (null != propValue$jscomp$0)
                switch (propKey$jscomp$0) {
                  case "children":
                    children$jscomp$0 = propValue$jscomp$0;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$0 = propValue$jscomp$0;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$0,
                      propValue$jscomp$0
                    );
                }
            }
          target$jscomp$0.push(endOfStartTag);
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
          return children$jscomp$0;
        case "option":
          var selectedValue = formatContext.selectedValue;
          target$jscomp$0.push(startChunkForTag("option"));
          var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
          for (propKey$jscomp$1 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$1)) {
              var propValue$jscomp$1 = props[propKey$jscomp$1];
              if (null != propValue$jscomp$1)
                switch (propKey$jscomp$1) {
                  case "children":
                    children$jscomp$1 = propValue$jscomp$1;
                    break;
                  case "selected":
                    selected = propValue$jscomp$1;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$1 = propValue$jscomp$1;
                    break;
                  case "value":
                    value = propValue$jscomp$1;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$1,
                      propValue$jscomp$1
                    );
                }
            }
          if (null != selectedValue) {
            var stringValue = null !== value ? "" + value : flattenOptionChildren(children$jscomp$1);
            if (isArrayImpl(selectedValue))
              for (var i = 0; i < selectedValue.length; i++) {
                if ("" + selectedValue[i] === stringValue) {
                  target$jscomp$0.push(selectedMarkerAttribute);
                  break;
                }
              }
            else
              "" + selectedValue === stringValue && target$jscomp$0.push(selectedMarkerAttribute);
          } else selected && target$jscomp$0.push(selectedMarkerAttribute);
          target$jscomp$0.push(endOfStartTag);
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
          return children$jscomp$1;
        case "textarea":
          target$jscomp$0.push(startChunkForTag("textarea"));
          var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
          for (propKey$jscomp$2 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$2)) {
              var propValue$jscomp$2 = props[propKey$jscomp$2];
              if (null != propValue$jscomp$2)
                switch (propKey$jscomp$2) {
                  case "children":
                    children$jscomp$2 = propValue$jscomp$2;
                    break;
                  case "value":
                    value$jscomp$0 = propValue$jscomp$2;
                    break;
                  case "defaultValue":
                    defaultValue = propValue$jscomp$2;
                    break;
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$2,
                      propValue$jscomp$2
                    );
                }
            }
          null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
          target$jscomp$0.push(endOfStartTag);
          if (null != children$jscomp$2) {
            if (null != value$jscomp$0)
              throw Error(
                "If you supply `defaultValue` on a <textarea>, do not pass children."
              );
            if (isArrayImpl(children$jscomp$2)) {
              if (1 < children$jscomp$2.length)
                throw Error("<textarea> can only have at most one child.");
              value$jscomp$0 = "" + children$jscomp$2[0];
            }
            value$jscomp$0 = "" + children$jscomp$2;
          }
          "string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline);
          null !== value$jscomp$0 && target$jscomp$0.push(escapeTextForBrowser("" + value$jscomp$0));
          return null;
        case "input":
          target$jscomp$0.push(startChunkForTag("input"));
          var name2 = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
          for (propKey$jscomp$3 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$3)) {
              var propValue$jscomp$3 = props[propKey$jscomp$3];
              if (null != propValue$jscomp$3)
                switch (propKey$jscomp$3) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      "input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  case "name":
                    name2 = propValue$jscomp$3;
                    break;
                  case "formAction":
                    formAction = propValue$jscomp$3;
                    break;
                  case "formEncType":
                    formEncType = propValue$jscomp$3;
                    break;
                  case "formMethod":
                    formMethod = propValue$jscomp$3;
                    break;
                  case "formTarget":
                    formTarget = propValue$jscomp$3;
                    break;
                  case "defaultChecked":
                    defaultChecked = propValue$jscomp$3;
                    break;
                  case "defaultValue":
                    defaultValue$jscomp$0 = propValue$jscomp$3;
                    break;
                  case "checked":
                    checked = propValue$jscomp$3;
                    break;
                  case "value":
                    value$jscomp$1 = propValue$jscomp$3;
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$3,
                      propValue$jscomp$3
                    );
                }
            }
          var formData = pushFormActionAttribute(
            target$jscomp$0,
            resumableState,
            renderState,
            formAction,
            formEncType,
            formMethod,
            formTarget,
            name2
          );
          null !== checked ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
          null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
          target$jscomp$0.push(endOfStartTagSelfClosing);
          null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);
          return null;
        case "button":
          target$jscomp$0.push(startChunkForTag("button"));
          var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
          for (propKey$jscomp$4 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$4)) {
              var propValue$jscomp$4 = props[propKey$jscomp$4];
              if (null != propValue$jscomp$4)
                switch (propKey$jscomp$4) {
                  case "children":
                    children$jscomp$3 = propValue$jscomp$4;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$2 = propValue$jscomp$4;
                    break;
                  case "name":
                    name$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formAction":
                    formAction$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formEncType":
                    formEncType$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formMethod":
                    formMethod$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formTarget":
                    formTarget$jscomp$0 = propValue$jscomp$4;
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$4,
                      propValue$jscomp$4
                    );
                }
            }
          var formData$jscomp$0 = pushFormActionAttribute(
            target$jscomp$0,
            resumableState,
            renderState,
            formAction$jscomp$0,
            formEncType$jscomp$0,
            formMethod$jscomp$0,
            formTarget$jscomp$0,
            name$jscomp$0
          );
          target$jscomp$0.push(endOfStartTag);
          null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
          if ("string" === typeof children$jscomp$3) {
            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));
            var JSCompiler_inline_result$jscomp$0 = null;
          } else JSCompiler_inline_result$jscomp$0 = children$jscomp$3;
          return JSCompiler_inline_result$jscomp$0;
        case "form":
          target$jscomp$0.push(startChunkForTag("form"));
          var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
          for (propKey$jscomp$5 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$5)) {
              var propValue$jscomp$5 = props[propKey$jscomp$5];
              if (null != propValue$jscomp$5)
                switch (propKey$jscomp$5) {
                  case "children":
                    children$jscomp$4 = propValue$jscomp$5;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$3 = propValue$jscomp$5;
                    break;
                  case "action":
                    formAction$jscomp$1 = propValue$jscomp$5;
                    break;
                  case "encType":
                    formEncType$jscomp$1 = propValue$jscomp$5;
                    break;
                  case "method":
                    formMethod$jscomp$1 = propValue$jscomp$5;
                    break;
                  case "target":
                    formTarget$jscomp$1 = propValue$jscomp$5;
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$5,
                      propValue$jscomp$5
                    );
                }
            }
          var formData$jscomp$1 = null, formActionName = null;
          if ("function" === typeof formAction$jscomp$1) {
            var customFields = getCustomFormFields(
              resumableState,
              formAction$jscomp$1
            );
            null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(
              attributeSeparator,
              "action",
              attributeAssign,
              actionJavaScriptURL,
              attributeEnd
            ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
          }
          null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
          null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
          null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
          null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
          target$jscomp$0.push(endOfStartTag);
          null !== formActionName && (target$jscomp$0.push(startHiddenInputChunk), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), null != formData$jscomp$1 && formData$jscomp$1.forEach(pushAdditionalFormField, target$jscomp$0));
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
          if ("string" === typeof children$jscomp$4) {
            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));
            var JSCompiler_inline_result$jscomp$1 = null;
          } else JSCompiler_inline_result$jscomp$1 = children$jscomp$4;
          return JSCompiler_inline_result$jscomp$1;
        case "menuitem":
          target$jscomp$0.push(startChunkForTag("menuitem"));
          for (var propKey$jscomp$6 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$6)) {
              var propValue$jscomp$6 = props[propKey$jscomp$6];
              if (null != propValue$jscomp$6)
                switch (propKey$jscomp$6) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      "menuitems cannot have `children` nor `dangerouslySetInnerHTML`."
                    );
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$6,
                      propValue$jscomp$6
                    );
                }
            }
          target$jscomp$0.push(endOfStartTag);
          return null;
        case "object":
          target$jscomp$0.push(startChunkForTag("object"));
          var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
          for (propKey$jscomp$7 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$7)) {
              var propValue$jscomp$7 = props[propKey$jscomp$7];
              if (null != propValue$jscomp$7)
                switch (propKey$jscomp$7) {
                  case "children":
                    children$jscomp$5 = propValue$jscomp$7;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$4 = propValue$jscomp$7;
                    break;
                  case "data":
                    var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                    if ("" === sanitizedValue) break;
                    target$jscomp$0.push(
                      attributeSeparator,
                      "data",
                      attributeAssign,
                      escapeTextForBrowser(sanitizedValue),
                      attributeEnd
                    );
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$7,
                      propValue$jscomp$7
                    );
                }
            }
          target$jscomp$0.push(endOfStartTag);
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
          if ("string" === typeof children$jscomp$5) {
            target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));
            var JSCompiler_inline_result$jscomp$2 = null;
          } else JSCompiler_inline_result$jscomp$2 = children$jscomp$5;
          return JSCompiler_inline_result$jscomp$2;
        case "title":
          if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp)
            var JSCompiler_inline_result$jscomp$3 = pushTitleImpl(
              target$jscomp$0,
              props
            );
          else
            isFallback ? JSCompiler_inline_result$jscomp$3 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$3 = void 0);
          return JSCompiler_inline_result$jscomp$3;
        case "link":
          var rel = props.rel, href = props.href, precedence = props.precedence;
          if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
            pushLinkImpl(target$jscomp$0, props);
            var JSCompiler_inline_result$jscomp$4 = null;
          } else if ("stylesheet" === props.rel)
            if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError)
              JSCompiler_inline_result$jscomp$4 = pushLinkImpl(
                target$jscomp$0,
                props
              );
            else {
              var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
              if (null !== resourceState) {
                resumableState.styleResources[href] = null;
                styleQueue || (styleQueue = {
                  precedence: escapeTextForBrowser(precedence),
                  rules: [],
                  hrefs: [],
                  sheets: /* @__PURE__ */ new Map()
                }, renderState.styles.set(precedence, styleQueue));
                var resource = {
                  state: 0,
                  props: assign({}, props, {
                    "data-precedence": props.precedence,
                    precedence: null
                  })
                };
                if (resourceState) {
                  2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);
                  var preloadResource = renderState.preloads.stylesheets.get(href);
                  preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = 1;
                }
                styleQueue.sheets.set(href, resource);
                hoistableState && hoistableState.stylesheets.add(resource);
              } else if (styleQueue) {
                var resource$9 = styleQueue.sheets.get(href);
                resource$9 && hoistableState && hoistableState.stylesheets.add(resource$9);
              }
              textEmbedded && target$jscomp$0.push(textSeparator);
              JSCompiler_inline_result$jscomp$4 = null;
            }
          else
            props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$4 = pushLinkImpl(
              target$jscomp$0,
              props
            ) : (textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$4 = isFallback ? null : pushLinkImpl(renderState.hoistableChunks, props));
          return JSCompiler_inline_result$jscomp$4;
        case "script":
          var asyncProp = props.async;
          if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || 4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp)
            var JSCompiler_inline_result$jscomp$5 = pushScriptImpl(
              target$jscomp$0,
              props
            );
          else {
            var key = props.src;
            if ("module" === props.type) {
              var resources = resumableState.moduleScriptResources;
              var preloads = renderState.preloads.moduleScripts;
            } else
              resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
            var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
            if (null !== resourceState$jscomp$0) {
              resources[key] = null;
              var scriptProps = props;
              if (resourceState$jscomp$0) {
                2 === resourceState$jscomp$0.length && (scriptProps = assign({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
                var preloadResource$jscomp$0 = preloads.get(key);
                preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
              }
              var resource$jscomp$0 = [];
              renderState.scripts.add(resource$jscomp$0);
              pushScriptImpl(resource$jscomp$0, scriptProps);
            }
            textEmbedded && target$jscomp$0.push(textSeparator);
            JSCompiler_inline_result$jscomp$5 = null;
          }
          return JSCompiler_inline_result$jscomp$5;
        case "style":
          var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href;
          if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
            target$jscomp$0.push(startChunkForTag("style"));
            var children$jscomp$6 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
            for (propKey$jscomp$8 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$8)) {
                var propValue$jscomp$8 = props[propKey$jscomp$8];
                if (null != propValue$jscomp$8)
                  switch (propKey$jscomp$8) {
                    case "children":
                      children$jscomp$6 = propValue$jscomp$8;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$5 = propValue$jscomp$8;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$8,
                        propValue$jscomp$8
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            var child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
            "function" !== typeof child && "symbol" !== typeof child && null !== child && void 0 !== child && target$jscomp$0.push(("" + child).replace(styleRegex, styleReplacer));
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$6);
            target$jscomp$0.push(endChunkForTag("style"));
            var JSCompiler_inline_result$jscomp$6 = null;
          } else {
            var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0);
            if (null !== (resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0)) {
              resumableState.styleResources[href$jscomp$0] = null;
              styleQueue$jscomp$0 ? styleQueue$jscomp$0.hrefs.push(
                escapeTextForBrowser(href$jscomp$0)
              ) : (styleQueue$jscomp$0 = {
                precedence: escapeTextForBrowser(precedence$jscomp$0),
                rules: [],
                hrefs: [escapeTextForBrowser(href$jscomp$0)],
                sheets: /* @__PURE__ */ new Map()
              }, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));
              var target = styleQueue$jscomp$0.rules, children$jscomp$7 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
              for (propKey$jscomp$9 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$9)) {
                  var propValue$jscomp$9 = props[propKey$jscomp$9];
                  if (null != propValue$jscomp$9)
                    switch (propKey$jscomp$9) {
                      case "children":
                        children$jscomp$7 = propValue$jscomp$9;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$6 = propValue$jscomp$9;
                    }
                }
              var child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
              "function" !== typeof child$jscomp$0 && "symbol" !== typeof child$jscomp$0 && null !== child$jscomp$0 && void 0 !== child$jscomp$0 && target.push(
                ("" + child$jscomp$0).replace(styleRegex, styleReplacer)
              );
              pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$7);
            }
            styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
            textEmbedded && target$jscomp$0.push(textSeparator);
            JSCompiler_inline_result$jscomp$6 = void 0;
          }
          return JSCompiler_inline_result$jscomp$6;
        case "meta":
          if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp)
            var JSCompiler_inline_result$jscomp$7 = pushSelfClosing(
              target$jscomp$0,
              props,
              "meta"
            );
          else
            textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$7 = isFallback ? null : "string" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(renderState.hoistableChunks, props, "meta");
          return JSCompiler_inline_result$jscomp$7;
        case "listing":
        case "pre":
          target$jscomp$0.push(startChunkForTag(type));
          var children$jscomp$8 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
          for (propKey$jscomp$10 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$10)) {
              var propValue$jscomp$10 = props[propKey$jscomp$10];
              if (null != propValue$jscomp$10)
                switch (propKey$jscomp$10) {
                  case "children":
                    children$jscomp$8 = propValue$jscomp$10;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$7 = propValue$jscomp$10;
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$10,
                      propValue$jscomp$10
                    );
                }
            }
          target$jscomp$0.push(endOfStartTag);
          if (null != innerHTML$jscomp$7) {
            if (null != children$jscomp$8)
              throw Error(
                "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
              );
            if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            var html = innerHTML$jscomp$7.__html;
            null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push(leadingNewline, html) : target$jscomp$0.push("" + html));
          }
          "string" === typeof children$jscomp$8 && "\n" === children$jscomp$8[0] && target$jscomp$0.push(leadingNewline);
          return children$jscomp$8;
        case "img":
          var src = props.src, srcSet = props.srcSet;
          if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet) && "low" !== props.fetchPriority && false === !!(formatContext.tagScope & 3) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
            var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
            if (resource$jscomp$1) {
              if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size)
                promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
            } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
              resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
              var input = props.crossOrigin;
              var JSCompiler_inline_result$jscomp$8 = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
              var headers = renderState.headers, header;
              headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
                imageSrcSet: props.srcSet,
                imageSizes: props.sizes,
                crossOrigin: JSCompiler_inline_result$jscomp$8,
                integrity: props.integrity,
                nonce: props.nonce,
                type: props.type,
                fetchPriority: props.fetchPriority,
                referrerPolicy: props.refererPolicy
              }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
                rel: "preload",
                as: "image",
                href: srcSet ? void 0 : src,
                imageSrcSet: srcSet,
                imageSizes: sizes,
                crossOrigin: JSCompiler_inline_result$jscomp$8,
                integrity: props.integrity,
                type: props.type,
                fetchPriority: props.fetchPriority,
                referrerPolicy: props.referrerPolicy
              }), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
            }
          }
          return pushSelfClosing(target$jscomp$0, props, "img");
        case "base":
        case "area":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return pushSelfClosing(target$jscomp$0, props, type);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          break;
        case "head":
          if (2 > formatContext.insertionMode) {
            var preamble = preambleState || renderState.preamble;
            if (preamble.headChunks)
              throw Error("The `<head>` tag may only be rendered once.");
            preamble.headChunks = [];
            var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(
              preamble.headChunks,
              props,
              "head"
            );
          } else
            JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
              target$jscomp$0,
              props,
              "head"
            );
          return JSCompiler_inline_result$jscomp$9;
        case "body":
          if (2 > formatContext.insertionMode) {
            var preamble$jscomp$0 = preambleState || renderState.preamble;
            if (preamble$jscomp$0.bodyChunks)
              throw Error("The `<body>` tag may only be rendered once.");
            preamble$jscomp$0.bodyChunks = [];
            var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(
              preamble$jscomp$0.bodyChunks,
              props,
              "body"
            );
          } else
            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
              target$jscomp$0,
              props,
              "body"
            );
          return JSCompiler_inline_result$jscomp$10;
        case "html":
          if (0 === formatContext.insertionMode) {
            var preamble$jscomp$1 = preambleState || renderState.preamble;
            if (preamble$jscomp$1.htmlChunks)
              throw Error("The `<html>` tag may only be rendered once.");
            preamble$jscomp$1.htmlChunks = [doctypeChunk];
            var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(
              preamble$jscomp$1.htmlChunks,
              props,
              "html"
            );
          } else
            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
              target$jscomp$0,
              props,
              "html"
            );
          return JSCompiler_inline_result$jscomp$11;
        default:
          if (-1 !== type.indexOf("-")) {
            target$jscomp$0.push(startChunkForTag(type));
            var children$jscomp$9 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
            for (propKey$jscomp$11 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$11)) {
                var propValue$jscomp$11 = props[propKey$jscomp$11];
                if (null != propValue$jscomp$11) {
                  var attributeName = propKey$jscomp$11;
                  switch (propKey$jscomp$11) {
                    case "children":
                      children$jscomp$9 = propValue$jscomp$11;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$8 = propValue$jscomp$11;
                      break;
                    case "style":
                      pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                      break;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "ref":
                      break;
                    case "className":
                      attributeName = "class";
                    default:
                      if (isAttributeNameSafe(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {
                        if (true === propValue$jscomp$11) propValue$jscomp$11 = "";
                        else if ("object" === typeof propValue$jscomp$11) continue;
                        target$jscomp$0.push(
                          attributeSeparator,
                          attributeName,
                          attributeAssign,
                          escapeTextForBrowser(propValue$jscomp$11),
                          attributeEnd
                        );
                      }
                  }
                }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$9);
            return children$jscomp$9;
          }
      }
      return pushStartGenericElement(target$jscomp$0, props, type);
    }
    var endTagCache = /* @__PURE__ */ new Map();
    function endChunkForTag(tag) {
      var chunk = endTagCache.get(tag);
      void 0 === chunk && (chunk = stringToPrecomputedChunk("</" + tag + ">"), endTagCache.set(tag, chunk));
      return chunk;
    }
    function hoistPreambleState(renderState, preambleState) {
      renderState = renderState.preamble;
      null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks, preambleState.contribution |= 1);
      null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks, preambleState.contribution |= 4);
      null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks, preambleState.contribution |= 2);
    }
    function writeBootstrap(destination, renderState) {
      renderState = renderState.bootstrapChunks;
      for (var i = 0; i < renderState.length - 1; i++)
        writeChunk(destination, renderState[i]);
      return i < renderState.length ? (i = renderState[i], renderState.length = 0, writeChunkAndReturn(destination, i)) : true;
    }
    var placeholder1 = stringToPrecomputedChunk('<template id="');
    var placeholder2 = stringToPrecomputedChunk('"></template>');
    var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
    var startPendingSuspenseBoundary1 = stringToPrecomputedChunk(
      '<!--$?--><template id="'
    );
    var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
    var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
    var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
    var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
    var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
    var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
    stringToPrecomputedChunk(' data-msg="');
    stringToPrecomputedChunk(' data-stck="');
    stringToPrecomputedChunk(' data-cstck="');
    var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
    function writeStartPendingSuspenseBoundary(destination, renderState, id) {
      writeChunk(destination, startPendingSuspenseBoundary1);
      if (null === id)
        throw Error(
          "An ID must have been assigned before we can complete the boundary."
        );
      writeChunk(destination, renderState.boundaryPrefix);
      writeChunk(destination, id.toString(16));
      return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
    }
    var boundaryPreambleContributionChunkStart = stringToPrecomputedChunk("<!--");
    var boundaryPreambleContributionChunkEnd = stringToPrecomputedChunk("-->");
    function writePreambleContribution(destination, preambleState) {
      preambleState = preambleState.contribution;
      0 !== preambleState && (writeChunk(destination, boundaryPreambleContributionChunkStart), writeChunk(destination, "" + preambleState), writeChunk(destination, boundaryPreambleContributionChunkEnd));
    }
    var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
    var startSegmentHTML2 = stringToPrecomputedChunk('">');
    var endSegmentHTML = stringToPrecomputedChunk("</div>");
    var startSegmentSVG = stringToPrecomputedChunk(
      '<svg aria-hidden="true" style="display:none" id="'
    );
    var startSegmentSVG2 = stringToPrecomputedChunk('">');
    var endSegmentSVG = stringToPrecomputedChunk("</svg>");
    var startSegmentMathML = stringToPrecomputedChunk(
      '<math aria-hidden="true" style="display:none" id="'
    );
    var startSegmentMathML2 = stringToPrecomputedChunk('">');
    var endSegmentMathML = stringToPrecomputedChunk("</math>");
    var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
    var startSegmentTable2 = stringToPrecomputedChunk('">');
    var endSegmentTable = stringToPrecomputedChunk("</table>");
    var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
    var startSegmentTableBody2 = stringToPrecomputedChunk('">');
    var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
    var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
    var startSegmentTableRow2 = stringToPrecomputedChunk('">');
    var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
    var startSegmentColGroup = stringToPrecomputedChunk(
      '<table hidden><colgroup id="'
    );
    var startSegmentColGroup2 = stringToPrecomputedChunk('">');
    var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
    function writeStartSegment(destination, renderState, formatContext, id) {
      switch (formatContext.insertionMode) {
        case 0:
        case 1:
        case 3:
        case 2:
          return writeChunk(destination, startSegmentHTML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentHTML2);
        case 4:
          return writeChunk(destination, startSegmentSVG), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentSVG2);
        case 5:
          return writeChunk(destination, startSegmentMathML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentMathML2);
        case 6:
          return writeChunk(destination, startSegmentTable), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTable2);
        case 7:
          return writeChunk(destination, startSegmentTableBody), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTableBody2);
        case 8:
          return writeChunk(destination, startSegmentTableRow), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTableRow2);
        case 9:
          return writeChunk(destination, startSegmentColGroup), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentColGroup2);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function writeEndSegment(destination, formatContext) {
      switch (formatContext.insertionMode) {
        case 0:
        case 1:
        case 3:
        case 2:
          return writeChunkAndReturn(destination, endSegmentHTML);
        case 4:
          return writeChunkAndReturn(destination, endSegmentSVG);
        case 5:
          return writeChunkAndReturn(destination, endSegmentMathML);
        case 6:
          return writeChunkAndReturn(destination, endSegmentTable);
        case 7:
          return writeChunkAndReturn(destination, endSegmentTableBody);
        case 8:
          return writeChunkAndReturn(destination, endSegmentTableRow);
        case 9:
          return writeChunkAndReturn(destination, endSegmentColGroup);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var completeSegmentScript1Full = stringToPrecomputedChunk(
      '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
    );
    var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
    var completeSegmentScript2 = stringToPrecomputedChunk('","');
    var completeSegmentScriptEnd = stringToPrecomputedChunk('")</script>');
    stringToPrecomputedChunk('<template data-rsi="" data-sid="');
    stringToPrecomputedChunk('" data-pid="');
    var completeBoundaryScript1Full = stringToPrecomputedChunk(
      '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
    );
    var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
    var completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(
      '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
    );
    var completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(
      '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
    );
    var completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR("');
    var completeBoundaryScript2 = stringToPrecomputedChunk('","');
    var completeBoundaryScript3a = stringToPrecomputedChunk('",');
    var completeBoundaryScript3b = stringToPrecomputedChunk('"');
    var completeBoundaryScriptEnd = stringToPrecomputedChunk(")</script>");
    stringToPrecomputedChunk('<template data-rci="" data-bid="');
    stringToPrecomputedChunk('<template data-rri="" data-bid="');
    stringToPrecomputedChunk('" data-sid="');
    stringToPrecomputedChunk('" data-sty="');
    var clientRenderScript1Full = stringToPrecomputedChunk(
      '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
    );
    var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
    var clientRenderScript1A = stringToPrecomputedChunk('"');
    var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
    var clientRenderScriptEnd = stringToPrecomputedChunk(")</script>");
    stringToPrecomputedChunk('<template data-rxi="" data-bid="');
    stringToPrecomputedChunk('" data-dgst="');
    stringToPrecomputedChunk('" data-msg="');
    stringToPrecomputedChunk('" data-stck="');
    stringToPrecomputedChunk('" data-cstck="');
    var regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g;
    function escapeJSStringsForInstructionScripts(input) {
      return JSON.stringify(input).replace(
        regexForJSStringsInInstructionScripts,
        function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default:
              throw Error(
                "escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
              );
          }
        }
      );
    }
    var regexForJSStringsInScripts = /[&><\u2028\u2029]/g;
    function escapeJSObjectForInstructionScripts(input) {
      return JSON.stringify(input).replace(
        regexForJSStringsInScripts,
        function(match) {
          switch (match) {
            case "&":
              return "\\u0026";
            case ">":
              return "\\u003e";
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default:
              throw Error(
                "escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
              );
          }
        }
      );
    }
    var lateStyleTagResourceOpen1 = stringToPrecomputedChunk(
      '<style media="not all" data-precedence="'
    );
    var lateStyleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="');
    var lateStyleTagResourceOpen3 = stringToPrecomputedChunk('">');
    var lateStyleTagTemplateClose = stringToPrecomputedChunk("</style>");
    var currentlyRenderingBoundaryHasStylesToHoist = false;
    var destinationHasCapacity = true;
    function flushStyleTagsLateForBoundary(styleQueue) {
      var rules = styleQueue.rules, hrefs = styleQueue.hrefs, i = 0;
      if (hrefs.length) {
        writeChunk(this, lateStyleTagResourceOpen1);
        writeChunk(this, styleQueue.precedence);
        for (writeChunk(this, lateStyleTagResourceOpen2); i < hrefs.length - 1; i++)
          writeChunk(this, hrefs[i]), writeChunk(this, spaceSeparator);
        writeChunk(this, hrefs[i]);
        writeChunk(this, lateStyleTagResourceOpen3);
        for (i = 0; i < rules.length; i++) writeChunk(this, rules[i]);
        destinationHasCapacity = writeChunkAndReturn(
          this,
          lateStyleTagTemplateClose
        );
        currentlyRenderingBoundaryHasStylesToHoist = true;
        rules.length = 0;
        hrefs.length = 0;
      }
    }
    function hasStylesToHoist(stylesheet) {
      return 2 !== stylesheet.state ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
    }
    function writeHoistablesForBoundary(destination, hoistableState, renderState) {
      currentlyRenderingBoundaryHasStylesToHoist = false;
      destinationHasCapacity = true;
      hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
      hoistableState.stylesheets.forEach(hasStylesToHoist);
      currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
      return destinationHasCapacity;
    }
    function flushResource(resource) {
      for (var i = 0; i < resource.length; i++) writeChunk(this, resource[i]);
      resource.length = 0;
    }
    var stylesheetFlushingQueue = [];
    function flushStyleInPreamble(stylesheet) {
      pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
      for (var i = 0; i < stylesheetFlushingQueue.length; i++)
        writeChunk(this, stylesheetFlushingQueue[i]);
      stylesheetFlushingQueue.length = 0;
      stylesheet.state = 2;
    }
    var styleTagResourceOpen1 = stringToPrecomputedChunk(
      '<style data-precedence="'
    );
    var styleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="');
    var spaceSeparator = stringToPrecomputedChunk(" ");
    var styleTagResourceOpen3 = stringToPrecomputedChunk('">');
    var styleTagResourceClose = stringToPrecomputedChunk("</style>");
    function flushStylesInPreamble(styleQueue) {
      var hasStylesheets = 0 < styleQueue.sheets.size;
      styleQueue.sheets.forEach(flushStyleInPreamble, this);
      styleQueue.sheets.clear();
      var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
      if (!hasStylesheets || hrefs.length) {
        writeChunk(this, styleTagResourceOpen1);
        writeChunk(this, styleQueue.precedence);
        styleQueue = 0;
        if (hrefs.length) {
          for (writeChunk(this, styleTagResourceOpen2); styleQueue < hrefs.length - 1; styleQueue++)
            writeChunk(this, hrefs[styleQueue]), writeChunk(this, spaceSeparator);
          writeChunk(this, hrefs[styleQueue]);
        }
        writeChunk(this, styleTagResourceOpen3);
        for (styleQueue = 0; styleQueue < rules.length; styleQueue++)
          writeChunk(this, rules[styleQueue]);
        writeChunk(this, styleTagResourceClose);
        rules.length = 0;
        hrefs.length = 0;
      }
    }
    function preloadLateStyle(stylesheet) {
      if (0 === stylesheet.state) {
        stylesheet.state = 1;
        var props = stylesheet.props;
        pushLinkImpl(stylesheetFlushingQueue, {
          rel: "preload",
          as: "style",
          href: stylesheet.props.href,
          crossOrigin: props.crossOrigin,
          fetchPriority: props.fetchPriority,
          integrity: props.integrity,
          media: props.media,
          hrefLang: props.hrefLang,
          referrerPolicy: props.referrerPolicy
        });
        for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)
          writeChunk(this, stylesheetFlushingQueue[stylesheet]);
        stylesheetFlushingQueue.length = 0;
      }
    }
    function preloadLateStyles(styleQueue) {
      styleQueue.sheets.forEach(preloadLateStyle, this);
      styleQueue.sheets.clear();
    }
    var arrayFirstOpenBracket = stringToPrecomputedChunk("[");
    var arraySubsequentOpenBracket = stringToPrecomputedChunk(",[");
    var arrayInterstitial = stringToPrecomputedChunk(",");
    var arrayCloseBracket = stringToPrecomputedChunk("]");
    function writeStyleResourceDependenciesInJS(destination, hoistableState) {
      writeChunk(destination, arrayFirstOpenBracket);
      var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
      hoistableState.stylesheets.forEach(function(resource) {
        if (2 !== resource.state)
          if (3 === resource.state)
            writeChunk(destination, nextArrayOpenBrackChunk), writeChunk(
              destination,
              escapeJSObjectForInstructionScripts("" + resource.props.href)
            ), writeChunk(destination, arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
          else {
            writeChunk(destination, nextArrayOpenBrackChunk);
            var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
            writeChunk(
              destination,
              escapeJSObjectForInstructionScripts(coercedHref)
            );
            precedence = "" + precedence;
            writeChunk(destination, arrayInterstitial);
            writeChunk(
              destination,
              escapeJSObjectForInstructionScripts(precedence)
            );
            for (var propKey in props)
              if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], null != precedence))
                switch (propKey) {
                  case "href":
                  case "rel":
                  case "precedence":
                  case "data-precedence":
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    writeStyleResourceAttributeInJS(
                      destination,
                      propKey,
                      precedence
                    );
                }
            writeChunk(destination, arrayCloseBracket);
            nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
            resource.state = 3;
          }
      });
      writeChunk(destination, arrayCloseBracket);
    }
    function writeStyleResourceAttributeInJS(destination, name2, value) {
      var attributeName = name2.toLowerCase();
      switch (typeof value) {
        case "function":
        case "symbol":
          return;
      }
      switch (name2) {
        case "innerHTML":
        case "dangerouslySetInnerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "style":
        case "ref":
          return;
        case "className":
          attributeName = "class";
          name2 = "" + value;
          break;
        case "hidden":
          if (false === value) return;
          name2 = "";
          break;
        case "src":
        case "href":
          value = sanitizeURL(value);
          name2 = "" + value;
          break;
        default:
          if (2 < name2.length && ("o" === name2[0] || "O" === name2[0]) && ("n" === name2[1] || "N" === name2[1]) || !isAttributeNameSafe(name2))
            return;
          name2 = "" + value;
      }
      writeChunk(destination, arrayInterstitial);
      writeChunk(destination, escapeJSObjectForInstructionScripts(attributeName));
      writeChunk(destination, arrayInterstitial);
      writeChunk(destination, escapeJSObjectForInstructionScripts(name2));
    }
    function createHoistableState() {
      return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set() };
    }
    function prefetchDNS(href) {
      var request = resolveRequest();
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if ("string" === typeof href && href) {
          if (!resumableState.dnsResources.hasOwnProperty(href)) {
            resumableState.dnsResources[href] = null;
            resumableState = renderState.headers;
            var header, JSCompiler_temp;
            if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
              JSCompiler_temp = (header = "<" + ("" + href).replace(
                regexForHrefInLinkHeaderURLContext,
                escapeHrefForLinkHeaderURLContextReplacer
              ) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
            JSCompiler_temp ? (renderState.resets.dns[href] = null, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
          }
          enqueueFlush(request);
        }
      } else previousDispatcher.D(href);
    }
    function preconnect(href, crossOrigin) {
      var request = resolveRequest();
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if ("string" === typeof href && href) {
          var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
          if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
            resumableState.connectResources[bucket][href] = null;
            resumableState = renderState.headers;
            var header, JSCompiler_temp;
            if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
              JSCompiler_temp = "<" + ("" + href).replace(
                regexForHrefInLinkHeaderURLContext,
                escapeHrefForLinkHeaderURLContextReplacer
              ) + ">; rel=preconnect";
              if ("string" === typeof crossOrigin) {
                var escapedCrossOrigin = ("" + crossOrigin).replace(
                  regexForLinkHeaderQuotedParamValueContext,
                  escapeStringForLinkHeaderQuotedParamValueContextReplacer
                );
                JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
              }
              JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
            }
            JSCompiler_temp ? (renderState.resets.connect[bucket][href] = null, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
              rel: "preconnect",
              href,
              crossOrigin
            }), renderState.preconnects.add(bucket));
          }
          enqueueFlush(request);
        }
      } else previousDispatcher.C(href, crossOrigin);
    }
    function preload(href, as3, options) {
      var request = resolveRequest();
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if (as3 && href) {
          switch (as3) {
            case "image":
              if (options) {
                var imageSrcSet = options.imageSrcSet;
                var imageSizes = options.imageSizes;
                var fetchPriority = options.fetchPriority;
              }
              var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
              if (resumableState.imageResources.hasOwnProperty(key)) return;
              resumableState.imageResources[key] = PRELOAD_NO_CREDS;
              resumableState = renderState.headers;
              var header;
              resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader(href, as3, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(
                resumableState,
                assign(
                  { rel: "preload", href: imageSrcSet ? void 0 : href, as: as3 },
                  options
                )
              ), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
              break;
            case "style":
              if (resumableState.styleResources.hasOwnProperty(href)) return;
              imageSrcSet = [];
              pushLinkImpl(
                imageSrcSet,
                assign({ rel: "preload", href, as: as3 }, options)
              );
              resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
              renderState.preloads.stylesheets.set(href, imageSrcSet);
              renderState.bulkPreloads.add(imageSrcSet);
              break;
            case "script":
              if (resumableState.scriptResources.hasOwnProperty(href)) return;
              imageSrcSet = [];
              renderState.preloads.scripts.set(href, imageSrcSet);
              renderState.bulkPreloads.add(imageSrcSet);
              pushLinkImpl(
                imageSrcSet,
                assign({ rel: "preload", href, as: as3 }, options)
              );
              resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
              break;
            default:
              if (resumableState.unknownResources.hasOwnProperty(as3)) {
                if (imageSrcSet = resumableState.unknownResources[as3], imageSrcSet.hasOwnProperty(href))
                  return;
              } else
                imageSrcSet = {}, resumableState.unknownResources[as3] = imageSrcSet;
              imageSrcSet[href] = PRELOAD_NO_CREDS;
              if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as3 && (key = getPreloadAsHeader(href, as3, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
                renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
              else
                switch (resumableState = [], href = assign({ rel: "preload", href, as: as3 }, options), pushLinkImpl(resumableState, href), as3) {
                  case "font":
                    renderState.fontPreloads.add(resumableState);
                    break;
                  default:
                    renderState.bulkPreloads.add(resumableState);
                }
          }
          enqueueFlush(request);
        }
      } else previousDispatcher.L(href, as3, options);
    }
    function preloadModule(href, options) {
      var request = resolveRequest();
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if (href) {
          var as3 = options && "string" === typeof options.as ? options.as : "script";
          switch (as3) {
            case "script":
              if (resumableState.moduleScriptResources.hasOwnProperty(href)) return;
              as3 = [];
              resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
              renderState.preloads.moduleScripts.set(href, as3);
              break;
            default:
              if (resumableState.moduleUnknownResources.hasOwnProperty(as3)) {
                var resources = resumableState.unknownResources[as3];
                if (resources.hasOwnProperty(href)) return;
              } else
                resources = {}, resumableState.moduleUnknownResources[as3] = resources;
              as3 = [];
              resources[href] = PRELOAD_NO_CREDS;
          }
          pushLinkImpl(as3, assign({ rel: "modulepreload", href }, options));
          renderState.bulkPreloads.add(as3);
          enqueueFlush(request);
        }
      } else previousDispatcher.m(href, options);
    }
    function preinitStyle(href, precedence, options) {
      var request = resolveRequest();
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if (href) {
          precedence = precedence || "default";
          var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
          null !== resourceState && (resumableState.styleResources[href] = null, styleQueue || (styleQueue = {
            precedence: escapeTextForBrowser(precedence),
            rules: [],
            hrefs: [],
            sheets: /* @__PURE__ */ new Map()
          }, renderState.styles.set(precedence, styleQueue)), precedence = {
            state: 0,
            props: assign(
              { rel: "stylesheet", href, "data-precedence": precedence },
              options
            )
          }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = 1), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
        }
      } else previousDispatcher.S(href, precedence, options);
    }
    function preinitScript(src, options) {
      var request = resolveRequest();
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if (src) {
          var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : void 0;
          null !== resourceState && (resumableState.scriptResources[src] = null, options = assign({ src, async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
        }
      } else previousDispatcher.X(src, options);
    }
    function preinitModuleScript(src, options) {
      var request = resolveRequest();
      if (request) {
        var resumableState = request.resumableState, renderState = request.renderState;
        if (src) {
          var resourceState = resumableState.moduleScriptResources.hasOwnProperty(
            src
          ) ? resumableState.moduleScriptResources[src] : void 0;
          null !== resourceState && (resumableState.moduleScriptResources[src] = null, options = assign({ src, type: "module", async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
        }
      } else previousDispatcher.M(src, options);
    }
    function adoptPreloadCredentials(target, preloadState) {
      null == target.crossOrigin && (target.crossOrigin = preloadState[0]);
      null == target.integrity && (target.integrity = preloadState[1]);
    }
    function getPreloadAsHeader(href, as3, params) {
      href = ("" + href).replace(
        regexForHrefInLinkHeaderURLContext,
        escapeHrefForLinkHeaderURLContextReplacer
      );
      as3 = ("" + as3).replace(
        regexForLinkHeaderQuotedParamValueContext,
        escapeStringForLinkHeaderQuotedParamValueContextReplacer
      );
      as3 = "<" + href + '>; rel=preload; as="' + as3 + '"';
      for (var paramName in params)
        hasOwnProperty.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as3 += "; " + paramName.toLowerCase() + '="' + ("" + href).replace(
          regexForLinkHeaderQuotedParamValueContext,
          escapeStringForLinkHeaderQuotedParamValueContextReplacer
        ) + '"'));
      return as3;
    }
    var regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g;
    function escapeHrefForLinkHeaderURLContextReplacer(match) {
      switch (match) {
        case "<":
          return "%3C";
        case ">":
          return "%3E";
        case "\n":
          return "%0A";
        case "\r":
          return "%0D";
        default:
          throw Error(
            "escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
          );
      }
    }
    var regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g;
    function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {
      switch (match) {
        case '"':
          return "%22";
        case "'":
          return "%27";
        case ";":
          return "%3B";
        case ",":
          return "%2C";
        case "\n":
          return "%0A";
        case "\r":
          return "%0D";
        default:
          throw Error(
            "escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
          );
      }
    }
    function hoistStyleQueueDependency(styleQueue) {
      this.styles.add(styleQueue);
    }
    function hoistStylesheetDependency(stylesheet) {
      this.stylesheets.add(stylesheet);
    }
    var bind = Function.prototype.bind;
    var requestStorage = new async_hooks.AsyncLocalStorage();
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {
            }
        }
      return null;
    }
    var emptyContextObject = {};
    var currentActiveSnapshot = null;
    function popToNearestCommonAncestor(prev, next) {
      if (prev !== next) {
        prev.context._currentValue = prev.parentValue;
        prev = prev.parent;
        var parentNext = next.parent;
        if (null === prev) {
          if (null !== parentNext)
            throw Error(
              "The stacks must reach the root at the same time. This is a bug in React."
            );
        } else {
          if (null === parentNext)
            throw Error(
              "The stacks must reach the root at the same time. This is a bug in React."
            );
          popToNearestCommonAncestor(prev, parentNext);
        }
        next.context._currentValue = next.value;
      }
    }
    function popAllPrevious(prev) {
      prev.context._currentValue = prev.parentValue;
      prev = prev.parent;
      null !== prev && popAllPrevious(prev);
    }
    function pushAllNext(next) {
      var parentNext = next.parent;
      null !== parentNext && pushAllNext(parentNext);
      next.context._currentValue = next.value;
    }
    function popPreviousToCommonLevel(prev, next) {
      prev.context._currentValue = prev.parentValue;
      prev = prev.parent;
      if (null === prev)
        throw Error(
          "The depth must equal at least at zero before reaching the root. This is a bug in React."
        );
      prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
    }
    function popNextToCommonLevel(prev, next) {
      var parentNext = next.parent;
      if (null === parentNext)
        throw Error(
          "The depth must equal at least at zero before reaching the root. This is a bug in React."
        );
      prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
      next.context._currentValue = next.value;
    }
    function switchContext(newSnapshot) {
      var prev = currentActiveSnapshot;
      prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
    }
    var classComponentUpdater = {
      enqueueSetState: function(inst, payload) {
        inst = inst._reactInternals;
        null !== inst.queue && inst.queue.push(payload);
      },
      enqueueReplaceState: function(inst, payload) {
        inst = inst._reactInternals;
        inst.replace = true;
        inst.queue = [payload];
      },
      enqueueForceUpdate: function() {
      }
    };
    var emptyTreeContext = { id: 1, overflow: "" };
    function pushTreeContext(baseContext, totalChildren, index) {
      var baseIdWithLeadingBit = baseContext.id;
      baseContext = baseContext.overflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        return {
          id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
          overflow: length + baseContext
        };
      }
      return {
        id: 1 << length | index << baseLength | baseIdWithLeadingBit,
        overflow: baseContext
      };
    }
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
    var log = Math.log;
    var LN2 = Math.LN2;
    function clz32Fallback(x) {
      x >>>= 0;
      return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
    }
    var SuspenseException = Error(
      "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
    );
    function noop$2() {
    }
    function trackUsedThenable(thenableState2, thenable, index) {
      index = thenableState2[index];
      void 0 === index ? thenableState2.push(thenable) : index !== thenable && (thenable.then(noop$2, noop$2), thenable = index);
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          "string" === typeof thenable.status ? thenable.then(noop$2, noop$2) : (thenableState2 = thenable, thenableState2.status = "pending", thenableState2.then(
            function(fulfilledValue) {
              if ("pending" === thenable.status) {
                var fulfilledThenable = thenable;
                fulfilledThenable.status = "fulfilled";
                fulfilledThenable.value = fulfilledValue;
              }
            },
            function(error) {
              if ("pending" === thenable.status) {
                var rejectedThenable = thenable;
                rejectedThenable.status = "rejected";
                rejectedThenable.reason = error;
              }
            }
          ));
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
          suspendedThenable = thenable;
          throw SuspenseException;
      }
    }
    var suspendedThenable = null;
    function getSuspendedThenable() {
      if (null === suspendedThenable)
        throw Error(
          "Expected a suspended thenable. This is a bug in React. Please file an issue."
        );
      var thenable = suspendedThenable;
      suspendedThenable = null;
      return thenable;
    }
    function is3(x, y2) {
      return x === y2 && (0 !== x || 1 / x === 1 / y2) || x !== x && y2 !== y2;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is3;
    var currentlyRenderingComponent = null;
    var currentlyRenderingTask = null;
    var currentlyRenderingRequest = null;
    var currentlyRenderingKeyPath = null;
    var firstWorkInProgressHook = null;
    var workInProgressHook = null;
    var isReRender = false;
    var didScheduleRenderPhaseUpdate = false;
    var localIdCounter = 0;
    var actionStateCounter = 0;
    var actionStateMatchingIndex = -1;
    var thenableIndexCounter = 0;
    var thenableState = null;
    var renderPhaseUpdates = null;
    var numberOfReRenders = 0;
    function resolveCurrentlyRenderingComponent() {
      if (null === currentlyRenderingComponent)
        throw Error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
      return currentlyRenderingComponent;
    }
    function createHook() {
      if (0 < numberOfReRenders)
        throw Error("Rendered more hooks than during the previous render");
      return { memoizedState: null, queue: null, next: null };
    }
    function createWorkInProgressHook() {
      null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
      return workInProgressHook;
    }
    function getThenableStateAfterSuspending() {
      var state = thenableState;
      thenableState = null;
      return state;
    }
    function resetHooksState() {
      currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
      didScheduleRenderPhaseUpdate = false;
      firstWorkInProgressHook = null;
      numberOfReRenders = 0;
      workInProgressHook = renderPhaseUpdates = null;
    }
    function basicStateReducer(state, action) {
      return "function" === typeof action ? action(state) : action;
    }
    function useReducer(reducer, initialArg, init) {
      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
      workInProgressHook = createWorkInProgressHook();
      if (isReRender) {
        var queue = workInProgressHook.queue;
        initialArg = queue.dispatch;
        if (null !== renderPhaseUpdates && (init = renderPhaseUpdates.get(queue), void 0 !== init)) {
          renderPhaseUpdates.delete(queue);
          queue = workInProgressHook.memoizedState;
          do
            queue = reducer(queue, init.action), init = init.next;
          while (null !== init);
          workInProgressHook.memoizedState = queue;
          return [queue, initialArg];
        }
        return [workInProgressHook.memoizedState, initialArg];
      }
      reducer = reducer === basicStateReducer ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init ? init(initialArg) : initialArg;
      workInProgressHook.memoizedState = reducer;
      reducer = workInProgressHook.queue = { last: null, dispatch: null };
      reducer = reducer.dispatch = dispatchAction.bind(
        null,
        currentlyRenderingComponent,
        reducer
      );
      return [workInProgressHook.memoizedState, reducer];
    }
    function useMemo(nextCreate, deps) {
      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
      workInProgressHook = createWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      if (null !== workInProgressHook) {
        var prevState = workInProgressHook.memoizedState;
        if (null !== prevState && null !== deps) {
          var prevDeps = prevState[1];
          a: if (null === prevDeps) prevDeps = false;
          else {
            for (var i = 0; i < prevDeps.length && i < deps.length; i++)
              if (!objectIs(deps[i], prevDeps[i])) {
                prevDeps = false;
                break a;
              }
            prevDeps = true;
          }
          if (prevDeps) return prevState[0];
        }
      }
      nextCreate = nextCreate();
      workInProgressHook.memoizedState = [nextCreate, deps];
      return nextCreate;
    }
    function dispatchAction(componentIdentity, queue, action) {
      if (25 <= numberOfReRenders)
        throw Error(
          "Too many re-renders. React limits the number of renders to prevent an infinite loop."
        );
      if (componentIdentity === currentlyRenderingComponent)
        if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)
          renderPhaseUpdates.set(queue, componentIdentity);
        else {
          for (queue = action; null !== queue.next; ) queue = queue.next;
          queue.next = componentIdentity;
        }
    }
    function unsupportedStartTransition() {
      throw Error("startTransition cannot be called during server rendering.");
    }
    function unsupportedSetOptimisticState() {
      throw Error("Cannot update optimistic state while rendering.");
    }
    function createPostbackActionStateKey(permalink, componentKeyPath, hookIndex) {
      if (void 0 !== permalink) return "p" + permalink;
      permalink = JSON.stringify([componentKeyPath, null, hookIndex]);
      componentKeyPath = crypto.createHash("md5");
      componentKeyPath.update(permalink);
      return "k" + componentKeyPath.digest("hex");
    }
    function useActionState(action, initialState, permalink) {
      resolveCurrentlyRenderingComponent();
      var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
      if ("function" === typeof action.$$FORM_ACTION) {
        var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
        request = request.formState;
        var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
        if (null !== request && "function" === typeof isSignatureEqual) {
          var postbackKey = request[1];
          isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = createPostbackActionStateKey(
            permalink,
            componentKeyPath,
            actionStateHookIndex
          ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
        }
        var boundAction = action.bind(null, initialState);
        action = function(payload) {
          boundAction(payload);
        };
        "function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix2) {
          prefix2 = boundAction.$$FORM_ACTION(prefix2);
          void 0 !== permalink && (permalink += "", prefix2.action = permalink);
          var formData = prefix2.data;
          formData && (null === nextPostbackStateKey && (nextPostbackStateKey = createPostbackActionStateKey(
            permalink,
            componentKeyPath,
            actionStateHookIndex
          )), formData.append("$ACTION_KEY", nextPostbackStateKey));
          return prefix2;
        });
        return [initialState, action, false];
      }
      var boundAction$22 = action.bind(null, initialState);
      return [
        initialState,
        function(payload) {
          boundAction$22(payload);
        },
        false
      ];
    }
    function unwrapThenable(thenable) {
      var index = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = []);
      return trackUsedThenable(thenableState, thenable, index);
    }
    function unsupportedRefresh() {
      throw Error("Cache cannot be refreshed during server rendering.");
    }
    function noop$1() {
    }
    var HooksDispatcher = {
      readContext: function(context) {
        return context._currentValue;
      },
      use: function(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return unwrapThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return usable._currentValue;
        }
        throw Error("An unsupported type was passed to use(): " + String(usable));
      },
      useContext: function(context) {
        resolveCurrentlyRenderingComponent();
        return context._currentValue;
      },
      useMemo,
      useReducer,
      useRef: function(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        return null === previousRef ? (initialValue = { current: initialValue }, workInProgressHook.memoizedState = initialValue) : previousRef;
      },
      useState: function(initialState) {
        return useReducer(basicStateReducer, initialState);
      },
      useInsertionEffect: noop$1,
      useLayoutEffect: noop$1,
      useCallback: function(callback, deps) {
        return useMemo(function() {
          return callback;
        }, deps);
      },
      useImperativeHandle: noop$1,
      useEffect: noop$1,
      useDebugValue: noop$1,
      useDeferredValue: function(value, initialValue) {
        resolveCurrentlyRenderingComponent();
        return void 0 !== initialValue ? initialValue : value;
      },
      useTransition: function() {
        resolveCurrentlyRenderingComponent();
        return [false, unsupportedStartTransition];
      },
      useId: function() {
        var JSCompiler_inline_result = currentlyRenderingTask.treeContext;
        var overflow = JSCompiler_inline_result.overflow;
        JSCompiler_inline_result = JSCompiler_inline_result.id;
        JSCompiler_inline_result = (JSCompiler_inline_result & ~(1 << 32 - clz32(JSCompiler_inline_result) - 1)).toString(32) + overflow;
        var resumableState = currentResumableState;
        if (null === resumableState)
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component."
          );
        overflow = localIdCounter++;
        JSCompiler_inline_result = "\xAB" + resumableState.idPrefix + "R" + JSCompiler_inline_result;
        0 < overflow && (JSCompiler_inline_result += "H" + overflow.toString(32));
        return JSCompiler_inline_result + "\xBB";
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        if (void 0 === getServerSnapshot)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        return getServerSnapshot();
      },
      useOptimistic: function(passthrough) {
        resolveCurrentlyRenderingComponent();
        return [passthrough, unsupportedSetOptimisticState];
      },
      useActionState,
      useFormState: useActionState,
      useHostTransitionStatus: function() {
        resolveCurrentlyRenderingComponent();
        return sharedNotPendingObject;
      },
      useMemoCache: function(size) {
        for (var data = Array(size), i = 0; i < size; i++)
          data[i] = REACT_MEMO_CACHE_SENTINEL;
        return data;
      },
      useCacheRefresh: function() {
        return unsupportedRefresh;
      }
    };
    var currentResumableState = null;
    var DefaultAsyncDispatcher = {
      getCacheForType: function() {
        throw Error("Not implemented.");
      }
    };
    function prepareStackTrace(error, structuredStackTrace) {
      error = (error.name || "Error") + ": " + (error.message || "");
      for (var i = 0; i < structuredStackTrace.length; i++)
        error += "\n    at " + structuredStackTrace[i].toString();
      return error;
    }
    var prefix;
    var suffix;
    function describeBuiltInComponentFrame(name2) {
      if (void 0 === prefix)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = match && match[1] || "";
          suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return "\n" + prefix + name2 + suffix;
    }
    var reentry = false;
    function describeNativeComponentFrame(fn4, construct) {
      if (!fn4 || reentry) return "";
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = prepareStackTrace;
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn4, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$24) {
                    control = x$24;
                  }
                  fn4.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$25) {
                  control = x$25;
                }
                (Fake = fn4()) && "function" === typeof Fake.catch && Fake.catch(function() {
                });
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
          for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
            RunInRootFrame++;
          for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
            "DetermineComponentFrameRoot"
          ); )
            namePropDescriptor++;
          if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
            for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
              namePropDescriptor--;
          for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
            if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
              if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                do
                  if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                    var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                    fn4.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn4.displayName));
                    return frame;
                  }
                while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
              }
              break;
            }
        }
      } finally {
        reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
      }
      return (previousPrepareStackTrace = fn4 ? fn4.displayName || fn4.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
    }
    function describeComponentStackByType(type) {
      if ("string" === typeof type) return describeBuiltInComponentFrame(type);
      if ("function" === typeof type)
        return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame(type, true) : describeNativeComponentFrame(type, false);
      if ("object" === typeof type && null !== type) {
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return describeNativeComponentFrame(type.render, false);
          case REACT_MEMO_TYPE:
            return describeNativeComponentFrame(type.type, false);
          case REACT_LAZY_TYPE:
            var lazyComponent = type, payload = lazyComponent._payload;
            lazyComponent = lazyComponent._init;
            try {
              type = lazyComponent(payload);
            } catch (x) {
              return describeBuiltInComponentFrame("Lazy");
            }
            return describeComponentStackByType(type);
        }
        if ("string" === typeof type.name)
          return payload = type.env, describeBuiltInComponentFrame(
            type.name + (payload ? " [" + payload + "]" : "")
          );
      }
      switch (type) {
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame("SuspenseList");
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame("Suspense");
      }
      return "";
    }
    function defaultErrorHandler(error) {
      if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
        var JSCompiler_inline_result = error.environmentName;
        error = [error].slice(0);
        "string" === typeof error[0] ? error.splice(
          0,
          1,
          "\x1B[0m\x1B[7m%c%s\x1B[0m%c " + error[0],
          "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
          " " + JSCompiler_inline_result + " ",
          ""
        ) : error.splice(
          0,
          0,
          "\x1B[0m\x1B[7m%c%s\x1B[0m%c ",
          "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
          " " + JSCompiler_inline_result + " ",
          ""
        );
        error.unshift(console);
        JSCompiler_inline_result = bind.apply(console.error, error);
        JSCompiler_inline_result();
      } else console.error(error);
      return null;
    }
    function noop() {
    }
    function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
      var abortSet = /* @__PURE__ */ new Set();
      this.destination = null;
      this.flushScheduled = false;
      this.resumableState = resumableState;
      this.renderState = renderState;
      this.rootFormatContext = rootFormatContext;
      this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
      this.status = 10;
      this.fatalError = null;
      this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
      this.completedPreambleSegments = this.completedRootSegment = null;
      this.abortableTasks = abortSet;
      this.pingedTasks = [];
      this.clientRenderedBoundaries = [];
      this.completedBoundaries = [];
      this.partialBoundaries = [];
      this.trackedPostpones = null;
      this.onError = void 0 === onError ? defaultErrorHandler : onError;
      this.onPostpone = void 0 === onPostpone ? noop : onPostpone;
      this.onAllReady = void 0 === onAllReady ? noop : onAllReady;
      this.onShellReady = void 0 === onShellReady ? noop : onShellReady;
      this.onShellError = void 0 === onShellError ? noop : onShellError;
      this.onFatalError = void 0 === onFatalError ? noop : onFatalError;
      this.formState = void 0 === formState ? null : formState;
    }
    function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
      resumableState = new RequestInstance(
        resumableState,
        renderState,
        rootFormatContext,
        progressiveChunkSize,
        onError,
        onAllReady,
        onShellReady,
        onShellError,
        onFatalError,
        onPostpone,
        formState
      );
      renderState = createPendingSegment(
        resumableState,
        0,
        null,
        rootFormatContext,
        false,
        false
      );
      renderState.parentFlushed = true;
      children = createRenderTask(
        resumableState,
        null,
        children,
        -1,
        null,
        renderState,
        null,
        null,
        resumableState.abortableTasks,
        null,
        rootFormatContext,
        null,
        emptyTreeContext,
        null,
        false
      );
      pushComponentStack(children);
      resumableState.pingedTasks.push(children);
      return resumableState;
    }
    function createPrerenderRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
      children = createRequest(
        children,
        resumableState,
        renderState,
        rootFormatContext,
        progressiveChunkSize,
        onError,
        onAllReady,
        onShellReady,
        onShellError,
        onFatalError,
        onPostpone,
        void 0
      );
      children.trackedPostpones = {
        workingMap: /* @__PURE__ */ new Map(),
        rootNodes: [],
        rootSlots: null
      };
      return children;
    }
    var currentRequest = null;
    function resolveRequest() {
      if (currentRequest) return currentRequest;
      var store = requestStorage.getStore();
      return store ? store : null;
    }
    function pingTask(request, task) {
      request.pingedTasks.push(task);
      1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, null !== request.trackedPostpones || 10 === request.status ? scheduleMicrotask(function() {
        return performWork(request);
      }) : setImmediate(function() {
        return performWork(request);
      }));
    }
    function createSuspenseBoundary(request, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
      return {
        status: 0,
        rootSegmentID: -1,
        parentFlushed: false,
        pendingTasks: 0,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks,
        errorDigest: null,
        contentState: createHoistableState(),
        fallbackState: createHoistableState(),
        contentPreamble,
        fallbackPreamble,
        trackedContentKeyPath: null,
        trackedFallbackNode: null
      };
    }
    function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback) {
      request.allPendingTasks++;
      null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
      var task = {
        replay: null,
        node,
        childIndex,
        ping: function() {
          return pingTask(request, task);
        },
        blockedBoundary,
        blockedSegment,
        blockedPreamble,
        hoistableState,
        abortSet,
        keyPath,
        formatContext,
        context,
        treeContext,
        componentStack,
        thenableState: thenableState2,
        isFallback
      };
      abortSet.add(task);
      return task;
    }
    function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback) {
      request.allPendingTasks++;
      null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
      replay.pendingTasks++;
      var task = {
        replay,
        node,
        childIndex,
        ping: function() {
          return pingTask(request, task);
        },
        blockedBoundary,
        blockedSegment: null,
        blockedPreamble: null,
        hoistableState,
        abortSet,
        keyPath,
        formatContext,
        context,
        treeContext,
        componentStack,
        thenableState: thenableState2,
        isFallback
      };
      abortSet.add(task);
      return task;
    }
    function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
      return {
        status: 0,
        parentFlushed: false,
        id: -1,
        index,
        chunks: [],
        children: [],
        preambleChildren: [],
        parentFormatContext,
        boundary,
        lastPushedText,
        textEmbedded
      };
    }
    function pushComponentStack(task) {
      var node = task.node;
      if ("object" === typeof node && null !== node)
        switch (node.$$typeof) {
          case REACT_ELEMENT_TYPE:
            task.componentStack = { parent: task.componentStack, type: node.type };
        }
    }
    function getThrownInfo(node$jscomp$0) {
      var errorInfo = {};
      node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
        configurable: true,
        enumerable: true,
        get: function() {
          try {
            var info = "", node = node$jscomp$0;
            do
              info += describeComponentStackByType(node.type), node = node.parent;
            while (node);
            var JSCompiler_inline_result = info;
          } catch (x) {
            JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
          }
          Object.defineProperty(errorInfo, "componentStack", {
            value: JSCompiler_inline_result
          });
          return JSCompiler_inline_result;
        }
      });
      return errorInfo;
    }
    function logRecoverableError(request, error, errorInfo) {
      request = request.onError;
      error = request(error, errorInfo);
      if (null == error || "string" === typeof error) return error;
    }
    function fatalError(request, error) {
      var onShellError = request.onShellError, onFatalError = request.onFatalError;
      onShellError(error);
      onFatalError(error);
      null !== request.destination ? (request.status = 14, request.destination.destroy(error)) : (request.status = 13, request.fatalError = error);
    }
    function renderWithHooks(request, task, keyPath, Component, props, secondArg) {
      var prevThenableState = task.thenableState;
      task.thenableState = null;
      currentlyRenderingComponent = {};
      currentlyRenderingTask = task;
      currentlyRenderingRequest = request;
      currentlyRenderingKeyPath = keyPath;
      actionStateCounter = localIdCounter = 0;
      actionStateMatchingIndex = -1;
      thenableIndexCounter = 0;
      thenableState = prevThenableState;
      for (request = Component(props, secondArg); didScheduleRenderPhaseUpdate; )
        didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);
      resetHooksState();
      return request;
    }
    function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
      var didEmitActionStateMarkers = false;
      if (0 !== actionStateCount && null !== request.formState) {
        var segment = task.blockedSegment;
        if (null !== segment) {
          didEmitActionStateMarkers = true;
          segment = segment.chunks;
          for (var i = 0; i < actionStateCount; i++)
            i === actionStateMatchingIndex2 ? segment.push(formStateMarkerIsMatching) : segment.push(formStateMarkerIsNotMatching);
        }
      }
      actionStateCount = task.keyPath;
      task.keyPath = keyPath;
      hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode2(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode2(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
      task.keyPath = actionStateCount;
    }
    function renderElement(request, task, keyPath, type, props, ref) {
      if ("function" === typeof type)
        if (type.prototype && type.prototype.isReactComponent) {
          var newProps = props;
          if ("ref" in props) {
            newProps = {};
            for (var propName in props)
              "ref" !== propName && (newProps[propName] = props[propName]);
          }
          var defaultProps = type.defaultProps;
          if (defaultProps) {
            newProps === props && (newProps = assign({}, newProps, props));
            for (var propName$33 in defaultProps)
              void 0 === newProps[propName$33] && (newProps[propName$33] = defaultProps[propName$33]);
          }
          props = newProps;
          newProps = emptyContextObject;
          defaultProps = type.contextType;
          "object" === typeof defaultProps && null !== defaultProps && (newProps = defaultProps._currentValue);
          newProps = new type(props, newProps);
          var initialState = void 0 !== newProps.state ? newProps.state : null;
          newProps.updater = classComponentUpdater;
          newProps.props = props;
          newProps.state = initialState;
          defaultProps = { queue: [], replace: false };
          newProps._reactInternals = defaultProps;
          ref = type.contextType;
          newProps.context = "object" === typeof ref && null !== ref ? ref._currentValue : emptyContextObject;
          ref = type.getDerivedStateFromProps;
          "function" === typeof ref && (ref = ref(props, initialState), initialState = null === ref || void 0 === ref ? initialState : assign({}, initialState, ref), newProps.state = initialState);
          if ("function" !== typeof type.getDerivedStateFromProps && "function" !== typeof newProps.getSnapshotBeforeUpdate && ("function" === typeof newProps.UNSAFE_componentWillMount || "function" === typeof newProps.componentWillMount))
            if (type = newProps.state, "function" === typeof newProps.componentWillMount && newProps.componentWillMount(), "function" === typeof newProps.UNSAFE_componentWillMount && newProps.UNSAFE_componentWillMount(), type !== newProps.state && classComponentUpdater.enqueueReplaceState(
              newProps,
              newProps.state,
              null
            ), null !== defaultProps.queue && 0 < defaultProps.queue.length)
              if (type = defaultProps.queue, ref = defaultProps.replace, defaultProps.queue = null, defaultProps.replace = false, ref && 1 === type.length)
                newProps.state = type[0];
              else {
                defaultProps = ref ? type[0] : newProps.state;
                initialState = true;
                for (ref = ref ? 1 : 0; ref < type.length; ref++)
                  propName$33 = type[ref], propName$33 = "function" === typeof propName$33 ? propName$33.call(newProps, defaultProps, props, void 0) : propName$33, null != propName$33 && (initialState ? (initialState = false, defaultProps = assign({}, defaultProps, propName$33)) : assign(defaultProps, propName$33));
                newProps.state = defaultProps;
              }
            else defaultProps.queue = null;
          type = newProps.render();
          if (12 === request.status) throw null;
          props = task.keyPath;
          task.keyPath = keyPath;
          renderNodeDestructive(request, task, type, -1);
          task.keyPath = props;
        } else {
          type = renderWithHooks(request, task, keyPath, type, props, void 0);
          if (12 === request.status) throw null;
          finishFunctionComponent(
            request,
            task,
            keyPath,
            type,
            0 !== localIdCounter,
            actionStateCounter,
            actionStateMatchingIndex
          );
        }
      else if ("string" === typeof type)
        if (newProps = task.blockedSegment, null === newProps)
          newProps = props.children, defaultProps = task.formatContext, initialState = task.keyPath, task.formatContext = getChildFormatContext(defaultProps, type, props), task.keyPath = keyPath, renderNode2(request, task, newProps, -1), task.formatContext = defaultProps, task.keyPath = initialState;
        else {
          ref = pushStartInstance(
            newProps.chunks,
            type,
            props,
            request.resumableState,
            request.renderState,
            task.blockedPreamble,
            task.hoistableState,
            task.formatContext,
            newProps.lastPushedText,
            task.isFallback
          );
          newProps.lastPushedText = false;
          defaultProps = task.formatContext;
          initialState = task.keyPath;
          task.keyPath = keyPath;
          3 === (task.formatContext = getChildFormatContext(defaultProps, type, props)).insertionMode ? (keyPath = createPendingSegment(
            request,
            0,
            null,
            task.formatContext,
            false,
            false
          ), newProps.preambleChildren.push(keyPath), keyPath = createRenderTask(
            request,
            null,
            ref,
            -1,
            task.blockedBoundary,
            keyPath,
            task.blockedPreamble,
            task.hoistableState,
            request.abortableTasks,
            task.keyPath,
            task.formatContext,
            task.context,
            task.treeContext,
            task.componentStack,
            task.isFallback
          ), pushComponentStack(keyPath), request.pingedTasks.push(keyPath)) : renderNode2(request, task, ref, -1);
          task.formatContext = defaultProps;
          task.keyPath = initialState;
          a: {
            task = newProps.chunks;
            request = request.resumableState;
            switch (type) {
              case "title":
              case "style":
              case "script":
              case "area":
              case "base":
              case "br":
              case "col":
              case "embed":
              case "hr":
              case "img":
              case "input":
              case "keygen":
              case "link":
              case "meta":
              case "param":
              case "source":
              case "track":
              case "wbr":
                break a;
              case "body":
                if (1 >= defaultProps.insertionMode) {
                  request.hasBody = true;
                  break a;
                }
                break;
              case "html":
                if (0 === defaultProps.insertionMode) {
                  request.hasHtml = true;
                  break a;
                }
                break;
              case "head":
                if (1 >= defaultProps.insertionMode) break a;
            }
            task.push(endChunkForTag(type));
          }
          newProps.lastPushedText = false;
        }
      else {
        switch (type) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE:
            type = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, props.children, -1);
            task.keyPath = type;
            return;
          case REACT_ACTIVITY_TYPE:
            "hidden" !== props.mode && (type = task.keyPath, task.keyPath = keyPath, renderNodeDestructive(request, task, props.children, -1), task.keyPath = type);
            return;
          case REACT_SUSPENSE_LIST_TYPE:
            type = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, props.children, -1);
            task.keyPath = type;
            return;
          case REACT_VIEW_TRANSITION_TYPE:
          case REACT_SCOPE_TYPE:
            throw Error("ReactDOMServer does not yet support scope components.");
          case REACT_SUSPENSE_TYPE:
            a: if (null !== task.replay) {
              type = task.keyPath;
              task.keyPath = keyPath;
              keyPath = props.children;
              try {
                renderNode2(request, task, keyPath, -1);
              } finally {
                task.keyPath = type;
              }
            } else {
              type = task.keyPath;
              var parentBoundary = task.blockedBoundary;
              ref = task.blockedPreamble;
              var parentHoistableState = task.hoistableState;
              propName$33 = task.blockedSegment;
              propName = props.fallback;
              props = props.children;
              var fallbackAbortSet = /* @__PURE__ */ new Set();
              var newBoundary = 2 > task.formatContext.insertionMode ? createSuspenseBoundary(
                request,
                fallbackAbortSet,
                createPreambleState(),
                createPreambleState()
              ) : createSuspenseBoundary(request, fallbackAbortSet, null, null);
              null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
              var boundarySegment = createPendingSegment(
                request,
                propName$33.chunks.length,
                newBoundary,
                task.formatContext,
                false,
                false
              );
              propName$33.children.push(boundarySegment);
              propName$33.lastPushedText = false;
              var contentRootSegment = createPendingSegment(
                request,
                0,
                null,
                task.formatContext,
                false,
                false
              );
              contentRootSegment.parentFlushed = true;
              if (null !== request.trackedPostpones) {
                newProps = [keyPath[0], "Suspense Fallback", keyPath[2]];
                defaultProps = [newProps[1], newProps[2], [], null];
                request.trackedPostpones.workingMap.set(newProps, defaultProps);
                newBoundary.trackedFallbackNode = defaultProps;
                task.blockedSegment = boundarySegment;
                task.blockedPreamble = newBoundary.fallbackPreamble;
                task.keyPath = newProps;
                boundarySegment.status = 6;
                try {
                  renderNode2(request, task, propName, -1), boundarySegment.lastPushedText && boundarySegment.textEmbedded && boundarySegment.chunks.push(textSeparator), boundarySegment.status = 1;
                } catch (thrownValue) {
                  throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;
                } finally {
                  task.blockedSegment = propName$33, task.blockedPreamble = ref, task.keyPath = type;
                }
                task = createRenderTask(
                  request,
                  null,
                  props,
                  -1,
                  newBoundary,
                  contentRootSegment,
                  newBoundary.contentPreamble,
                  newBoundary.contentState,
                  task.abortSet,
                  keyPath,
                  task.formatContext,
                  task.context,
                  task.treeContext,
                  task.componentStack,
                  task.isFallback
                );
                pushComponentStack(task);
                request.pingedTasks.push(task);
              } else {
                task.blockedBoundary = newBoundary;
                task.blockedPreamble = newBoundary.contentPreamble;
                task.hoistableState = newBoundary.contentState;
                task.blockedSegment = contentRootSegment;
                task.keyPath = keyPath;
                contentRootSegment.status = 6;
                try {
                  if (renderNode2(request, task, props, -1), contentRootSegment.lastPushedText && contentRootSegment.textEmbedded && contentRootSegment.chunks.push(textSeparator), contentRootSegment.status = 1, queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && 0 === newBoundary.status) {
                    newBoundary.status = 1;
                    0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);
                    break a;
                  }
                } catch (thrownValue$28) {
                  newBoundary.status = 4, 12 === request.status ? (contentRootSegment.status = 3, newProps = request.fatalError) : (contentRootSegment.status = 4, newProps = thrownValue$28), defaultProps = getThrownInfo(task.componentStack), initialState = logRecoverableError(
                    request,
                    newProps,
                    defaultProps
                  ), newBoundary.errorDigest = initialState, untrackBoundary(request, newBoundary);
                } finally {
                  task.blockedBoundary = parentBoundary, task.blockedPreamble = ref, task.hoistableState = parentHoistableState, task.blockedSegment = propName$33, task.keyPath = type;
                }
                task = createRenderTask(
                  request,
                  null,
                  propName,
                  -1,
                  parentBoundary,
                  boundarySegment,
                  newBoundary.fallbackPreamble,
                  newBoundary.fallbackState,
                  fallbackAbortSet,
                  [keyPath[0], "Suspense Fallback", keyPath[2]],
                  task.formatContext,
                  task.context,
                  task.treeContext,
                  task.componentStack,
                  true
                );
                pushComponentStack(task);
                request.pingedTasks.push(task);
              }
            }
            return;
        }
        if ("object" === typeof type && null !== type)
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              if ("ref" in props)
                for (newBoundary in newProps = {}, props)
                  "ref" !== newBoundary && (newProps[newBoundary] = props[newBoundary]);
              else newProps = props;
              type = renderWithHooks(
                request,
                task,
                keyPath,
                type.render,
                newProps,
                ref
              );
              finishFunctionComponent(
                request,
                task,
                keyPath,
                type,
                0 !== localIdCounter,
                actionStateCounter,
                actionStateMatchingIndex
              );
              return;
            case REACT_MEMO_TYPE:
              renderElement(request, task, keyPath, type.type, props, ref);
              return;
            case REACT_PROVIDER_TYPE:
            case REACT_CONTEXT_TYPE:
              defaultProps = props.children;
              newProps = task.keyPath;
              props = props.value;
              initialState = type._currentValue;
              type._currentValue = props;
              ref = currentActiveSnapshot;
              currentActiveSnapshot = type = {
                parent: ref,
                depth: null === ref ? 0 : ref.depth + 1,
                context: type,
                parentValue: initialState,
                value: props
              };
              task.context = type;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, defaultProps, -1);
              request = currentActiveSnapshot;
              if (null === request)
                throw Error(
                  "Tried to pop a Context at the root of the app. This is a bug in React."
                );
              request.context._currentValue = request.parentValue;
              request = currentActiveSnapshot = request.parent;
              task.context = request;
              task.keyPath = newProps;
              return;
            case REACT_CONSUMER_TYPE:
              props = props.children;
              type = props(type._context._currentValue);
              props = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, type, -1);
              task.keyPath = props;
              return;
            case REACT_LAZY_TYPE:
              newProps = type._init;
              type = newProps(type._payload);
              if (12 === request.status) throw null;
              renderElement(request, task, keyPath, type, props, ref);
              return;
          }
        throw Error(
          "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type ? type : typeof type) + ".")
        );
      }
    }
    function resumeNode(request, task, segmentId, node, childIndex) {
      var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(
        request,
        0,
        null,
        task.formatContext,
        false,
        false
      );
      resumedSegment.id = segmentId;
      resumedSegment.parentFlushed = true;
      try {
        task.replay = null, task.blockedSegment = resumedSegment, renderNode2(request, task, node, childIndex), resumedSegment.status = 1, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
      } finally {
        task.replay = prevReplay, task.blockedSegment = null;
      }
    }
    function renderNodeDestructive(request, task, node, childIndex) {
      null !== task.replay && "number" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, pushComponentStack(task), retryNode(request, task), task.componentStack = node);
    }
    function retryNode(request, task) {
      var node = task.node, childIndex = task.childIndex;
      if (null !== node) {
        if ("object" === typeof node) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = node.type, key = node.key, props = node.props;
              node = props.ref;
              var ref = void 0 !== node ? node : null, name2 = getComponentNameFromType(type), keyOrIndex = null == key ? -1 === childIndex ? 0 : childIndex : key;
              key = [task.keyPath, name2, keyOrIndex];
              if (null !== task.replay)
                a: {
                  var replay = task.replay;
                  childIndex = replay.nodes;
                  for (node = 0; node < childIndex.length; node++) {
                    var node$jscomp$0 = childIndex[node];
                    if (keyOrIndex === node$jscomp$0[1]) {
                      if (4 === node$jscomp$0.length) {
                        if (null !== name2 && name2 !== node$jscomp$0[0])
                          throw Error(
                            "Expected the resume to render <" + node$jscomp$0[0] + "> in this slot but instead it rendered <" + name2 + ">. The tree doesn't match so React will fallback to client rendering."
                          );
                        var childNodes = node$jscomp$0[2];
                        name2 = node$jscomp$0[3];
                        keyOrIndex = task.node;
                        task.replay = {
                          nodes: childNodes,
                          slots: name2,
                          pendingTasks: 1
                        };
                        try {
                          renderElement(request, task, key, type, props, ref);
                          if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                            throw Error(
                              "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                            );
                          task.replay.pendingTasks--;
                        } catch (x) {
                          if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                            throw task.node === keyOrIndex && (task.replay = replay), x;
                          task.replay.pendingTasks--;
                          props = getThrownInfo(task.componentStack);
                          key = task.blockedBoundary;
                          type = x;
                          props = logRecoverableError(request, type, props);
                          abortRemainingReplayNodes(
                            request,
                            key,
                            childNodes,
                            name2,
                            type,
                            props
                          );
                        }
                        task.replay = replay;
                      } else {
                        if (type !== REACT_SUSPENSE_TYPE)
                          throw Error(
                            "Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering."
                          );
                        b: {
                          replay = void 0;
                          type = node$jscomp$0[5];
                          ref = node$jscomp$0[2];
                          name2 = node$jscomp$0[3];
                          keyOrIndex = null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];
                          node$jscomp$0 = null === node$jscomp$0[4] ? null : node$jscomp$0[4][3];
                          var prevKeyPath = task.keyPath, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
                          props = 2 > task.formatContext.insertionMode ? createSuspenseBoundary(
                            request,
                            fallbackAbortSet,
                            createPreambleState(),
                            createPreambleState()
                          ) : createSuspenseBoundary(
                            request,
                            fallbackAbortSet,
                            null,
                            null
                          );
                          props.parentFlushed = true;
                          props.rootSegmentID = type;
                          task.blockedBoundary = props;
                          task.hoistableState = props.contentState;
                          task.keyPath = key;
                          task.replay = {
                            nodes: ref,
                            slots: name2,
                            pendingTasks: 1
                          };
                          try {
                            renderNode2(request, task, content, -1);
                            if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                              throw Error(
                                "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                              );
                            task.replay.pendingTasks--;
                            if (0 === props.pendingTasks && 0 === props.status) {
                              props.status = 1;
                              request.completedBoundaries.push(props);
                              break b;
                            }
                          } catch (error) {
                            props.status = 4, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(
                              request,
                              error,
                              childNodes
                            ), props.errorDigest = replay, task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
                          } finally {
                            task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath;
                          }
                          task = createReplayTask(
                            request,
                            null,
                            {
                              nodes: keyOrIndex,
                              slots: node$jscomp$0,
                              pendingTasks: 0
                            },
                            fallback,
                            -1,
                            parentBoundary,
                            props.fallbackState,
                            fallbackAbortSet,
                            [key[0], "Suspense Fallback", key[2]],
                            task.formatContext,
                            task.context,
                            task.treeContext,
                            task.componentStack,
                            true
                          );
                          pushComponentStack(task);
                          request.pingedTasks.push(task);
                        }
                      }
                      childIndex.splice(node, 1);
                      break a;
                    }
                  }
                }
              else renderElement(request, task, key, type, props, ref);
              return;
            case REACT_PORTAL_TYPE:
              throw Error(
                "Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render."
              );
            case REACT_LAZY_TYPE:
              childNodes = node._init;
              node = childNodes(node._payload);
              if (12 === request.status) throw null;
              renderNodeDestructive(request, task, node, childIndex);
              return;
          }
          if (isArrayImpl(node)) {
            renderChildrenArray(request, task, node, childIndex);
            return;
          }
          null === node || "object" !== typeof node ? childNodes = null : (childNodes = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], childNodes = "function" === typeof childNodes ? childNodes : null);
          if (childNodes && (childNodes = childNodes.call(node))) {
            node = childNodes.next();
            if (!node.done) {
              props = [];
              do
                props.push(node.value), node = childNodes.next();
              while (!node.done);
              renderChildrenArray(request, task, props, childIndex);
            }
            return;
          }
          if ("function" === typeof node.then)
            return task.thenableState = null, renderNodeDestructive(request, task, unwrapThenable(node), childIndex);
          if (node.$$typeof === REACT_CONTEXT_TYPE)
            return renderNodeDestructive(
              request,
              task,
              node._currentValue,
              childIndex
            );
          childIndex = Object.prototype.toString.call(node);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === childIndex ? "object with keys {" + Object.keys(node).join(", ") + "}" : childIndex) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        if ("string" === typeof node)
          childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(
            childIndex.chunks,
            node,
            request.renderState,
            childIndex.lastPushedText
          ));
        else if ("number" === typeof node || "bigint" === typeof node)
          childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(
            childIndex.chunks,
            "" + node,
            request.renderState,
            childIndex.lastPushedText
          ));
      }
    }
    function renderChildrenArray(request, task, children, childIndex) {
      var prevKeyPath = task.keyPath;
      if (-1 !== childIndex && (task.keyPath = [task.keyPath, "Fragment", childIndex], null !== task.replay)) {
        for (var replay = task.replay, replayNodes = replay.nodes, j3 = 0; j3 < replayNodes.length; j3++) {
          var node = replayNodes[j3];
          if (node[1] === childIndex) {
            childIndex = node[2];
            node = node[3];
            task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
            try {
              renderChildrenArray(request, task, children, -1);
              if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                throw Error(
                  "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                );
              task.replay.pendingTasks--;
            } catch (x) {
              if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                throw x;
              task.replay.pendingTasks--;
              children = getThrownInfo(task.componentStack);
              var boundary = task.blockedBoundary, error = x;
              children = logRecoverableError(request, error, children);
              abortRemainingReplayNodes(
                request,
                boundary,
                childIndex,
                node,
                error,
                children
              );
            }
            task.replay = replay;
            replayNodes.splice(j3, 1);
            break;
          }
        }
        task.keyPath = prevKeyPath;
        return;
      }
      replay = task.treeContext;
      replayNodes = children.length;
      if (null !== task.replay && (j3 = task.replay.slots, null !== j3 && "object" === typeof j3)) {
        for (childIndex = 0; childIndex < replayNodes; childIndex++)
          node = children[childIndex], task.treeContext = pushTreeContext(replay, replayNodes, childIndex), boundary = j3[childIndex], "number" === typeof boundary ? (resumeNode(request, task, boundary, node, childIndex), delete j3[childIndex]) : renderNode2(request, task, node, childIndex);
        task.treeContext = replay;
        task.keyPath = prevKeyPath;
        return;
      }
      for (j3 = 0; j3 < replayNodes; j3++)
        childIndex = children[j3], task.treeContext = pushTreeContext(replay, replayNodes, j3), renderNode2(request, task, childIndex, j3);
      task.treeContext = replay;
      task.keyPath = prevKeyPath;
    }
    function untrackBoundary(request, boundary) {
      request = request.trackedPostpones;
      null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
    }
    function spawnNewSuspendedReplayTask(request, task, thenableState2) {
      return createReplayTask(
        request,
        thenableState2,
        task.replay,
        task.node,
        task.childIndex,
        task.blockedBoundary,
        task.hoistableState,
        task.abortSet,
        task.keyPath,
        task.formatContext,
        task.context,
        task.treeContext,
        task.componentStack,
        task.isFallback
      );
    }
    function spawnNewSuspendedRenderTask(request, task, thenableState2) {
      var segment = task.blockedSegment, newSegment = createPendingSegment(
        request,
        segment.chunks.length,
        null,
        task.formatContext,
        segment.lastPushedText,
        true
      );
      segment.children.push(newSegment);
      segment.lastPushedText = false;
      return createRenderTask(
        request,
        thenableState2,
        task.node,
        task.childIndex,
        task.blockedBoundary,
        newSegment,
        task.blockedPreamble,
        task.hoistableState,
        task.abortSet,
        task.keyPath,
        task.formatContext,
        task.context,
        task.treeContext,
        task.componentStack,
        task.isFallback
      );
    }
    function renderNode2(request, task, node, childIndex) {
      var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, segment = task.blockedSegment;
      if (null === segment)
        try {
          return renderNodeDestructive(request, task, node, childIndex);
        } catch (thrownValue) {
          if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, "object" === typeof node && null !== node) {
            if ("function" === typeof node.then) {
              childIndex = getThenableStateAfterSuspending();
              request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
              node.then(request, request);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              switchContext(previousContext);
              return;
            }
            if ("Maximum call stack size exceeded" === node.message) {
              node = getThenableStateAfterSuspending();
              node = spawnNewSuspendedReplayTask(request, task, node);
              request.pingedTasks.push(node);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              switchContext(previousContext);
              return;
            }
          }
        }
      else {
        var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
        try {
          return renderNodeDestructive(request, task, node, childIndex);
        } catch (thrownValue$48) {
          if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$48 === SuspenseException ? getSuspendedThenable() : thrownValue$48, "object" === typeof node && null !== node) {
            if ("function" === typeof node.then) {
              childIndex = getThenableStateAfterSuspending();
              request = spawnNewSuspendedRenderTask(request, task, childIndex).ping;
              node.then(request, request);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              switchContext(previousContext);
              return;
            }
            if ("Maximum call stack size exceeded" === node.message) {
              node = getThenableStateAfterSuspending();
              node = spawnNewSuspendedRenderTask(request, task, node);
              request.pingedTasks.push(node);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              switchContext(previousContext);
              return;
            }
          }
        }
      }
      task.formatContext = previousFormatContext;
      task.context = previousContext;
      task.keyPath = previousKeyPath;
      task.treeContext = previousTreeContext;
      switchContext(previousContext);
      throw node;
    }
    function abortTaskSoft(task) {
      var boundary = task.blockedBoundary;
      task = task.blockedSegment;
      null !== task && (task.status = 3, finishedTask(this, boundary, task));
    }
    function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error, errorDigest$jscomp$0) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (4 === node.length)
          abortRemainingReplayNodes(
            request$jscomp$0,
            boundary,
            node[2],
            node[3],
            error,
            errorDigest$jscomp$0
          );
        else {
          node = node[5];
          var request = request$jscomp$0, errorDigest = errorDigest$jscomp$0, resumedBoundary = createSuspenseBoundary(
            request,
            /* @__PURE__ */ new Set(),
            null,
            null
          );
          resumedBoundary.parentFlushed = true;
          resumedBoundary.rootSegmentID = node;
          resumedBoundary.status = 4;
          resumedBoundary.errorDigest = errorDigest;
          resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
        }
      }
      nodes.length = 0;
      if (null !== slots) {
        if (null === boundary)
          throw Error(
            "We should not have any resumable nodes in the shell. This is a bug in React."
          );
        4 !== boundary.status && (boundary.status = 4, boundary.errorDigest = errorDigest$jscomp$0, boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
        if ("object" === typeof slots) for (var index in slots) delete slots[index];
      }
    }
    function abortTask(task, request, error) {
      var boundary = task.blockedBoundary, segment = task.blockedSegment;
      if (null !== segment) {
        if (6 === segment.status) return;
        segment.status = 3;
      }
      segment = getThrownInfo(task.componentStack);
      if (null === boundary) {
        if (13 !== request.status && 14 !== request.status) {
          boundary = task.replay;
          if (null === boundary) {
            logRecoverableError(request, error, segment);
            fatalError(request, error);
            return;
          }
          boundary.pendingTasks--;
          0 === boundary.pendingTasks && 0 < boundary.nodes.length && (task = logRecoverableError(request, error, segment), abortRemainingReplayNodes(
            request,
            null,
            boundary.nodes,
            boundary.slots,
            error,
            task
          ));
          request.pendingRootTasks--;
          0 === request.pendingRootTasks && completeShell(request);
        }
      } else
        boundary.pendingTasks--, 4 !== boundary.status && (boundary.status = 4, task = logRecoverableError(request, error, segment), boundary.status = 4, boundary.errorDigest = task, untrackBoundary(request, boundary), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary)), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
          return abortTask(fallbackTask, request, error);
        }), boundary.fallbackAbortableTasks.clear();
      request.allPendingTasks--;
      0 === request.allPendingTasks && completeAll(request);
    }
    function safelyEmitEarlyPreloads(request, shellComplete) {
      try {
        var renderState = request.renderState, onHeaders = renderState.onHeaders;
        if (onHeaders) {
          var headers = renderState.headers;
          if (headers) {
            renderState.headers = null;
            var linkHeader = headers.preconnects;
            headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
            headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
            if (!shellComplete) {
              var queueIter = renderState.styles.values(), queueStep = queueIter.next();
              b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
                for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                  var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props, header = getPreloadAsHeader(props$jscomp$0.href, "style", {
                    crossOrigin: props$jscomp$0.crossOrigin,
                    integrity: props$jscomp$0.integrity,
                    nonce: props$jscomp$0.nonce,
                    type: props$jscomp$0.type,
                    fetchPriority: props$jscomp$0.fetchPriority,
                    referrerPolicy: props$jscomp$0.referrerPolicy,
                    media: props$jscomp$0.media
                  });
                  if (0 <= (headers.remainingCapacity -= header.length + 2))
                    renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                  else break b;
                }
            }
            linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
          }
        }
      } catch (error) {
        logRecoverableError(request, error, {});
      }
    }
    function completeShell(request) {
      null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);
      null === request.trackedPostpones && preparePreamble(request);
      request.onShellError = noop;
      request = request.onShellReady;
      request();
    }
    function completeAll(request) {
      safelyEmitEarlyPreloads(
        request,
        null === request.trackedPostpones ? true : null === request.completedRootSegment || 5 !== request.completedRootSegment.status
      );
      preparePreamble(request);
      request = request.onAllReady;
      request();
    }
    function queueCompletedSegment(boundary, segment) {
      if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
        var childSegment = segment.children[0];
        childSegment.id = segment.id;
        childSegment.parentFlushed = true;
        1 === childSegment.status && queueCompletedSegment(boundary, childSegment);
      } else boundary.completedSegments.push(segment);
    }
    function finishedTask(request, boundary, segment) {
      if (null === boundary) {
        if (null !== segment && segment.parentFlushed) {
          if (null !== request.completedRootSegment)
            throw Error(
              "There can only be one root segment. This is a bug in React."
            );
          request.completedRootSegment = segment;
        }
        request.pendingRootTasks--;
        0 === request.pendingRootTasks && completeShell(request);
      } else
        boundary.pendingTasks--, 4 !== boundary.status && (0 === boundary.pendingTasks ? (0 === boundary.status && (boundary.status = 1), null !== segment && segment.parentFlushed && 1 === segment.status && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), 1 === boundary.status && (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request), boundary.fallbackAbortableTasks.clear(), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request))) : null !== segment && segment.parentFlushed && 1 === segment.status && (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)));
      request.allPendingTasks--;
      0 === request.allPendingTasks && completeAll(request);
    }
    function performWork(request$jscomp$2) {
      if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {
        var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = HooksDispatcher;
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        var prevRequest = currentRequest;
        currentRequest = request$jscomp$2;
        var prevResumableState = currentResumableState;
        currentResumableState = request$jscomp$2.resumableState;
        try {
          var pingedTasks = request$jscomp$2.pingedTasks, i;
          for (i = 0; i < pingedTasks.length; i++) {
            var task = pingedTasks[i], request = request$jscomp$2, segment = task.blockedSegment;
            if (null === segment) {
              var request$jscomp$0 = request;
              if (0 !== task.replay.pendingTasks) {
                switchContext(task.context);
                try {
                  "number" === typeof task.replay.slots ? resumeNode(
                    request$jscomp$0,
                    task,
                    task.replay.slots,
                    task.node,
                    task.childIndex
                  ) : retryNode(request$jscomp$0, task);
                  if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                    throw Error(
                      "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                    );
                  task.replay.pendingTasks--;
                  task.abortSet.delete(task);
                  finishedTask(request$jscomp$0, task.blockedBoundary, null);
                } catch (thrownValue) {
                  resetHooksState();
                  var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                  if ("object" === typeof x && null !== x && "function" === typeof x.then) {
                    var ping = task.ping;
                    x.then(ping, ping);
                    task.thenableState = getThenableStateAfterSuspending();
                  } else {
                    task.replay.pendingTasks--;
                    task.abortSet.delete(task);
                    var errorInfo = getThrownInfo(task.componentStack);
                    request = void 0;
                    var request$jscomp$1 = request$jscomp$0, boundary = task.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, replayNodes = task.replay.nodes, resumeSlots = task.replay.slots;
                    request = logRecoverableError(
                      request$jscomp$1,
                      error$jscomp$0,
                      errorInfo
                    );
                    abortRemainingReplayNodes(
                      request$jscomp$1,
                      boundary,
                      replayNodes,
                      resumeSlots,
                      error$jscomp$0,
                      request
                    );
                    request$jscomp$0.pendingRootTasks--;
                    0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);
                    request$jscomp$0.allPendingTasks--;
                    0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);
                  }
                } finally {
                }
              }
            } else if (request$jscomp$0 = void 0, request$jscomp$1 = segment, 0 === request$jscomp$1.status) {
              request$jscomp$1.status = 6;
              switchContext(task.context);
              var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
              try {
                retryNode(request, task), request$jscomp$1.lastPushedText && request$jscomp$1.textEmbedded && request$jscomp$1.chunks.push(textSeparator), task.abortSet.delete(task), request$jscomp$1.status = 1, finishedTask(request, task.blockedBoundary, request$jscomp$1);
              } catch (thrownValue) {
                resetHooksState();
                request$jscomp$1.children.length = childrenLength;
                request$jscomp$1.chunks.length = chunkLength;
                var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;
                if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
                  request$jscomp$1.status = 0;
                  task.thenableState = getThenableStateAfterSuspending();
                  var ping$jscomp$0 = task.ping;
                  x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
                } else {
                  var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
                  task.abortSet.delete(task);
                  request$jscomp$1.status = 4;
                  var boundary$jscomp$0 = task.blockedBoundary;
                  request$jscomp$0 = logRecoverableError(
                    request,
                    x$jscomp$0,
                    errorInfo$jscomp$0
                  );
                  null === boundary$jscomp$0 ? fatalError(request, x$jscomp$0) : (boundary$jscomp$0.pendingTasks--, 4 !== boundary$jscomp$0.status && (boundary$jscomp$0.status = 4, boundary$jscomp$0.errorDigest = request$jscomp$0, untrackBoundary(request, boundary$jscomp$0), boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request)));
                  request.allPendingTasks--;
                  0 === request.allPendingTasks && completeAll(request);
                }
              } finally {
              }
            }
          }
          pingedTasks.splice(0, i);
          null !== request$jscomp$2.destination && flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);
        } catch (error) {
          logRecoverableError(request$jscomp$2, error, {}), fatalError(request$jscomp$2, error);
        } finally {
          currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
        }
      }
    }
    function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
      segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
      for (var pendingPreambles = false, i = 0; i < segment.children.length; i++)
        pendingPreambles = preparePreambleFromSegment(
          request,
          segment.children[i],
          collectedPreambleSegments
        ) || pendingPreambles;
      return pendingPreambles;
    }
    function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
      var boundary = segment.boundary;
      if (null === boundary)
        return preparePreambleFromSubtree(
          request,
          segment,
          collectedPreambleSegments
        );
      var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
      if (null === preamble || null === fallbackPreamble) return false;
      switch (boundary.status) {
        case 1:
          hoistPreambleState(request.renderState, preamble);
          segment = boundary.completedSegments[0];
          if (!segment)
            throw Error(
              "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
            );
          return preparePreambleFromSubtree(
            request,
            segment,
            collectedPreambleSegments
          );
        case 5:
          if (null !== request.trackedPostpones) return true;
        case 4:
          if (1 === segment.status)
            return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(
              request,
              segment,
              collectedPreambleSegments
            );
        default:
          return true;
      }
    }
    function preparePreamble(request) {
      if (request.completedRootSegment && null === request.completedPreambleSegments) {
        var collectedPreambleSegments = [], hasPendingPreambles = preparePreambleFromSegment(
          request,
          request.completedRootSegment,
          collectedPreambleSegments
        ), preamble = request.renderState.preamble;
        if (false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks)
          request.completedPreambleSegments = collectedPreambleSegments;
      }
    }
    function flushSubtree(request, destination, segment, hoistableState) {
      segment.parentFlushed = true;
      switch (segment.status) {
        case 0:
          segment.id = request.nextSegmentId++;
        case 5:
          return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, writeChunk(destination, placeholder1), writeChunk(destination, request.placeholderPrefix), request = hoistableState.toString(16), writeChunk(destination, request), writeChunkAndReturn(destination, placeholder2);
        case 1:
          segment.status = 2;
          var r2 = true, chunks = segment.chunks, chunkIdx = 0;
          segment = segment.children;
          for (var childIdx = 0; childIdx < segment.length; childIdx++) {
            for (r2 = segment[childIdx]; chunkIdx < r2.index; chunkIdx++)
              writeChunk(destination, chunks[chunkIdx]);
            r2 = flushSegment(request, destination, r2, hoistableState);
          }
          for (; chunkIdx < chunks.length - 1; chunkIdx++)
            writeChunk(destination, chunks[chunkIdx]);
          chunkIdx < chunks.length && (r2 = writeChunkAndReturn(destination, chunks[chunkIdx]));
          return r2;
        default:
          throw Error(
            "Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React."
          );
      }
    }
    function flushSegment(request, destination, segment, hoistableState) {
      var boundary = segment.boundary;
      if (null === boundary)
        return flushSubtree(request, destination, segment, hoistableState);
      boundary.parentFlushed = true;
      if (4 === boundary.status) {
        var errorDigest = boundary.errorDigest;
        writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
        writeChunk(destination, clientRenderedSuspenseBoundaryError1);
        errorDigest && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(destination, escapeTextForBrowser(errorDigest)), writeChunk(
          destination,
          clientRenderedSuspenseBoundaryErrorAttrInterstitial
        ));
        writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
        flushSubtree(request, destination, segment, hoistableState);
        (request = boundary.fallbackPreamble) && writePreambleContribution(destination, request);
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      if (1 !== boundary.status)
        return 0 === boundary.status && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
          destination,
          request.renderState,
          boundary.rootSegmentID
        ), hoistableState && (boundary = boundary.fallbackState, boundary.styles.forEach(hoistStyleQueueDependency, hoistableState), boundary.stylesheets.forEach(
          hoistStylesheetDependency,
          hoistableState
        )), flushSubtree(request, destination, segment, hoistableState), writeChunkAndReturn(destination, endSuspenseBoundary);
      if (boundary.byteSize > request.progressiveChunkSize)
        return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
          destination,
          request.renderState,
          boundary.rootSegmentID
        ), flushSubtree(request, destination, segment, hoistableState), writeChunkAndReturn(destination, endSuspenseBoundary);
      hoistableState && (segment = boundary.contentState, segment.styles.forEach(hoistStyleQueueDependency, hoistableState), segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));
      writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      segment = boundary.completedSegments;
      if (1 !== segment.length)
        throw Error(
          "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
        );
      flushSegment(request, destination, segment[0], hoistableState);
      (request = boundary.contentPreamble) && writePreambleContribution(destination, request);
      return writeChunkAndReturn(destination, endSuspenseBoundary);
    }
    function flushSegmentContainer(request, destination, segment, hoistableState) {
      writeStartSegment(
        destination,
        request.renderState,
        segment.parentFormatContext,
        segment.id
      );
      flushSegment(request, destination, segment, hoistableState);
      return writeEndSegment(destination, segment.parentFormatContext);
    }
    function flushCompletedBoundary(request, destination, boundary) {
      for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++)
        flushPartiallyCompletedSegment(
          request,
          destination,
          boundary,
          completedSegments[i]
        );
      completedSegments.length = 0;
      writeHoistablesForBoundary(
        destination,
        boundary.contentState,
        request.renderState
      );
      completedSegments = request.resumableState;
      request = request.renderState;
      i = boundary.rootSegmentID;
      boundary = boundary.contentState;
      var requiresStyleInsertion = request.stylesToHoist;
      request.stylesToHoist = false;
      writeChunk(destination, request.startInlineScript);
      requiresStyleInsertion ? 0 === (completedSegments.instructions & 2) ? (completedSegments.instructions |= 10, writeChunk(destination, completeBoundaryWithStylesScript1FullBoth)) : 0 === (completedSegments.instructions & 8) ? (completedSegments.instructions |= 8, writeChunk(destination, completeBoundaryWithStylesScript1FullPartial)) : writeChunk(destination, completeBoundaryWithStylesScript1Partial) : 0 === (completedSegments.instructions & 2) ? (completedSegments.instructions |= 2, writeChunk(destination, completeBoundaryScript1Full)) : writeChunk(destination, completeBoundaryScript1Partial);
      completedSegments = i.toString(16);
      writeChunk(destination, request.boundaryPrefix);
      writeChunk(destination, completedSegments);
      writeChunk(destination, completeBoundaryScript2);
      writeChunk(destination, request.segmentPrefix);
      writeChunk(destination, completedSegments);
      requiresStyleInsertion ? (writeChunk(destination, completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : writeChunk(destination, completeBoundaryScript3b);
      boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
      return writeBootstrap(destination, request) && boundary;
    }
    function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
      if (2 === segment.status) return true;
      var hoistableState = boundary.contentState, segmentID = segment.id;
      if (-1 === segmentID) {
        if (-1 === (segment.id = boundary.rootSegmentID))
          throw Error(
            "A root segment ID must have been assigned by now. This is a bug in React."
          );
        return flushSegmentContainer(request, destination, segment, hoistableState);
      }
      if (segmentID === boundary.rootSegmentID)
        return flushSegmentContainer(request, destination, segment, hoistableState);
      flushSegmentContainer(request, destination, segment, hoistableState);
      boundary = request.resumableState;
      request = request.renderState;
      writeChunk(destination, request.startInlineScript);
      0 === (boundary.instructions & 1) ? (boundary.instructions |= 1, writeChunk(destination, completeSegmentScript1Full)) : writeChunk(destination, completeSegmentScript1Partial);
      writeChunk(destination, request.segmentPrefix);
      segmentID = segmentID.toString(16);
      writeChunk(destination, segmentID);
      writeChunk(destination, completeSegmentScript2);
      writeChunk(destination, request.placeholderPrefix);
      writeChunk(destination, segmentID);
      destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);
      return destination;
    }
    function flushCompletedQueues(request, destination) {
      currentView = new Uint8Array(2048);
      writtenBytes = 0;
      destinationHasCapacity$1 = true;
      try {
        if (!(0 < request.pendingRootTasks)) {
          var i, completedRootSegment = request.completedRootSegment;
          if (null !== completedRootSegment) {
            if (5 === completedRootSegment.status) return;
            var completedPreambleSegments = request.completedPreambleSegments;
            if (null === completedPreambleSegments) return;
            var renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
            if (htmlChunks) {
              for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
                writeChunk(destination, htmlChunks[i$jscomp$0]);
              if (headChunks)
                for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                  writeChunk(destination, headChunks[i$jscomp$0]);
              else
                writeChunk(destination, startChunkForTag("head")), writeChunk(destination, endOfStartTag);
            } else if (headChunks)
              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                writeChunk(destination, headChunks[i$jscomp$0]);
            var charsetChunks = renderState.charsetChunks;
            for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
              writeChunk(destination, charsetChunks[i$jscomp$0]);
            charsetChunks.length = 0;
            renderState.preconnects.forEach(flushResource, destination);
            renderState.preconnects.clear();
            var viewportChunks = renderState.viewportChunks;
            for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
              writeChunk(destination, viewportChunks[i$jscomp$0]);
            viewportChunks.length = 0;
            renderState.fontPreloads.forEach(flushResource, destination);
            renderState.fontPreloads.clear();
            renderState.highImagePreloads.forEach(flushResource, destination);
            renderState.highImagePreloads.clear();
            renderState.styles.forEach(flushStylesInPreamble, destination);
            var importMapChunks = renderState.importMapChunks;
            for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
              writeChunk(destination, importMapChunks[i$jscomp$0]);
            importMapChunks.length = 0;
            renderState.bootstrapScripts.forEach(flushResource, destination);
            renderState.scripts.forEach(flushResource, destination);
            renderState.scripts.clear();
            renderState.bulkPreloads.forEach(flushResource, destination);
            renderState.bulkPreloads.clear();
            var hoistableChunks = renderState.hoistableChunks;
            for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
              writeChunk(destination, hoistableChunks[i$jscomp$0]);
            for (renderState = hoistableChunks.length = 0; renderState < completedPreambleSegments.length; renderState++) {
              var segments = completedPreambleSegments[renderState];
              for (preamble = 0; preamble < segments.length; preamble++)
                flushSegment(request, destination, segments[preamble], null);
            }
            var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
            (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) && writeChunk(destination, endChunkForTag("head"));
            var bodyChunks = preamble$jscomp$0.bodyChunks;
            if (bodyChunks)
              for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
                writeChunk(destination, bodyChunks[completedPreambleSegments]);
            flushSegment(request, destination, completedRootSegment, null);
            request.completedRootSegment = null;
            writeBootstrap(destination, request.renderState);
          }
          var renderState$jscomp$0 = request.renderState;
          completedRootSegment = 0;
          var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;
          for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
            writeChunk(destination, viewportChunks$jscomp$0[completedRootSegment]);
          viewportChunks$jscomp$0.length = 0;
          renderState$jscomp$0.preconnects.forEach(flushResource, destination);
          renderState$jscomp$0.preconnects.clear();
          renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);
          renderState$jscomp$0.fontPreloads.clear();
          renderState$jscomp$0.highImagePreloads.forEach(
            flushResource,
            destination
          );
          renderState$jscomp$0.highImagePreloads.clear();
          renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);
          renderState$jscomp$0.scripts.forEach(flushResource, destination);
          renderState$jscomp$0.scripts.clear();
          renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);
          renderState$jscomp$0.bulkPreloads.clear();
          var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;
          for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
            writeChunk(destination, hoistableChunks$jscomp$0[completedRootSegment]);
          hoistableChunks$jscomp$0.length = 0;
          var clientRenderedBoundaries = request.clientRenderedBoundaries;
          for (i = 0; i < clientRenderedBoundaries.length; i++) {
            var boundary = clientRenderedBoundaries[i];
            renderState$jscomp$0 = destination;
            var resumableState = request.resumableState, renderState$jscomp$1 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest;
            writeChunk(
              renderState$jscomp$0,
              renderState$jscomp$1.startInlineScript
            );
            0 === (resumableState.instructions & 4) ? (resumableState.instructions |= 4, writeChunk(renderState$jscomp$0, clientRenderScript1Full)) : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);
            writeChunk(renderState$jscomp$0, renderState$jscomp$1.boundaryPrefix);
            writeChunk(renderState$jscomp$0, id.toString(16));
            writeChunk(renderState$jscomp$0, clientRenderScript1A);
            errorDigest && (writeChunk(
              renderState$jscomp$0,
              clientRenderErrorScriptArgInterstitial
            ), writeChunk(
              renderState$jscomp$0,
              escapeJSStringsForInstructionScripts(errorDigest || "")
            ));
            var JSCompiler_inline_result = writeChunkAndReturn(
              renderState$jscomp$0,
              clientRenderScriptEnd
            );
            if (!JSCompiler_inline_result) {
              request.destination = null;
              i++;
              clientRenderedBoundaries.splice(0, i);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i);
          var completedBoundaries = request.completedBoundaries;
          for (i = 0; i < completedBoundaries.length; i++)
            if (!flushCompletedBoundary(request, destination, completedBoundaries[i])) {
              request.destination = null;
              i++;
              completedBoundaries.splice(0, i);
              return;
            }
          completedBoundaries.splice(0, i);
          completeWriting(destination);
          currentView = new Uint8Array(2048);
          writtenBytes = 0;
          destinationHasCapacity$1 = true;
          var partialBoundaries = request.partialBoundaries;
          for (i = 0; i < partialBoundaries.length; i++) {
            var boundary$51 = partialBoundaries[i];
            a: {
              clientRenderedBoundaries = request;
              boundary = destination;
              var completedSegments = boundary$51.completedSegments;
              for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
                if (!flushPartiallyCompletedSegment(
                  clientRenderedBoundaries,
                  boundary,
                  boundary$51,
                  completedSegments[JSCompiler_inline_result]
                )) {
                  JSCompiler_inline_result++;
                  completedSegments.splice(0, JSCompiler_inline_result);
                  var JSCompiler_inline_result$jscomp$0 = false;
                  break a;
                }
              completedSegments.splice(0, JSCompiler_inline_result);
              JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
                boundary,
                boundary$51.contentState,
                clientRenderedBoundaries.renderState
              );
            }
            if (!JSCompiler_inline_result$jscomp$0) {
              request.destination = null;
              i++;
              partialBoundaries.splice(0, i);
              return;
            }
          }
          partialBoundaries.splice(0, i);
          var largeBoundaries = request.completedBoundaries;
          for (i = 0; i < largeBoundaries.length; i++)
            if (!flushCompletedBoundary(request, destination, largeBoundaries[i])) {
              request.destination = null;
              i++;
              largeBoundaries.splice(0, i);
              return;
            }
          largeBoundaries.splice(0, i);
        }
      } finally {
        0 === request.allPendingTasks && 0 === request.pingedTasks.length && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length ? (request.flushScheduled = false, i = request.resumableState, i.hasBody && writeChunk(destination, endChunkForTag("body")), i.hasHtml && writeChunk(destination, endChunkForTag("html")), completeWriting(destination), flushBuffered(destination), request.status = 14, destination.end(), request.destination = null) : (completeWriting(destination), flushBuffered(destination));
      }
    }
    function startWork(request) {
      request.flushScheduled = null !== request.destination;
      scheduleMicrotask(function() {
        return requestStorage.run(request, performWork, request);
      });
      setImmediate(function() {
        10 === request.status && (request.status = 11);
        null === request.trackedPostpones && requestStorage.run(
          request,
          enqueueEarlyPreloadsAfterInitialWork,
          request
        );
      });
    }
    function enqueueEarlyPreloadsAfterInitialWork(request) {
      safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);
    }
    function enqueueFlush(request) {
      false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination && (request.flushScheduled = true, setImmediate(function() {
        var destination = request.destination;
        destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
      }));
    }
    function startFlowing(request, destination) {
      if (13 === request.status)
        request.status = 14, destination.destroy(request.fatalError);
      else if (14 !== request.status && null === request.destination) {
        request.destination = destination;
        try {
          flushCompletedQueues(request, destination);
        } catch (error) {
          logRecoverableError(request, error, {}), fatalError(request, error);
        }
      }
    }
    function abort(request, reason) {
      if (11 === request.status || 10 === request.status) request.status = 12;
      try {
        var abortableTasks = request.abortableTasks;
        if (0 < abortableTasks.size) {
          var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
          request.fatalError = error;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, error);
          });
          abortableTasks.clear();
        }
        null !== request.destination && flushCompletedQueues(request, request.destination);
      } catch (error$53) {
        logRecoverableError(request, error$53, {}), fatalError(request, error$53);
      }
    }
    function ensureCorrectIsomorphicReactVersion() {
      var isomorphicReactPackageVersion = React12.version;
      if ("19.1.1" !== isomorphicReactPackageVersion)
        throw Error(
          'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.1.1\nLearn more: https://react.dev/warnings/version-mismatch")
        );
    }
    ensureCorrectIsomorphicReactVersion();
    function createDrainHandler(destination, request) {
      return function() {
        return startFlowing(request, destination);
      };
    }
    function createCancelHandler(request, reason) {
      return function() {
        request.destination = null;
        abort(request, Error(reason));
      };
    }
    function createRequestImpl(children, options) {
      var resumableState = createResumableState(
        options ? options.identifierPrefix : void 0,
        options ? options.unstable_externalRuntimeSrc : void 0,
        options ? options.bootstrapScriptContent : void 0,
        options ? options.bootstrapScripts : void 0,
        options ? options.bootstrapModules : void 0
      );
      return createRequest(
        children,
        resumableState,
        createRenderState(
          resumableState,
          options ? options.nonce : void 0,
          options ? options.unstable_externalRuntimeSrc : void 0,
          options ? options.importMap : void 0,
          options ? options.onHeaders : void 0,
          options ? options.maxHeadersLength : void 0
        ),
        createRootFormatContext(options ? options.namespaceURI : void 0),
        options ? options.progressiveChunkSize : void 0,
        options ? options.onError : void 0,
        options ? options.onAllReady : void 0,
        options ? options.onShellReady : void 0,
        options ? options.onShellError : void 0,
        void 0,
        options ? options.onPostpone : void 0,
        options ? options.formState : void 0
      );
    }
    ensureCorrectIsomorphicReactVersion();
    function createFakeWritable(readable) {
      return {
        write: function(chunk) {
          return readable.push(chunk);
        },
        end: function() {
          readable.push(null);
        },
        destroy: function(error) {
          readable.destroy(error);
        }
      };
    }
    exports2.prerenderToNodeStream = function(children, options) {
      return new Promise(function(resolve, reject) {
        var resumableState = createResumableState(
          options ? options.identifierPrefix : void 0,
          options ? options.unstable_externalRuntimeSrc : void 0,
          options ? options.bootstrapScriptContent : void 0,
          options ? options.bootstrapScripts : void 0,
          options ? options.bootstrapModules : void 0
        ), request = createPrerenderRequest(
          children,
          resumableState,
          createRenderState(
            resumableState,
            void 0,
            options ? options.unstable_externalRuntimeSrc : void 0,
            options ? options.importMap : void 0,
            options ? options.onHeaders : void 0,
            options ? options.maxHeadersLength : void 0
          ),
          createRootFormatContext(options ? options.namespaceURI : void 0),
          options ? options.progressiveChunkSize : void 0,
          options ? options.onError : void 0,
          function() {
            var readable = new stream.Readable({
              read: function() {
                startFlowing(request, writable);
              }
            }), writable = createFakeWritable(readable);
            resolve({ prelude: readable });
          },
          void 0,
          void 0,
          reject,
          options ? options.onPostpone : void 0
        );
        if (options && options.signal) {
          var signal = options.signal;
          if (signal.aborted) abort(request, signal.reason);
          else {
            var listener = function() {
              abort(request, signal.reason);
              signal.removeEventListener("abort", listener);
            };
            signal.addEventListener("abort", listener);
          }
        }
        startWork(request);
      });
    };
    exports2.renderToPipeableStream = function(children, options) {
      var request = createRequestImpl(children, options), hasStartedFlowing = false;
      startWork(request);
      return {
        pipe: function(destination) {
          if (hasStartedFlowing)
            throw Error(
              "React currently only supports piping to one writable stream."
            );
          hasStartedFlowing = true;
          safelyEmitEarlyPreloads(
            request,
            null === request.trackedPostpones ? 0 === request.pendingRootTasks : null === request.completedRootSegment ? 0 === request.pendingRootTasks : 5 !== request.completedRootSegment.status
          );
          startFlowing(request, destination);
          destination.on("drain", createDrainHandler(destination, request));
          destination.on(
            "error",
            createCancelHandler(
              request,
              "The destination stream errored while writing data."
            )
          );
          destination.on(
            "close",
            createCancelHandler(request, "The destination stream closed early.")
          );
          return destination;
        },
        abort: function(reason) {
          abort(request, reason);
        }
      };
    };
    exports2.version = "19.1.1";
  }
});

// node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js
var require_react_dom_server_legacy_node_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js"(exports2) {
    "use strict";
    "production" !== process.env.NODE_ENV && (function() {
      function styleReplacer(match, prefix2, s2, suffix2) {
        return "" + prefix2 + ("s" === s2 ? "\\73 " : "\\53 ") + suffix2;
      }
      function scriptReplacer(match, prefix2, s2, suffix2) {
        return "" + prefix2 + ("s" === s2 ? "\\u0073" : "\\u0053") + suffix2;
      }
      function objectName(object) {
        return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
          return p0;
        });
      }
      function describeKeyForErrorMessage(key) {
        var encodedKey = JSON.stringify(key);
        return '"' + key + '"' === encodedKey ? key : encodedKey;
      }
      function describeValueForErrorMessage(value) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(
              10 >= value.length ? value : value.slice(0, 10) + "..."
            );
          case "object":
            if (isArrayImpl(value)) return "[...]";
            if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
              return "client";
            value = objectName(value);
            return "Object" === value ? "{...}" : value;
          case "function":
            return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
          default:
            return String(value);
        }
      }
      function describeElementType(type) {
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeElementType(type.render);
            case REACT_MEMO_TYPE:
              return describeElementType(type.type);
            case REACT_LAZY_TYPE:
              var payload = type._payload;
              type = type._init;
              try {
                return describeElementType(type(payload));
              } catch (x) {
              }
          }
        return "";
      }
      function describeObjectForErrorMessage(objectOrArray, expandedName) {
        var objKind = objectName(objectOrArray);
        if ("Object" !== objKind && "Array" !== objKind) return objKind;
        var start = -1, length = 0;
        if (isArrayImpl(objectOrArray))
          if (jsxChildrenParents.has(objectOrArray)) {
            var type = jsxChildrenParents.get(objectOrArray);
            objKind = "<" + describeElementType(type) + ">";
            for (var i = 0; i < objectOrArray.length; i++) {
              var value = objectOrArray[i];
              value = "string" === typeof value ? value : "object" === typeof value && null !== value ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
              "" + i === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
            }
            objKind += "</" + describeElementType(type) + ">";
          } else {
            objKind = "[";
            for (type = 0; type < objectOrArray.length; type++)
              0 < type && (objKind += ", "), i = objectOrArray[type], i = "object" === typeof i && null !== i ? describeObjectForErrorMessage(i) : describeValueForErrorMessage(i), "" + type === expandedName ? (start = objKind.length, length = i.length, objKind += i) : objKind = 10 > i.length && 40 > objKind.length + i.length ? objKind + i : objKind + "...";
            objKind += "]";
          }
        else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
          objKind = "<" + describeElementType(objectOrArray.type) + "/>";
        else {
          if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
          if (jsxPropsParents.has(objectOrArray)) {
            objKind = jsxPropsParents.get(objectOrArray);
            objKind = "<" + (describeElementType(objKind) || "...");
            type = Object.keys(objectOrArray);
            for (i = 0; i < type.length; i++) {
              objKind += " ";
              value = type[i];
              objKind += describeKeyForErrorMessage(value) + "=";
              var _value2 = objectOrArray[value];
              var _substr2 = value === expandedName && "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
              "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
              value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
            }
            objKind += ">";
          } else {
            objKind = "{";
            type = Object.keys(objectOrArray);
            for (i = 0; i < type.length; i++)
              0 < i && (objKind += ", "), value = type[i], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
            objKind += "}";
          }
        }
        return void 0 === expandedName ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), "\n  " + objKind + "\n  " + objectOrArray) : "\n  " + objKind;
      }
      function murmurhash3_32_gc(key, seed) {
        var remainder = key.length & 3;
        var bytes = key.length - remainder;
        var h1 = seed;
        for (seed = 0; seed < bytes; ) {
          var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
          ++seed;
          k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
          h1 ^= k1;
          h1 = h1 << 13 | h1 >>> 19;
          h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
          h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
          case 2:
            k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
          case 1:
            k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
        }
        h1 ^= key.length;
        h1 ^= h1 >>> 16;
        h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
        return (h1 ^ h1 >>> 16) >>> 0;
      }
      function typeName(value) {
        return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
      }
      function willCoercionThrow(value) {
        try {
          return testStringCoercion(value), false;
        } catch (e2) {
          return true;
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
            attributeName,
            typeName(value)
          ), testStringCoercion(value);
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
            propName,
            typeName(value)
          ), testStringCoercion(value);
      }
      function checkHtmlStringCoercion(value) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(value)
          ), testStringCoercion(value);
      }
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
          return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        console.error("Invalid attribute name: `%s`", attributeName);
        return false;
      }
      function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
        ) : console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
        ));
        props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
          "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
        );
      }
      function validateProperty$1(tagName, name2) {
        if (hasOwnProperty.call(warnedProperties$1, name2) && warnedProperties$1[name2])
          return true;
        if (rARIACamel$1.test(name2)) {
          tagName = "aria-" + name2.slice(4).toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
              name2
            ), warnedProperties$1[name2] = true;
          if (name2 !== tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. Did you mean `%s`?",
              name2,
              tagName
            ), warnedProperties$1[name2] = true;
        }
        if (rARIA$1.test(name2)) {
          tagName = name2.toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName) return warnedProperties$1[name2] = true, false;
          name2 !== tagName && (console.error(
            "Unknown ARIA attribute `%s`. Did you mean `%s`?",
            name2,
            tagName
          ), warnedProperties$1[name2] = true);
        }
        return true;
      }
      function validateProperties$2(type, props) {
        var invalidProps = [], key;
        for (key in props)
          validateProperty$1(type, key) || invalidProps.push(key);
        props = invalidProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === invalidProps.length ? console.error(
          "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type
        ) : 1 < invalidProps.length && console.error(
          "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type
        );
      }
      function validateProperty(tagName, name2, value, eventRegistry) {
        if (hasOwnProperty.call(warnedProperties, name2) && warnedProperties[name2])
          return true;
        var lowerCasedName = name2.toLowerCase();
        if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
          return console.error(
            "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
          ), warnedProperties[name2] = true;
        if ("function" === typeof value && ("form" === tagName && "action" === name2 || "input" === tagName && "formAction" === name2 || "button" === tagName && "formAction" === name2))
          return true;
        if (null != eventRegistry) {
          tagName = eventRegistry.possibleRegistrationNames;
          if (eventRegistry.registrationNameDependencies.hasOwnProperty(name2))
            return true;
          eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
          if (null != eventRegistry)
            return console.error(
              "Invalid event handler property `%s`. Did you mean `%s`?",
              name2,
              eventRegistry
            ), warnedProperties[name2] = true;
          if (EVENT_NAME_REGEX.test(name2))
            return console.error(
              "Unknown event handler property `%s`. It will be ignored.",
              name2
            ), warnedProperties[name2] = true;
        } else if (EVENT_NAME_REGEX.test(name2))
          return INVALID_EVENT_NAME_REGEX.test(name2) && console.error(
            "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
            name2
          ), warnedProperties[name2] = true;
        if (rARIA.test(name2) || rARIACamel.test(name2)) return true;
        if ("innerhtml" === lowerCasedName)
          return console.error(
            "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
          ), warnedProperties[name2] = true;
        if ("aria" === lowerCasedName)
          return console.error(
            "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
          ), warnedProperties[name2] = true;
        if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
          return console.error(
            "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
            typeof value
          ), warnedProperties[name2] = true;
        if ("number" === typeof value && isNaN(value))
          return console.error(
            "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
            name2
          ), warnedProperties[name2] = true;
        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
          if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name2)
            return console.error(
              "Invalid DOM property `%s`. Did you mean `%s`?",
              name2,
              lowerCasedName
            ), warnedProperties[name2] = true;
        } else if (name2 !== lowerCasedName)
          return console.error(
            "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
            name2,
            lowerCasedName
          ), warnedProperties[name2] = true;
        switch (name2) {
          case "dangerouslySetInnerHTML":
          case "children":
          case "style":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            return true;
          case "innerText":
          case "textContent":
            return true;
        }
        switch (typeof value) {
          case "boolean":
            switch (name2) {
              case "autoFocus":
              case "checked":
              case "multiple":
              case "muted":
              case "selected":
              case "contentEditable":
              case "spellCheck":
              case "draggable":
              case "value":
              case "autoReverse":
              case "externalResourcesRequired":
              case "focusable":
              case "preserveAlpha":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "capture":
              case "download":
              case "inert":
                return true;
              default:
                lowerCasedName = name2.toLowerCase().slice(0, 5);
                if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                  return true;
                value ? console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                  value,
                  name2,
                  name2,
                  value,
                  name2
                ) : console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                  value,
                  name2,
                  name2,
                  value,
                  name2,
                  name2,
                  name2
                );
                return warnedProperties[name2] = true;
            }
          case "function":
          case "symbol":
            return warnedProperties[name2] = true, false;
          case "string":
            if ("false" === value || "true" === value) {
              switch (name2) {
                case "checked":
                case "selected":
                case "multiple":
                case "muted":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "inert":
                  break;
                default:
                  return true;
              }
              console.error(
                "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                value,
                name2,
                "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                name2,
                value
              );
              warnedProperties[name2] = true;
            }
        }
        return true;
      }
      function warnUnknownProperties(type, props, eventRegistry) {
        var unknownProps = [], key;
        for (key in props)
          validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
        props = unknownProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === unknownProps.length ? console.error(
          "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type
        ) : 1 < unknownProps.length && console.error(
          "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type
        );
      }
      function camelize(string) {
        return string.replace(hyphenPattern, function(_3, character) {
          return character.toUpperCase();
        });
      }
      function escapeTextForBrowser(text) {
        if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text)
          return "" + text;
        checkHtmlStringCoercion(text);
        text = "" + text;
        var match = matchHtmlRegExp.exec(text);
        if (match) {
          var html = "", index, lastIndex = 0;
          for (index = match.index; index < text.length; index++) {
            switch (text.charCodeAt(index)) {
              case 34:
                match = "&quot;";
                break;
              case 38:
                match = "&amp;";
                break;
              case 39:
                match = "&#x27;";
                break;
              case 60:
                match = "&lt;";
                break;
              case 62:
                match = "&gt;";
                break;
              default:
                continue;
            }
            lastIndex !== index && (html += text.slice(lastIndex, index));
            lastIndex = index + 1;
            html += match;
          }
          text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
        }
        return text;
      }
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      function escapeEntireInlineScriptContent(scriptText) {
        checkHtmlStringCoercion(scriptText);
        return ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        return {
          idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
          nextFormID: 0,
          streamingFormat: 0,
          bootstrapScriptContent,
          bootstrapScripts,
          bootstrapModules,
          instructions: NothingSent,
          hasBody: false,
          hasHtml: false,
          unknownResources: {},
          dnsResources: {},
          connectResources: { default: {}, anonymous: {}, credentials: {} },
          imageResources: {},
          styleResources: {},
          scriptResources: {},
          moduleUnknownResources: {},
          moduleScriptResources: {}
        };
      }
      function createPreambleState() {
        return {
          htmlChunks: null,
          headChunks: null,
          bodyChunks: null,
          contribution: NoContribution
        };
      }
      function createFormatContext(insertionMode, selectedValue, tagScope) {
        return {
          insertionMode,
          selectedValue,
          tagScope
        };
      }
      function getChildFormatContext(parentContext, type, props) {
        switch (type) {
          case "noscript":
            return createFormatContext(
              HTML_MODE,
              null,
              parentContext.tagScope | 1
            );
          case "select":
            return createFormatContext(
              HTML_MODE,
              null != props.value ? props.value : props.defaultValue,
              parentContext.tagScope
            );
          case "svg":
            return createFormatContext(SVG_MODE, null, parentContext.tagScope);
          case "picture":
            return createFormatContext(
              HTML_MODE,
              null,
              parentContext.tagScope | 2
            );
          case "math":
            return createFormatContext(MATHML_MODE, null, parentContext.tagScope);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null, parentContext.tagScope);
          case "table":
            return createFormatContext(
              HTML_TABLE_MODE,
              null,
              parentContext.tagScope
            );
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(
              HTML_TABLE_BODY_MODE,
              null,
              parentContext.tagScope
            );
          case "colgroup":
            return createFormatContext(
              HTML_COLGROUP_MODE,
              null,
              parentContext.tagScope
            );
          case "tr":
            return createFormatContext(
              HTML_TABLE_ROW_MODE,
              null,
              parentContext.tagScope
            );
          case "head":
            if (parentContext.insertionMode < HTML_MODE)
              return createFormatContext(
                HTML_HEAD_MODE,
                null,
                parentContext.tagScope
              );
            break;
          case "html":
            if (parentContext.insertionMode === ROOT_HTML_MODE)
              return createFormatContext(
                HTML_HTML_MODE,
                null,
                parentContext.tagScope
              );
        }
        return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode < HTML_MODE ? createFormatContext(HTML_MODE, null, parentContext.tagScope) : parentContext;
      }
      function pushStyleAttribute(target, style) {
        if ("object" !== typeof style)
          throw Error(
            "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
          );
        var isFirst = true, styleName;
        for (styleName in style)
          if (hasOwnProperty.call(style, styleName)) {
            var styleValue = style[styleName];
            if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
              if (0 === styleName.indexOf("--")) {
                var nameChunk = escapeTextForBrowser(styleName);
                checkCSSPropertyStringCoercion(styleValue, styleName);
                styleValue = escapeTextForBrowser(("" + styleValue).trim());
              } else {
                nameChunk = styleName;
                var value = styleValue;
                if (-1 < nameChunk.indexOf("-")) {
                  var name2 = nameChunk;
                  warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2] || (warnedStyleNames[name2] = true, console.error(
                    "Unsupported style property %s. Did you mean %s?",
                    name2,
                    camelize(name2.replace(msPattern$1, "ms-"))
                  ));
                } else if (badVendoredStyleNamePattern.test(nameChunk))
                  name2 = nameChunk, warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2] || (warnedStyleNames[name2] = true, console.error(
                    "Unsupported vendor-prefixed style property %s. Did you mean %s?",
                    name2,
                    name2.charAt(0).toUpperCase() + name2.slice(1)
                  ));
                else if (badStyleValueWithSemicolonPattern.test(value)) {
                  name2 = nameChunk;
                  var value$jscomp$0 = value;
                  warnedStyleValues.hasOwnProperty(value$jscomp$0) && warnedStyleValues[value$jscomp$0] || (warnedStyleValues[value$jscomp$0] = true, console.error(
                    `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
                    name2,
                    value$jscomp$0.replace(
                      badStyleValueWithSemicolonPattern,
                      ""
                    )
                  ));
                }
                "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
                  "`NaN` is an invalid value for the `%s` css style property.",
                  nameChunk
                )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
                  "`Infinity` is an invalid value for the `%s` css style property.",
                  nameChunk
                )));
                nameChunk = styleName;
                value = styleNameCache.get(nameChunk);
                void 0 !== value ? nameChunk = value : (value = escapeTextForBrowser(
                  nameChunk.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")
                ), styleNameCache.set(nameChunk, value), nameChunk = value);
                "number" === typeof styleValue ? styleValue = 0 === styleValue || unitlessNumbers.has(styleName) ? "" + styleValue : styleValue + "px" : (checkCSSPropertyStringCoercion(styleValue, styleName), styleValue = escapeTextForBrowser(
                  ("" + styleValue).trim()
                ));
              }
              isFirst ? (isFirst = false, target.push(
                styleAttributeStart,
                nameChunk,
                styleAssign,
                styleValue
              )) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);
            }
          }
        isFirst || target.push(attributeEnd);
      }
      function pushBooleanAttribute(target, name2, value) {
        value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name2, attributeEmptyString);
      }
      function pushStringAttribute(target, name2, value) {
        "function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(
          attributeSeparator,
          name2,
          attributeAssign,
          escapeTextForBrowser(value),
          attributeEnd
        );
      }
      function pushAdditionalFormField(value, key) {
        this.push('<input type="hidden"');
        validateAdditionalFormField(value);
        pushStringAttribute(this, "name", key);
        pushStringAttribute(this, "value", value);
        this.push(endOfStartTagSelfClosing);
      }
      function validateAdditionalFormField(value) {
        if ("string" !== typeof value)
          throw Error(
            "File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration."
          );
      }
      function getCustomFormFields(resumableState, formAction) {
        if ("function" === typeof formAction.$$FORM_ACTION) {
          var id = resumableState.nextFormID++;
          resumableState = resumableState.idPrefix + id;
          try {
            var customFields = formAction.$$FORM_ACTION(resumableState);
            if (customFields) {
              var formData = customFields.data;
              null != formData && formData.forEach(validateAdditionalFormField);
            }
            return customFields;
          } catch (x) {
            if ("object" === typeof x && null !== x && "function" === typeof x.then)
              throw x;
            console.error(
              "Failed to serialize an action for progressive enhancement:\n%s",
              x
            );
          }
        }
        return null;
      }
      function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name2) {
        var formData = null;
        if ("function" === typeof formAction) {
          null === name2 || didWarnFormActionName || (didWarnFormActionName = true, console.error(
            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
          ));
          null === formEncType && null === formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
          ));
          null === formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
          ));
          var customFields = getCustomFormFields(resumableState, formAction);
          null !== customFields ? (name2 = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(
            attributeSeparator,
            "formAction",
            attributeAssign,
            actionJavaScriptURL,
            attributeEnd
          ), formTarget = formMethod = formEncType = formAction = name2 = null, injectFormReplayingRuntime(resumableState, renderState));
        }
        null != name2 && pushAttribute(target, "name", name2);
        null != formAction && pushAttribute(target, "formAction", formAction);
        null != formEncType && pushAttribute(target, "formEncType", formEncType);
        null != formMethod && pushAttribute(target, "formMethod", formMethod);
        null != formTarget && pushAttribute(target, "formTarget", formTarget);
        return formData;
      }
      function pushAttribute(target, name2, value) {
        switch (name2) {
          case "className":
            pushStringAttribute(target, "class", value);
            break;
          case "tabIndex":
            pushStringAttribute(target, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            pushStringAttribute(target, name2, value);
            break;
          case "style":
            pushStyleAttribute(target, value);
            break;
          case "src":
          case "href":
            if ("" === value) {
              "src" === name2 ? console.error(
                'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                name2,
                name2
              ) : console.error(
                'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                name2,
                name2
              );
              break;
            }
          case "action":
          case "formAction":
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
              break;
            checkAttributeStringCoercion(value, name2);
            value = sanitizeURL("" + value);
            target.push(
              attributeSeparator,
              name2,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "ref":
            break;
          case "autoFocus":
          case "multiple":
          case "muted":
            pushBooleanAttribute(target, name2.toLowerCase(), value);
            break;
          case "xlinkHref":
            if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
              break;
            checkAttributeStringCoercion(value, name2);
            value = sanitizeURL("" + value);
            target.push(
              attributeSeparator,
              "xlink:href",
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              name2,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "inert":
            "" !== value || didWarnForNewBooleanPropsWithEmptyValue[name2] || (didWarnForNewBooleanPropsWithEmptyValue[name2] = true, console.error(
              "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
              name2
            ));
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name2, attributeEmptyString);
            break;
          case "capture":
          case "download":
            true === value ? target.push(attributeSeparator, name2, attributeEmptyString) : false !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              name2,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(
              attributeSeparator,
              name2,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "rowSpan":
          case "start":
            "function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(
              attributeSeparator,
              name2,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "xlinkActuate":
            pushStringAttribute(target, "xlink:actuate", value);
            break;
          case "xlinkArcrole":
            pushStringAttribute(target, "xlink:arcrole", value);
            break;
          case "xlinkRole":
            pushStringAttribute(target, "xlink:role", value);
            break;
          case "xlinkShow":
            pushStringAttribute(target, "xlink:show", value);
            break;
          case "xlinkTitle":
            pushStringAttribute(target, "xlink:title", value);
            break;
          case "xlinkType":
            pushStringAttribute(target, "xlink:type", value);
            break;
          case "xmlBase":
            pushStringAttribute(target, "xml:base", value);
            break;
          case "xmlLang":
            pushStringAttribute(target, "xml:lang", value);
            break;
          case "xmlSpace":
            pushStringAttribute(target, "xml:space", value);
            break;
          default:
            if (!(2 < name2.length) || "o" !== name2[0] && "O" !== name2[0] || "n" !== name2[1] && "N" !== name2[1]) {
              if (name2 = aliases.get(name2) || name2, isAttributeNameSafe(name2)) {
                switch (typeof value) {
                  case "function":
                  case "symbol":
                    return;
                  case "boolean":
                    var prefix2 = name2.toLowerCase().slice(0, 5);
                    if ("data-" !== prefix2 && "aria-" !== prefix2) return;
                }
                target.push(
                  attributeSeparator,
                  name2,
                  attributeAssign,
                  escapeTextForBrowser(value),
                  attributeEnd
                );
              }
            }
        }
      }
      function pushInnerHTML(target, innerHTML, children) {
        if (null != innerHTML) {
          if (null != children)
            throw Error(
              "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
            );
          if ("object" !== typeof innerHTML || !("__html" in innerHTML))
            throw Error(
              "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
            );
          innerHTML = innerHTML.__html;
          null !== innerHTML && void 0 !== innerHTML && (checkHtmlStringCoercion(innerHTML), target.push("" + innerHTML));
        }
      }
      function checkSelectProp(props, propName) {
        var value = props[propName];
        null != value && (value = isArrayImpl(value), props.multiple && !value ? console.error(
          "The `%s` prop supplied to <select> must be an array if `multiple` is true.",
          propName
        ) : !props.multiple && value && console.error(
          "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.",
          propName
        ));
      }
      function flattenOptionChildren(children) {
        var content = "";
        React12.Children.forEach(children, function(child) {
          null != child && (content += child, didWarnInvalidOptionChildren || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || (didWarnInvalidOptionChildren = true, console.error(
            "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
          )));
        });
        return content;
      }
      function injectFormReplayingRuntime(resumableState, renderState) {
        (resumableState.instructions & 16) === NothingSent && (resumableState.instructions |= 16, renderState.bootstrapChunks.unshift(
          renderState.startInlineScript,
          formReplayingRuntimeScript,
          "</script>"
        ));
      }
      function pushLinkImpl(target, props) {
        target.push(startChunkForTag("link"));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function escapeStyleTextContent(styleText) {
        checkHtmlStringCoercion(styleText);
        return ("" + styleText).replace(styleRegex, styleReplacer);
      }
      function pushSelfClosing(target, props, tag) {
        target.push(startChunkForTag(tag));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushTitleImpl(target, props) {
        target.push(startChunkForTag("title"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
        "function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(escapeTextForBrowser("" + props));
        pushInnerHTML(target, innerHTML, children);
        target.push(endChunkForTag("title"));
        return null;
      }
      function pushScriptImpl(target, props) {
        target.push(startChunkForTag("script"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        null != children && "string" !== typeof children && (props = "number" === typeof children ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error(
          "A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.",
          props
        ));
        pushInnerHTML(target, innerHTML, children);
        "string" === typeof children && target.push(escapeEntireInlineScriptContent(children));
        target.push(endChunkForTag("script"));
        return null;
      }
      function pushStartSingletonElement(target, props, tag) {
        target.push(startChunkForTag(tag));
        var innerHTML = tag = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  tag = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, tag);
        return tag;
      }
      function pushStartGenericElement(target, props, tag) {
        target.push(startChunkForTag(tag));
        var innerHTML = tag = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  tag = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, tag);
        return "string" === typeof tag ? (target.push(escapeTextForBrowser(tag)), null) : tag;
      }
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (void 0 === tagStartChunk) {
          if (!VALID_TAG_REGEX.test(tag)) throw Error("Invalid tag: " + tag);
          tagStartChunk = "<" + tag;
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      function pushStartInstance(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded, isFallback) {
        validateProperties$2(type, props);
        "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
          "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
          type
        ) : console.error(
          "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
          type
        ));
        b: if (-1 === type.indexOf("-")) var JSCompiler_inline_result = false;
        else
          switch (type) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              JSCompiler_inline_result = false;
              break b;
            default:
              JSCompiler_inline_result = true;
          }
        JSCompiler_inline_result || "string" === typeof props.is || warnUnknownProperties(type, props, null);
        !props.suppressContentEditableWarning && props.contentEditable && null != props.children && console.error(
          "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
        );
        formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && -1 === type.indexOf("-") && type.toLowerCase() !== type && console.error(
          "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
          type
        );
        switch (type) {
          case "div":
          case "span":
          case "svg":
          case "path":
            break;
          case "a":
            target$jscomp$0.push(startChunkForTag("a"));
            var children = null, innerHTML = null, propKey;
            for (propKey in props)
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "children":
                      children = propValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML = propValue;
                      break;
                    case "href":
                      "" === propValue ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                      break;
                    default:
                      pushAttribute(target$jscomp$0, propKey, propValue);
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML, children);
            if ("string" === typeof children) {
              target$jscomp$0.push(escapeTextForBrowser(children));
              var JSCompiler_inline_result$jscomp$0 = null;
            } else JSCompiler_inline_result$jscomp$0 = children;
            return JSCompiler_inline_result$jscomp$0;
          case "g":
          case "p":
          case "li":
            break;
          case "select":
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultSelectValue || (console.error(
              "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
            ), didWarnDefaultSelectValue = true);
            target$jscomp$0.push(startChunkForTag("select"));
            var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
            for (propKey$jscomp$0 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$0)) {
                var propValue$jscomp$0 = props[propKey$jscomp$0];
                if (null != propValue$jscomp$0)
                  switch (propKey$jscomp$0) {
                    case "children":
                      children$jscomp$0 = propValue$jscomp$0;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$0 = propValue$jscomp$0;
                      break;
                    case "defaultValue":
                    case "value":
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$0,
                        propValue$jscomp$0
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
            return children$jscomp$0;
          case "option":
            var selectedValue = formatContext.selectedValue;
            target$jscomp$0.push(startChunkForTag("option"));
            var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
            for (propKey$jscomp$1 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$1)) {
                var propValue$jscomp$1 = props[propKey$jscomp$1];
                if (null != propValue$jscomp$1)
                  switch (propKey$jscomp$1) {
                    case "children":
                      children$jscomp$1 = propValue$jscomp$1;
                      break;
                    case "selected":
                      selected = propValue$jscomp$1;
                      didWarnSelectedSetOnOption || (console.error(
                        "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
                      ), didWarnSelectedSetOnOption = true);
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$1 = propValue$jscomp$1;
                      break;
                    case "value":
                      value = propValue$jscomp$1;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$1,
                        propValue$jscomp$1
                      );
                  }
              }
            if (null != selectedValue) {
              if (null !== value) {
                checkAttributeStringCoercion(value, "value");
                var stringValue = "" + value;
              } else
                null === innerHTML$jscomp$1 || didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = true, console.error(
                  "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
                )), stringValue = flattenOptionChildren(children$jscomp$1);
              if (isArrayImpl(selectedValue))
                for (var i = 0; i < selectedValue.length; i++) {
                  if (checkAttributeStringCoercion(selectedValue[i], "value"), "" + selectedValue[i] === stringValue) {
                    target$jscomp$0.push(' selected=""');
                    break;
                  }
                }
              else
                checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(' selected=""');
            } else selected && target$jscomp$0.push(' selected=""');
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
            return children$jscomp$1;
          case "textarea":
            checkControlledValueProps("textarea", props);
            void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultTextareaValue || (console.error(
              "Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"
            ), didWarnDefaultTextareaValue = true);
            target$jscomp$0.push(startChunkForTag("textarea"));
            var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
            for (propKey$jscomp$2 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$2)) {
                var propValue$jscomp$2 = props[propKey$jscomp$2];
                if (null != propValue$jscomp$2)
                  switch (propKey$jscomp$2) {
                    case "children":
                      children$jscomp$2 = propValue$jscomp$2;
                      break;
                    case "value":
                      value$jscomp$0 = propValue$jscomp$2;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$jscomp$2;
                      break;
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                      );
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$2,
                        propValue$jscomp$2
                      );
                  }
              }
            null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
            target$jscomp$0.push(endOfStartTag);
            if (null != children$jscomp$2) {
              console.error(
                "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
              );
              if (null != value$jscomp$0)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children$jscomp$2)) {
                if (1 < children$jscomp$2.length)
                  throw Error("<textarea> can only have at most one child.");
                checkHtmlStringCoercion(children$jscomp$2[0]);
                value$jscomp$0 = "" + children$jscomp$2[0];
              }
              checkHtmlStringCoercion(children$jscomp$2);
              value$jscomp$0 = "" + children$jscomp$2;
            }
            "string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline);
            null !== value$jscomp$0 && (checkAttributeStringCoercion(value$jscomp$0, "value"), target$jscomp$0.push(escapeTextForBrowser("" + value$jscomp$0)));
            return null;
          case "input":
            checkControlledValueProps("input", props);
            target$jscomp$0.push(startChunkForTag("input"));
            var name2 = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
            for (propKey$jscomp$3 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$3)) {
                var propValue$jscomp$3 = props[propKey$jscomp$3];
                if (null != propValue$jscomp$3)
                  switch (propKey$jscomp$3) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    case "name":
                      name2 = propValue$jscomp$3;
                      break;
                    case "formAction":
                      formAction = propValue$jscomp$3;
                      break;
                    case "formEncType":
                      formEncType = propValue$jscomp$3;
                      break;
                    case "formMethod":
                      formMethod = propValue$jscomp$3;
                      break;
                    case "formTarget":
                      formTarget = propValue$jscomp$3;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$jscomp$3;
                      break;
                    case "defaultValue":
                      defaultValue$jscomp$0 = propValue$jscomp$3;
                      break;
                    case "checked":
                      checked = propValue$jscomp$3;
                      break;
                    case "value":
                      value$jscomp$1 = propValue$jscomp$3;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$3,
                        propValue$jscomp$3
                      );
                  }
              }
            null === formAction || "image" === props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
              'An input can only specify a formAction along with type="submit" or type="image".'
            ));
            var formData = pushFormActionAttribute(
              target$jscomp$0,
              resumableState,
              renderState,
              formAction,
              formEncType,
              formMethod,
              formTarget,
              name2
            );
            null === checked || null === defaultChecked || didWarnDefaultChecked || (console.error(
              "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              "A component",
              props.type
            ), didWarnDefaultChecked = true);
            null === value$jscomp$1 || null === defaultValue$jscomp$0 || didWarnDefaultInputValue || (console.error(
              "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              "A component",
              props.type
            ), didWarnDefaultInputValue = true);
            null !== checked ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
            null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
            target$jscomp$0.push(endOfStartTagSelfClosing);
            null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);
            return null;
          case "button":
            target$jscomp$0.push(startChunkForTag("button"));
            var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
            for (propKey$jscomp$4 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$4)) {
                var propValue$jscomp$4 = props[propKey$jscomp$4];
                if (null != propValue$jscomp$4)
                  switch (propKey$jscomp$4) {
                    case "children":
                      children$jscomp$3 = propValue$jscomp$4;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$2 = propValue$jscomp$4;
                      break;
                    case "name":
                      name$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formAction":
                      formAction$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formEncType":
                      formEncType$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formMethod":
                      formMethod$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formTarget":
                      formTarget$jscomp$0 = propValue$jscomp$4;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$4,
                        propValue$jscomp$4
                      );
                  }
              }
            null === formAction$jscomp$0 || null == props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
              'A button can only specify a formAction along with type="submit" or no type.'
            ));
            var formData$jscomp$0 = pushFormActionAttribute(
              target$jscomp$0,
              resumableState,
              renderState,
              formAction$jscomp$0,
              formEncType$jscomp$0,
              formMethod$jscomp$0,
              formTarget$jscomp$0,
              name$jscomp$0
            );
            target$jscomp$0.push(endOfStartTag);
            null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
            if ("string" === typeof children$jscomp$3) {
              target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));
              var JSCompiler_inline_result$jscomp$1 = null;
            } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
            return JSCompiler_inline_result$jscomp$1;
          case "form":
            target$jscomp$0.push(startChunkForTag("form"));
            var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
            for (propKey$jscomp$5 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$5)) {
                var propValue$jscomp$5 = props[propKey$jscomp$5];
                if (null != propValue$jscomp$5)
                  switch (propKey$jscomp$5) {
                    case "children":
                      children$jscomp$4 = propValue$jscomp$5;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$3 = propValue$jscomp$5;
                      break;
                    case "action":
                      formAction$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "encType":
                      formEncType$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "method":
                      formMethod$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "target":
                      formTarget$jscomp$1 = propValue$jscomp$5;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$5,
                        propValue$jscomp$5
                      );
                  }
              }
            var formData$jscomp$1 = null, formActionName = null;
            if ("function" === typeof formAction$jscomp$1) {
              null === formEncType$jscomp$1 && null === formMethod$jscomp$1 || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              ));
              null === formTarget$jscomp$1 || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ));
              var customFields = getCustomFormFields(
                resumableState,
                formAction$jscomp$1
              );
              null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(
                attributeSeparator,
                "action",
                attributeAssign,
                actionJavaScriptURL,
                attributeEnd
              ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
            }
            null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
            null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
            null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
            null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
            target$jscomp$0.push(endOfStartTag);
            null !== formActionName && (target$jscomp$0.push('<input type="hidden"'), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), null != formData$jscomp$1 && formData$jscomp$1.forEach(
              pushAdditionalFormField,
              target$jscomp$0
            ));
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
            if ("string" === typeof children$jscomp$4) {
              target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));
              var JSCompiler_inline_result$jscomp$2 = null;
            } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
            return JSCompiler_inline_result$jscomp$2;
          case "menuitem":
            target$jscomp$0.push(startChunkForTag("menuitem"));
            for (var propKey$jscomp$6 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$6)) {
                var propValue$jscomp$6 = props[propKey$jscomp$6];
                if (null != propValue$jscomp$6)
                  switch (propKey$jscomp$6) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "menuitems cannot have `children` nor `dangerouslySetInnerHTML`."
                      );
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$6,
                        propValue$jscomp$6
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            return null;
          case "object":
            target$jscomp$0.push(startChunkForTag("object"));
            var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
            for (propKey$jscomp$7 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$7)) {
                var propValue$jscomp$7 = props[propKey$jscomp$7];
                if (null != propValue$jscomp$7)
                  switch (propKey$jscomp$7) {
                    case "children":
                      children$jscomp$5 = propValue$jscomp$7;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$4 = propValue$jscomp$7;
                      break;
                    case "data":
                      checkAttributeStringCoercion(propValue$jscomp$7, "data");
                      var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                      if ("" === sanitizedValue) {
                        console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          propKey$jscomp$7,
                          propKey$jscomp$7
                        );
                        break;
                      }
                      target$jscomp$0.push(
                        attributeSeparator,
                        "data",
                        attributeAssign,
                        escapeTextForBrowser(sanitizedValue),
                        attributeEnd
                      );
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$7,
                        propValue$jscomp$7
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
            if ("string" === typeof children$jscomp$5) {
              target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));
              var JSCompiler_inline_result$jscomp$3 = null;
            } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
            return JSCompiler_inline_result$jscomp$3;
          case "title":
            var insertionMode = formatContext.insertionMode, noscriptTagInScope = !!(formatContext.tagScope & 1);
            if (hasOwnProperty.call(props, "children")) {
              var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
              Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.",
                children$jscomp$6.length
              ) : "function" === typeof child || "symbol" === typeof child ? console.error(
                "React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.",
                "function" === typeof child ? "a Function" : "a Sybmol"
              ) : child && child.toString === {}.toString && (null != child.$$typeof ? console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML."
              ) : console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."
              ));
            }
            if (insertionMode === SVG_MODE || noscriptTagInScope || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(
                target$jscomp$0,
                props
              );
            else
              isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = void 0);
            return JSCompiler_inline_result$jscomp$4;
          case "link":
            var rel = props.rel, href = props.href, precedence = props.precedence;
            if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
              "stylesheet" === rel && "string" === typeof props.precedence && ("string" === typeof href && href || console.error(
                'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',
                null === href ? "`null`" : void 0 === href ? "`undefined`" : "" === href ? "an empty string" : 'something with type "' + typeof href + '"'
              ));
              pushLinkImpl(target$jscomp$0, props);
              var JSCompiler_inline_result$jscomp$5 = null;
            } else if ("stylesheet" === props.rel)
              if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError) {
                if ("string" === typeof precedence) {
                  if (null != props.disabled)
                    console.error(
                      'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'
                    );
                  else if (props.onLoad || props.onError) {
                    var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
                    console.error(
                      'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                      propDescription,
                      propDescription
                    );
                  }
                }
                JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                  target$jscomp$0,
                  props
                );
              } else {
                var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(
                  href
                ) ? resumableState.styleResources[href] : void 0;
                if (resourceState !== EXISTS) {
                  resumableState.styleResources[href] = EXISTS;
                  styleQueue || (styleQueue = {
                    precedence: escapeTextForBrowser(precedence),
                    rules: [],
                    hrefs: [],
                    sheets: /* @__PURE__ */ new Map()
                  }, renderState.styles.set(precedence, styleQueue));
                  var resource = {
                    state: PENDING$1,
                    props: assign({}, props, {
                      "data-precedence": props.precedence,
                      precedence: null
                    })
                  };
                  if (resourceState) {
                    2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);
                    var preloadResource = renderState.preloads.stylesheets.get(href);
                    preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED;
                  }
                  styleQueue.sheets.set(href, resource);
                  hoistableState && hoistableState.stylesheets.add(resource);
                } else if (styleQueue) {
                  var _resource = styleQueue.sheets.get(href);
                  _resource && hoistableState && hoistableState.stylesheets.add(_resource);
                }
                textEmbedded && target$jscomp$0.push("<!-- -->");
                JSCompiler_inline_result$jscomp$5 = null;
              }
            else
              props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                target$jscomp$0,
                props
              ) : (textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$5 = isFallback ? null : pushLinkImpl(renderState.hoistableChunks, props));
            return JSCompiler_inline_result$jscomp$5;
          case "script":
            var asyncProp = props.async;
            if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(
                target$jscomp$0,
                props
              );
            else {
              var key = props.src;
              if ("module" === props.type) {
                var resources = resumableState.moduleScriptResources;
                var preloads = renderState.preloads.moduleScripts;
              } else
                resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
              var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
              if (resourceState$jscomp$0 !== EXISTS) {
                resources[key] = EXISTS;
                var scriptProps = props;
                if (resourceState$jscomp$0) {
                  2 === resourceState$jscomp$0.length && (scriptProps = assign({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
                  var preloadResource$jscomp$0 = preloads.get(key);
                  preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
                }
                var resource$jscomp$0 = [];
                renderState.scripts.add(resource$jscomp$0);
                pushScriptImpl(resource$jscomp$0, scriptProps);
              }
              textEmbedded && target$jscomp$0.push("<!-- -->");
              JSCompiler_inline_result$jscomp$6 = null;
            }
            return JSCompiler_inline_result$jscomp$6;
          case "style":
            var insertionMode$jscomp$0 = formatContext.insertionMode, noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);
            if (hasOwnProperty.call(props, "children")) {
              var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
              ("function" === typeof child$jscomp$0 || "symbol" === typeof child$jscomp$0 || Array.isArray(child$jscomp$0)) && console.error(
                "React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.",
                "function" === typeof child$jscomp$0 ? "a Function" : "symbol" === typeof child$jscomp$0 ? "a Sybmol" : "an Array"
              );
            }
            var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href;
            if (insertionMode$jscomp$0 === SVG_MODE || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
              target$jscomp$0.push(startChunkForTag("style"));
              var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
              for (propKey$jscomp$8 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$8)) {
                  var propValue$jscomp$8 = props[propKey$jscomp$8];
                  if (null != propValue$jscomp$8)
                    switch (propKey$jscomp$8) {
                      case "children":
                        children$jscomp$8 = propValue$jscomp$8;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$5 = propValue$jscomp$8;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$8,
                          propValue$jscomp$8
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
              "function" !== typeof child$jscomp$1 && "symbol" !== typeof child$jscomp$1 && null !== child$jscomp$1 && void 0 !== child$jscomp$1 && target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));
              pushInnerHTML(
                target$jscomp$0,
                innerHTML$jscomp$5,
                children$jscomp$8
              );
              target$jscomp$0.push(endChunkForTag("style"));
              var JSCompiler_inline_result$jscomp$7 = null;
            } else {
              href$jscomp$0.includes(" ") && console.error(
                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is "%s".',
                href$jscomp$0
              );
              var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0;
              if (resourceState$jscomp$1 !== EXISTS) {
                resumableState.styleResources[href$jscomp$0] = EXISTS;
                resourceState$jscomp$1 && console.error(
                  'React encountered a hoistable style tag for the same href as a preload: "%s". When using a style tag to inline styles you should not also preload it as a stylsheet.',
                  href$jscomp$0
                );
                styleQueue$jscomp$0 ? styleQueue$jscomp$0.hrefs.push(
                  escapeTextForBrowser(href$jscomp$0)
                ) : (styleQueue$jscomp$0 = {
                  precedence: escapeTextForBrowser(precedence$jscomp$0),
                  rules: [],
                  hrefs: [escapeTextForBrowser(href$jscomp$0)],
                  sheets: /* @__PURE__ */ new Map()
                }, renderState.styles.set(
                  precedence$jscomp$0,
                  styleQueue$jscomp$0
                ));
                var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
                for (propKey$jscomp$9 in props)
                  if (hasOwnProperty.call(props, propKey$jscomp$9)) {
                    var propValue$jscomp$9 = props[propKey$jscomp$9];
                    if (null != propValue$jscomp$9)
                      switch (propKey$jscomp$9) {
                        case "children":
                          children$jscomp$9 = propValue$jscomp$9;
                          break;
                        case "dangerouslySetInnerHTML":
                          innerHTML$jscomp$6 = propValue$jscomp$9;
                      }
                  }
                var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
                "function" !== typeof child$jscomp$2 && "symbol" !== typeof child$jscomp$2 && null !== child$jscomp$2 && void 0 !== child$jscomp$2 && target.push(escapeStyleTextContent(child$jscomp$2));
                pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);
              }
              styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
              textEmbedded && target$jscomp$0.push("<!-- -->");
              JSCompiler_inline_result$jscomp$7 = void 0;
            }
            return JSCompiler_inline_result$jscomp$7;
          case "meta":
            if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(
                target$jscomp$0,
                props,
                "meta"
              );
            else
              textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$8 = isFallback ? null : "string" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(
                renderState.hoistableChunks,
                props,
                "meta"
              );
            return JSCompiler_inline_result$jscomp$8;
          case "listing":
          case "pre":
            target$jscomp$0.push(startChunkForTag(type));
            var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
            for (propKey$jscomp$10 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$10)) {
                var propValue$jscomp$10 = props[propKey$jscomp$10];
                if (null != propValue$jscomp$10)
                  switch (propKey$jscomp$10) {
                    case "children":
                      children$jscomp$10 = propValue$jscomp$10;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$7 = propValue$jscomp$10;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$10,
                        propValue$jscomp$10
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            if (null != innerHTML$jscomp$7) {
              if (null != children$jscomp$10)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7))
                throw Error(
                  "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                );
              var html = innerHTML$jscomp$7.__html;
              null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push(leadingNewline, html) : (checkHtmlStringCoercion(html), target$jscomp$0.push("" + html)));
            }
            "string" === typeof children$jscomp$10 && "\n" === children$jscomp$10[0] && target$jscomp$0.push(leadingNewline);
            return children$jscomp$10;
          case "img":
            var src = props.src, srcSet = props.srcSet;
            if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet) && "low" !== props.fetchPriority && false === !!(formatContext.tagScope & 3) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
              var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
              if (resource$jscomp$1) {
                if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size)
                  promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
              } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
                resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
                var input = props.crossOrigin;
                var crossOrigin = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
                var headers = renderState.headers, header;
                headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
                  imageSrcSet: props.srcSet,
                  imageSizes: props.sizes,
                  crossOrigin,
                  integrity: props.integrity,
                  nonce: props.nonce,
                  type: props.type,
                  fetchPriority: props.fetchPriority,
                  referrerPolicy: props.refererPolicy
                }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
                  rel: "preload",
                  as: "image",
                  href: srcSet ? void 0 : src,
                  imageSrcSet: srcSet,
                  imageSizes: sizes,
                  crossOrigin,
                  integrity: props.integrity,
                  type: props.type,
                  fetchPriority: props.fetchPriority,
                  referrerPolicy: props.referrerPolicy
                }), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
              }
            }
            return pushSelfClosing(target$jscomp$0, props, "img");
          case "base":
          case "area":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "param":
          case "source":
          case "track":
          case "wbr":
            return pushSelfClosing(target$jscomp$0, props, type);
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            break;
          case "head":
            if (formatContext.insertionMode < HTML_MODE) {
              var preamble = preambleState || renderState.preamble;
              if (preamble.headChunks)
                throw Error("The `<head>` tag may only be rendered once.");
              preamble.headChunks = [];
              var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(
                preamble.headChunks,
                props,
                "head"
              );
            } else
              JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "head"
              );
            return JSCompiler_inline_result$jscomp$9;
          case "body":
            if (formatContext.insertionMode < HTML_MODE) {
              var preamble$jscomp$0 = preambleState || renderState.preamble;
              if (preamble$jscomp$0.bodyChunks)
                throw Error("The `<body>` tag may only be rendered once.");
              preamble$jscomp$0.bodyChunks = [];
              var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(
                preamble$jscomp$0.bodyChunks,
                props,
                "body"
              );
            } else
              JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "body"
              );
            return JSCompiler_inline_result$jscomp$10;
          case "html":
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              var preamble$jscomp$1 = preambleState || renderState.preamble;
              if (preamble$jscomp$1.htmlChunks)
                throw Error("The `<html>` tag may only be rendered once.");
              preamble$jscomp$1.htmlChunks = [doctypeChunk];
              var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(
                preamble$jscomp$1.htmlChunks,
                props,
                "html"
              );
            } else
              JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "html"
              );
            return JSCompiler_inline_result$jscomp$11;
          default:
            if (-1 !== type.indexOf("-")) {
              target$jscomp$0.push(startChunkForTag(type));
              var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
              for (propKey$jscomp$11 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$11)) {
                  var propValue$jscomp$11 = props[propKey$jscomp$11];
                  if (null != propValue$jscomp$11) {
                    var attributeName = propKey$jscomp$11;
                    switch (propKey$jscomp$11) {
                      case "children":
                        children$jscomp$11 = propValue$jscomp$11;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$8 = propValue$jscomp$11;
                        break;
                      case "style":
                        pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                        break;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "ref":
                        break;
                      case "className":
                        attributeName = "class";
                      default:
                        if (isAttributeNameSafe(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {
                          if (true === propValue$jscomp$11)
                            propValue$jscomp$11 = "";
                          else if ("object" === typeof propValue$jscomp$11)
                            continue;
                          target$jscomp$0.push(
                            attributeSeparator,
                            attributeName,
                            attributeAssign,
                            escapeTextForBrowser(propValue$jscomp$11),
                            attributeEnd
                          );
                        }
                    }
                  }
                }
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(
                target$jscomp$0,
                innerHTML$jscomp$8,
                children$jscomp$11
              );
              return children$jscomp$11;
            }
        }
        return pushStartGenericElement(target$jscomp$0, props, type);
      }
      function endChunkForTag(tag) {
        var chunk = endTagCache.get(tag);
        void 0 === chunk && (chunk = "</" + tag + ">", endTagCache.set(tag, chunk));
        return chunk;
      }
      function hoistPreambleState(renderState, preambleState) {
        renderState = renderState.preamble;
        null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks, preambleState.contribution |= 1);
        null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks, preambleState.contribution |= 4);
        null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks, preambleState.contribution |= 2);
      }
      function writeBootstrap(destination, renderState) {
        renderState = renderState.bootstrapChunks;
        for (var i = 0; i < renderState.length - 1; i++)
          destination.push(renderState[i]);
        return i < renderState.length ? (i = renderState[i], renderState.length = 0, destination.push(i)) : true;
      }
      function writeStartPendingSuspenseBoundary(destination, renderState, id) {
        destination.push(startPendingSuspenseBoundary1);
        if (null === id)
          throw Error(
            "An ID must have been assigned before we can complete the boundary."
          );
        destination.push(renderState.boundaryPrefix);
        renderState = id.toString(16);
        destination.push(renderState);
        return destination.push(startPendingSuspenseBoundary2);
      }
      function writePreambleContribution(destination, preambleState) {
        preambleState = preambleState.contribution;
        preambleState !== NoContribution && (destination.push(boundaryPreambleContributionChunkStart), destination.push("" + preambleState), destination.push(boundaryPreambleContributionChunkEnd));
      }
      function writeStartSegment(destination, renderState, formatContext, id) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_HTML_MODE:
          case HTML_HEAD_MODE:
          case HTML_MODE:
            return destination.push(startSegmentHTML), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentHTML2);
          case SVG_MODE:
            return destination.push(startSegmentSVG), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentSVG2);
          case MATHML_MODE:
            return destination.push(startSegmentMathML), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentMathML2);
          case HTML_TABLE_MODE:
            return destination.push(startSegmentTable), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTable2);
          case HTML_TABLE_BODY_MODE:
            return destination.push(startSegmentTableBody), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTableBody2);
          case HTML_TABLE_ROW_MODE:
            return destination.push(startSegmentTableRow), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTableRow2);
          case HTML_COLGROUP_MODE:
            return destination.push(startSegmentColGroup), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentColGroup2);
          default:
            throw Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_HTML_MODE:
          case HTML_HEAD_MODE:
          case HTML_MODE:
            return destination.push(endSegmentHTML);
          case SVG_MODE:
            return destination.push(endSegmentSVG);
          case MATHML_MODE:
            return destination.push(endSegmentMathML);
          case HTML_TABLE_MODE:
            return destination.push(endSegmentTable);
          case HTML_TABLE_BODY_MODE:
            return destination.push(endSegmentTableBody);
          case HTML_TABLE_ROW_MODE:
            return destination.push(endSegmentTableRow);
          case HTML_COLGROUP_MODE:
            return destination.push(endSegmentColGroup);
          default:
            throw Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      function escapeJSStringsForInstructionScripts(input) {
        return JSON.stringify(input).replace(
          regexForJSStringsInInstructionScripts,
          function(match) {
            switch (match) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default:
                throw Error(
                  "escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                );
            }
          }
        );
      }
      function escapeJSObjectForInstructionScripts(input) {
        return JSON.stringify(input).replace(
          regexForJSStringsInScripts,
          function(match) {
            switch (match) {
              case "&":
                return "\\u0026";
              case ">":
                return "\\u003e";
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default:
                throw Error(
                  "escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                );
            }
          }
        );
      }
      function flushStyleTagsLateForBoundary(styleQueue) {
        var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
        0 < rules.length && 0 === hrefs.length && console.error(
          "React expected to have at least one href for an a hoistable style but found none. This is a bug in React."
        );
        var i = 0;
        if (hrefs.length) {
          this.push(lateStyleTagResourceOpen1);
          this.push(styleQueue.precedence);
          for (this.push(lateStyleTagResourceOpen2); i < hrefs.length - 1; i++)
            this.push(hrefs[i]), this.push(spaceSeparator);
          this.push(hrefs[i]);
          this.push(lateStyleTagResourceOpen3);
          for (i = 0; i < rules.length; i++) this.push(rules[i]);
          destinationHasCapacity = this.push(lateStyleTagTemplateClose);
          currentlyRenderingBoundaryHasStylesToHoist = true;
          rules.length = 0;
          hrefs.length = 0;
        }
      }
      function hasStylesToHoist(stylesheet) {
        return stylesheet.state !== PREAMBLE ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
      }
      function writeHoistablesForBoundary(destination, hoistableState, renderState) {
        currentlyRenderingBoundaryHasStylesToHoist = false;
        destinationHasCapacity = true;
        hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
        hoistableState.stylesheets.forEach(hasStylesToHoist);
        currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
        return destinationHasCapacity;
      }
      function flushResource(resource) {
        for (var i = 0; i < resource.length; i++) this.push(resource[i]);
        resource.length = 0;
      }
      function flushStyleInPreamble(stylesheet) {
        pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
        for (var i = 0; i < stylesheetFlushingQueue.length; i++)
          this.push(stylesheetFlushingQueue[i]);
        stylesheetFlushingQueue.length = 0;
        stylesheet.state = PREAMBLE;
      }
      function flushStylesInPreamble(styleQueue) {
        var hasStylesheets = 0 < styleQueue.sheets.size;
        styleQueue.sheets.forEach(flushStyleInPreamble, this);
        styleQueue.sheets.clear();
        var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
        if (!hasStylesheets || hrefs.length) {
          this.push(styleTagResourceOpen1);
          this.push(styleQueue.precedence);
          styleQueue = 0;
          if (hrefs.length) {
            for (this.push(styleTagResourceOpen2); styleQueue < hrefs.length - 1; styleQueue++)
              this.push(hrefs[styleQueue]), this.push(spaceSeparator);
            this.push(hrefs[styleQueue]);
          }
          this.push(styleTagResourceOpen3);
          for (styleQueue = 0; styleQueue < rules.length; styleQueue++)
            this.push(rules[styleQueue]);
          this.push(styleTagResourceClose);
          rules.length = 0;
          hrefs.length = 0;
        }
      }
      function preloadLateStyle(stylesheet) {
        if (stylesheet.state === PENDING$1) {
          stylesheet.state = PRELOADED;
          var props = stylesheet.props;
          pushLinkImpl(stylesheetFlushingQueue, {
            rel: "preload",
            as: "style",
            href: stylesheet.props.href,
            crossOrigin: props.crossOrigin,
            fetchPriority: props.fetchPriority,
            integrity: props.integrity,
            media: props.media,
            hrefLang: props.hrefLang,
            referrerPolicy: props.referrerPolicy
          });
          for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)
            this.push(stylesheetFlushingQueue[stylesheet]);
          stylesheetFlushingQueue.length = 0;
        }
      }
      function preloadLateStyles(styleQueue) {
        styleQueue.sheets.forEach(preloadLateStyle, this);
        styleQueue.sheets.clear();
      }
      function writeStyleResourceDependenciesInJS(destination, hoistableState) {
        destination.push(arrayFirstOpenBracket);
        var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
        hoistableState.stylesheets.forEach(function(resource) {
          if (resource.state !== PREAMBLE)
            if (resource.state === LATE)
              destination.push(nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion(resource, "href"), resource = escapeJSObjectForInstructionScripts("" + resource), destination.push(resource), destination.push(arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
            else {
              destination.push(nextArrayOpenBrackChunk);
              var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
              coercedHref = escapeJSObjectForInstructionScripts(coercedHref);
              destination.push(coercedHref);
              checkAttributeStringCoercion(precedence, "precedence");
              precedence = "" + precedence;
              destination.push(arrayInterstitial);
              precedence = escapeJSObjectForInstructionScripts(precedence);
              destination.push(precedence);
              for (var propKey in props)
                if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], null != precedence))
                  switch (propKey) {
                    case "href":
                    case "rel":
                    case "precedence":
                    case "data-precedence":
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      writeStyleResourceAttributeInJS(
                        destination,
                        propKey,
                        precedence
                      );
                  }
              destination.push(arrayCloseBracket);
              nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
              resource.state = LATE;
            }
        });
        destination.push(arrayCloseBracket);
      }
      function writeStyleResourceAttributeInJS(destination, name2, value) {
        var attributeName = name2.toLowerCase();
        switch (typeof value) {
          case "function":
          case "symbol":
            return;
        }
        switch (name2) {
          case "innerHTML":
          case "dangerouslySetInnerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "style":
          case "ref":
            return;
          case "className":
            attributeName = "class";
            checkAttributeStringCoercion(value, attributeName);
            name2 = "" + value;
            break;
          case "hidden":
            if (false === value) return;
            name2 = "";
            break;
          case "src":
          case "href":
            value = sanitizeURL(value);
            checkAttributeStringCoercion(value, attributeName);
            name2 = "" + value;
            break;
          default:
            if (2 < name2.length && ("o" === name2[0] || "O" === name2[0]) && ("n" === name2[1] || "N" === name2[1]) || !isAttributeNameSafe(name2))
              return;
            checkAttributeStringCoercion(value, attributeName);
            name2 = "" + value;
        }
        destination.push(arrayInterstitial);
        attributeName = escapeJSObjectForInstructionScripts(attributeName);
        destination.push(attributeName);
        destination.push(arrayInterstitial);
        attributeName = escapeJSObjectForInstructionScripts(name2);
        destination.push(attributeName);
      }
      function createHoistableState() {
        return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set() };
      }
      function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {
        (resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error(
          'Internal React Error: React expected bootstrap script or module with src "%s" to not have been preloaded already. please file an issue',
          href
        );
        resumableState.scriptResources[href] = EXISTS;
        resumableState.moduleScriptResources[href] = EXISTS;
        resumableState = [];
        pushLinkImpl(resumableState, props);
        renderState.bootstrapScripts.add(resumableState);
      }
      function adoptPreloadCredentials(target, preloadState) {
        null == target.crossOrigin && (target.crossOrigin = preloadState[0]);
        null == target.integrity && (target.integrity = preloadState[1]);
      }
      function getPreloadAsHeader(href, as3, params) {
        href = escapeHrefForLinkHeaderURLContext(href);
        as3 = escapeStringForLinkHeaderQuotedParamValueContext(as3, "as");
        as3 = "<" + href + '>; rel=preload; as="' + as3 + '"';
        for (var paramName in params)
          hasOwnProperty.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as3 += "; " + paramName.toLowerCase() + '="' + escapeStringForLinkHeaderQuotedParamValueContext(
            href,
            paramName
          ) + '"'));
        return as3;
      }
      function escapeHrefForLinkHeaderURLContext(hrefInput) {
        checkAttributeStringCoercion(hrefInput, "href");
        return ("" + hrefInput).replace(
          regexForHrefInLinkHeaderURLContext,
          escapeHrefForLinkHeaderURLContextReplacer
        );
      }
      function escapeHrefForLinkHeaderURLContextReplacer(match) {
        switch (match) {
          case "<":
            return "%3C";
          case ">":
            return "%3E";
          case "\n":
            return "%0A";
          case "\r":
            return "%0D";
          default:
            throw Error(
              "escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
      function escapeStringForLinkHeaderQuotedParamValueContext(value, name2) {
        willCoercionThrow(value) && (console.error(
          "The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.",
          name2,
          typeName(value)
        ), testStringCoercion(value));
        return ("" + value).replace(
          regexForLinkHeaderQuotedParamValueContext,
          escapeStringForLinkHeaderQuotedParamValueContextReplacer
        );
      }
      function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {
        switch (match) {
          case '"':
            return "%22";
          case "'":
            return "%27";
          case ";":
            return "%3B";
          case ",":
            return "%2C";
          case "\n":
            return "%0A";
          case "\r":
            return "%0D";
          default:
            throw Error(
              "escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
      function hoistStyleQueueDependency(styleQueue) {
        this.styles.add(styleQueue);
      }
      function hoistStylesheetDependency(stylesheet) {
        this.stylesheets.add(stylesheet);
      }
      function createRenderState(resumableState, generateStaticMarkup) {
        var idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
        void 0 !== bootstrapScriptContent && bootstrapChunks.push(
          "<script>",
          escapeEntireInlineScriptContent(bootstrapScriptContent),
          "</script>"
        );
        idPrefix = {
          placeholderPrefix: idPrefix + "P:",
          segmentPrefix: idPrefix + "S:",
          boundaryPrefix: idPrefix + "B:",
          startInlineScript: "<script>",
          preamble: createPreambleState(),
          externalRuntimeScript: null,
          bootstrapChunks,
          importMapChunks: [],
          onHeaders: void 0,
          headers: null,
          resets: {
            font: {},
            dns: {},
            connect: { default: {}, anonymous: {}, credentials: {} },
            image: {},
            style: {}
          },
          charsetChunks: [],
          viewportChunks: [],
          hoistableChunks: [],
          preconnects: /* @__PURE__ */ new Set(),
          fontPreloads: /* @__PURE__ */ new Set(),
          highImagePreloads: /* @__PURE__ */ new Set(),
          styles: /* @__PURE__ */ new Map(),
          bootstrapScripts: /* @__PURE__ */ new Set(),
          scripts: /* @__PURE__ */ new Set(),
          bulkPreloads: /* @__PURE__ */ new Set(),
          preloads: {
            images: /* @__PURE__ */ new Map(),
            stylesheets: /* @__PURE__ */ new Map(),
            scripts: /* @__PURE__ */ new Map(),
            moduleScripts: /* @__PURE__ */ new Map()
          },
          nonce: void 0,
          hoistableState: null,
          stylesToHoist: false
        };
        if (void 0 !== bootstrapScripts)
          for (bootstrapScriptContent = 0; bootstrapScriptContent < bootstrapScripts.length; bootstrapScriptContent++) {
            var scriptConfig = bootstrapScripts[bootstrapScriptContent], src, crossOrigin = void 0, integrity = void 0, props = {
              rel: "preload",
              as: "script",
              fetchPriority: "low",
              nonce: void 0
            };
            "string" === typeof scriptConfig ? props.href = src = scriptConfig : (props.href = src = scriptConfig.src, props.integrity = integrity = "string" === typeof scriptConfig.integrity ? scriptConfig.integrity : void 0, props.crossOrigin = crossOrigin = "string" === typeof scriptConfig || null == scriptConfig.crossOrigin ? void 0 : "use-credentials" === scriptConfig.crossOrigin ? "use-credentials" : "");
            preloadBootstrapScriptOrModule(resumableState, idPrefix, src, props);
            bootstrapChunks.push('<script src="', escapeTextForBrowser(src));
            "string" === typeof integrity && bootstrapChunks.push(
              '" integrity="',
              escapeTextForBrowser(integrity)
            );
            "string" === typeof crossOrigin && bootstrapChunks.push(
              '" crossorigin="',
              escapeTextForBrowser(crossOrigin)
            );
            bootstrapChunks.push('" async=""></script>');
          }
        if (void 0 !== bootstrapModules)
          for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++)
            bootstrapScriptContent = bootstrapModules[bootstrapScripts], crossOrigin = src = void 0, integrity = {
              rel: "modulepreload",
              fetchPriority: "low",
              nonce: void 0
            }, "string" === typeof bootstrapScriptContent ? integrity.href = scriptConfig = bootstrapScriptContent : (integrity.href = scriptConfig = bootstrapScriptContent.src, integrity.integrity = crossOrigin = "string" === typeof bootstrapScriptContent.integrity ? bootstrapScriptContent.integrity : void 0, integrity.crossOrigin = src = "string" === typeof bootstrapScriptContent || null == bootstrapScriptContent.crossOrigin ? void 0 : "use-credentials" === bootstrapScriptContent.crossOrigin ? "use-credentials" : ""), preloadBootstrapScriptOrModule(
              resumableState,
              idPrefix,
              scriptConfig,
              integrity
            ), bootstrapChunks.push(
              '<script type="module" src="',
              escapeTextForBrowser(scriptConfig)
            ), "string" === typeof crossOrigin && bootstrapChunks.push(
              '" integrity="',
              escapeTextForBrowser(crossOrigin)
            ), "string" === typeof src && bootstrapChunks.push(
              '" crossorigin="',
              escapeTextForBrowser(src)
            ), bootstrapChunks.push('" async=""></script>');
        return {
          placeholderPrefix: idPrefix.placeholderPrefix,
          segmentPrefix: idPrefix.segmentPrefix,
          boundaryPrefix: idPrefix.boundaryPrefix,
          startInlineScript: idPrefix.startInlineScript,
          preamble: idPrefix.preamble,
          externalRuntimeScript: idPrefix.externalRuntimeScript,
          bootstrapChunks: idPrefix.bootstrapChunks,
          importMapChunks: idPrefix.importMapChunks,
          onHeaders: idPrefix.onHeaders,
          headers: idPrefix.headers,
          resets: idPrefix.resets,
          charsetChunks: idPrefix.charsetChunks,
          viewportChunks: idPrefix.viewportChunks,
          hoistableChunks: idPrefix.hoistableChunks,
          preconnects: idPrefix.preconnects,
          fontPreloads: idPrefix.fontPreloads,
          highImagePreloads: idPrefix.highImagePreloads,
          styles: idPrefix.styles,
          bootstrapScripts: idPrefix.bootstrapScripts,
          scripts: idPrefix.scripts,
          bulkPreloads: idPrefix.bulkPreloads,
          preloads: idPrefix.preloads,
          stylesToHoist: idPrefix.stylesToHoist,
          generateStaticMarkup
        };
      }
      function pushTextInstance(target, text, renderState, textEmbedded) {
        if (renderState.generateStaticMarkup)
          return target.push(escapeTextForBrowser(text)), false;
        "" === text ? target = textEmbedded : (textEmbedded && target.push("<!-- -->"), target.push(escapeTextForBrowser(text)), target = true);
        return target;
      }
      function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {
        renderState.generateStaticMarkup || lastPushedText && textEmbedded && target.push("<!-- -->");
      }
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev !== next) {
          prev.context._currentValue2 = prev.parentValue;
          prev = prev.parent;
          var parentNext = next.parent;
          if (null === prev) {
            if (null !== parentNext)
              throw Error(
                "The stacks must reach the root at the same time. This is a bug in React."
              );
          } else {
            if (null === parentNext)
              throw Error(
                "The stacks must reach the root at the same time. This is a bug in React."
              );
            popToNearestCommonAncestor(prev, parentNext);
          }
          next.context._currentValue2 = next.value;
        }
      }
      function popAllPrevious(prev) {
        prev.context._currentValue2 = prev.parentValue;
        prev = prev.parent;
        null !== prev && popAllPrevious(prev);
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        null !== parentNext && pushAllNext(parentNext);
        next.context._currentValue2 = next.value;
      }
      function popPreviousToCommonLevel(prev, next) {
        prev.context._currentValue2 = prev.parentValue;
        prev = prev.parent;
        if (null === prev)
          throw Error(
            "The depth must equal at least at zero before reaching the root. This is a bug in React."
          );
        prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (null === parentNext)
          throw Error(
            "The depth must equal at least at zero before reaching the root. This is a bug in React."
          );
        prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
        next.context._currentValue2 = next.value;
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
      }
      function warnOnInvalidCallback(callback) {
        if (null !== callback && "function" !== typeof callback) {
          var key = String(callback);
          didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ));
        }
      }
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType(publicInstance) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnAboutNoopUpdateForComponent[warningKey] || (console.error(
          "Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.",
          callerName,
          publicInstance
        ), didWarnAboutNoopUpdateForComponent[warningKey] = true);
      }
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        baseContext = baseContext.overflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          return {
            id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
            overflow: length + baseContext
          };
        }
        return {
          id: 1 << length | index << baseLength | baseIdWithLeadingBit,
          overflow: baseContext
        };
      }
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
      }
      function noop$2() {
      }
      function trackUsedThenable(thenableState2, thenable, index) {
        index = thenableState2[index];
        void 0 === index ? thenableState2.push(thenable) : index !== thenable && (thenable.then(noop$2, noop$2), thenable = index);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            "string" === typeof thenable.status ? thenable.then(noop$2, noop$2) : (thenableState2 = thenable, thenableState2.status = "pending", thenableState2.then(
              function(fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function(error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            ));
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      function getSuspendedThenable() {
        if (null === suspendedThenable)
          throw Error(
            "Expected a suspended thenable. This is a bug in React. Please file an issue."
          );
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function is3(x, y2) {
        return x === y2 && (0 !== x || 1 / x === 1 / y2) || x !== x && y2 !== y2;
      }
      function resolveCurrentlyRenderingComponent() {
        if (null === currentlyRenderingComponent)
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        isInHookUserCodeInDev && console.error(
          "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
        );
        return currentlyRenderingComponent;
      }
      function createHook() {
        if (0 < numberOfReRenders)
          throw Error("Rendered more hooks than during the previous render");
        return { memoizedState: null, queue: null, next: null };
      }
      function createWorkInProgressHook() {
        null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
        return workInProgressHook;
      }
      function getThenableStateAfterSuspending() {
        var state = thenableState;
        thenableState = null;
        return state;
      }
      function resetHooksState() {
        isInHookUserCodeInDev = false;
        currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        workInProgressHook = renderPhaseUpdates = null;
      }
      function readContext(context) {
        isInHookUserCodeInDev && console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
        return context._currentValue2;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function useReducer(reducer, initialArg, init) {
        reducer !== basicStateReducer && (currentHookNameInDev = "useReducer");
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          init = workInProgressHook.queue;
          initialArg = init.dispatch;
          if (null !== renderPhaseUpdates) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);
            if (void 0 !== firstRenderPhaseUpdate) {
              renderPhaseUpdates.delete(init);
              init = workInProgressHook.memoizedState;
              do {
                var action = firstRenderPhaseUpdate.action;
                isInHookUserCodeInDev = true;
                init = reducer(init, action);
                isInHookUserCodeInDev = false;
                firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
              } while (null !== firstRenderPhaseUpdate);
              workInProgressHook.memoizedState = init;
              return [init, initialArg];
            }
          }
          return [workInProgressHook.memoizedState, initialArg];
        }
        isInHookUserCodeInDev = true;
        reducer = reducer === basicStateReducer ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init ? init(initialArg) : initialArg;
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = reducer;
        reducer = workInProgressHook.queue = { last: null, dispatch: null };
        reducer = reducer.dispatch = dispatchAction.bind(
          null,
          currentlyRenderingComponent,
          reducer
        );
        return [workInProgressHook.memoizedState, reducer];
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        if (null !== workInProgressHook) {
          var prevState = workInProgressHook.memoizedState;
          if (null !== prevState && null !== deps) {
            a: {
              var JSCompiler_inline_result = prevState[1];
              if (null === JSCompiler_inline_result)
                console.error(
                  "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
                  currentHookNameInDev
                ), JSCompiler_inline_result = false;
              else {
                deps.length !== JSCompiler_inline_result.length && console.error(
                  "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
                  currentHookNameInDev,
                  "[" + deps.join(", ") + "]",
                  "[" + JSCompiler_inline_result.join(", ") + "]"
                );
                for (var i = 0; i < JSCompiler_inline_result.length && i < deps.length; i++)
                  if (!objectIs(deps[i], JSCompiler_inline_result[i])) {
                    JSCompiler_inline_result = false;
                    break a;
                  }
                JSCompiler_inline_result = true;
              }
            }
            if (JSCompiler_inline_result) return prevState[0];
          }
        }
        isInHookUserCodeInDev = true;
        nextCreate = nextCreate();
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = [nextCreate, deps];
        return nextCreate;
      }
      function dispatchAction(componentIdentity, queue, action) {
        if (25 <= numberOfReRenders)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        if (componentIdentity === currentlyRenderingComponent)
          if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)
            renderPhaseUpdates.set(queue, componentIdentity);
          else {
            for (queue = action; null !== queue.next; ) queue = queue.next;
            queue.next = componentIdentity;
          }
      }
      function unsupportedStartTransition() {
        throw Error("startTransition cannot be called during server rendering.");
      }
      function unsupportedSetOptimisticState() {
        throw Error("Cannot update optimistic state while rendering.");
      }
      function useActionState(action, initialState, permalink) {
        resolveCurrentlyRenderingComponent();
        var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
        if ("function" === typeof action.$$FORM_ACTION) {
          var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
          request = request.formState;
          var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
          if (null !== request && "function" === typeof isSignatureEqual) {
            var postbackKey = request[1];
            isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
              JSON.stringify([
                componentKeyPath,
                null,
                actionStateHookIndex
              ]),
              0
            ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
          }
          var boundAction = action.bind(null, initialState);
          action = function(payload) {
            boundAction(payload);
          };
          "function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix2) {
            prefix2 = boundAction.$$FORM_ACTION(prefix2);
            void 0 !== permalink && (checkAttributeStringCoercion(permalink, "target"), permalink += "", prefix2.action = permalink);
            var formData = prefix2.data;
            formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
              JSON.stringify([
                componentKeyPath,
                null,
                actionStateHookIndex
              ]),
              0
            )), formData.append("$ACTION_KEY", nextPostbackStateKey));
            return prefix2;
          });
          return [initialState, action, false];
        }
        var _boundAction = action.bind(null, initialState);
        return [
          initialState,
          function(payload) {
            _boundAction(payload);
          },
          false
        ];
      }
      function unwrapThenable(thenable) {
        var index = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        return trackUsedThenable(thenableState, thenable, index);
      }
      function unsupportedRefresh() {
        throw Error("Cache cannot be refreshed during server rendering.");
      }
      function noop$1() {
      }
      function disabledLog() {
      }
      function disableLogs() {
        if (0 === disabledDepth) {
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd;
          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          };
          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
        }
        disabledDepth++;
      }
      function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
          var props = { configurable: true, enumerable: true, writable: true };
          Object.defineProperties(console, {
            log: assign({}, props, { value: prevLog }),
            info: assign({}, props, { value: prevInfo }),
            warn: assign({}, props, { value: prevWarn }),
            error: assign({}, props, { value: prevError }),
            group: assign({}, props, { value: prevGroup }),
            groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
            groupEnd: assign({}, props, { value: prevGroupEnd })
          });
        }
        0 > disabledDepth && console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
      }
      function describeBuiltInComponentFrame(name2) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name2 + suffix;
      }
      function describeNativeComponentFrame(fn4, construct) {
        if (!fn4 || reentry) return "";
        var frame = componentFrameCache.get(fn4);
        if (void 0 !== frame) return frame;
        reentry = true;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher2 = null;
        previousDispatcher2 = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn4, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$0) {
                      control = x$0;
                    }
                    fn4.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$1) {
                    control = x$1;
                  }
                  (Fake = fn4()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            ); )
              _RunInRootFrame$Deter++;
            if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
              for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                _RunInRootFrame$Deter--;
            for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
              if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                  do
                    if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                      var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                      fn4.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn4.displayName));
                      "function" === typeof fn4 && componentFrameCache.set(fn4, _frame);
                      return _frame;
                    }
                  while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                }
                break;
              }
          }
        } finally {
          reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn4 ? fn4.displayName || fn4.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn4 && componentFrameCache.set(fn4, sampleLines);
        return sampleLines;
      }
      function formatOwnerStack(error) {
        var prevPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        error = error.stack;
        Error.prepareStackTrace = prevPrepareStackTrace;
        error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
        prevPrepareStackTrace = error.indexOf("\n");
        -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
        prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
        -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
          "\n",
          prevPrepareStackTrace
        ));
        if (-1 !== prevPrepareStackTrace)
          error = error.slice(0, prevPrepareStackTrace);
        else return "";
        return error;
      }
      function describeComponentStackByType(type) {
        if ("string" === typeof type) return describeBuiltInComponentFrame(type);
        if ("function" === typeof type)
          return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame(type, true) : describeNativeComponentFrame(type, false);
        if ("object" === typeof type && null !== type) {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeNativeComponentFrame(type.render, false);
            case REACT_MEMO_TYPE:
              return describeNativeComponentFrame(type.type, false);
            case REACT_LAZY_TYPE:
              var lazyComponent = type, payload = lazyComponent._payload;
              lazyComponent = lazyComponent._init;
              try {
                type = lazyComponent(payload);
              } catch (x) {
                return describeBuiltInComponentFrame("Lazy");
              }
              return describeComponentStackByType(type);
          }
          if ("string" === typeof type.name)
            return payload = type.env, describeBuiltInComponentFrame(
              type.name + (payload ? " [" + payload + "]" : "")
            );
        }
        switch (type) {
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
        }
        return "";
      }
      function defaultErrorHandler(error) {
        if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
          var JSCompiler_inline_result = error.environmentName;
          error = [error].slice(0);
          "string" === typeof error[0] ? error.splice(
            0,
            1,
            "[%s] " + error[0],
            " " + JSCompiler_inline_result + " "
          ) : error.splice(0, 0, "[%s] ", " " + JSCompiler_inline_result + " ");
          error.unshift(console);
          JSCompiler_inline_result = bind.apply(console.error, error);
          JSCompiler_inline_result();
        } else console.error(error);
        return null;
      }
      function noop() {
      }
      function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
        var abortSet = /* @__PURE__ */ new Set();
        this.destination = null;
        this.flushScheduled = false;
        this.resumableState = resumableState;
        this.renderState = renderState;
        this.rootFormatContext = rootFormatContext;
        this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
        this.status = 10;
        this.fatalError = null;
        this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
        this.completedPreambleSegments = this.completedRootSegment = null;
        this.abortableTasks = abortSet;
        this.pingedTasks = [];
        this.clientRenderedBoundaries = [];
        this.completedBoundaries = [];
        this.partialBoundaries = [];
        this.trackedPostpones = null;
        this.onError = void 0 === onError2 ? defaultErrorHandler : onError2;
        this.onPostpone = void 0 === onPostpone ? noop : onPostpone;
        this.onAllReady = void 0 === onAllReady ? noop : onAllReady;
        this.onShellReady = void 0 === onShellReady ? noop : onShellReady;
        this.onShellError = void 0 === onShellError ? noop : onShellError;
        this.onFatalError = void 0 === onFatalError ? noop : onFatalError;
        this.formState = void 0 === formState ? null : formState;
        this.didWarnForKey = null;
      }
      function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
        var now = getCurrentTime();
        1e3 < now - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = now);
        resumableState = new RequestInstance(
          resumableState,
          renderState,
          rootFormatContext,
          progressiveChunkSize,
          onError2,
          onAllReady,
          onShellReady,
          onShellError,
          onFatalError,
          onPostpone,
          formState
        );
        renderState = createPendingSegment(
          resumableState,
          0,
          null,
          rootFormatContext,
          false,
          false
        );
        renderState.parentFlushed = true;
        children = createRenderTask(
          resumableState,
          null,
          children,
          -1,
          null,
          renderState,
          null,
          null,
          resumableState.abortableTasks,
          null,
          rootFormatContext,
          null,
          emptyTreeContext,
          null,
          false,
          emptyContextObject,
          null
        );
        pushComponentStack(children);
        resumableState.pingedTasks.push(children);
        return resumableState;
      }
      function pingTask(request, task) {
        request.pingedTasks.push(task);
        1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, performWork(request));
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
        return {
          status: PENDING,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null,
          contentState: createHoistableState(),
          fallbackState: createHoistableState(),
          contentPreamble,
          fallbackPreamble,
          trackedContentKeyPath: null,
          trackedFallbackNode: null,
          errorMessage: null,
          errorStack: null,
          errorComponentStack: null
        };
      }
      function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
        request.allPendingTasks++;
        null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        var task = {
          replay: null,
          node,
          childIndex,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          blockedPreamble,
          hoistableState,
          abortSet,
          keyPath,
          formatContext,
          context,
          treeContext,
          componentStack,
          thenableState: thenableState2,
          isFallback
        };
        task.debugTask = debugTask;
        abortSet.add(task);
        return task;
      }
      function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
        request.allPendingTasks++;
        null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        replay.pendingTasks++;
        var task = {
          replay,
          node,
          childIndex,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment: null,
          blockedPreamble: null,
          hoistableState,
          abortSet,
          keyPath,
          formatContext,
          context,
          treeContext,
          componentStack,
          thenableState: thenableState2,
          isFallback
        };
        task.debugTask = debugTask;
        abortSet.add(task);
        return task;
      }
      function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          parentFlushed: false,
          id: -1,
          index,
          chunks: [],
          children: [],
          preambleChildren: [],
          parentFormatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      function getCurrentStackInDEV() {
        if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
          return "";
        var componentStack = currentTaskInDEV.componentStack;
        try {
          var info = "";
          if ("string" === typeof componentStack.type)
            info += describeBuiltInComponentFrame(componentStack.type);
          else if ("function" === typeof componentStack.type) {
            if (!componentStack.owner) {
              var JSCompiler_temp_const = info, fn4 = componentStack.type, name2 = fn4 ? fn4.displayName || fn4.name : "";
              var JSCompiler_inline_result = name2 ? describeBuiltInComponentFrame(name2) : "";
              info = JSCompiler_temp_const + JSCompiler_inline_result;
            }
          } else
            componentStack.owner || (info += describeComponentStackByType(componentStack.type));
          for (; componentStack; )
            JSCompiler_temp_const = null, null != componentStack.debugStack ? JSCompiler_temp_const = formatOwnerStack(
              componentStack.debugStack
            ) : (JSCompiler_inline_result = componentStack, null != JSCompiler_inline_result.stack && (JSCompiler_temp_const = "string" !== typeof JSCompiler_inline_result.stack ? JSCompiler_inline_result.stack = formatOwnerStack(
              JSCompiler_inline_result.stack
            ) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += "\n" + JSCompiler_temp_const);
          var JSCompiler_inline_result$jscomp$0 = info;
        } catch (x) {
          JSCompiler_inline_result$jscomp$0 = "\nError generating stack: " + x.message + "\n" + x.stack;
        }
        return JSCompiler_inline_result$jscomp$0;
      }
      function pushServerComponentStack(task, debugInfo) {
        if (null != debugInfo)
          for (var i = 0; i < debugInfo.length; i++) {
            var componentInfo = debugInfo[i];
            "string" === typeof componentInfo.name && void 0 !== componentInfo.debugStack && (task.componentStack = {
              parent: task.componentStack,
              type: componentInfo,
              owner: componentInfo.owner,
              stack: componentInfo.debugStack
            }, task.debugTask = componentInfo.debugTask);
          }
      }
      function pushComponentStack(task) {
        var node = task.node;
        if ("object" === typeof node && null !== node)
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = node.type, owner = node._owner, stack = node._debugStack;
              pushServerComponentStack(task, node._debugInfo);
              task.debugTask = node._debugTask;
              task.componentStack = {
                parent: task.componentStack,
                type,
                owner,
                stack
              };
              break;
            case REACT_LAZY_TYPE:
              pushServerComponentStack(task, node._debugInfo);
              break;
            default:
              "function" === typeof node.then && pushServerComponentStack(task, node._debugInfo);
          }
      }
      function getThrownInfo(node$jscomp$0) {
        var errorInfo = {};
        node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
          configurable: true,
          enumerable: true,
          get: function() {
            try {
              var info = "", node = node$jscomp$0;
              do
                info += describeComponentStackByType(node.type), node = node.parent;
              while (node);
              var stack = info;
            } catch (x) {
              stack = "\nError generating stack: " + x.message + "\n" + x.stack;
            }
            Object.defineProperty(errorInfo, "componentStack", {
              value: stack
            });
            return stack;
          }
        });
        return errorInfo;
      }
      function encodeErrorForBoundary(boundary, digest, error, thrownInfo, wasAborted) {
        boundary.errorDigest = digest;
        error instanceof Error ? (digest = String(error.message), error = String(error.stack)) : (digest = "object" === typeof error && null !== error ? describeObjectForErrorMessage(error) : String(error), error = null);
        wasAborted = wasAborted ? "Switched to client rendering because the server rendering aborted due to:\n\n" : "Switched to client rendering because the server rendering errored:\n\n";
        boundary.errorMessage = wasAborted + digest;
        boundary.errorStack = null !== error ? wasAborted + error : null;
        boundary.errorComponentStack = thrownInfo.componentStack;
      }
      function logRecoverableError(request, error, errorInfo, debugTask) {
        request = request.onError;
        error = debugTask ? debugTask.run(request.bind(null, error, errorInfo)) : request(error, errorInfo);
        if (null != error && "string" !== typeof error)
          console.error(
            'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
            typeof error
          );
        else return error;
      }
      function fatalError(request, error, errorInfo, debugTask) {
        errorInfo = request.onShellError;
        var onFatalError = request.onFatalError;
        debugTask ? (debugTask.run(errorInfo.bind(null, error)), debugTask.run(onFatalError.bind(null, error))) : (errorInfo(error), onFatalError(error));
        null !== request.destination ? (request.status = CLOSED, request.destination.destroy(error)) : (request.status = 13, request.fatalError = error);
      }
      function renderWithHooks(request, task, keyPath, Component, props, secondArg) {
        var prevThenableState = task.thenableState;
        task.thenableState = null;
        currentlyRenderingComponent = {};
        currentlyRenderingTask = task;
        currentlyRenderingRequest = request;
        currentlyRenderingKeyPath = keyPath;
        isInHookUserCodeInDev = false;
        actionStateCounter = localIdCounter = 0;
        actionStateMatchingIndex = -1;
        thenableIndexCounter = 0;
        thenableState = prevThenableState;
        for (request = callComponentInDEV(Component, props, secondArg); didScheduleRenderPhaseUpdate; )
          didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);
        resetHooksState();
        return request;
      }
      function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
        var didEmitActionStateMarkers = false;
        if (0 !== actionStateCount && null !== request.formState) {
          var segment = task.blockedSegment;
          if (null !== segment) {
            didEmitActionStateMarkers = true;
            segment = segment.chunks;
            for (var i = 0; i < actionStateCount; i++)
              i === actionStateMatchingIndex2 ? segment.push("<!--F!-->") : segment.push("<!--F-->");
          }
        }
        actionStateCount = task.keyPath;
        task.keyPath = keyPath;
        hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode2(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode2(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
        task.keyPath = actionStateCount;
      }
      function renderElement(request, task, keyPath, type, props, ref) {
        if ("function" === typeof type)
          if (type.prototype && type.prototype.isReactComponent) {
            var newProps = props;
            if ("ref" in props) {
              newProps = {};
              for (var propName in props)
                "ref" !== propName && (newProps[propName] = props[propName]);
            }
            var defaultProps = type.defaultProps;
            if (defaultProps) {
              newProps === props && (newProps = assign({}, newProps, props));
              for (var _propName in defaultProps)
                void 0 === newProps[_propName] && (newProps[_propName] = defaultProps[_propName]);
            }
            var resolvedProps = newProps;
            var context = emptyContextObject, contextType = type.contextType;
            if ("contextType" in type && null !== contextType && (void 0 === contextType || contextType.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(type)) {
              didWarnAboutInvalidateContextType.add(type);
              var addendum = void 0 === contextType ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof contextType ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              console.error(
                "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
                getComponentNameFromType(type) || "Component",
                addendum
              );
            }
            "object" === typeof contextType && null !== contextType && (context = contextType._currentValue2);
            var instance = new type(resolvedProps, context);
            if ("function" === typeof type.getDerivedStateFromProps && (null === instance.state || void 0 === instance.state)) {
              var componentName = getComponentNameFromType(type) || "Component";
              didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), console.error(
                "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
                componentName,
                null === instance.state ? "null" : "undefined",
                componentName
              ));
            }
            if ("function" === typeof type.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate) {
              var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
              "function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning ? foundWillMountName = "componentWillMount" : "function" === typeof instance.UNSAFE_componentWillMount && (foundWillMountName = "UNSAFE_componentWillMount");
              "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning ? foundWillReceivePropsName = "componentWillReceiveProps" : "function" === typeof instance.UNSAFE_componentWillReceiveProps && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
              "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== foundWillMountName || null !== foundWillReceivePropsName || null !== foundWillUpdateName) {
                var _componentName = getComponentNameFromType(type) || "Component", newApiName = "function" === typeof type.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(
                  _componentName
                ), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _componentName,
                  newApiName,
                  null !== foundWillMountName ? "\n  " + foundWillMountName : "",
                  null !== foundWillReceivePropsName ? "\n  " + foundWillReceivePropsName : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            var name2 = getComponentNameFromType(type) || "Component";
            instance.render || (type.prototype && "function" === typeof type.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              name2
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              name2
            ));
            !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              name2
            );
            instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              name2
            );
            instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              name2
            );
            type.childContextTypes && !didWarnAboutChildContextTypes.has(type) && (didWarnAboutChildContextTypes.add(type), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              name2
            ));
            type.contextTypes && !didWarnAboutContextTypes$1.has(type) && (didWarnAboutContextTypes$1.add(type), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              name2
            ));
            "function" === typeof instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              name2
            );
            type.prototype && type.prototype.isPureReactComponent && "undefined" !== typeof instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(type) || "A pure component"
            );
            "function" === typeof instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              name2
            );
            "function" === typeof instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              name2
            );
            "function" === typeof instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              name2
            );
            "function" === typeof instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              name2
            );
            var hasMutatedProps = instance.props !== resolvedProps;
            void 0 !== instance.props && hasMutatedProps && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              name2
            );
            instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              name2,
              name2
            );
            "function" !== typeof instance.getSnapshotBeforeUpdate || "function" === typeof instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(type)
            ));
            "function" === typeof instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              name2
            );
            "function" === typeof instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              name2
            );
            "function" === typeof type.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              name2
            );
            var state = instance.state;
            state && ("object" !== typeof state || isArrayImpl(state)) && console.error("%s.state: must be set to an object or null", name2);
            "function" === typeof instance.getChildContext && "object" !== typeof type.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              name2
            );
            var initialState = void 0 !== instance.state ? instance.state : null;
            instance.updater = classComponentUpdater;
            instance.props = resolvedProps;
            instance.state = initialState;
            var internalInstance = { queue: [], replace: false };
            instance._reactInternals = internalInstance;
            var contextType$jscomp$0 = type.contextType;
            instance.context = "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 ? contextType$jscomp$0._currentValue2 : emptyContextObject;
            if (instance.state === resolvedProps) {
              var componentName$jscomp$0 = getComponentNameFromType(type) || "Component";
              didWarnAboutDirectlyAssigningPropsToState.has(
                componentName$jscomp$0
              ) || (didWarnAboutDirectlyAssigningPropsToState.add(
                componentName$jscomp$0
              ), console.error(
                "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
                componentName$jscomp$0
              ));
            }
            var getDerivedStateFromProps = type.getDerivedStateFromProps;
            if ("function" === typeof getDerivedStateFromProps) {
              var partialState = getDerivedStateFromProps(
                resolvedProps,
                initialState
              );
              if (void 0 === partialState) {
                var componentName$jscomp$1 = getComponentNameFromType(type) || "Component";
                didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1), console.error(
                  "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
                  componentName$jscomp$1
                ));
              }
              var JSCompiler_inline_result = null === partialState || void 0 === partialState ? initialState : assign({}, initialState, partialState);
              instance.state = JSCompiler_inline_result;
            }
            if ("function" !== typeof type.getDerivedStateFromProps && "function" !== typeof instance.getSnapshotBeforeUpdate && ("function" === typeof instance.UNSAFE_componentWillMount || "function" === typeof instance.componentWillMount)) {
              var oldState = instance.state;
              if ("function" === typeof instance.componentWillMount) {
                if (true !== instance.componentWillMount.__suppressDeprecationWarning) {
                  var componentName$jscomp$2 = getComponentNameFromType(type) || "Unknown";
                  didWarnAboutDeprecatedWillMount[componentName$jscomp$2] || (console.warn(
                    "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName$jscomp$2
                  ), didWarnAboutDeprecatedWillMount[componentName$jscomp$2] = true);
                }
                instance.componentWillMount();
              }
              "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount();
              oldState !== instance.state && (console.error(
                "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
                getComponentNameFromType(type) || "Component"
              ), classComponentUpdater.enqueueReplaceState(
                instance,
                instance.state,
                null
              ));
              if (null !== internalInstance.queue && 0 < internalInstance.queue.length) {
                var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
                internalInstance.queue = null;
                internalInstance.replace = false;
                if (oldReplace && 1 === oldQueue.length)
                  instance.state = oldQueue[0];
                else {
                  for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = true, i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                    var partial = oldQueue[i], partialState$jscomp$0 = "function" === typeof partial ? partial.call(
                      instance,
                      nextState,
                      resolvedProps,
                      void 0
                    ) : partial;
                    null != partialState$jscomp$0 && (dontMutate ? (dontMutate = false, nextState = assign(
                      {},
                      nextState,
                      partialState$jscomp$0
                    )) : assign(nextState, partialState$jscomp$0));
                  }
                  instance.state = nextState;
                }
              } else internalInstance.queue = null;
            }
            var nextChildren = callRenderInDEV(instance);
            if (12 === request.status) throw null;
            instance.props !== resolvedProps && (didWarnAboutReassigningProps || console.error(
              "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
              getComponentNameFromType(type) || "a component"
            ), didWarnAboutReassigningProps = true);
            var prevKeyPath = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, nextChildren, -1);
            task.keyPath = prevKeyPath;
          } else {
            if (type.prototype && "function" === typeof type.prototype.render) {
              var componentName$jscomp$3 = getComponentNameFromType(type) || "Unknown";
              didWarnAboutBadClass[componentName$jscomp$3] || (console.error(
                "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
                componentName$jscomp$3,
                componentName$jscomp$3
              ), didWarnAboutBadClass[componentName$jscomp$3] = true);
            }
            var value = renderWithHooks(
              request,
              task,
              keyPath,
              type,
              props,
              void 0
            );
            if (12 === request.status) throw null;
            var hasId = 0 !== localIdCounter, actionStateCount = actionStateCounter, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;
            if (type.contextTypes) {
              var _componentName$jscomp$0 = getComponentNameFromType(type) || "Unknown";
              didWarnAboutContextTypes[_componentName$jscomp$0] || (didWarnAboutContextTypes[_componentName$jscomp$0] = true, console.error(
                "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
                _componentName$jscomp$0
              ));
            }
            type && type.childContextTypes && console.error(
              "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
              type.displayName || type.name || "Component"
            );
            if ("function" === typeof type.getDerivedStateFromProps) {
              var _componentName2 = getComponentNameFromType(type) || "Unknown";
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] || (console.error(
                "%s: Function components do not support getDerivedStateFromProps.",
                _componentName2
              ), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true);
            }
            if ("object" === typeof type.contextType && null !== type.contextType) {
              var _componentName3 = getComponentNameFromType(type) || "Unknown";
              didWarnAboutContextTypeOnFunctionComponent[_componentName3] || (console.error(
                "%s: Function components do not support contextType.",
                _componentName3
              ), didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true);
            }
            finishFunctionComponent(
              request,
              task,
              keyPath,
              value,
              hasId,
              actionStateCount,
              actionStateMatchingIndex$jscomp$0
            );
          }
        else if ("string" === typeof type) {
          var segment = task.blockedSegment;
          if (null === segment) {
            var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
            task.formatContext = getChildFormatContext(prevContext, type, props);
            task.keyPath = keyPath;
            renderNode2(request, task, children, -1);
            task.formatContext = prevContext;
            task.keyPath = prevKeyPath$jscomp$0;
          } else {
            var _children = pushStartInstance(
              segment.chunks,
              type,
              props,
              request.resumableState,
              request.renderState,
              task.blockedPreamble,
              task.hoistableState,
              task.formatContext,
              segment.lastPushedText,
              task.isFallback
            );
            segment.lastPushedText = false;
            var _prevContext = task.formatContext, _prevKeyPath2 = task.keyPath;
            task.keyPath = keyPath;
            if ((task.formatContext = getChildFormatContext(
              _prevContext,
              type,
              props
            )).insertionMode === HTML_HEAD_MODE) {
              var preambleSegment = createPendingSegment(
                request,
                0,
                null,
                task.formatContext,
                false,
                false
              );
              segment.preambleChildren.push(preambleSegment);
              var preambleTask = createRenderTask(
                request,
                null,
                _children,
                -1,
                task.blockedBoundary,
                preambleSegment,
                task.blockedPreamble,
                task.hoistableState,
                request.abortableTasks,
                task.keyPath,
                task.formatContext,
                task.context,
                task.treeContext,
                task.componentStack,
                task.isFallback,
                emptyContextObject,
                task.debugTask
              );
              pushComponentStack(preambleTask);
              request.pingedTasks.push(preambleTask);
            } else renderNode2(request, task, _children, -1);
            task.formatContext = _prevContext;
            task.keyPath = _prevKeyPath2;
            a: {
              var target = segment.chunks, resumableState = request.resumableState;
              switch (type) {
                case "title":
                case "style":
                case "script":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "img":
                case "input":
                case "keygen":
                case "link":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                  break a;
                case "body":
                  if (_prevContext.insertionMode <= HTML_HTML_MODE) {
                    resumableState.hasBody = true;
                    break a;
                  }
                  break;
                case "html":
                  if (_prevContext.insertionMode === ROOT_HTML_MODE) {
                    resumableState.hasHtml = true;
                    break a;
                  }
                  break;
                case "head":
                  if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;
              }
              target.push(endChunkForTag(type));
            }
            segment.lastPushedText = false;
          }
        } else {
          switch (type) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE:
              var prevKeyPath$jscomp$1 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, props.children, -1);
              task.keyPath = prevKeyPath$jscomp$1;
              return;
            case REACT_ACTIVITY_TYPE:
              if ("hidden" !== props.mode) {
                var prevKeyPath$jscomp$2 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, props.children, -1);
                task.keyPath = prevKeyPath$jscomp$2;
              }
              return;
            case REACT_SUSPENSE_LIST_TYPE:
              var _prevKeyPath3 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, props.children, -1);
              task.keyPath = _prevKeyPath3;
              return;
            case REACT_VIEW_TRANSITION_TYPE:
            case REACT_SCOPE_TYPE:
              throw Error(
                "ReactDOMServer does not yet support scope components."
              );
            case REACT_SUSPENSE_TYPE:
              a: if (null !== task.replay) {
                var _prevKeyPath = task.keyPath;
                task.keyPath = keyPath;
                var _content = props.children;
                try {
                  renderNode2(request, task, _content, -1);
                } finally {
                  task.keyPath = _prevKeyPath;
                }
              } else {
                var prevKeyPath$jscomp$3 = task.keyPath, parentBoundary = task.blockedBoundary, parentPreamble = task.blockedPreamble, parentHoistableState = task.hoistableState, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set();
                var newBoundary = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  createPreambleState(),
                  createPreambleState()
                ) : createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  null,
                  null
                );
                null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
                var boundarySegment = createPendingSegment(
                  request,
                  parentSegment.chunks.length,
                  newBoundary,
                  task.formatContext,
                  false,
                  false
                );
                parentSegment.children.push(boundarySegment);
                parentSegment.lastPushedText = false;
                var contentRootSegment = createPendingSegment(
                  request,
                  0,
                  null,
                  task.formatContext,
                  false,
                  false
                );
                contentRootSegment.parentFlushed = true;
                if (null !== request.trackedPostpones) {
                  var fallbackKeyPath = [
                    keyPath[0],
                    "Suspense Fallback",
                    keyPath[2]
                  ], fallbackReplayNode = [
                    fallbackKeyPath[1],
                    fallbackKeyPath[2],
                    [],
                    null
                  ];
                  request.trackedPostpones.workingMap.set(
                    fallbackKeyPath,
                    fallbackReplayNode
                  );
                  newBoundary.trackedFallbackNode = fallbackReplayNode;
                  task.blockedSegment = boundarySegment;
                  task.blockedPreamble = newBoundary.fallbackPreamble;
                  task.keyPath = fallbackKeyPath;
                  boundarySegment.status = 6;
                  try {
                    renderNode2(request, task, fallback, -1), pushSegmentFinale(
                      boundarySegment.chunks,
                      request.renderState,
                      boundarySegment.lastPushedText,
                      boundarySegment.textEmbedded
                    ), boundarySegment.status = COMPLETED;
                  } catch (thrownValue) {
                    throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;
                  } finally {
                    task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$3;
                  }
                  var suspendedPrimaryTask = createRenderTask(
                    request,
                    null,
                    content,
                    -1,
                    newBoundary,
                    contentRootSegment,
                    newBoundary.contentPreamble,
                    newBoundary.contentState,
                    task.abortSet,
                    keyPath,
                    task.formatContext,
                    task.context,
                    task.treeContext,
                    task.componentStack,
                    task.isFallback,
                    emptyContextObject,
                    task.debugTask
                  );
                  pushComponentStack(suspendedPrimaryTask);
                  request.pingedTasks.push(suspendedPrimaryTask);
                } else {
                  task.blockedBoundary = newBoundary;
                  task.blockedPreamble = newBoundary.contentPreamble;
                  task.hoistableState = newBoundary.contentState;
                  task.blockedSegment = contentRootSegment;
                  task.keyPath = keyPath;
                  contentRootSegment.status = 6;
                  try {
                    if (renderNode2(request, task, content, -1), pushSegmentFinale(
                      contentRootSegment.chunks,
                      request.renderState,
                      contentRootSegment.lastPushedText,
                      contentRootSegment.textEmbedded
                    ), contentRootSegment.status = COMPLETED, queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && newBoundary.status === PENDING) {
                      newBoundary.status = COMPLETED;
                      0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);
                      break a;
                    }
                  } catch (thrownValue$2) {
                    newBoundary.status = CLIENT_RENDERED;
                    if (12 === request.status) {
                      contentRootSegment.status = 3;
                      var error = request.fatalError;
                    } else
                      contentRootSegment.status = 4, error = thrownValue$2;
                    var thrownInfo = getThrownInfo(task.componentStack);
                    var errorDigest = logRecoverableError(
                      request,
                      error,
                      thrownInfo,
                      task.debugTask
                    );
                    encodeErrorForBoundary(
                      newBoundary,
                      errorDigest,
                      error,
                      thrownInfo,
                      false
                    );
                    untrackBoundary(request, newBoundary);
                  } finally {
                    task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$3;
                  }
                  var suspendedFallbackTask = createRenderTask(
                    request,
                    null,
                    fallback,
                    -1,
                    parentBoundary,
                    boundarySegment,
                    newBoundary.fallbackPreamble,
                    newBoundary.fallbackState,
                    fallbackAbortSet,
                    [keyPath[0], "Suspense Fallback", keyPath[2]],
                    task.formatContext,
                    task.context,
                    task.treeContext,
                    task.componentStack,
                    true,
                    emptyContextObject,
                    task.debugTask
                  );
                  pushComponentStack(suspendedFallbackTask);
                  request.pingedTasks.push(suspendedFallbackTask);
                }
              }
              return;
          }
          if ("object" === typeof type && null !== type)
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                if ("ref" in props) {
                  var propsWithoutRef = {};
                  for (var key in props)
                    "ref" !== key && (propsWithoutRef[key] = props[key]);
                } else propsWithoutRef = props;
                var children$jscomp$0 = renderWithHooks(
                  request,
                  task,
                  keyPath,
                  type.render,
                  propsWithoutRef,
                  ref
                );
                finishFunctionComponent(
                  request,
                  task,
                  keyPath,
                  children$jscomp$0,
                  0 !== localIdCounter,
                  actionStateCounter,
                  actionStateMatchingIndex
                );
                return;
              case REACT_MEMO_TYPE:
                renderElement(request, task, keyPath, type.type, props, ref);
                return;
              case REACT_PROVIDER_TYPE:
              case REACT_CONTEXT_TYPE:
                var value$jscomp$0 = props.value, children$jscomp$1 = props.children;
                var prevSnapshot = task.context;
                var prevKeyPath$jscomp$4 = task.keyPath;
                var prevValue = type._currentValue2;
                type._currentValue2 = value$jscomp$0;
                void 0 !== type._currentRenderer2 && null !== type._currentRenderer2 && type._currentRenderer2 !== rendererSigil && console.error(
                  "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                );
                type._currentRenderer2 = rendererSigil;
                var prevNode = currentActiveSnapshot, newNode = {
                  parent: prevNode,
                  depth: null === prevNode ? 0 : prevNode.depth + 1,
                  context: type,
                  parentValue: prevValue,
                  value: value$jscomp$0
                };
                currentActiveSnapshot = newNode;
                task.context = newNode;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, children$jscomp$1, -1);
                var prevSnapshot$jscomp$0 = currentActiveSnapshot;
                if (null === prevSnapshot$jscomp$0)
                  throw Error(
                    "Tried to pop a Context at the root of the app. This is a bug in React."
                  );
                prevSnapshot$jscomp$0.context !== type && console.error(
                  "The parent context is not the expected context. This is probably a bug in React."
                );
                prevSnapshot$jscomp$0.context._currentValue2 = prevSnapshot$jscomp$0.parentValue;
                void 0 !== type._currentRenderer2 && null !== type._currentRenderer2 && type._currentRenderer2 !== rendererSigil && console.error(
                  "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                );
                type._currentRenderer2 = rendererSigil;
                var JSCompiler_inline_result$jscomp$0 = currentActiveSnapshot = prevSnapshot$jscomp$0.parent;
                task.context = JSCompiler_inline_result$jscomp$0;
                task.keyPath = prevKeyPath$jscomp$4;
                prevSnapshot !== task.context && console.error(
                  "Popping the context provider did not return back to the original snapshot. This is a bug in React."
                );
                return;
              case REACT_CONSUMER_TYPE:
                var context$jscomp$0 = type._context, render3 = props.children;
                "function" !== typeof render3 && console.error(
                  "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
                );
                var newChildren = render3(context$jscomp$0._currentValue2), prevKeyPath$jscomp$5 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, newChildren, -1);
                task.keyPath = prevKeyPath$jscomp$5;
                return;
              case REACT_LAZY_TYPE:
                var Component = callLazyInitInDEV(type);
                if (12 === request.status) throw null;
                renderElement(request, task, keyPath, Component, props, ref);
                return;
            }
          var info = "";
          if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          throw Error(
            "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type ? type : typeof type) + "." + info)
          );
        }
      }
      function resumeNode(request, task, segmentId, node, childIndex) {
        var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(
          request,
          0,
          null,
          task.formatContext,
          false,
          false
        );
        resumedSegment.id = segmentId;
        resumedSegment.parentFlushed = true;
        try {
          task.replay = null, task.blockedSegment = resumedSegment, renderNode2(request, task, node, childIndex), resumedSegment.status = COMPLETED, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
        } finally {
          task.replay = prevReplay, task.blockedSegment = null;
        }
      }
      function replayElement(request, task, keyPath, name2, keyOrIndex, childIndex, type, props, ref, replay) {
        childIndex = replay.nodes;
        for (var i = 0; i < childIndex.length; i++) {
          var node = childIndex[i];
          if (keyOrIndex === node[1]) {
            if (4 === node.length) {
              if (null !== name2 && name2 !== node[0])
                throw Error(
                  "Expected the resume to render <" + node[0] + "> in this slot but instead it rendered <" + name2 + ">. The tree doesn't match so React will fallback to client rendering."
                );
              var childNodes = node[2];
              node = node[3];
              name2 = task.node;
              task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };
              try {
                renderElement(request, task, keyPath, type, props, ref);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(
                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                  );
                task.replay.pendingTasks--;
              } catch (x) {
                if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                  throw task.node === name2 && (task.replay = replay), x;
                task.replay.pendingTasks--;
                type = getThrownInfo(task.componentStack);
                props = request;
                request = task.blockedBoundary;
                keyPath = x;
                ref = node;
                node = logRecoverableError(props, keyPath, type, task.debugTask);
                abortRemainingReplayNodes(
                  props,
                  request,
                  childNodes,
                  ref,
                  keyPath,
                  node,
                  type,
                  false
                );
              }
              task.replay = replay;
            } else {
              if (type !== REACT_SUSPENSE_TYPE)
                throw Error(
                  "Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering."
                );
              a: {
                replay = void 0;
                type = node[5];
                ref = node[2];
                name2 = node[3];
                keyOrIndex = null === node[4] ? [] : node[4][2];
                node = null === node[4] ? null : node[4][3];
                var prevKeyPath = task.keyPath, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
                props = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  createPreambleState(),
                  createPreambleState()
                ) : createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  null,
                  null
                );
                props.parentFlushed = true;
                props.rootSegmentID = type;
                task.blockedBoundary = props;
                task.hoistableState = props.contentState;
                task.keyPath = keyPath;
                task.replay = { nodes: ref, slots: name2, pendingTasks: 1 };
                try {
                  renderNode2(request, task, content, -1);
                  if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                    throw Error(
                      "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                    );
                  task.replay.pendingTasks--;
                  if (0 === props.pendingTasks && props.status === PENDING) {
                    props.status = COMPLETED;
                    request.completedBoundaries.push(props);
                    break a;
                  }
                } catch (error) {
                  props.status = CLIENT_RENDERED, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(
                    request,
                    error,
                    childNodes,
                    task.debugTask
                  ), encodeErrorForBoundary(props, replay, error, childNodes, false), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
                } finally {
                  task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath;
                }
                props = createReplayTask(
                  request,
                  null,
                  { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
                  fallback,
                  -1,
                  parentBoundary,
                  props.fallbackState,
                  fallbackAbortSet,
                  [keyPath[0], "Suspense Fallback", keyPath[2]],
                  task.formatContext,
                  task.context,
                  task.treeContext,
                  task.componentStack,
                  true,
                  emptyContextObject,
                  task.debugTask
                );
                pushComponentStack(props);
                request.pingedTasks.push(props);
              }
            }
            childIndex.splice(i, 1);
            break;
          }
        }
      }
      function renderNodeDestructive(request, task, node, childIndex) {
        null !== task.replay && "number" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, childIndex = task.debugTask, pushComponentStack(task), retryNode(request, task), task.componentStack = node, task.debugTask = childIndex);
      }
      function retryNode(request, task) {
        var node = task.node, childIndex = task.childIndex;
        if (null !== node) {
          if ("object" === typeof node) {
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = node.type, key = node.key;
                node = node.props;
                var refProp = node.ref;
                refProp = void 0 !== refProp ? refProp : null;
                var debugTask = task.debugTask, name2 = getComponentNameFromType(type);
                key = null == key ? -1 === childIndex ? 0 : childIndex : key;
                var keyPath = [task.keyPath, name2, key];
                null !== task.replay ? debugTask ? debugTask.run(
                  replayElement.bind(
                    null,
                    request,
                    task,
                    keyPath,
                    name2,
                    key,
                    childIndex,
                    type,
                    node,
                    refProp,
                    task.replay
                  )
                ) : replayElement(
                  request,
                  task,
                  keyPath,
                  name2,
                  key,
                  childIndex,
                  type,
                  node,
                  refProp,
                  task.replay
                ) : debugTask ? debugTask.run(
                  renderElement.bind(
                    null,
                    request,
                    task,
                    keyPath,
                    type,
                    node,
                    refProp
                  )
                ) : renderElement(request, task, keyPath, type, node, refProp);
                return;
              case REACT_PORTAL_TYPE:
                throw Error(
                  "Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render."
                );
              case REACT_LAZY_TYPE:
                node = callLazyInitInDEV(node);
                if (12 === request.status) throw null;
                renderNodeDestructive(request, task, node, childIndex);
                return;
            }
            if (isArrayImpl(node)) {
              renderChildrenArray(request, task, node, childIndex);
              return;
            }
            null === node || "object" !== typeof node ? key = null : (type = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], key = "function" === typeof type ? type : null);
            if (key && (type = key.call(node))) {
              if (type === node) {
                if (-1 !== childIndex || null === task.componentStack || "function" !== typeof task.componentStack.type || "[object GeneratorFunction]" !== Object.prototype.toString.call(task.componentStack.type) || "[object Generator]" !== Object.prototype.toString.call(type))
                  didWarnAboutGenerators || console.error(
                    "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                  ), didWarnAboutGenerators = true;
              } else
                node.entries !== key || didWarnAboutMaps || (console.error(
                  "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                ), didWarnAboutMaps = true);
              node = type.next();
              if (!node.done) {
                key = [];
                do
                  key.push(node.value), node = type.next();
                while (!node.done);
                renderChildrenArray(request, task, key, childIndex);
              }
              return;
            }
            if ("function" === typeof node.then)
              return task.thenableState = null, renderNodeDestructive(
                request,
                task,
                unwrapThenable(node),
                childIndex
              );
            if (node.$$typeof === REACT_CONTEXT_TYPE)
              return renderNodeDestructive(
                request,
                task,
                node._currentValue2,
                childIndex
              );
            request = Object.prototype.toString.call(node);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === request ? "object with keys {" + Object.keys(node).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          "string" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
            task.chunks,
            node,
            request.renderState,
            task.lastPushedText
          ))) : "number" === typeof node || "bigint" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
            task.chunks,
            "" + node,
            request.renderState,
            task.lastPushedText
          ))) : ("function" === typeof node && (request = node.displayName || node.name || "Component", console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
            request,
            request
          )), "symbol" === typeof node && console.error(
            "Symbols are not valid as a React child.\n  %s",
            String(node)
          ));
        }
      }
      function renderChildrenArray(request, task, children, childIndex) {
        var prevKeyPath = task.keyPath, previousComponentStack = task.componentStack;
        var previousDebugTask = task.debugTask;
        pushServerComponentStack(task, task.node._debugInfo);
        if (-1 !== childIndex && (task.keyPath = [task.keyPath, "Fragment", childIndex], null !== task.replay)) {
          for (var replay = task.replay, replayNodes = replay.nodes, j3 = 0; j3 < replayNodes.length; j3++) {
            var node = replayNodes[j3];
            if (node[1] === childIndex) {
              childIndex = node[2];
              node = node[3];
              task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
              try {
                renderChildrenArray(request, task, children, -1);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(
                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                  );
                task.replay.pendingTasks--;
              } catch (x) {
                if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                  throw x;
                task.replay.pendingTasks--;
                var thrownInfo = getThrownInfo(task.componentStack);
                children = task.blockedBoundary;
                var error = x, resumeSlots = node;
                node = logRecoverableError(
                  request,
                  error,
                  thrownInfo,
                  task.debugTask
                );
                abortRemainingReplayNodes(
                  request,
                  children,
                  childIndex,
                  resumeSlots,
                  error,
                  node,
                  thrownInfo,
                  false
                );
              }
              task.replay = replay;
              replayNodes.splice(j3, 1);
              break;
            }
          }
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          return;
        }
        replay = task.treeContext;
        replayNodes = children.length;
        if (null !== task.replay && (j3 = task.replay.slots, null !== j3 && "object" === typeof j3)) {
          for (childIndex = 0; childIndex < replayNodes; childIndex++)
            node = children[childIndex], task.treeContext = pushTreeContext(
              replay,
              replayNodes,
              childIndex
            ), error = j3[childIndex], "number" === typeof error ? (resumeNode(request, task, error, node, childIndex), delete j3[childIndex]) : renderNode2(request, task, node, childIndex);
          task.treeContext = replay;
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          return;
        }
        for (j3 = 0; j3 < replayNodes; j3++) {
          childIndex = children[j3];
          resumeSlots = request;
          node = task;
          error = childIndex;
          if (null !== error && "object" === typeof error && (error.$$typeof === REACT_ELEMENT_TYPE || error.$$typeof === REACT_PORTAL_TYPE) && error._store && (!error._store.validated && null == error.key || 2 === error._store.validated)) {
            if ("object" !== typeof error._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            error._store.validated = 1;
            thrownInfo = resumeSlots.didWarnForKey;
            null == thrownInfo && (thrownInfo = resumeSlots.didWarnForKey = /* @__PURE__ */ new WeakSet());
            resumeSlots = node.componentStack;
            if (null !== resumeSlots && !thrownInfo.has(resumeSlots)) {
              thrownInfo.add(resumeSlots);
              var componentName = getComponentNameFromType(error.type);
              thrownInfo = error._owner;
              var parentOwner = resumeSlots.owner;
              resumeSlots = "";
              if (parentOwner && "undefined" !== typeof parentOwner.type) {
                var name2 = getComponentNameFromType(parentOwner.type);
                name2 && (resumeSlots = "\n\nCheck the render method of `" + name2 + "`.");
              }
              resumeSlots || componentName && (resumeSlots = "\n\nCheck the top-level render call using <" + componentName + ">.");
              componentName = "";
              null != thrownInfo && parentOwner !== thrownInfo && (parentOwner = null, "undefined" !== typeof thrownInfo.type ? parentOwner = getComponentNameFromType(thrownInfo.type) : "string" === typeof thrownInfo.name && (parentOwner = thrownInfo.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
              thrownInfo = node.componentStack;
              node.componentStack = {
                parent: node.componentStack,
                type: error.type,
                owner: error._owner,
                stack: error._debugStack
              };
              console.error(
                'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                resumeSlots,
                componentName
              );
              node.componentStack = thrownInfo;
            }
          }
          task.treeContext = pushTreeContext(replay, replayNodes, j3);
          renderNode2(request, task, childIndex, j3);
        }
        task.treeContext = replay;
        task.keyPath = prevKeyPath;
        task.componentStack = previousComponentStack;
        task.debugTask = previousDebugTask;
      }
      function untrackBoundary(request, boundary) {
        request = request.trackedPostpones;
        null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
      }
      function spawnNewSuspendedReplayTask(request, task, thenableState2) {
        return createReplayTask(
          request,
          thenableState2,
          task.replay,
          task.node,
          task.childIndex,
          task.blockedBoundary,
          task.hoistableState,
          task.abortSet,
          task.keyPath,
          task.formatContext,
          task.context,
          task.treeContext,
          task.componentStack,
          task.isFallback,
          emptyContextObject,
          task.debugTask
        );
      }
      function spawnNewSuspendedRenderTask(request, task, thenableState2) {
        var segment = task.blockedSegment, newSegment = createPendingSegment(
          request,
          segment.chunks.length,
          null,
          task.formatContext,
          segment.lastPushedText,
          true
        );
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        return createRenderTask(
          request,
          thenableState2,
          task.node,
          task.childIndex,
          task.blockedBoundary,
          newSegment,
          task.blockedPreamble,
          task.hoistableState,
          task.abortSet,
          task.keyPath,
          task.formatContext,
          task.context,
          task.treeContext,
          task.componentStack,
          task.isFallback,
          emptyContextObject,
          task.debugTask
        );
      }
      function renderNode2(request, task, node, childIndex) {
        var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, previousDebugTask = task.debugTask, segment = task.blockedSegment;
        if (null === segment)
          try {
            return renderNodeDestructive(request, task, node, childIndex);
          } catch (thrownValue) {
            if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, "object" === typeof node && null !== node) {
              if ("function" === typeof node.then) {
                childIndex = getThenableStateAfterSuspending();
                request = spawnNewSuspendedReplayTask(
                  request,
                  task,
                  childIndex
                ).ping;
                node.then(request, request);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
              if ("Maximum call stack size exceeded" === node.message) {
                node = getThenableStateAfterSuspending();
                node = spawnNewSuspendedReplayTask(request, task, node);
                request.pingedTasks.push(node);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
            }
          }
        else {
          var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
          try {
            return renderNodeDestructive(request, task, node, childIndex);
          } catch (thrownValue$3) {
            if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$3 === SuspenseException ? getSuspendedThenable() : thrownValue$3, "object" === typeof node && null !== node) {
              if ("function" === typeof node.then) {
                childIndex = getThenableStateAfterSuspending();
                request = spawnNewSuspendedRenderTask(
                  request,
                  task,
                  childIndex
                ).ping;
                node.then(request, request);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
              if ("Maximum call stack size exceeded" === node.message) {
                node = getThenableStateAfterSuspending();
                node = spawnNewSuspendedRenderTask(request, task, node);
                request.pingedTasks.push(node);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
            }
          }
        }
        task.formatContext = previousFormatContext;
        task.context = previousContext;
        task.keyPath = previousKeyPath;
        task.treeContext = previousTreeContext;
        switchContext(previousContext);
        throw node;
      }
      function abortTaskSoft(task) {
        var boundary = task.blockedBoundary;
        task = task.blockedSegment;
        null !== task && (task.status = 3, finishedTask(this, boundary, task));
      }
      function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted) {
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (4 === node.length)
            abortRemainingReplayNodes(
              request$jscomp$0,
              boundary,
              node[2],
              node[3],
              error$jscomp$0,
              errorDigest$jscomp$0,
              errorInfo$jscomp$0,
              aborted
            );
          else {
            var request = request$jscomp$0;
            node = node[5];
            var error = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted, resumedBoundary = createSuspenseBoundary(
              request,
              /* @__PURE__ */ new Set(),
              null,
              null
            );
            resumedBoundary.parentFlushed = true;
            resumedBoundary.rootSegmentID = node;
            resumedBoundary.status = CLIENT_RENDERED;
            encodeErrorForBoundary(
              resumedBoundary,
              errorDigest,
              error,
              errorInfo,
              wasAborted
            );
            resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
          }
        }
        nodes.length = 0;
        if (null !== slots) {
          if (null === boundary)
            throw Error(
              "We should not have any resumable nodes in the shell. This is a bug in React."
            );
          boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(
            boundary,
            errorDigest$jscomp$0,
            error$jscomp$0,
            errorInfo$jscomp$0,
            aborted
          ), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
          if ("object" === typeof slots)
            for (var index in slots) delete slots[index];
        }
      }
      function abortTask(task, request, error) {
        var boundary = task.blockedBoundary, segment = task.blockedSegment;
        if (null !== segment) {
          if (6 === segment.status) return;
          segment.status = 3;
        }
        segment = getThrownInfo(task.componentStack);
        if (null === boundary) {
          if (13 !== request.status && request.status !== CLOSED) {
            boundary = task.replay;
            if (null === boundary) {
              logRecoverableError(request, error, segment, null);
              fatalError(request, error, segment, null);
              return;
            }
            boundary.pendingTasks--;
            0 === boundary.pendingTasks && 0 < boundary.nodes.length && (task = logRecoverableError(request, error, segment, null), abortRemainingReplayNodes(
              request,
              null,
              boundary.nodes,
              boundary.slots,
              error,
              task,
              segment,
              true
            ));
            request.pendingRootTasks--;
            0 === request.pendingRootTasks && completeShell(request);
          }
        } else
          boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, task = logRecoverableError(request, error, segment, null), boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(boundary, task, error, segment, true), untrackBoundary(request, boundary), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary)), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, error);
          }), boundary.fallbackAbortableTasks.clear();
        request.allPendingTasks--;
        0 === request.allPendingTasks && completeAll(request);
      }
      function safelyEmitEarlyPreloads(request, shellComplete) {
        try {
          var renderState = request.renderState, onHeaders = renderState.onHeaders;
          if (onHeaders) {
            var headers = renderState.headers;
            if (headers) {
              renderState.headers = null;
              var linkHeader = headers.preconnects;
              headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
              headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
              if (!shellComplete) {
                var queueIter = renderState.styles.values(), queueStep = queueIter.next();
                b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
                  for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                    var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
                    var header = getPreloadAsHeader(
                      props$jscomp$0.href,
                      "style",
                      {
                        crossOrigin: props$jscomp$0.crossOrigin,
                        integrity: props$jscomp$0.integrity,
                        nonce: props$jscomp$0.nonce,
                        type: props$jscomp$0.type,
                        fetchPriority: props$jscomp$0.fetchPriority,
                        referrerPolicy: props$jscomp$0.referrerPolicy,
                        media: props$jscomp$0.media
                      }
                    );
                    if (0 <= (headers.remainingCapacity -= header.length + 2))
                      renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                    else break b;
                  }
              }
              linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
            }
          }
        } catch (error) {
          logRecoverableError(request, error, {}, null);
        }
      }
      function completeShell(request) {
        null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);
        null === request.trackedPostpones && preparePreamble(request);
        request.onShellError = noop;
        request = request.onShellReady;
        request();
      }
      function completeAll(request) {
        safelyEmitEarlyPreloads(
          request,
          null === request.trackedPostpones ? true : null === request.completedRootSegment || request.completedRootSegment.status !== POSTPONED
        );
        preparePreamble(request);
        request = request.onAllReady;
        request();
      }
      function queueCompletedSegment(boundary, segment) {
        if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          childSegment.status === COMPLETED && queueCompletedSegment(boundary, childSegment);
        } else boundary.completedSegments.push(segment);
      }
      function finishedTask(request, boundary, segment) {
        if (null === boundary) {
          if (null !== segment && segment.parentFlushed) {
            if (null !== request.completedRootSegment)
              throw Error(
                "There can only be one root segment. This is a bug in React."
              );
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          0 === request.pendingRootTasks && completeShell(request);
        } else
          boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (0 === boundary.pendingTasks ? (boundary.status === PENDING && (boundary.status = COMPLETED), null !== segment && segment.parentFlushed && segment.status === COMPLETED && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED && (boundary.fallbackAbortableTasks.forEach(
            abortTaskSoft,
            request
          ), boundary.fallbackAbortableTasks.clear(), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request))) : null !== segment && segment.parentFlushed && segment.status === COMPLETED && (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)));
        request.allPendingTasks--;
        0 === request.allPendingTasks && completeAll(request);
      }
      function performWork(request$jscomp$2) {
        if (request$jscomp$2.status !== CLOSED && 13 !== request$jscomp$2.status) {
          var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = HooksDispatcher;
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          var prevRequest = currentRequest;
          currentRequest = request$jscomp$2;
          var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;
          ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
          var prevResumableState = currentResumableState;
          currentResumableState = request$jscomp$2.resumableState;
          try {
            var pingedTasks = request$jscomp$2.pingedTasks, i;
            for (i = 0; i < pingedTasks.length; i++) {
              var request = request$jscomp$2, task = pingedTasks[i], segment = task.blockedSegment;
              if (null === segment) {
                var prevTaskInDEV = void 0, request$jscomp$0 = request;
                request = task;
                if (0 !== request.replay.pendingTasks) {
                  switchContext(request.context);
                  prevTaskInDEV = currentTaskInDEV;
                  currentTaskInDEV = request;
                  try {
                    "number" === typeof request.replay.slots ? resumeNode(
                      request$jscomp$0,
                      request,
                      request.replay.slots,
                      request.node,
                      request.childIndex
                    ) : retryNode(request$jscomp$0, request);
                    if (1 === request.replay.pendingTasks && 0 < request.replay.nodes.length)
                      throw Error(
                        "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                      );
                    request.replay.pendingTasks--;
                    request.abortSet.delete(request);
                    finishedTask(request$jscomp$0, request.blockedBoundary, null);
                  } catch (thrownValue) {
                    resetHooksState();
                    var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                    if ("object" === typeof x && null !== x && "function" === typeof x.then) {
                      var ping = request.ping;
                      x.then(ping, ping);
                      request.thenableState = getThenableStateAfterSuspending();
                    } else {
                      request.replay.pendingTasks--;
                      request.abortSet.delete(request);
                      var errorInfo = getThrownInfo(request.componentStack), errorDigest = void 0, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
                      errorDigest = logRecoverableError(
                        request$jscomp$1,
                        error$jscomp$0,
                        errorInfo$jscomp$0,
                        request.debugTask
                      );
                      abortRemainingReplayNodes(
                        request$jscomp$1,
                        boundary,
                        replayNodes,
                        resumeSlots,
                        error$jscomp$0,
                        errorDigest,
                        errorInfo$jscomp$0,
                        false
                      );
                      request$jscomp$0.pendingRootTasks--;
                      0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);
                      request$jscomp$0.allPendingTasks--;
                      0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);
                    }
                  } finally {
                    currentTaskInDEV = prevTaskInDEV;
                  }
                }
              } else if (request$jscomp$0 = prevTaskInDEV = void 0, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING) {
                request$jscomp$1.status = 6;
                switchContext(errorDigest.context);
                request$jscomp$0 = currentTaskInDEV;
                currentTaskInDEV = errorDigest;
                var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
                try {
                  retryNode(request, errorDigest), pushSegmentFinale(
                    request$jscomp$1.chunks,
                    request.renderState,
                    request$jscomp$1.lastPushedText,
                    request$jscomp$1.textEmbedded
                  ), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED, finishedTask(
                    request,
                    errorDigest.blockedBoundary,
                    request$jscomp$1
                  );
                } catch (thrownValue) {
                  resetHooksState();
                  request$jscomp$1.children.length = childrenLength;
                  request$jscomp$1.chunks.length = chunkLength;
                  var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;
                  if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
                    request$jscomp$1.status = PENDING;
                    errorDigest.thenableState = getThenableStateAfterSuspending();
                    var ping$jscomp$0 = errorDigest.ping;
                    x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
                  } else {
                    var errorInfo$jscomp$1 = getThrownInfo(
                      errorDigest.componentStack
                    );
                    errorDigest.abortSet.delete(errorDigest);
                    request$jscomp$1.status = 4;
                    var boundary$jscomp$0 = errorDigest.blockedBoundary, debugTask = errorDigest.debugTask;
                    prevTaskInDEV = logRecoverableError(
                      request,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      debugTask
                    );
                    null === boundary$jscomp$0 ? fatalError(
                      request,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      debugTask
                    ) : (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED && (boundary$jscomp$0.status = CLIENT_RENDERED, encodeErrorForBoundary(
                      boundary$jscomp$0,
                      prevTaskInDEV,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      false
                    ), untrackBoundary(request, boundary$jscomp$0), boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(
                      boundary$jscomp$0
                    ), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request)));
                    request.allPendingTasks--;
                    0 === request.allPendingTasks && completeAll(request);
                  }
                } finally {
                  currentTaskInDEV = request$jscomp$0;
                }
              }
            }
            pingedTasks.splice(0, i);
            null !== request$jscomp$2.destination && flushCompletedQueues(
              request$jscomp$2,
              request$jscomp$2.destination
            );
          } catch (error) {
            pingedTasks = {}, logRecoverableError(request$jscomp$2, error, pingedTasks, null), fatalError(request$jscomp$2, error, pingedTasks, null);
          } finally {
            currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
          }
        }
      }
      function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
        segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
        for (var pendingPreambles = false, i = 0; i < segment.children.length; i++)
          pendingPreambles = preparePreambleFromSegment(
            request,
            segment.children[i],
            collectedPreambleSegments
          ) || pendingPreambles;
        return pendingPreambles;
      }
      function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
        var boundary = segment.boundary;
        if (null === boundary)
          return preparePreambleFromSubtree(
            request,
            segment,
            collectedPreambleSegments
          );
        var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
        if (null === preamble || null === fallbackPreamble) return false;
        switch (boundary.status) {
          case COMPLETED:
            hoistPreambleState(request.renderState, preamble);
            segment = boundary.completedSegments[0];
            if (!segment)
              throw Error(
                "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
              );
            return preparePreambleFromSubtree(
              request,
              segment,
              collectedPreambleSegments
            );
          case POSTPONED:
            if (null !== request.trackedPostpones) return true;
          case CLIENT_RENDERED:
            if (segment.status === COMPLETED)
              return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(
                request,
                segment,
                collectedPreambleSegments
              );
          default:
            return true;
        }
      }
      function preparePreamble(request) {
        if (request.completedRootSegment && null === request.completedPreambleSegments) {
          var collectedPreambleSegments = [], hasPendingPreambles = preparePreambleFromSegment(
            request,
            request.completedRootSegment,
            collectedPreambleSegments
          ), preamble = request.renderState.preamble;
          if (false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks)
            request.completedPreambleSegments = collectedPreambleSegments;
        }
      }
      function flushSubtree(request, destination, segment, hoistableState) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING:
            segment.id = request.nextSegmentId++;
          case POSTPONED:
            return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, destination.push(placeholder1), destination.push(request.placeholderPrefix), request = hoistableState.toString(16), destination.push(request), destination.push(placeholder2);
          case COMPLETED:
            segment.status = FLUSHED;
            var r2 = true, chunks = segment.chunks, chunkIdx = 0;
            segment = segment.children;
            for (var childIdx = 0; childIdx < segment.length; childIdx++) {
              for (r2 = segment[childIdx]; chunkIdx < r2.index; chunkIdx++)
                destination.push(chunks[chunkIdx]);
              r2 = flushSegment(request, destination, r2, hoistableState);
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++)
              destination.push(chunks[chunkIdx]);
            chunkIdx < chunks.length && (r2 = destination.push(chunks[chunkIdx]));
            return r2;
          default:
            throw Error(
              "Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React."
            );
        }
      }
      function flushSegment(request, destination, segment, hoistableState) {
        var boundary = segment.boundary;
        if (null === boundary)
          return flushSubtree(request, destination, segment, hoistableState);
        boundary.parentFlushed = true;
        if (boundary.status === CLIENT_RENDERED) {
          if (!request.renderState.generateStaticMarkup) {
            var errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
            destination.push(startClientRenderedSuspenseBoundary);
            destination.push(clientRenderedSuspenseBoundaryError1);
            errorDigest && (destination.push(clientRenderedSuspenseBoundaryError1A), errorDigest = escapeTextForBrowser(errorDigest), destination.push(errorDigest), destination.push(
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            errorMessage && (destination.push(clientRenderedSuspenseBoundaryError1B), errorMessage = escapeTextForBrowser(errorMessage), destination.push(errorMessage), destination.push(
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            errorStack && (destination.push(clientRenderedSuspenseBoundaryError1C), errorStack = escapeTextForBrowser(errorStack), destination.push(errorStack), destination.push(
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            errorComponentStack && (destination.push(clientRenderedSuspenseBoundaryError1D), errorComponentStack = escapeTextForBrowser(errorComponentStack), destination.push(errorComponentStack), destination.push(
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            destination.push(clientRenderedSuspenseBoundaryError2);
          }
          flushSubtree(request, destination, segment, hoistableState);
          request.renderState.generateStaticMarkup ? destination = true : ((request = boundary.fallbackPreamble) && writePreambleContribution(destination, request), destination = destination.push(endSuspenseBoundary));
          return destination;
        }
        if (boundary.status !== COMPLETED)
          return boundary.status === PENDING && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
            destination,
            request.renderState,
            boundary.rootSegmentID
          ), hoistableState && (boundary = boundary.fallbackState, boundary.styles.forEach(hoistStyleQueueDependency, hoistableState), boundary.stylesheets.forEach(
            hoistStylesheetDependency,
            hoistableState
          )), flushSubtree(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary);
        if (boundary.byteSize > request.progressiveChunkSize)
          return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
            destination,
            request.renderState,
            boundary.rootSegmentID
          ), flushSubtree(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary);
        hoistableState && (segment = boundary.contentState, segment.styles.forEach(hoistStyleQueueDependency, hoistableState), segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));
        request.renderState.generateStaticMarkup || destination.push(startCompletedSuspenseBoundary);
        segment = boundary.completedSegments;
        if (1 !== segment.length)
          throw Error(
            "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
          );
        flushSegment(request, destination, segment[0], hoistableState);
        request.renderState.generateStaticMarkup ? destination = true : ((request = boundary.contentPreamble) && writePreambleContribution(destination, request), destination = destination.push(endSuspenseBoundary));
        return destination;
      }
      function flushSegmentContainer(request, destination, segment, hoistableState) {
        writeStartSegment(
          destination,
          request.renderState,
          segment.parentFormatContext,
          segment.id
        );
        flushSegment(request, destination, segment, hoistableState);
        return writeEndSegment(destination, segment.parentFormatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++)
          flushPartiallyCompletedSegment(
            request,
            destination,
            boundary,
            completedSegments[i]
          );
        completedSegments.length = 0;
        writeHoistablesForBoundary(
          destination,
          boundary.contentState,
          request.renderState
        );
        completedSegments = request.resumableState;
        request = request.renderState;
        i = boundary.rootSegmentID;
        boundary = boundary.contentState;
        var requiresStyleInsertion = request.stylesToHoist;
        request.stylesToHoist = false;
        destination.push(request.startInlineScript);
        requiresStyleInsertion ? (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions = completedSegments.instructions | SentStyleInsertionFunction | SentCompleteBoundaryFunction, destination.push(completeBoundaryWithStylesScript1FullBoth)) : (completedSegments.instructions & SentStyleInsertionFunction) === NothingSent ? (completedSegments.instructions |= SentStyleInsertionFunction, destination.push(completeBoundaryWithStylesScript1FullPartial)) : destination.push(completeBoundaryWithStylesScript1Partial) : (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions |= SentCompleteBoundaryFunction, destination.push(completeBoundaryScript1Full)) : destination.push(completeBoundaryScript1Partial);
        completedSegments = i.toString(16);
        destination.push(request.boundaryPrefix);
        destination.push(completedSegments);
        destination.push(completeBoundaryScript2);
        destination.push(request.segmentPrefix);
        destination.push(completedSegments);
        requiresStyleInsertion ? (destination.push(completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : destination.push(completeBoundaryScript3b);
        boundary = destination.push(completeBoundaryScriptEnd);
        return writeBootstrap(destination, request) && boundary;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) return true;
        var hoistableState = boundary.contentState, segmentID = segment.id;
        if (-1 === segmentID) {
          if (-1 === (segment.id = boundary.rootSegmentID))
            throw Error(
              "A root segment ID must have been assigned by now. This is a bug in React."
            );
          return flushSegmentContainer(
            request,
            destination,
            segment,
            hoistableState
          );
        }
        if (segmentID === boundary.rootSegmentID)
          return flushSegmentContainer(
            request,
            destination,
            segment,
            hoistableState
          );
        flushSegmentContainer(request, destination, segment, hoistableState);
        boundary = request.resumableState;
        request = request.renderState;
        destination.push(request.startInlineScript);
        (boundary.instructions & SentCompleteSegmentFunction) === NothingSent ? (boundary.instructions |= SentCompleteSegmentFunction, destination.push(completeSegmentScript1Full)) : destination.push(completeSegmentScript1Partial);
        destination.push(request.segmentPrefix);
        segmentID = segmentID.toString(16);
        destination.push(segmentID);
        destination.push(completeSegmentScript2);
        destination.push(request.placeholderPrefix);
        destination.push(segmentID);
        destination = destination.push(completeSegmentScriptEnd);
        return destination;
      }
      function flushCompletedQueues(request, destination) {
        try {
          if (!(0 < request.pendingRootTasks)) {
            var i, completedRootSegment = request.completedRootSegment;
            if (null !== completedRootSegment) {
              if (completedRootSegment.status === POSTPONED) return;
              var completedPreambleSegments = request.completedPreambleSegments;
              if (null === completedPreambleSegments) return;
              var renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
              if (htmlChunks) {
                for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
                  destination.push(htmlChunks[i$jscomp$0]);
                if (headChunks)
                  for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                    destination.push(headChunks[i$jscomp$0]);
                else {
                  var chunk = startChunkForTag("head");
                  destination.push(chunk);
                  destination.push(endOfStartTag);
                }
              } else if (headChunks)
                for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                  destination.push(headChunks[i$jscomp$0]);
              var charsetChunks = renderState.charsetChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
                destination.push(charsetChunks[i$jscomp$0]);
              charsetChunks.length = 0;
              renderState.preconnects.forEach(flushResource, destination);
              renderState.preconnects.clear();
              var viewportChunks = renderState.viewportChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
                destination.push(viewportChunks[i$jscomp$0]);
              viewportChunks.length = 0;
              renderState.fontPreloads.forEach(flushResource, destination);
              renderState.fontPreloads.clear();
              renderState.highImagePreloads.forEach(flushResource, destination);
              renderState.highImagePreloads.clear();
              renderState.styles.forEach(flushStylesInPreamble, destination);
              var importMapChunks = renderState.importMapChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
                destination.push(importMapChunks[i$jscomp$0]);
              importMapChunks.length = 0;
              renderState.bootstrapScripts.forEach(flushResource, destination);
              renderState.scripts.forEach(flushResource, destination);
              renderState.scripts.clear();
              renderState.bulkPreloads.forEach(flushResource, destination);
              renderState.bulkPreloads.clear();
              var hoistableChunks = renderState.hoistableChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
                destination.push(hoistableChunks[i$jscomp$0]);
              for (renderState = hoistableChunks.length = 0; renderState < completedPreambleSegments.length; renderState++) {
                var segments = completedPreambleSegments[renderState];
                for (preamble = 0; preamble < segments.length; preamble++)
                  flushSegment(request, destination, segments[preamble], null);
              }
              var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
              if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
                var chunk$jscomp$0 = endChunkForTag("head");
                destination.push(chunk$jscomp$0);
              }
              var bodyChunks = preamble$jscomp$0.bodyChunks;
              if (bodyChunks)
                for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
                  destination.push(bodyChunks[completedPreambleSegments]);
              flushSegment(request, destination, completedRootSegment, null);
              request.completedRootSegment = null;
              writeBootstrap(destination, request.renderState);
            }
            var renderState$jscomp$0 = request.renderState;
            completedRootSegment = 0;
            var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;
            for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
              destination.push(viewportChunks$jscomp$0[completedRootSegment]);
            viewportChunks$jscomp$0.length = 0;
            renderState$jscomp$0.preconnects.forEach(flushResource, destination);
            renderState$jscomp$0.preconnects.clear();
            renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);
            renderState$jscomp$0.fontPreloads.clear();
            renderState$jscomp$0.highImagePreloads.forEach(
              flushResource,
              destination
            );
            renderState$jscomp$0.highImagePreloads.clear();
            renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);
            renderState$jscomp$0.scripts.forEach(flushResource, destination);
            renderState$jscomp$0.scripts.clear();
            renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);
            renderState$jscomp$0.bulkPreloads.clear();
            var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;
            for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
              destination.push(hoistableChunks$jscomp$0[completedRootSegment]);
            hoistableChunks$jscomp$0.length = 0;
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            for (i = 0; i < clientRenderedBoundaries.length; i++) {
              var boundary = clientRenderedBoundaries[i];
              renderState$jscomp$0 = destination;
              var resumableState = request.resumableState, renderState$jscomp$1 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
              renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript);
              (resumableState.instructions & SentClientRenderFunction) === NothingSent ? (resumableState.instructions |= SentClientRenderFunction, renderState$jscomp$0.push(clientRenderScript1Full)) : renderState$jscomp$0.push(clientRenderScript1Partial);
              renderState$jscomp$0.push(renderState$jscomp$1.boundaryPrefix);
              var chunk$jscomp$1 = id.toString(16);
              renderState$jscomp$0.push(chunk$jscomp$1);
              renderState$jscomp$0.push(clientRenderScript1A);
              if (errorDigest || errorMessage || errorStack || errorComponentStack) {
                renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
                var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(
                  errorDigest || ""
                );
                renderState$jscomp$0.push(chunk$jscomp$2);
              }
              if (errorMessage || errorStack || errorComponentStack) {
                renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
                var chunk$jscomp$3 = escapeJSStringsForInstructionScripts(
                  errorMessage || ""
                );
                renderState$jscomp$0.push(chunk$jscomp$3);
              }
              if (errorStack || errorComponentStack) {
                renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
                var chunk$jscomp$4 = escapeJSStringsForInstructionScripts(
                  errorStack || ""
                );
                renderState$jscomp$0.push(chunk$jscomp$4);
              }
              if (errorComponentStack) {
                renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
                var chunk$jscomp$5 = escapeJSStringsForInstructionScripts(errorComponentStack);
                renderState$jscomp$0.push(chunk$jscomp$5);
              }
              var JSCompiler_inline_result = renderState$jscomp$0.push(
                clientRenderScriptEnd
              );
              if (!JSCompiler_inline_result) {
                request.destination = null;
                i++;
                clientRenderedBoundaries.splice(0, i);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i);
            var completedBoundaries = request.completedBoundaries;
            for (i = 0; i < completedBoundaries.length; i++)
              if (!flushCompletedBoundary(
                request,
                destination,
                completedBoundaries[i]
              )) {
                request.destination = null;
                i++;
                completedBoundaries.splice(0, i);
                return;
              }
            completedBoundaries.splice(0, i);
            var partialBoundaries = request.partialBoundaries;
            for (i = 0; i < partialBoundaries.length; i++) {
              a: {
                clientRenderedBoundaries = request;
                boundary = destination;
                var boundary$jscomp$0 = partialBoundaries[i], completedSegments = boundary$jscomp$0.completedSegments;
                for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
                  if (!flushPartiallyCompletedSegment(
                    clientRenderedBoundaries,
                    boundary,
                    boundary$jscomp$0,
                    completedSegments[JSCompiler_inline_result]
                  )) {
                    JSCompiler_inline_result++;
                    completedSegments.splice(0, JSCompiler_inline_result);
                    var JSCompiler_inline_result$jscomp$0 = false;
                    break a;
                  }
                completedSegments.splice(0, JSCompiler_inline_result);
                JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
                  boundary,
                  boundary$jscomp$0.contentState,
                  clientRenderedBoundaries.renderState
                );
              }
              if (!JSCompiler_inline_result$jscomp$0) {
                request.destination = null;
                i++;
                partialBoundaries.splice(0, i);
                return;
              }
            }
            partialBoundaries.splice(0, i);
            var largeBoundaries = request.completedBoundaries;
            for (i = 0; i < largeBoundaries.length; i++)
              if (!flushCompletedBoundary(request, destination, largeBoundaries[i])) {
                request.destination = null;
                i++;
                largeBoundaries.splice(0, i);
                return;
              }
            largeBoundaries.splice(0, i);
          }
        } finally {
          0 === request.allPendingTasks && 0 === request.pingedTasks.length && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length && (request.flushScheduled = false, i = request.resumableState, i.hasBody && (partialBoundaries = endChunkForTag("body"), destination.push(partialBoundaries)), i.hasHtml && (i = endChunkForTag("html"), destination.push(i)), 0 !== request.abortableTasks.size && console.error(
            "There was still abortable task at the root when we closed. This is a bug in React."
          ), request.status = CLOSED, destination.push(null), request.destination = null);
        }
      }
      function startWork(request) {
        request.flushScheduled = null !== request.destination;
        performWork(request);
        10 === request.status && (request.status = 11);
        null === request.trackedPostpones && safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);
      }
      function enqueueFlush(request) {
        if (false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination) {
          request.flushScheduled = true;
          var destination = request.destination;
          destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
        }
      }
      function startFlowing(request, destination) {
        if (13 === request.status)
          request.status = CLOSED, destination.destroy(request.fatalError);
        else if (request.status !== CLOSED && null === request.destination) {
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error) {
            destination = {}, logRecoverableError(request, error, destination, null), fatalError(request, error, destination, null);
          }
        }
      }
      function abort(request, reason) {
        if (11 === request.status || 10 === request.status) request.status = 12;
        try {
          var abortableTasks = request.abortableTasks;
          if (0 < abortableTasks.size) {
            var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
            request.fatalError = error;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, error);
            });
            abortableTasks.clear();
          }
          null !== request.destination && flushCompletedQueues(request, request.destination);
        } catch (error$4) {
          reason = {}, logRecoverableError(request, error$4, reason, null), fatalError(request, error$4, reason, null);
        }
      }
      function onError() {
      }
      function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
        var didFatal = false, fatalError2 = null, result = "", readyToStream = false;
        options = createResumableState(
          options ? options.identifierPrefix : void 0
        );
        children = createRequest(
          children,
          options,
          createRenderState(options, generateStaticMarkup),
          createFormatContext(ROOT_HTML_MODE, null, 0),
          Infinity,
          onError,
          void 0,
          function() {
            readyToStream = true;
          },
          void 0,
          void 0,
          void 0
        );
        startWork(children);
        abort(children, abortReason);
        startFlowing(children, {
          push: function(chunk) {
            null !== chunk && (result += chunk);
            return true;
          },
          destroy: function(error) {
            didFatal = true;
            fatalError2 = error;
          }
        });
        if (didFatal && fatalError2 !== abortReason) throw fatalError2;
        if (!readyToStream)
          throw Error(
            "A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition."
          );
        return result;
      }
      var React12 = require_react(), ReactDOM = require_react_dom(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, isArrayImpl = Array.isArray, jsxPropsParents = /* @__PURE__ */ new WeakMap(), jsxChildrenParents = /* @__PURE__ */ new WeakMap(), CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"), assign = Object.assign, hasOwnProperty = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      ), aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]), hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      }, ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      }, warnedProperties$1 = {}, rARIA$1 = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel$1 = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), didWarnValueNull = false, possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        fetchpriority: "fetchPriority",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        inert: "inert",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        popover: "popover",
        popovertarget: "popoverTarget",
        popovertargetaction: "popoverTargetAction",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        transformorigin: "transformOrigin",
        "transform-origin": "transformOrigin",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      }, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern$1 = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, matchHtmlRegExp = /["'&<>]/, uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, ReactSharedInternals = React12.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
        pending: false,
        data: null,
        method: null,
        action: null
      }), previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: previousDispatcher.f,
        r: previousDispatcher.r,
        D: function(href) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if ("string" === typeof href && href) {
              if (!resumableState.dnsResources.hasOwnProperty(href)) {
                resumableState.dnsResources[href] = EXISTS;
                resumableState = renderState.headers;
                var header, JSCompiler_temp;
                if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
                  JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
                JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
              }
              enqueueFlush(request);
            }
          } else previousDispatcher.D(href);
        },
        C: function(href, crossOrigin) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if ("string" === typeof href && href) {
              var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
              if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
                resumableState.connectResources[bucket][href] = EXISTS;
                resumableState = renderState.headers;
                var header, JSCompiler_temp;
                if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
                  JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=preconnect";
                  if ("string" === typeof crossOrigin) {
                    var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(
                      crossOrigin,
                      "crossOrigin"
                    );
                    JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
                  }
                  JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
                }
                JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
                  rel: "preconnect",
                  href,
                  crossOrigin
                }), renderState.preconnects.add(bucket));
              }
              enqueueFlush(request);
            }
          } else previousDispatcher.C(href, crossOrigin);
        },
        L: function(href, as3, options) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (as3 && href) {
              switch (as3) {
                case "image":
                  if (options) {
                    var imageSrcSet = options.imageSrcSet;
                    var imageSizes = options.imageSizes;
                    var fetchPriority = options.fetchPriority;
                  }
                  var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
                  if (resumableState.imageResources.hasOwnProperty(key)) return;
                  resumableState.imageResources[key] = PRELOAD_NO_CREDS;
                  resumableState = renderState.headers;
                  var header;
                  resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader(href, as3, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(
                    resumableState,
                    assign(
                      {
                        rel: "preload",
                        href: imageSrcSet ? void 0 : href,
                        as: as3
                      },
                      options
                    )
                  ), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
                  break;
                case "style":
                  if (resumableState.styleResources.hasOwnProperty(href)) return;
                  imageSrcSet = [];
                  pushLinkImpl(
                    imageSrcSet,
                    assign({ rel: "preload", href, as: as3 }, options)
                  );
                  resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                  renderState.preloads.stylesheets.set(href, imageSrcSet);
                  renderState.bulkPreloads.add(imageSrcSet);
                  break;
                case "script":
                  if (resumableState.scriptResources.hasOwnProperty(href)) return;
                  imageSrcSet = [];
                  renderState.preloads.scripts.set(href, imageSrcSet);
                  renderState.bulkPreloads.add(imageSrcSet);
                  pushLinkImpl(
                    imageSrcSet,
                    assign({ rel: "preload", href, as: as3 }, options)
                  );
                  resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                  break;
                default:
                  if (resumableState.unknownResources.hasOwnProperty(as3)) {
                    if (imageSrcSet = resumableState.unknownResources[as3], imageSrcSet.hasOwnProperty(href))
                      return;
                  } else
                    imageSrcSet = {}, resumableState.unknownResources[as3] = imageSrcSet;
                  imageSrcSet[href] = PRELOAD_NO_CREDS;
                  if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as3 && (key = getPreloadAsHeader(href, as3, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
                    renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
                  else
                    switch (resumableState = [], href = assign(
                      { rel: "preload", href, as: as3 },
                      options
                    ), pushLinkImpl(resumableState, href), as3) {
                      case "font":
                        renderState.fontPreloads.add(resumableState);
                        break;
                      default:
                        renderState.bulkPreloads.add(resumableState);
                    }
              }
              enqueueFlush(request);
            }
          } else previousDispatcher.L(href, as3, options);
        },
        m: function(href, options) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (href) {
              var as3 = options && "string" === typeof options.as ? options.as : "script";
              switch (as3) {
                case "script":
                  if (resumableState.moduleScriptResources.hasOwnProperty(href))
                    return;
                  as3 = [];
                  resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                  renderState.preloads.moduleScripts.set(href, as3);
                  break;
                default:
                  if (resumableState.moduleUnknownResources.hasOwnProperty(as3)) {
                    var resources = resumableState.unknownResources[as3];
                    if (resources.hasOwnProperty(href)) return;
                  } else
                    resources = {}, resumableState.moduleUnknownResources[as3] = resources;
                  as3 = [];
                  resources[href] = PRELOAD_NO_CREDS;
              }
              pushLinkImpl(
                as3,
                assign({ rel: "modulepreload", href }, options)
              );
              renderState.bulkPreloads.add(as3);
              enqueueFlush(request);
            }
          } else previousDispatcher.m(href, options);
        },
        X: function(src, options) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (src) {
              var resourceState = resumableState.scriptResources.hasOwnProperty(
                src
              ) ? resumableState.scriptResources[src] : void 0;
              resourceState !== EXISTS && (resumableState.scriptResources[src] = EXISTS, options = assign({ src, async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
            }
          } else previousDispatcher.X(src, options);
        },
        S: function(href, precedence, options) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (href) {
              precedence = precedence || "default";
              var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
              resourceState !== EXISTS && (resumableState.styleResources[href] = EXISTS, styleQueue || (styleQueue = {
                precedence: escapeTextForBrowser(precedence),
                rules: [],
                hrefs: [],
                sheets: /* @__PURE__ */ new Map()
              }, renderState.styles.set(precedence, styleQueue)), precedence = {
                state: PENDING$1,
                props: assign(
                  {
                    rel: "stylesheet",
                    href,
                    "data-precedence": precedence
                  },
                  options
                )
              }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
            }
          } else previousDispatcher.S(href, precedence, options);
        },
        M: function(src, options) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (src) {
              var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : void 0;
              resourceState !== EXISTS && (resumableState.moduleScriptResources[src] = EXISTS, options = assign(
                { src, type: "module", async: true },
                options
              ), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
            }
          } else previousDispatcher.M(src, options);
        }
      };
      var NothingSent = 0, SentCompleteSegmentFunction = 1, SentCompleteBoundaryFunction = 2, SentClientRenderFunction = 4, SentStyleInsertionFunction = 8, EXISTS = null, PRELOAD_NO_CREDS = [];
      Object.freeze(PRELOAD_NO_CREDS);
      var scriptRegex = /(<\/|<)(s)(cript)/gi;
      var didWarnForNewBooleanPropsWithEmptyValue = {};
      var NoContribution = 0, ROOT_HTML_MODE = 0, HTML_HTML_MODE = 1, HTML_MODE = 2, HTML_HEAD_MODE = 3, SVG_MODE = 4, MATHML_MODE = 5, HTML_TABLE_MODE = 6, HTML_TABLE_BODY_MODE = 7, HTML_TABLE_ROW_MODE = 8, HTML_COLGROUP_MODE = 9, styleNameCache = /* @__PURE__ */ new Map(), styleAttributeStart = ' style="', styleAssign = ":", styleSeparator = ";", attributeSeparator = " ", attributeAssign = '="', attributeEnd = '"', attributeEmptyString = '=""', actionJavaScriptURL = escapeTextForBrowser(
        "javascript:throw new Error('React form unexpectedly submitted.')"
      ), endOfStartTag = ">", endOfStartTagSelfClosing = "/>", didWarnDefaultInputValue = false, didWarnDefaultChecked = false, didWarnDefaultSelectValue = false, didWarnDefaultTextareaValue = false, didWarnInvalidOptionChildren = false, didWarnInvalidOptionInnerHTML = false, didWarnSelectedSetOnOption = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, formReplayingRuntimeScript = `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`, styleRegex = /(<\/|<)(s)(tyle)/gi, leadingNewline = "\n", VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map(), endTagCache = /* @__PURE__ */ new Map(), placeholder1 = '<template id="', placeholder2 = '"></template>', startCompletedSuspenseBoundary = "<!--$-->", startPendingSuspenseBoundary1 = '<!--$?--><template id="', startPendingSuspenseBoundary2 = '"></template>', startClientRenderedSuspenseBoundary = "<!--$!-->", endSuspenseBoundary = "<!--/$-->", clientRenderedSuspenseBoundaryError1 = "<template", clientRenderedSuspenseBoundaryErrorAttrInterstitial = '"', clientRenderedSuspenseBoundaryError1A = ' data-dgst="', clientRenderedSuspenseBoundaryError1B = ' data-msg="', clientRenderedSuspenseBoundaryError1C = ' data-stck="', clientRenderedSuspenseBoundaryError1D = ' data-cstck="', clientRenderedSuspenseBoundaryError2 = "></template>", boundaryPreambleContributionChunkStart = "<!--", boundaryPreambleContributionChunkEnd = "-->", startSegmentHTML = '<div hidden id="', startSegmentHTML2 = '">', endSegmentHTML = "</div>", startSegmentSVG = '<svg aria-hidden="true" style="display:none" id="', startSegmentSVG2 = '">', endSegmentSVG = "</svg>", startSegmentMathML = '<math aria-hidden="true" style="display:none" id="', startSegmentMathML2 = '">', endSegmentMathML = "</math>", startSegmentTable = '<table hidden id="', startSegmentTable2 = '">', endSegmentTable = "</table>", startSegmentTableBody = '<table hidden><tbody id="', startSegmentTableBody2 = '">', endSegmentTableBody = "</tbody></table>", startSegmentTableRow = '<table hidden><tr id="', startSegmentTableRow2 = '">', endSegmentTableRow = "</tr></table>", startSegmentColGroup = '<table hidden><colgroup id="', startSegmentColGroup2 = '">', endSegmentColGroup = "</colgroup></table>", completeSegmentScript1Full = '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("', completeSegmentScript1Partial = '$RS("', completeSegmentScript2 = '","', completeSegmentScriptEnd = '")</script>', completeBoundaryScript1Full = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("', completeBoundaryScript1Partial = '$RC("', completeBoundaryWithStylesScript1FullBoth = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("', completeBoundaryWithStylesScript1FullPartial = '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("', completeBoundaryWithStylesScript1Partial = '$RR("', completeBoundaryScript2 = '","', completeBoundaryScript3a = '",', completeBoundaryScript3b = '"', completeBoundaryScriptEnd = ")</script>", clientRenderScript1Full = '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("', clientRenderScript1Partial = '$RX("', clientRenderScript1A = '"', clientRenderErrorScriptArgInterstitial = ",", clientRenderScriptEnd = ")</script>", regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g, regexForJSStringsInScripts = /[&><\u2028\u2029]/g, lateStyleTagResourceOpen1 = '<style media="not all" data-precedence="', lateStyleTagResourceOpen2 = '" data-href="', lateStyleTagResourceOpen3 = '">', lateStyleTagTemplateClose = "</style>", currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true, stylesheetFlushingQueue = [], styleTagResourceOpen1 = '<style data-precedence="', styleTagResourceOpen2 = '" data-href="', spaceSeparator = " ", styleTagResourceOpen3 = '">', styleTagResourceClose = "</style>", arrayFirstOpenBracket = "[", arraySubsequentOpenBracket = ",[", arrayInterstitial = ",", arrayCloseBracket = "]", PENDING$1 = 0, PRELOADED = 1, PREAMBLE = 2, LATE = 3, regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g, regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g, doctypeChunk = "", bind = Function.prototype.bind, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), emptyContextObject = {};
      Object.freeze(emptyContextObject);
      var rendererSigil = {};
      var currentActiveSnapshot = null, didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
      var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
      var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
      var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
      var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
      var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          var internals = inst._reactInternals;
          null === internals.queue ? warnNoop(inst, "setState") : (internals.queue.push(payload), void 0 !== callback && null !== callback && warnOnInvalidCallback(callback));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          inst.replace = true;
          inst.queue = [payload];
          void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
        },
        enqueueForceUpdate: function(inst, callback) {
          null === inst._reactInternals.queue ? warnNoop(inst, "forceUpdate") : void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
        }
      }, emptyTreeContext = { id: 1, overflow: "" }, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, SuspenseException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
      ), suspendedThenable = null, objectIs = "function" === typeof Object.is ? Object.is : is3, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0, isInHookUserCodeInDev = false, currentHookNameInDev, HooksDispatcher = {
        readContext,
        use: function(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then)
              return unwrapThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE)
              return readContext(usable);
          }
          throw Error(
            "An unsupported type was passed to use(): " + String(usable)
          );
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          resolveCurrentlyRenderingComponent();
          return context._currentValue2;
        },
        useMemo,
        useReducer,
        useRef: function(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          return null === previousRef ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook.memoizedState = initialValue) : previousRef;
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState";
          return useReducer(basicStateReducer, initialState);
        },
        useInsertionEffect: noop$1,
        useLayoutEffect: noop$1,
        useCallback: function(callback, deps) {
          return useMemo(function() {
            return callback;
          }, deps);
        },
        useImperativeHandle: noop$1,
        useEffect: noop$1,
        useDebugValue: noop$1,
        useDeferredValue: function(value, initialValue) {
          resolveCurrentlyRenderingComponent();
          return void 0 !== initialValue ? initialValue : value;
        },
        useTransition: function() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        },
        useId: function() {
          var treeId = currentlyRenderingTask.treeContext;
          var overflow = treeId.overflow;
          treeId = treeId.id;
          treeId = (treeId & ~(1 << 32 - clz32(treeId) - 1)).toString(32) + overflow;
          var resumableState = currentResumableState;
          if (null === resumableState)
            throw Error(
              "Invalid hook call. Hooks can only be called inside of the body of a function component."
            );
          overflow = localIdCounter++;
          treeId = "\xAB" + resumableState.idPrefix + "R" + treeId;
          0 < overflow && (treeId += "H" + overflow.toString(32));
          return treeId + "\xBB";
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          if (void 0 === getServerSnapshot)
            throw Error(
              "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
            );
          return getServerSnapshot();
        },
        useOptimistic: function(passthrough) {
          resolveCurrentlyRenderingComponent();
          return [passthrough, unsupportedSetOptimisticState];
        },
        useActionState,
        useFormState: useActionState,
        useHostTransitionStatus: function() {
          resolveCurrentlyRenderingComponent();
          return NotPending;
        },
        useMemoCache: function(size) {
          for (var data = Array(size), i = 0; i < size; i++)
            data[i] = REACT_MEMO_CACHE_SENTINEL;
          return data;
        },
        useCacheRefresh: function() {
          return unsupportedRefresh;
        }
      }, currentResumableState = null, currentTaskInDEV = null, DefaultAsyncDispatcher = {
        getCacheForType: function() {
          throw Error("Not implemented.");
        },
        getOwner: function() {
          return null === currentTaskInDEV ? null : currentTaskInDEV.componentStack;
        }
      }, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      disabledLog.__reactDisabledLog = true;
      var prefix, suffix, reentry = false;
      var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
      var callComponent = {
        react_stack_bottom_frame: function(Component, props, secondArg) {
          return Component(props, secondArg);
        }
      }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
        react_stack_bottom_frame: function(instance) {
          return instance.render();
        }
      }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callLazyInit = {
        react_stack_bottom_frame: function(lazy) {
          var init = lazy._init;
          return init(lazy._payload);
        }
      }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), lastResetTime = 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        var getCurrentTime = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date;
        getCurrentTime = function() {
          return localDate.now();
        };
      }
      var CLIENT_RENDERED = 4, PENDING = 0, COMPLETED = 1, FLUSHED = 2, POSTPONED = 5, CLOSED = 14, currentRequest = null, didWarnAboutBadClass = {}, didWarnAboutContextTypes = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = false, didWarnAboutGenerators = false, didWarnAboutMaps = false;
      exports2.renderToStaticMarkup = function(children, options) {
        return renderToStringImpl(
          children,
          options,
          true,
          'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server'
        );
      };
      exports2.renderToString = function(children, options) {
        return renderToStringImpl(
          children,
          options,
          false,
          'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server'
        );
      };
      exports2.version = "19.1.1";
    })();
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.development.js
var require_react_dom_server_node_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.development.js"(exports2) {
    "use strict";
    "production" !== process.env.NODE_ENV && (function() {
      function styleReplacer(match, prefix2, s2, suffix2) {
        return "" + prefix2 + ("s" === s2 ? "\\73 " : "\\53 ") + suffix2;
      }
      function scriptReplacer(match, prefix2, s2, suffix2) {
        return "" + prefix2 + ("s" === s2 ? "\\u0073" : "\\u0053") + suffix2;
      }
      function objectName(object) {
        return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
          return p0;
        });
      }
      function describeKeyForErrorMessage(key) {
        var encodedKey = JSON.stringify(key);
        return '"' + key + '"' === encodedKey ? key : encodedKey;
      }
      function describeValueForErrorMessage(value) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(
              10 >= value.length ? value : value.slice(0, 10) + "..."
            );
          case "object":
            if (isArrayImpl(value)) return "[...]";
            if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
              return "client";
            value = objectName(value);
            return "Object" === value ? "{...}" : value;
          case "function":
            return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
          default:
            return String(value);
        }
      }
      function describeElementType(type) {
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeElementType(type.render);
            case REACT_MEMO_TYPE:
              return describeElementType(type.type);
            case REACT_LAZY_TYPE:
              var payload = type._payload;
              type = type._init;
              try {
                return describeElementType(type(payload));
              } catch (x) {
              }
          }
        return "";
      }
      function describeObjectForErrorMessage(objectOrArray, expandedName) {
        var objKind = objectName(objectOrArray);
        if ("Object" !== objKind && "Array" !== objKind) return objKind;
        var start = -1, length = 0;
        if (isArrayImpl(objectOrArray))
          if (jsxChildrenParents.has(objectOrArray)) {
            var type = jsxChildrenParents.get(objectOrArray);
            objKind = "<" + describeElementType(type) + ">";
            for (var i = 0; i < objectOrArray.length; i++) {
              var value = objectOrArray[i];
              value = "string" === typeof value ? value : "object" === typeof value && null !== value ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
              "" + i === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
            }
            objKind += "</" + describeElementType(type) + ">";
          } else {
            objKind = "[";
            for (type = 0; type < objectOrArray.length; type++)
              0 < type && (objKind += ", "), i = objectOrArray[type], i = "object" === typeof i && null !== i ? describeObjectForErrorMessage(i) : describeValueForErrorMessage(i), "" + type === expandedName ? (start = objKind.length, length = i.length, objKind += i) : objKind = 10 > i.length && 40 > objKind.length + i.length ? objKind + i : objKind + "...";
            objKind += "]";
          }
        else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
          objKind = "<" + describeElementType(objectOrArray.type) + "/>";
        else {
          if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
          if (jsxPropsParents.has(objectOrArray)) {
            objKind = jsxPropsParents.get(objectOrArray);
            objKind = "<" + (describeElementType(objKind) || "...");
            type = Object.keys(objectOrArray);
            for (i = 0; i < type.length; i++) {
              objKind += " ";
              value = type[i];
              objKind += describeKeyForErrorMessage(value) + "=";
              var _value2 = objectOrArray[value];
              var _substr2 = value === expandedName && "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
              "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
              value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
            }
            objKind += ">";
          } else {
            objKind = "{";
            type = Object.keys(objectOrArray);
            for (i = 0; i < type.length; i++)
              0 < i && (objKind += ", "), value = type[i], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
            objKind += "}";
          }
        }
        return void 0 === expandedName ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), "\n  " + objKind + "\n  " + objectOrArray) : "\n  " + objKind;
      }
      function flushBuffered(destination) {
        "function" === typeof destination.flush && destination.flush();
      }
      function writeChunk(destination, chunk) {
        if ("string" === typeof chunk) {
          if (0 !== chunk.length)
            if (2048 < 3 * chunk.length)
              0 < writtenBytes && (writeToDestination(
                destination,
                currentView.subarray(0, writtenBytes)
              ), currentView = new Uint8Array(2048), writtenBytes = 0), writeToDestination(destination, chunk);
            else {
              var target = currentView;
              0 < writtenBytes && (target = currentView.subarray(writtenBytes));
              target = textEncoder.encodeInto(chunk, target);
              var read = target.read;
              writtenBytes += target.written;
              read < chunk.length && (writeToDestination(
                destination,
                currentView.subarray(0, writtenBytes)
              ), currentView = new Uint8Array(2048), writtenBytes = textEncoder.encodeInto(
                chunk.slice(read),
                currentView
              ).written);
              2048 === writtenBytes && (writeToDestination(destination, currentView), currentView = new Uint8Array(2048), writtenBytes = 0);
            }
        } else
          0 !== chunk.byteLength && (2048 < chunk.byteLength ? (0 < writtenBytes && (writeToDestination(
            destination,
            currentView.subarray(0, writtenBytes)
          ), currentView = new Uint8Array(2048), writtenBytes = 0), writeToDestination(destination, chunk)) : (target = currentView.length - writtenBytes, target < chunk.byteLength && (0 === target ? writeToDestination(destination, currentView) : (currentView.set(chunk.subarray(0, target), writtenBytes), writtenBytes += target, writeToDestination(destination, currentView), chunk = chunk.subarray(target)), currentView = new Uint8Array(2048), writtenBytes = 0), currentView.set(chunk, writtenBytes), writtenBytes += chunk.byteLength, 2048 === writtenBytes && (writeToDestination(destination, currentView), currentView = new Uint8Array(2048), writtenBytes = 0)));
      }
      function writeToDestination(destination, view) {
        destination = destination.write(view);
        destinationHasCapacity$1 = destinationHasCapacity$1 && destination;
      }
      function writeChunkAndReturn(destination, chunk) {
        writeChunk(destination, chunk);
        return destinationHasCapacity$1;
      }
      function completeWriting(destination) {
        currentView && 0 < writtenBytes && destination.write(currentView.subarray(0, writtenBytes));
        currentView = null;
        writtenBytes = 0;
        destinationHasCapacity$1 = true;
      }
      function stringToPrecomputedChunk(content) {
        content = textEncoder.encode(content);
        2048 < content.byteLength && console.error(
          "precomputed chunks must be smaller than the view size configured for this host. This is a bug in React."
        );
        return content;
      }
      function typeName(value) {
        return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
      }
      function willCoercionThrow(value) {
        try {
          return testStringCoercion(value), false;
        } catch (e2) {
          return true;
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
            attributeName,
            typeName(value)
          ), testStringCoercion(value);
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
            propName,
            typeName(value)
          ), testStringCoercion(value);
      }
      function checkHtmlStringCoercion(value) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(value)
          ), testStringCoercion(value);
      }
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
          return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        console.error("Invalid attribute name: `%s`", attributeName);
        return false;
      }
      function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
        ) : console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
        ));
        props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
          "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
        );
      }
      function validateProperty$1(tagName, name2) {
        if (hasOwnProperty.call(warnedProperties$1, name2) && warnedProperties$1[name2])
          return true;
        if (rARIACamel$1.test(name2)) {
          tagName = "aria-" + name2.slice(4).toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
              name2
            ), warnedProperties$1[name2] = true;
          if (name2 !== tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. Did you mean `%s`?",
              name2,
              tagName
            ), warnedProperties$1[name2] = true;
        }
        if (rARIA$1.test(name2)) {
          tagName = name2.toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName) return warnedProperties$1[name2] = true, false;
          name2 !== tagName && (console.error(
            "Unknown ARIA attribute `%s`. Did you mean `%s`?",
            name2,
            tagName
          ), warnedProperties$1[name2] = true);
        }
        return true;
      }
      function validateProperties$2(type, props) {
        var invalidProps = [], key;
        for (key in props)
          validateProperty$1(type, key) || invalidProps.push(key);
        props = invalidProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === invalidProps.length ? console.error(
          "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type
        ) : 1 < invalidProps.length && console.error(
          "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type
        );
      }
      function validateProperty(tagName, name2, value, eventRegistry) {
        if (hasOwnProperty.call(warnedProperties, name2) && warnedProperties[name2])
          return true;
        var lowerCasedName = name2.toLowerCase();
        if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
          return console.error(
            "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
          ), warnedProperties[name2] = true;
        if ("function" === typeof value && ("form" === tagName && "action" === name2 || "input" === tagName && "formAction" === name2 || "button" === tagName && "formAction" === name2))
          return true;
        if (null != eventRegistry) {
          tagName = eventRegistry.possibleRegistrationNames;
          if (eventRegistry.registrationNameDependencies.hasOwnProperty(name2))
            return true;
          eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
          if (null != eventRegistry)
            return console.error(
              "Invalid event handler property `%s`. Did you mean `%s`?",
              name2,
              eventRegistry
            ), warnedProperties[name2] = true;
          if (EVENT_NAME_REGEX.test(name2))
            return console.error(
              "Unknown event handler property `%s`. It will be ignored.",
              name2
            ), warnedProperties[name2] = true;
        } else if (EVENT_NAME_REGEX.test(name2))
          return INVALID_EVENT_NAME_REGEX.test(name2) && console.error(
            "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
            name2
          ), warnedProperties[name2] = true;
        if (rARIA.test(name2) || rARIACamel.test(name2)) return true;
        if ("innerhtml" === lowerCasedName)
          return console.error(
            "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
          ), warnedProperties[name2] = true;
        if ("aria" === lowerCasedName)
          return console.error(
            "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
          ), warnedProperties[name2] = true;
        if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
          return console.error(
            "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
            typeof value
          ), warnedProperties[name2] = true;
        if ("number" === typeof value && isNaN(value))
          return console.error(
            "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
            name2
          ), warnedProperties[name2] = true;
        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
          if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name2)
            return console.error(
              "Invalid DOM property `%s`. Did you mean `%s`?",
              name2,
              lowerCasedName
            ), warnedProperties[name2] = true;
        } else if (name2 !== lowerCasedName)
          return console.error(
            "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
            name2,
            lowerCasedName
          ), warnedProperties[name2] = true;
        switch (name2) {
          case "dangerouslySetInnerHTML":
          case "children":
          case "style":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            return true;
          case "innerText":
          case "textContent":
            return true;
        }
        switch (typeof value) {
          case "boolean":
            switch (name2) {
              case "autoFocus":
              case "checked":
              case "multiple":
              case "muted":
              case "selected":
              case "contentEditable":
              case "spellCheck":
              case "draggable":
              case "value":
              case "autoReverse":
              case "externalResourcesRequired":
              case "focusable":
              case "preserveAlpha":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "capture":
              case "download":
              case "inert":
                return true;
              default:
                lowerCasedName = name2.toLowerCase().slice(0, 5);
                if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                  return true;
                value ? console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                  value,
                  name2,
                  name2,
                  value,
                  name2
                ) : console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                  value,
                  name2,
                  name2,
                  value,
                  name2,
                  name2,
                  name2
                );
                return warnedProperties[name2] = true;
            }
          case "function":
          case "symbol":
            return warnedProperties[name2] = true, false;
          case "string":
            if ("false" === value || "true" === value) {
              switch (name2) {
                case "checked":
                case "selected":
                case "multiple":
                case "muted":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "inert":
                  break;
                default:
                  return true;
              }
              console.error(
                "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                value,
                name2,
                "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                name2,
                value
              );
              warnedProperties[name2] = true;
            }
        }
        return true;
      }
      function warnUnknownProperties(type, props, eventRegistry) {
        var unknownProps = [], key;
        for (key in props)
          validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
        props = unknownProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === unknownProps.length ? console.error(
          "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type
        ) : 1 < unknownProps.length && console.error(
          "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type
        );
      }
      function camelize(string) {
        return string.replace(hyphenPattern, function(_3, character) {
          return character.toUpperCase();
        });
      }
      function escapeTextForBrowser(text) {
        if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text)
          return "" + text;
        checkHtmlStringCoercion(text);
        text = "" + text;
        var match = matchHtmlRegExp.exec(text);
        if (match) {
          var html = "", index, lastIndex = 0;
          for (index = match.index; index < text.length; index++) {
            switch (text.charCodeAt(index)) {
              case 34:
                match = "&quot;";
                break;
              case 38:
                match = "&amp;";
                break;
              case 39:
                match = "&#x27;";
                break;
              case 60:
                match = "&lt;";
                break;
              case 62:
                match = "&gt;";
                break;
              default:
                continue;
            }
            lastIndex !== index && (html += text.slice(lastIndex, index));
            lastIndex = index + 1;
            html += match;
          }
          text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
        }
        return text;
      }
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      function escapeEntireInlineScriptContent(scriptText) {
        checkHtmlStringCoercion(scriptText);
        return ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      function createRenderState(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {
        var inlineScriptWithNonce = void 0 === nonce ? startInlineScript : stringToPrecomputedChunk(
          '<script nonce="' + escapeTextForBrowser(nonce) + '">'
        ), idPrefix = resumableState.idPrefix;
        externalRuntimeConfig = [];
        var bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
        void 0 !== bootstrapScriptContent && externalRuntimeConfig.push(
          inlineScriptWithNonce,
          escapeEntireInlineScriptContent(bootstrapScriptContent),
          endInlineScript
        );
        bootstrapScriptContent = [];
        void 0 !== importMap && (bootstrapScriptContent.push(importMapScriptStart), bootstrapScriptContent.push(
          escapeEntireInlineScriptContent(JSON.stringify(importMap))
        ), bootstrapScriptContent.push(importMapScriptEnd));
        onHeaders && "number" === typeof maxHeadersLength && 0 >= maxHeadersLength && console.error(
          "React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.",
          0 === maxHeadersLength ? "zero" : maxHeadersLength
        );
        importMap = onHeaders ? {
          preconnects: "",
          fontPreloads: "",
          highImagePreloads: "",
          remainingCapacity: 2 + ("number" === typeof maxHeadersLength ? maxHeadersLength : 2e3)
        } : null;
        onHeaders = {
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
          boundaryPrefix: stringToPrecomputedChunk(idPrefix + "B:"),
          startInlineScript: inlineScriptWithNonce,
          preamble: createPreambleState(),
          externalRuntimeScript: null,
          bootstrapChunks: externalRuntimeConfig,
          importMapChunks: bootstrapScriptContent,
          onHeaders,
          headers: importMap,
          resets: {
            font: {},
            dns: {},
            connect: { default: {}, anonymous: {}, credentials: {} },
            image: {},
            style: {}
          },
          charsetChunks: [],
          viewportChunks: [],
          hoistableChunks: [],
          preconnects: /* @__PURE__ */ new Set(),
          fontPreloads: /* @__PURE__ */ new Set(),
          highImagePreloads: /* @__PURE__ */ new Set(),
          styles: /* @__PURE__ */ new Map(),
          bootstrapScripts: /* @__PURE__ */ new Set(),
          scripts: /* @__PURE__ */ new Set(),
          bulkPreloads: /* @__PURE__ */ new Set(),
          preloads: {
            images: /* @__PURE__ */ new Map(),
            stylesheets: /* @__PURE__ */ new Map(),
            scripts: /* @__PURE__ */ new Map(),
            moduleScripts: /* @__PURE__ */ new Map()
          },
          nonce,
          hoistableState: null,
          stylesToHoist: false
        };
        if (void 0 !== bootstrapScripts)
          for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {
            maxHeadersLength = bootstrapScripts[importMap];
            bootstrapScriptContent = idPrefix = void 0;
            var props = {
              rel: "preload",
              as: "script",
              fetchPriority: "low",
              nonce
            };
            "string" === typeof maxHeadersLength ? props.href = inlineScriptWithNonce = maxHeadersLength : (props.href = inlineScriptWithNonce = maxHeadersLength.src, props.integrity = bootstrapScriptContent = "string" === typeof maxHeadersLength.integrity ? maxHeadersLength.integrity : void 0, props.crossOrigin = idPrefix = "string" === typeof maxHeadersLength || null == maxHeadersLength.crossOrigin ? void 0 : "use-credentials" === maxHeadersLength.crossOrigin ? "use-credentials" : "");
            preloadBootstrapScriptOrModule(
              resumableState,
              onHeaders,
              inlineScriptWithNonce,
              props
            );
            externalRuntimeConfig.push(
              startScriptSrc,
              escapeTextForBrowser(inlineScriptWithNonce)
            );
            nonce && externalRuntimeConfig.push(
              scriptNonce,
              escapeTextForBrowser(nonce)
            );
            "string" === typeof bootstrapScriptContent && externalRuntimeConfig.push(
              scriptIntegirty,
              escapeTextForBrowser(bootstrapScriptContent)
            );
            "string" === typeof idPrefix && externalRuntimeConfig.push(
              scriptCrossOrigin,
              escapeTextForBrowser(idPrefix)
            );
            externalRuntimeConfig.push(endAsyncScript);
          }
        if (void 0 !== bootstrapModules)
          for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++)
            importMap = bootstrapModules[bootstrapScripts], idPrefix = inlineScriptWithNonce = void 0, bootstrapScriptContent = {
              rel: "modulepreload",
              fetchPriority: "low",
              nonce
            }, "string" === typeof importMap ? bootstrapScriptContent.href = maxHeadersLength = importMap : (bootstrapScriptContent.href = maxHeadersLength = importMap.src, bootstrapScriptContent.integrity = idPrefix = "string" === typeof importMap.integrity ? importMap.integrity : void 0, bootstrapScriptContent.crossOrigin = inlineScriptWithNonce = "string" === typeof importMap || null == importMap.crossOrigin ? void 0 : "use-credentials" === importMap.crossOrigin ? "use-credentials" : ""), preloadBootstrapScriptOrModule(
              resumableState,
              onHeaders,
              maxHeadersLength,
              bootstrapScriptContent
            ), externalRuntimeConfig.push(
              startModuleSrc,
              escapeTextForBrowser(maxHeadersLength)
            ), nonce && externalRuntimeConfig.push(
              scriptNonce,
              escapeTextForBrowser(nonce)
            ), "string" === typeof idPrefix && externalRuntimeConfig.push(
              scriptIntegirty,
              escapeTextForBrowser(idPrefix)
            ), "string" === typeof inlineScriptWithNonce && externalRuntimeConfig.push(
              scriptCrossOrigin,
              escapeTextForBrowser(inlineScriptWithNonce)
            ), externalRuntimeConfig.push(endAsyncScript);
        return onHeaders;
      }
      function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        return {
          idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
          nextFormID: 0,
          streamingFormat: 0,
          bootstrapScriptContent,
          bootstrapScripts,
          bootstrapModules,
          instructions: NothingSent,
          hasBody: false,
          hasHtml: false,
          unknownResources: {},
          dnsResources: {},
          connectResources: { default: {}, anonymous: {}, credentials: {} },
          imageResources: {},
          styleResources: {},
          scriptResources: {},
          moduleUnknownResources: {},
          moduleScriptResources: {}
        };
      }
      function createPreambleState() {
        return {
          htmlChunks: null,
          headChunks: null,
          bodyChunks: null,
          contribution: NoContribution
        };
      }
      function createFormatContext(insertionMode, selectedValue, tagScope) {
        return {
          insertionMode,
          selectedValue,
          tagScope
        };
      }
      function createRootFormatContext(namespaceURI) {
        return createFormatContext(
          "http://www.w3.org/2000/svg" === namespaceURI ? SVG_MODE : "http://www.w3.org/1998/Math/MathML" === namespaceURI ? MATHML_MODE : ROOT_HTML_MODE,
          null,
          0
        );
      }
      function getChildFormatContext(parentContext, type, props) {
        switch (type) {
          case "noscript":
            return createFormatContext(
              HTML_MODE,
              null,
              parentContext.tagScope | 1
            );
          case "select":
            return createFormatContext(
              HTML_MODE,
              null != props.value ? props.value : props.defaultValue,
              parentContext.tagScope
            );
          case "svg":
            return createFormatContext(SVG_MODE, null, parentContext.tagScope);
          case "picture":
            return createFormatContext(
              HTML_MODE,
              null,
              parentContext.tagScope | 2
            );
          case "math":
            return createFormatContext(MATHML_MODE, null, parentContext.tagScope);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null, parentContext.tagScope);
          case "table":
            return createFormatContext(
              HTML_TABLE_MODE,
              null,
              parentContext.tagScope
            );
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(
              HTML_TABLE_BODY_MODE,
              null,
              parentContext.tagScope
            );
          case "colgroup":
            return createFormatContext(
              HTML_COLGROUP_MODE,
              null,
              parentContext.tagScope
            );
          case "tr":
            return createFormatContext(
              HTML_TABLE_ROW_MODE,
              null,
              parentContext.tagScope
            );
          case "head":
            if (parentContext.insertionMode < HTML_MODE)
              return createFormatContext(
                HTML_HEAD_MODE,
                null,
                parentContext.tagScope
              );
            break;
          case "html":
            if (parentContext.insertionMode === ROOT_HTML_MODE)
              return createFormatContext(
                HTML_HTML_MODE,
                null,
                parentContext.tagScope
              );
        }
        return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode < HTML_MODE ? createFormatContext(HTML_MODE, null, parentContext.tagScope) : parentContext;
      }
      function pushTextInstance(target, text, renderState, textEmbedded) {
        if ("" === text) return textEmbedded;
        textEmbedded && target.push(textSeparator);
        target.push(escapeTextForBrowser(text));
        return true;
      }
      function pushStyleAttribute(target, style) {
        if ("object" !== typeof style)
          throw Error(
            "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
          );
        var isFirst = true, styleName;
        for (styleName in style)
          if (hasOwnProperty.call(style, styleName)) {
            var styleValue = style[styleName];
            if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
              if (0 === styleName.indexOf("--")) {
                var nameChunk = escapeTextForBrowser(styleName);
                checkCSSPropertyStringCoercion(styleValue, styleName);
                styleValue = escapeTextForBrowser(("" + styleValue).trim());
              } else {
                nameChunk = styleName;
                var value = styleValue;
                if (-1 < nameChunk.indexOf("-")) {
                  var name2 = nameChunk;
                  warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2] || (warnedStyleNames[name2] = true, console.error(
                    "Unsupported style property %s. Did you mean %s?",
                    name2,
                    camelize(name2.replace(msPattern$1, "ms-"))
                  ));
                } else if (badVendoredStyleNamePattern.test(nameChunk))
                  name2 = nameChunk, warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2] || (warnedStyleNames[name2] = true, console.error(
                    "Unsupported vendor-prefixed style property %s. Did you mean %s?",
                    name2,
                    name2.charAt(0).toUpperCase() + name2.slice(1)
                  ));
                else if (badStyleValueWithSemicolonPattern.test(value)) {
                  name2 = nameChunk;
                  var value$jscomp$0 = value;
                  warnedStyleValues.hasOwnProperty(value$jscomp$0) && warnedStyleValues[value$jscomp$0] || (warnedStyleValues[value$jscomp$0] = true, console.error(
                    `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
                    name2,
                    value$jscomp$0.replace(
                      badStyleValueWithSemicolonPattern,
                      ""
                    )
                  ));
                }
                "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
                  "`NaN` is an invalid value for the `%s` css style property.",
                  nameChunk
                )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
                  "`Infinity` is an invalid value for the `%s` css style property.",
                  nameChunk
                )));
                nameChunk = styleName;
                value = styleNameCache.get(nameChunk);
                void 0 !== value ? nameChunk = value : (value = stringToPrecomputedChunk(
                  escapeTextForBrowser(
                    nameChunk.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")
                  )
                ), styleNameCache.set(nameChunk, value), nameChunk = value);
                "number" === typeof styleValue ? styleValue = 0 === styleValue || unitlessNumbers.has(styleName) ? "" + styleValue : styleValue + "px" : (checkCSSPropertyStringCoercion(styleValue, styleName), styleValue = escapeTextForBrowser(
                  ("" + styleValue).trim()
                ));
              }
              isFirst ? (isFirst = false, target.push(
                styleAttributeStart,
                nameChunk,
                styleAssign,
                styleValue
              )) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);
            }
          }
        isFirst || target.push(attributeEnd);
      }
      function pushBooleanAttribute(target, name2, value) {
        value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name2, attributeEmptyString);
      }
      function pushStringAttribute(target, name2, value) {
        "function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(
          attributeSeparator,
          name2,
          attributeAssign,
          escapeTextForBrowser(value),
          attributeEnd
        );
      }
      function pushAdditionalFormField(value, key) {
        this.push(startHiddenInputChunk);
        validateAdditionalFormField(value);
        pushStringAttribute(this, "name", key);
        pushStringAttribute(this, "value", value);
        this.push(endOfStartTagSelfClosing);
      }
      function validateAdditionalFormField(value) {
        if ("string" !== typeof value)
          throw Error(
            "File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration."
          );
      }
      function getCustomFormFields(resumableState, formAction) {
        if ("function" === typeof formAction.$$FORM_ACTION) {
          var id = resumableState.nextFormID++;
          resumableState = resumableState.idPrefix + id;
          try {
            var customFields = formAction.$$FORM_ACTION(resumableState);
            if (customFields) {
              var formData = customFields.data;
              null != formData && formData.forEach(validateAdditionalFormField);
            }
            return customFields;
          } catch (x) {
            if ("object" === typeof x && null !== x && "function" === typeof x.then)
              throw x;
            console.error(
              "Failed to serialize an action for progressive enhancement:\n%s",
              x
            );
          }
        }
        return null;
      }
      function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name2) {
        var formData = null;
        if ("function" === typeof formAction) {
          null === name2 || didWarnFormActionName || (didWarnFormActionName = true, console.error(
            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
          ));
          null === formEncType && null === formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
          ));
          null === formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
          ));
          var customFields = getCustomFormFields(resumableState, formAction);
          null !== customFields ? (name2 = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(
            attributeSeparator,
            "formAction",
            attributeAssign,
            actionJavaScriptURL,
            attributeEnd
          ), formTarget = formMethod = formEncType = formAction = name2 = null, injectFormReplayingRuntime(resumableState, renderState));
        }
        null != name2 && pushAttribute(target, "name", name2);
        null != formAction && pushAttribute(target, "formAction", formAction);
        null != formEncType && pushAttribute(target, "formEncType", formEncType);
        null != formMethod && pushAttribute(target, "formMethod", formMethod);
        null != formTarget && pushAttribute(target, "formTarget", formTarget);
        return formData;
      }
      function pushAttribute(target, name2, value) {
        switch (name2) {
          case "className":
            pushStringAttribute(target, "class", value);
            break;
          case "tabIndex":
            pushStringAttribute(target, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            pushStringAttribute(target, name2, value);
            break;
          case "style":
            pushStyleAttribute(target, value);
            break;
          case "src":
          case "href":
            if ("" === value) {
              "src" === name2 ? console.error(
                'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                name2,
                name2
              ) : console.error(
                'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                name2,
                name2
              );
              break;
            }
          case "action":
          case "formAction":
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
              break;
            checkAttributeStringCoercion(value, name2);
            value = sanitizeURL("" + value);
            target.push(
              attributeSeparator,
              name2,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "ref":
            break;
          case "autoFocus":
          case "multiple":
          case "muted":
            pushBooleanAttribute(target, name2.toLowerCase(), value);
            break;
          case "xlinkHref":
            if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
              break;
            checkAttributeStringCoercion(value, name2);
            value = sanitizeURL("" + value);
            target.push(
              attributeSeparator,
              "xlink:href",
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              name2,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "inert":
            "" !== value || didWarnForNewBooleanPropsWithEmptyValue[name2] || (didWarnForNewBooleanPropsWithEmptyValue[name2] = true, console.error(
              "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
              name2
            ));
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name2, attributeEmptyString);
            break;
          case "capture":
          case "download":
            true === value ? target.push(attributeSeparator, name2, attributeEmptyString) : false !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              name2,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(
              attributeSeparator,
              name2,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "rowSpan":
          case "start":
            "function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(
              attributeSeparator,
              name2,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "xlinkActuate":
            pushStringAttribute(target, "xlink:actuate", value);
            break;
          case "xlinkArcrole":
            pushStringAttribute(target, "xlink:arcrole", value);
            break;
          case "xlinkRole":
            pushStringAttribute(target, "xlink:role", value);
            break;
          case "xlinkShow":
            pushStringAttribute(target, "xlink:show", value);
            break;
          case "xlinkTitle":
            pushStringAttribute(target, "xlink:title", value);
            break;
          case "xlinkType":
            pushStringAttribute(target, "xlink:type", value);
            break;
          case "xmlBase":
            pushStringAttribute(target, "xml:base", value);
            break;
          case "xmlLang":
            pushStringAttribute(target, "xml:lang", value);
            break;
          case "xmlSpace":
            pushStringAttribute(target, "xml:space", value);
            break;
          default:
            if (!(2 < name2.length) || "o" !== name2[0] && "O" !== name2[0] || "n" !== name2[1] && "N" !== name2[1]) {
              if (name2 = aliases.get(name2) || name2, isAttributeNameSafe(name2)) {
                switch (typeof value) {
                  case "function":
                  case "symbol":
                    return;
                  case "boolean":
                    var prefix2 = name2.toLowerCase().slice(0, 5);
                    if ("data-" !== prefix2 && "aria-" !== prefix2) return;
                }
                target.push(
                  attributeSeparator,
                  name2,
                  attributeAssign,
                  escapeTextForBrowser(value),
                  attributeEnd
                );
              }
            }
        }
      }
      function pushInnerHTML(target, innerHTML, children) {
        if (null != innerHTML) {
          if (null != children)
            throw Error(
              "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
            );
          if ("object" !== typeof innerHTML || !("__html" in innerHTML))
            throw Error(
              "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
            );
          innerHTML = innerHTML.__html;
          null !== innerHTML && void 0 !== innerHTML && (checkHtmlStringCoercion(innerHTML), target.push("" + innerHTML));
        }
      }
      function checkSelectProp(props, propName) {
        var value = props[propName];
        null != value && (value = isArrayImpl(value), props.multiple && !value ? console.error(
          "The `%s` prop supplied to <select> must be an array if `multiple` is true.",
          propName
        ) : !props.multiple && value && console.error(
          "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.",
          propName
        ));
      }
      function flattenOptionChildren(children) {
        var content = "";
        React12.Children.forEach(children, function(child) {
          null != child && (content += child, didWarnInvalidOptionChildren || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || (didWarnInvalidOptionChildren = true, console.error(
            "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
          )));
        });
        return content;
      }
      function injectFormReplayingRuntime(resumableState, renderState) {
        (resumableState.instructions & 16) === NothingSent && (resumableState.instructions |= 16, renderState.bootstrapChunks.unshift(
          renderState.startInlineScript,
          formReplayingRuntimeScript,
          endInlineScript
        ));
      }
      function pushLinkImpl(target, props) {
        target.push(startChunkForTag("link"));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function escapeStyleTextContent(styleText) {
        checkHtmlStringCoercion(styleText);
        return ("" + styleText).replace(styleRegex, styleReplacer);
      }
      function pushSelfClosing(target, props, tag) {
        target.push(startChunkForTag(tag));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushTitleImpl(target, props) {
        target.push(startChunkForTag("title"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
        "function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(escapeTextForBrowser("" + props));
        pushInnerHTML(target, innerHTML, children);
        target.push(endChunkForTag("title"));
        return null;
      }
      function pushScriptImpl(target, props) {
        target.push(startChunkForTag("script"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        null != children && "string" !== typeof children && (props = "number" === typeof children ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error(
          "A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.",
          props
        ));
        pushInnerHTML(target, innerHTML, children);
        "string" === typeof children && target.push(escapeEntireInlineScriptContent(children));
        target.push(endChunkForTag("script"));
        return null;
      }
      function pushStartSingletonElement(target, props, tag) {
        target.push(startChunkForTag(tag));
        var innerHTML = tag = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  tag = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, tag);
        return tag;
      }
      function pushStartGenericElement(target, props, tag) {
        target.push(startChunkForTag(tag));
        var innerHTML = tag = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  tag = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, tag);
        return "string" === typeof tag ? (target.push(escapeTextForBrowser(tag)), null) : tag;
      }
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (void 0 === tagStartChunk) {
          if (!VALID_TAG_REGEX.test(tag)) throw Error("Invalid tag: " + tag);
          tagStartChunk = stringToPrecomputedChunk("<" + tag);
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      function pushStartInstance(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded, isFallback) {
        validateProperties$2(type, props);
        "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
          "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
          type
        ) : console.error(
          "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
          type
        ));
        b: if (-1 === type.indexOf("-")) var JSCompiler_inline_result = false;
        else
          switch (type) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              JSCompiler_inline_result = false;
              break b;
            default:
              JSCompiler_inline_result = true;
          }
        JSCompiler_inline_result || "string" === typeof props.is || warnUnknownProperties(type, props, null);
        !props.suppressContentEditableWarning && props.contentEditable && null != props.children && console.error(
          "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
        );
        formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && -1 === type.indexOf("-") && type.toLowerCase() !== type && console.error(
          "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
          type
        );
        switch (type) {
          case "div":
          case "span":
          case "svg":
          case "path":
            break;
          case "a":
            target$jscomp$0.push(startChunkForTag("a"));
            var children = null, innerHTML = null, propKey;
            for (propKey in props)
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "children":
                      children = propValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML = propValue;
                      break;
                    case "href":
                      "" === propValue ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                      break;
                    default:
                      pushAttribute(target$jscomp$0, propKey, propValue);
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML, children);
            if ("string" === typeof children) {
              target$jscomp$0.push(escapeTextForBrowser(children));
              var JSCompiler_inline_result$jscomp$0 = null;
            } else JSCompiler_inline_result$jscomp$0 = children;
            return JSCompiler_inline_result$jscomp$0;
          case "g":
          case "p":
          case "li":
            break;
          case "select":
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultSelectValue || (console.error(
              "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
            ), didWarnDefaultSelectValue = true);
            target$jscomp$0.push(startChunkForTag("select"));
            var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
            for (propKey$jscomp$0 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$0)) {
                var propValue$jscomp$0 = props[propKey$jscomp$0];
                if (null != propValue$jscomp$0)
                  switch (propKey$jscomp$0) {
                    case "children":
                      children$jscomp$0 = propValue$jscomp$0;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$0 = propValue$jscomp$0;
                      break;
                    case "defaultValue":
                    case "value":
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$0,
                        propValue$jscomp$0
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
            return children$jscomp$0;
          case "option":
            var selectedValue = formatContext.selectedValue;
            target$jscomp$0.push(startChunkForTag("option"));
            var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
            for (propKey$jscomp$1 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$1)) {
                var propValue$jscomp$1 = props[propKey$jscomp$1];
                if (null != propValue$jscomp$1)
                  switch (propKey$jscomp$1) {
                    case "children":
                      children$jscomp$1 = propValue$jscomp$1;
                      break;
                    case "selected":
                      selected = propValue$jscomp$1;
                      didWarnSelectedSetOnOption || (console.error(
                        "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
                      ), didWarnSelectedSetOnOption = true);
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$1 = propValue$jscomp$1;
                      break;
                    case "value":
                      value = propValue$jscomp$1;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$1,
                        propValue$jscomp$1
                      );
                  }
              }
            if (null != selectedValue) {
              if (null !== value) {
                checkAttributeStringCoercion(value, "value");
                var stringValue = "" + value;
              } else
                null === innerHTML$jscomp$1 || didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = true, console.error(
                  "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
                )), stringValue = flattenOptionChildren(children$jscomp$1);
              if (isArrayImpl(selectedValue))
                for (var i = 0; i < selectedValue.length; i++) {
                  if (checkAttributeStringCoercion(selectedValue[i], "value"), "" + selectedValue[i] === stringValue) {
                    target$jscomp$0.push(selectedMarkerAttribute);
                    break;
                  }
                }
              else
                checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(selectedMarkerAttribute);
            } else selected && target$jscomp$0.push(selectedMarkerAttribute);
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
            return children$jscomp$1;
          case "textarea":
            checkControlledValueProps("textarea", props);
            void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultTextareaValue || (console.error(
              "Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"
            ), didWarnDefaultTextareaValue = true);
            target$jscomp$0.push(startChunkForTag("textarea"));
            var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
            for (propKey$jscomp$2 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$2)) {
                var propValue$jscomp$2 = props[propKey$jscomp$2];
                if (null != propValue$jscomp$2)
                  switch (propKey$jscomp$2) {
                    case "children":
                      children$jscomp$2 = propValue$jscomp$2;
                      break;
                    case "value":
                      value$jscomp$0 = propValue$jscomp$2;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$jscomp$2;
                      break;
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                      );
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$2,
                        propValue$jscomp$2
                      );
                  }
              }
            null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
            target$jscomp$0.push(endOfStartTag);
            if (null != children$jscomp$2) {
              console.error(
                "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
              );
              if (null != value$jscomp$0)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children$jscomp$2)) {
                if (1 < children$jscomp$2.length)
                  throw Error("<textarea> can only have at most one child.");
                checkHtmlStringCoercion(children$jscomp$2[0]);
                value$jscomp$0 = "" + children$jscomp$2[0];
              }
              checkHtmlStringCoercion(children$jscomp$2);
              value$jscomp$0 = "" + children$jscomp$2;
            }
            "string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline);
            null !== value$jscomp$0 && (checkAttributeStringCoercion(value$jscomp$0, "value"), target$jscomp$0.push(escapeTextForBrowser("" + value$jscomp$0)));
            return null;
          case "input":
            checkControlledValueProps("input", props);
            target$jscomp$0.push(startChunkForTag("input"));
            var name2 = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
            for (propKey$jscomp$3 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$3)) {
                var propValue$jscomp$3 = props[propKey$jscomp$3];
                if (null != propValue$jscomp$3)
                  switch (propKey$jscomp$3) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    case "name":
                      name2 = propValue$jscomp$3;
                      break;
                    case "formAction":
                      formAction = propValue$jscomp$3;
                      break;
                    case "formEncType":
                      formEncType = propValue$jscomp$3;
                      break;
                    case "formMethod":
                      formMethod = propValue$jscomp$3;
                      break;
                    case "formTarget":
                      formTarget = propValue$jscomp$3;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$jscomp$3;
                      break;
                    case "defaultValue":
                      defaultValue$jscomp$0 = propValue$jscomp$3;
                      break;
                    case "checked":
                      checked = propValue$jscomp$3;
                      break;
                    case "value":
                      value$jscomp$1 = propValue$jscomp$3;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$3,
                        propValue$jscomp$3
                      );
                  }
              }
            null === formAction || "image" === props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
              'An input can only specify a formAction along with type="submit" or type="image".'
            ));
            var formData = pushFormActionAttribute(
              target$jscomp$0,
              resumableState,
              renderState,
              formAction,
              formEncType,
              formMethod,
              formTarget,
              name2
            );
            null === checked || null === defaultChecked || didWarnDefaultChecked || (console.error(
              "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              "A component",
              props.type
            ), didWarnDefaultChecked = true);
            null === value$jscomp$1 || null === defaultValue$jscomp$0 || didWarnDefaultInputValue || (console.error(
              "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              "A component",
              props.type
            ), didWarnDefaultInputValue = true);
            null !== checked ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
            null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
            target$jscomp$0.push(endOfStartTagSelfClosing);
            null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);
            return null;
          case "button":
            target$jscomp$0.push(startChunkForTag("button"));
            var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
            for (propKey$jscomp$4 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$4)) {
                var propValue$jscomp$4 = props[propKey$jscomp$4];
                if (null != propValue$jscomp$4)
                  switch (propKey$jscomp$4) {
                    case "children":
                      children$jscomp$3 = propValue$jscomp$4;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$2 = propValue$jscomp$4;
                      break;
                    case "name":
                      name$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formAction":
                      formAction$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formEncType":
                      formEncType$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formMethod":
                      formMethod$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formTarget":
                      formTarget$jscomp$0 = propValue$jscomp$4;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$4,
                        propValue$jscomp$4
                      );
                  }
              }
            null === formAction$jscomp$0 || null == props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
              'A button can only specify a formAction along with type="submit" or no type.'
            ));
            var formData$jscomp$0 = pushFormActionAttribute(
              target$jscomp$0,
              resumableState,
              renderState,
              formAction$jscomp$0,
              formEncType$jscomp$0,
              formMethod$jscomp$0,
              formTarget$jscomp$0,
              name$jscomp$0
            );
            target$jscomp$0.push(endOfStartTag);
            null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
            if ("string" === typeof children$jscomp$3) {
              target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));
              var JSCompiler_inline_result$jscomp$1 = null;
            } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
            return JSCompiler_inline_result$jscomp$1;
          case "form":
            target$jscomp$0.push(startChunkForTag("form"));
            var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
            for (propKey$jscomp$5 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$5)) {
                var propValue$jscomp$5 = props[propKey$jscomp$5];
                if (null != propValue$jscomp$5)
                  switch (propKey$jscomp$5) {
                    case "children":
                      children$jscomp$4 = propValue$jscomp$5;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$3 = propValue$jscomp$5;
                      break;
                    case "action":
                      formAction$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "encType":
                      formEncType$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "method":
                      formMethod$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "target":
                      formTarget$jscomp$1 = propValue$jscomp$5;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$5,
                        propValue$jscomp$5
                      );
                  }
              }
            var formData$jscomp$1 = null, formActionName = null;
            if ("function" === typeof formAction$jscomp$1) {
              null === formEncType$jscomp$1 && null === formMethod$jscomp$1 || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              ));
              null === formTarget$jscomp$1 || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ));
              var customFields = getCustomFormFields(
                resumableState,
                formAction$jscomp$1
              );
              null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(
                attributeSeparator,
                "action",
                attributeAssign,
                actionJavaScriptURL,
                attributeEnd
              ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
            }
            null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
            null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
            null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
            null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
            target$jscomp$0.push(endOfStartTag);
            null !== formActionName && (target$jscomp$0.push(startHiddenInputChunk), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), null != formData$jscomp$1 && formData$jscomp$1.forEach(
              pushAdditionalFormField,
              target$jscomp$0
            ));
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
            if ("string" === typeof children$jscomp$4) {
              target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));
              var JSCompiler_inline_result$jscomp$2 = null;
            } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
            return JSCompiler_inline_result$jscomp$2;
          case "menuitem":
            target$jscomp$0.push(startChunkForTag("menuitem"));
            for (var propKey$jscomp$6 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$6)) {
                var propValue$jscomp$6 = props[propKey$jscomp$6];
                if (null != propValue$jscomp$6)
                  switch (propKey$jscomp$6) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "menuitems cannot have `children` nor `dangerouslySetInnerHTML`."
                      );
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$6,
                        propValue$jscomp$6
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            return null;
          case "object":
            target$jscomp$0.push(startChunkForTag("object"));
            var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
            for (propKey$jscomp$7 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$7)) {
                var propValue$jscomp$7 = props[propKey$jscomp$7];
                if (null != propValue$jscomp$7)
                  switch (propKey$jscomp$7) {
                    case "children":
                      children$jscomp$5 = propValue$jscomp$7;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$4 = propValue$jscomp$7;
                      break;
                    case "data":
                      checkAttributeStringCoercion(propValue$jscomp$7, "data");
                      var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                      if ("" === sanitizedValue) {
                        console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          propKey$jscomp$7,
                          propKey$jscomp$7
                        );
                        break;
                      }
                      target$jscomp$0.push(
                        attributeSeparator,
                        "data",
                        attributeAssign,
                        escapeTextForBrowser(sanitizedValue),
                        attributeEnd
                      );
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$7,
                        propValue$jscomp$7
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
            if ("string" === typeof children$jscomp$5) {
              target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));
              var JSCompiler_inline_result$jscomp$3 = null;
            } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
            return JSCompiler_inline_result$jscomp$3;
          case "title":
            var insertionMode = formatContext.insertionMode, noscriptTagInScope = !!(formatContext.tagScope & 1);
            if (hasOwnProperty.call(props, "children")) {
              var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
              Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.",
                children$jscomp$6.length
              ) : "function" === typeof child || "symbol" === typeof child ? console.error(
                "React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.",
                "function" === typeof child ? "a Function" : "a Sybmol"
              ) : child && child.toString === {}.toString && (null != child.$$typeof ? console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML."
              ) : console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."
              ));
            }
            if (insertionMode === SVG_MODE || noscriptTagInScope || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(
                target$jscomp$0,
                props
              );
            else
              isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = void 0);
            return JSCompiler_inline_result$jscomp$4;
          case "link":
            var rel = props.rel, href = props.href, precedence = props.precedence;
            if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
              "stylesheet" === rel && "string" === typeof props.precedence && ("string" === typeof href && href || console.error(
                'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',
                null === href ? "`null`" : void 0 === href ? "`undefined`" : "" === href ? "an empty string" : 'something with type "' + typeof href + '"'
              ));
              pushLinkImpl(target$jscomp$0, props);
              var JSCompiler_inline_result$jscomp$5 = null;
            } else if ("stylesheet" === props.rel)
              if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError) {
                if ("string" === typeof precedence) {
                  if (null != props.disabled)
                    console.error(
                      'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'
                    );
                  else if (props.onLoad || props.onError) {
                    var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
                    console.error(
                      'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                      propDescription,
                      propDescription
                    );
                  }
                }
                JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                  target$jscomp$0,
                  props
                );
              } else {
                var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(
                  href
                ) ? resumableState.styleResources[href] : void 0;
                if (resourceState !== EXISTS) {
                  resumableState.styleResources[href] = EXISTS;
                  styleQueue || (styleQueue = {
                    precedence: escapeTextForBrowser(precedence),
                    rules: [],
                    hrefs: [],
                    sheets: /* @__PURE__ */ new Map()
                  }, renderState.styles.set(precedence, styleQueue));
                  var resource = {
                    state: PENDING$1,
                    props: assign({}, props, {
                      "data-precedence": props.precedence,
                      precedence: null
                    })
                  };
                  if (resourceState) {
                    2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);
                    var preloadResource = renderState.preloads.stylesheets.get(href);
                    preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED;
                  }
                  styleQueue.sheets.set(href, resource);
                  hoistableState && hoistableState.stylesheets.add(resource);
                } else if (styleQueue) {
                  var _resource = styleQueue.sheets.get(href);
                  _resource && hoistableState && hoistableState.stylesheets.add(_resource);
                }
                textEmbedded && target$jscomp$0.push(textSeparator);
                JSCompiler_inline_result$jscomp$5 = null;
              }
            else
              props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                target$jscomp$0,
                props
              ) : (textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$5 = isFallback ? null : pushLinkImpl(renderState.hoistableChunks, props));
            return JSCompiler_inline_result$jscomp$5;
          case "script":
            var asyncProp = props.async;
            if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(
                target$jscomp$0,
                props
              );
            else {
              var key = props.src;
              if ("module" === props.type) {
                var resources = resumableState.moduleScriptResources;
                var preloads = renderState.preloads.moduleScripts;
              } else
                resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
              var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
              if (resourceState$jscomp$0 !== EXISTS) {
                resources[key] = EXISTS;
                var scriptProps = props;
                if (resourceState$jscomp$0) {
                  2 === resourceState$jscomp$0.length && (scriptProps = assign({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
                  var preloadResource$jscomp$0 = preloads.get(key);
                  preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
                }
                var resource$jscomp$0 = [];
                renderState.scripts.add(resource$jscomp$0);
                pushScriptImpl(resource$jscomp$0, scriptProps);
              }
              textEmbedded && target$jscomp$0.push(textSeparator);
              JSCompiler_inline_result$jscomp$6 = null;
            }
            return JSCompiler_inline_result$jscomp$6;
          case "style":
            var insertionMode$jscomp$0 = formatContext.insertionMode, noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);
            if (hasOwnProperty.call(props, "children")) {
              var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
              ("function" === typeof child$jscomp$0 || "symbol" === typeof child$jscomp$0 || Array.isArray(child$jscomp$0)) && console.error(
                "React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.",
                "function" === typeof child$jscomp$0 ? "a Function" : "symbol" === typeof child$jscomp$0 ? "a Sybmol" : "an Array"
              );
            }
            var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href;
            if (insertionMode$jscomp$0 === SVG_MODE || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
              target$jscomp$0.push(startChunkForTag("style"));
              var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
              for (propKey$jscomp$8 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$8)) {
                  var propValue$jscomp$8 = props[propKey$jscomp$8];
                  if (null != propValue$jscomp$8)
                    switch (propKey$jscomp$8) {
                      case "children":
                        children$jscomp$8 = propValue$jscomp$8;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$5 = propValue$jscomp$8;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$8,
                          propValue$jscomp$8
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
              "function" !== typeof child$jscomp$1 && "symbol" !== typeof child$jscomp$1 && null !== child$jscomp$1 && void 0 !== child$jscomp$1 && target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));
              pushInnerHTML(
                target$jscomp$0,
                innerHTML$jscomp$5,
                children$jscomp$8
              );
              target$jscomp$0.push(endChunkForTag("style"));
              var JSCompiler_inline_result$jscomp$7 = null;
            } else {
              href$jscomp$0.includes(" ") && console.error(
                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is "%s".',
                href$jscomp$0
              );
              var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0;
              if (resourceState$jscomp$1 !== EXISTS) {
                resumableState.styleResources[href$jscomp$0] = EXISTS;
                resourceState$jscomp$1 && console.error(
                  'React encountered a hoistable style tag for the same href as a preload: "%s". When using a style tag to inline styles you should not also preload it as a stylsheet.',
                  href$jscomp$0
                );
                styleQueue$jscomp$0 ? styleQueue$jscomp$0.hrefs.push(
                  escapeTextForBrowser(href$jscomp$0)
                ) : (styleQueue$jscomp$0 = {
                  precedence: escapeTextForBrowser(precedence$jscomp$0),
                  rules: [],
                  hrefs: [escapeTextForBrowser(href$jscomp$0)],
                  sheets: /* @__PURE__ */ new Map()
                }, renderState.styles.set(
                  precedence$jscomp$0,
                  styleQueue$jscomp$0
                ));
                var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
                for (propKey$jscomp$9 in props)
                  if (hasOwnProperty.call(props, propKey$jscomp$9)) {
                    var propValue$jscomp$9 = props[propKey$jscomp$9];
                    if (null != propValue$jscomp$9)
                      switch (propKey$jscomp$9) {
                        case "children":
                          children$jscomp$9 = propValue$jscomp$9;
                          break;
                        case "dangerouslySetInnerHTML":
                          innerHTML$jscomp$6 = propValue$jscomp$9;
                      }
                  }
                var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
                "function" !== typeof child$jscomp$2 && "symbol" !== typeof child$jscomp$2 && null !== child$jscomp$2 && void 0 !== child$jscomp$2 && target.push(escapeStyleTextContent(child$jscomp$2));
                pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);
              }
              styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
              textEmbedded && target$jscomp$0.push(textSeparator);
              JSCompiler_inline_result$jscomp$7 = void 0;
            }
            return JSCompiler_inline_result$jscomp$7;
          case "meta":
            if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(
                target$jscomp$0,
                props,
                "meta"
              );
            else
              textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$8 = isFallback ? null : "string" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(
                renderState.hoistableChunks,
                props,
                "meta"
              );
            return JSCompiler_inline_result$jscomp$8;
          case "listing":
          case "pre":
            target$jscomp$0.push(startChunkForTag(type));
            var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
            for (propKey$jscomp$10 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$10)) {
                var propValue$jscomp$10 = props[propKey$jscomp$10];
                if (null != propValue$jscomp$10)
                  switch (propKey$jscomp$10) {
                    case "children":
                      children$jscomp$10 = propValue$jscomp$10;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$7 = propValue$jscomp$10;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$10,
                        propValue$jscomp$10
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            if (null != innerHTML$jscomp$7) {
              if (null != children$jscomp$10)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7))
                throw Error(
                  "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                );
              var html = innerHTML$jscomp$7.__html;
              null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push(leadingNewline, html) : (checkHtmlStringCoercion(html), target$jscomp$0.push("" + html)));
            }
            "string" === typeof children$jscomp$10 && "\n" === children$jscomp$10[0] && target$jscomp$0.push(leadingNewline);
            return children$jscomp$10;
          case "img":
            var src = props.src, srcSet = props.srcSet;
            if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet) && "low" !== props.fetchPriority && false === !!(formatContext.tagScope & 3) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
              var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
              if (resource$jscomp$1) {
                if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size)
                  promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
              } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
                resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
                var input = props.crossOrigin;
                var crossOrigin = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
                var headers = renderState.headers, header;
                headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
                  imageSrcSet: props.srcSet,
                  imageSizes: props.sizes,
                  crossOrigin,
                  integrity: props.integrity,
                  nonce: props.nonce,
                  type: props.type,
                  fetchPriority: props.fetchPriority,
                  referrerPolicy: props.refererPolicy
                }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
                  rel: "preload",
                  as: "image",
                  href: srcSet ? void 0 : src,
                  imageSrcSet: srcSet,
                  imageSizes: sizes,
                  crossOrigin,
                  integrity: props.integrity,
                  type: props.type,
                  fetchPriority: props.fetchPriority,
                  referrerPolicy: props.referrerPolicy
                }), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
              }
            }
            return pushSelfClosing(target$jscomp$0, props, "img");
          case "base":
          case "area":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "param":
          case "source":
          case "track":
          case "wbr":
            return pushSelfClosing(target$jscomp$0, props, type);
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            break;
          case "head":
            if (formatContext.insertionMode < HTML_MODE) {
              var preamble = preambleState || renderState.preamble;
              if (preamble.headChunks)
                throw Error("The `<head>` tag may only be rendered once.");
              preamble.headChunks = [];
              var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(
                preamble.headChunks,
                props,
                "head"
              );
            } else
              JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "head"
              );
            return JSCompiler_inline_result$jscomp$9;
          case "body":
            if (formatContext.insertionMode < HTML_MODE) {
              var preamble$jscomp$0 = preambleState || renderState.preamble;
              if (preamble$jscomp$0.bodyChunks)
                throw Error("The `<body>` tag may only be rendered once.");
              preamble$jscomp$0.bodyChunks = [];
              var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(
                preamble$jscomp$0.bodyChunks,
                props,
                "body"
              );
            } else
              JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "body"
              );
            return JSCompiler_inline_result$jscomp$10;
          case "html":
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              var preamble$jscomp$1 = preambleState || renderState.preamble;
              if (preamble$jscomp$1.htmlChunks)
                throw Error("The `<html>` tag may only be rendered once.");
              preamble$jscomp$1.htmlChunks = [doctypeChunk];
              var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(
                preamble$jscomp$1.htmlChunks,
                props,
                "html"
              );
            } else
              JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "html"
              );
            return JSCompiler_inline_result$jscomp$11;
          default:
            if (-1 !== type.indexOf("-")) {
              target$jscomp$0.push(startChunkForTag(type));
              var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
              for (propKey$jscomp$11 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$11)) {
                  var propValue$jscomp$11 = props[propKey$jscomp$11];
                  if (null != propValue$jscomp$11) {
                    var attributeName = propKey$jscomp$11;
                    switch (propKey$jscomp$11) {
                      case "children":
                        children$jscomp$11 = propValue$jscomp$11;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$8 = propValue$jscomp$11;
                        break;
                      case "style":
                        pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                        break;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "ref":
                        break;
                      case "className":
                        attributeName = "class";
                      default:
                        if (isAttributeNameSafe(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {
                          if (true === propValue$jscomp$11)
                            propValue$jscomp$11 = "";
                          else if ("object" === typeof propValue$jscomp$11)
                            continue;
                          target$jscomp$0.push(
                            attributeSeparator,
                            attributeName,
                            attributeAssign,
                            escapeTextForBrowser(propValue$jscomp$11),
                            attributeEnd
                          );
                        }
                    }
                  }
                }
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(
                target$jscomp$0,
                innerHTML$jscomp$8,
                children$jscomp$11
              );
              return children$jscomp$11;
            }
        }
        return pushStartGenericElement(target$jscomp$0, props, type);
      }
      function endChunkForTag(tag) {
        var chunk = endTagCache.get(tag);
        void 0 === chunk && (chunk = stringToPrecomputedChunk("</" + tag + ">"), endTagCache.set(tag, chunk));
        return chunk;
      }
      function hoistPreambleState(renderState, preambleState) {
        renderState = renderState.preamble;
        null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks, preambleState.contribution |= 1);
        null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks, preambleState.contribution |= 4);
        null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks, preambleState.contribution |= 2);
      }
      function writeBootstrap(destination, renderState) {
        renderState = renderState.bootstrapChunks;
        for (var i = 0; i < renderState.length - 1; i++)
          writeChunk(destination, renderState[i]);
        return i < renderState.length ? (i = renderState[i], renderState.length = 0, writeChunkAndReturn(destination, i)) : true;
      }
      function writeStartPendingSuspenseBoundary(destination, renderState, id) {
        writeChunk(destination, startPendingSuspenseBoundary1);
        if (null === id)
          throw Error(
            "An ID must have been assigned before we can complete the boundary."
          );
        writeChunk(destination, renderState.boundaryPrefix);
        writeChunk(destination, id.toString(16));
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      function writePreambleContribution(destination, preambleState) {
        preambleState = preambleState.contribution;
        preambleState !== NoContribution && (writeChunk(destination, boundaryPreambleContributionChunkStart), writeChunk(destination, "" + preambleState), writeChunk(destination, boundaryPreambleContributionChunkEnd));
      }
      function writeStartSegment(destination, renderState, formatContext, id) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_HTML_MODE:
          case HTML_HEAD_MODE:
          case HTML_MODE:
            return writeChunk(destination, startSegmentHTML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentHTML2);
          case SVG_MODE:
            return writeChunk(destination, startSegmentSVG), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentSVG2);
          case MATHML_MODE:
            return writeChunk(destination, startSegmentMathML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentMathML2);
          case HTML_TABLE_MODE:
            return writeChunk(destination, startSegmentTable), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTable2);
          case HTML_TABLE_BODY_MODE:
            return writeChunk(destination, startSegmentTableBody), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTableBody2);
          case HTML_TABLE_ROW_MODE:
            return writeChunk(destination, startSegmentTableRow), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentTableRow2);
          case HTML_COLGROUP_MODE:
            return writeChunk(destination, startSegmentColGroup), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), writeChunkAndReturn(destination, startSegmentColGroup2);
          default:
            throw Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_HTML_MODE:
          case HTML_HEAD_MODE:
          case HTML_MODE:
            return writeChunkAndReturn(destination, endSegmentHTML);
          case SVG_MODE:
            return writeChunkAndReturn(destination, endSegmentSVG);
          case MATHML_MODE:
            return writeChunkAndReturn(destination, endSegmentMathML);
          case HTML_TABLE_MODE:
            return writeChunkAndReturn(destination, endSegmentTable);
          case HTML_TABLE_BODY_MODE:
            return writeChunkAndReturn(destination, endSegmentTableBody);
          case HTML_TABLE_ROW_MODE:
            return writeChunkAndReturn(destination, endSegmentTableRow);
          case HTML_COLGROUP_MODE:
            return writeChunkAndReturn(destination, endSegmentColGroup);
          default:
            throw Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      function escapeJSStringsForInstructionScripts(input) {
        return JSON.stringify(input).replace(
          regexForJSStringsInInstructionScripts,
          function(match) {
            switch (match) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default:
                throw Error(
                  "escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                );
            }
          }
        );
      }
      function escapeJSObjectForInstructionScripts(input) {
        return JSON.stringify(input).replace(
          regexForJSStringsInScripts,
          function(match) {
            switch (match) {
              case "&":
                return "\\u0026";
              case ">":
                return "\\u003e";
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default:
                throw Error(
                  "escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                );
            }
          }
        );
      }
      function flushStyleTagsLateForBoundary(styleQueue) {
        var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
        0 < rules.length && 0 === hrefs.length && console.error(
          "React expected to have at least one href for an a hoistable style but found none. This is a bug in React."
        );
        var i = 0;
        if (hrefs.length) {
          writeChunk(this, lateStyleTagResourceOpen1);
          writeChunk(this, styleQueue.precedence);
          for (writeChunk(this, lateStyleTagResourceOpen2); i < hrefs.length - 1; i++)
            writeChunk(this, hrefs[i]), writeChunk(this, spaceSeparator);
          writeChunk(this, hrefs[i]);
          writeChunk(this, lateStyleTagResourceOpen3);
          for (i = 0; i < rules.length; i++) writeChunk(this, rules[i]);
          destinationHasCapacity = writeChunkAndReturn(
            this,
            lateStyleTagTemplateClose
          );
          currentlyRenderingBoundaryHasStylesToHoist = true;
          rules.length = 0;
          hrefs.length = 0;
        }
      }
      function hasStylesToHoist(stylesheet) {
        return stylesheet.state !== PREAMBLE ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
      }
      function writeHoistablesForBoundary(destination, hoistableState, renderState) {
        currentlyRenderingBoundaryHasStylesToHoist = false;
        destinationHasCapacity = true;
        hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
        hoistableState.stylesheets.forEach(hasStylesToHoist);
        currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
        return destinationHasCapacity;
      }
      function flushResource(resource) {
        for (var i = 0; i < resource.length; i++) writeChunk(this, resource[i]);
        resource.length = 0;
      }
      function flushStyleInPreamble(stylesheet) {
        pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
        for (var i = 0; i < stylesheetFlushingQueue.length; i++)
          writeChunk(this, stylesheetFlushingQueue[i]);
        stylesheetFlushingQueue.length = 0;
        stylesheet.state = PREAMBLE;
      }
      function flushStylesInPreamble(styleQueue) {
        var hasStylesheets = 0 < styleQueue.sheets.size;
        styleQueue.sheets.forEach(flushStyleInPreamble, this);
        styleQueue.sheets.clear();
        var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
        if (!hasStylesheets || hrefs.length) {
          writeChunk(this, styleTagResourceOpen1);
          writeChunk(this, styleQueue.precedence);
          styleQueue = 0;
          if (hrefs.length) {
            for (writeChunk(this, styleTagResourceOpen2); styleQueue < hrefs.length - 1; styleQueue++)
              writeChunk(this, hrefs[styleQueue]), writeChunk(this, spaceSeparator);
            writeChunk(this, hrefs[styleQueue]);
          }
          writeChunk(this, styleTagResourceOpen3);
          for (styleQueue = 0; styleQueue < rules.length; styleQueue++)
            writeChunk(this, rules[styleQueue]);
          writeChunk(this, styleTagResourceClose);
          rules.length = 0;
          hrefs.length = 0;
        }
      }
      function preloadLateStyle(stylesheet) {
        if (stylesheet.state === PENDING$1) {
          stylesheet.state = PRELOADED;
          var props = stylesheet.props;
          pushLinkImpl(stylesheetFlushingQueue, {
            rel: "preload",
            as: "style",
            href: stylesheet.props.href,
            crossOrigin: props.crossOrigin,
            fetchPriority: props.fetchPriority,
            integrity: props.integrity,
            media: props.media,
            hrefLang: props.hrefLang,
            referrerPolicy: props.referrerPolicy
          });
          for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)
            writeChunk(this, stylesheetFlushingQueue[stylesheet]);
          stylesheetFlushingQueue.length = 0;
        }
      }
      function preloadLateStyles(styleQueue) {
        styleQueue.sheets.forEach(preloadLateStyle, this);
        styleQueue.sheets.clear();
      }
      function writeStyleResourceDependenciesInJS(destination, hoistableState) {
        writeChunk(destination, arrayFirstOpenBracket);
        var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
        hoistableState.stylesheets.forEach(function(resource) {
          if (resource.state !== PREAMBLE)
            if (resource.state === LATE)
              writeChunk(destination, nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion(resource, "href"), writeChunk(
                destination,
                escapeJSObjectForInstructionScripts("" + resource)
              ), writeChunk(destination, arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
            else {
              writeChunk(destination, nextArrayOpenBrackChunk);
              var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
              writeChunk(
                destination,
                escapeJSObjectForInstructionScripts(coercedHref)
              );
              checkAttributeStringCoercion(precedence, "precedence");
              precedence = "" + precedence;
              writeChunk(destination, arrayInterstitial);
              writeChunk(
                destination,
                escapeJSObjectForInstructionScripts(precedence)
              );
              for (var propKey in props)
                if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], null != precedence))
                  switch (propKey) {
                    case "href":
                    case "rel":
                    case "precedence":
                    case "data-precedence":
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      writeStyleResourceAttributeInJS(
                        destination,
                        propKey,
                        precedence
                      );
                  }
              writeChunk(destination, arrayCloseBracket);
              nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
              resource.state = LATE;
            }
        });
        writeChunk(destination, arrayCloseBracket);
      }
      function writeStyleResourceAttributeInJS(destination, name2, value) {
        var attributeName = name2.toLowerCase();
        switch (typeof value) {
          case "function":
          case "symbol":
            return;
        }
        switch (name2) {
          case "innerHTML":
          case "dangerouslySetInnerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "style":
          case "ref":
            return;
          case "className":
            attributeName = "class";
            checkAttributeStringCoercion(value, attributeName);
            name2 = "" + value;
            break;
          case "hidden":
            if (false === value) return;
            name2 = "";
            break;
          case "src":
          case "href":
            value = sanitizeURL(value);
            checkAttributeStringCoercion(value, attributeName);
            name2 = "" + value;
            break;
          default:
            if (2 < name2.length && ("o" === name2[0] || "O" === name2[0]) && ("n" === name2[1] || "N" === name2[1]) || !isAttributeNameSafe(name2))
              return;
            checkAttributeStringCoercion(value, attributeName);
            name2 = "" + value;
        }
        writeChunk(destination, arrayInterstitial);
        writeChunk(
          destination,
          escapeJSObjectForInstructionScripts(attributeName)
        );
        writeChunk(destination, arrayInterstitial);
        writeChunk(destination, escapeJSObjectForInstructionScripts(name2));
      }
      function createHoistableState() {
        return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set() };
      }
      function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {
        (resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error(
          'Internal React Error: React expected bootstrap script or module with src "%s" to not have been preloaded already. please file an issue',
          href
        );
        resumableState.scriptResources[href] = EXISTS;
        resumableState.moduleScriptResources[href] = EXISTS;
        resumableState = [];
        pushLinkImpl(resumableState, props);
        renderState.bootstrapScripts.add(resumableState);
      }
      function adoptPreloadCredentials(target, preloadState) {
        null == target.crossOrigin && (target.crossOrigin = preloadState[0]);
        null == target.integrity && (target.integrity = preloadState[1]);
      }
      function getPreloadAsHeader(href, as3, params) {
        href = escapeHrefForLinkHeaderURLContext(href);
        as3 = escapeStringForLinkHeaderQuotedParamValueContext(as3, "as");
        as3 = "<" + href + '>; rel=preload; as="' + as3 + '"';
        for (var paramName in params)
          hasOwnProperty.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as3 += "; " + paramName.toLowerCase() + '="' + escapeStringForLinkHeaderQuotedParamValueContext(
            href,
            paramName
          ) + '"'));
        return as3;
      }
      function escapeHrefForLinkHeaderURLContext(hrefInput) {
        checkAttributeStringCoercion(hrefInput, "href");
        return ("" + hrefInput).replace(
          regexForHrefInLinkHeaderURLContext,
          escapeHrefForLinkHeaderURLContextReplacer
        );
      }
      function escapeHrefForLinkHeaderURLContextReplacer(match) {
        switch (match) {
          case "<":
            return "%3C";
          case ">":
            return "%3E";
          case "\n":
            return "%0A";
          case "\r":
            return "%0D";
          default:
            throw Error(
              "escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
      function escapeStringForLinkHeaderQuotedParamValueContext(value, name2) {
        willCoercionThrow(value) && (console.error(
          "The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.",
          name2,
          typeName(value)
        ), testStringCoercion(value));
        return ("" + value).replace(
          regexForLinkHeaderQuotedParamValueContext,
          escapeStringForLinkHeaderQuotedParamValueContextReplacer
        );
      }
      function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {
        switch (match) {
          case '"':
            return "%22";
          case "'":
            return "%27";
          case ";":
            return "%3B";
          case ",":
            return "%2C";
          case "\n":
            return "%0A";
          case "\r":
            return "%0D";
          default:
            throw Error(
              "escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
      function hoistStyleQueueDependency(styleQueue) {
        this.styles.add(styleQueue);
      }
      function hoistStylesheetDependency(stylesheet) {
        this.stylesheets.add(stylesheet);
      }
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev !== next) {
          prev.context._currentValue = prev.parentValue;
          prev = prev.parent;
          var parentNext = next.parent;
          if (null === prev) {
            if (null !== parentNext)
              throw Error(
                "The stacks must reach the root at the same time. This is a bug in React."
              );
          } else {
            if (null === parentNext)
              throw Error(
                "The stacks must reach the root at the same time. This is a bug in React."
              );
            popToNearestCommonAncestor(prev, parentNext);
          }
          next.context._currentValue = next.value;
        }
      }
      function popAllPrevious(prev) {
        prev.context._currentValue = prev.parentValue;
        prev = prev.parent;
        null !== prev && popAllPrevious(prev);
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        null !== parentNext && pushAllNext(parentNext);
        next.context._currentValue = next.value;
      }
      function popPreviousToCommonLevel(prev, next) {
        prev.context._currentValue = prev.parentValue;
        prev = prev.parent;
        if (null === prev)
          throw Error(
            "The depth must equal at least at zero before reaching the root. This is a bug in React."
          );
        prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (null === parentNext)
          throw Error(
            "The depth must equal at least at zero before reaching the root. This is a bug in React."
          );
        prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
        next.context._currentValue = next.value;
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
      }
      function warnOnInvalidCallback(callback) {
        if (null !== callback && "function" !== typeof callback) {
          var key = String(callback);
          didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ));
        }
      }
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType(publicInstance) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnAboutNoopUpdateForComponent[warningKey] || (console.error(
          "Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.",
          callerName,
          publicInstance
        ), didWarnAboutNoopUpdateForComponent[warningKey] = true);
      }
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        baseContext = baseContext.overflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          return {
            id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
            overflow: length + baseContext
          };
        }
        return {
          id: 1 << length | index << baseLength | baseIdWithLeadingBit,
          overflow: baseContext
        };
      }
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
      }
      function noop$2() {
      }
      function trackUsedThenable(thenableState2, thenable, index) {
        index = thenableState2[index];
        void 0 === index ? thenableState2.push(thenable) : index !== thenable && (thenable.then(noop$2, noop$2), thenable = index);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            "string" === typeof thenable.status ? thenable.then(noop$2, noop$2) : (thenableState2 = thenable, thenableState2.status = "pending", thenableState2.then(
              function(fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function(error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            ));
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      function getSuspendedThenable() {
        if (null === suspendedThenable)
          throw Error(
            "Expected a suspended thenable. This is a bug in React. Please file an issue."
          );
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function is3(x, y2) {
        return x === y2 && (0 !== x || 1 / x === 1 / y2) || x !== x && y2 !== y2;
      }
      function resolveCurrentlyRenderingComponent() {
        if (null === currentlyRenderingComponent)
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        isInHookUserCodeInDev && console.error(
          "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
        );
        return currentlyRenderingComponent;
      }
      function createHook() {
        if (0 < numberOfReRenders)
          throw Error("Rendered more hooks than during the previous render");
        return { memoizedState: null, queue: null, next: null };
      }
      function createWorkInProgressHook() {
        null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
        return workInProgressHook;
      }
      function getThenableStateAfterSuspending() {
        var state = thenableState;
        thenableState = null;
        return state;
      }
      function resetHooksState() {
        isInHookUserCodeInDev = false;
        currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        workInProgressHook = renderPhaseUpdates = null;
      }
      function readContext(context) {
        isInHookUserCodeInDev && console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
        return context._currentValue;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function useReducer(reducer, initialArg, init) {
        reducer !== basicStateReducer && (currentHookNameInDev = "useReducer");
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          init = workInProgressHook.queue;
          initialArg = init.dispatch;
          if (null !== renderPhaseUpdates) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);
            if (void 0 !== firstRenderPhaseUpdate) {
              renderPhaseUpdates.delete(init);
              init = workInProgressHook.memoizedState;
              do {
                var action = firstRenderPhaseUpdate.action;
                isInHookUserCodeInDev = true;
                init = reducer(init, action);
                isInHookUserCodeInDev = false;
                firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
              } while (null !== firstRenderPhaseUpdate);
              workInProgressHook.memoizedState = init;
              return [init, initialArg];
            }
          }
          return [workInProgressHook.memoizedState, initialArg];
        }
        isInHookUserCodeInDev = true;
        reducer = reducer === basicStateReducer ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init ? init(initialArg) : initialArg;
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = reducer;
        reducer = workInProgressHook.queue = { last: null, dispatch: null };
        reducer = reducer.dispatch = dispatchAction.bind(
          null,
          currentlyRenderingComponent,
          reducer
        );
        return [workInProgressHook.memoizedState, reducer];
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        if (null !== workInProgressHook) {
          var prevState = workInProgressHook.memoizedState;
          if (null !== prevState && null !== deps) {
            a: {
              var JSCompiler_inline_result = prevState[1];
              if (null === JSCompiler_inline_result)
                console.error(
                  "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
                  currentHookNameInDev
                ), JSCompiler_inline_result = false;
              else {
                deps.length !== JSCompiler_inline_result.length && console.error(
                  "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
                  currentHookNameInDev,
                  "[" + deps.join(", ") + "]",
                  "[" + JSCompiler_inline_result.join(", ") + "]"
                );
                for (var i = 0; i < JSCompiler_inline_result.length && i < deps.length; i++)
                  if (!objectIs(deps[i], JSCompiler_inline_result[i])) {
                    JSCompiler_inline_result = false;
                    break a;
                  }
                JSCompiler_inline_result = true;
              }
            }
            if (JSCompiler_inline_result) return prevState[0];
          }
        }
        isInHookUserCodeInDev = true;
        nextCreate = nextCreate();
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = [nextCreate, deps];
        return nextCreate;
      }
      function dispatchAction(componentIdentity, queue, action) {
        if (25 <= numberOfReRenders)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        if (componentIdentity === currentlyRenderingComponent)
          if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)
            renderPhaseUpdates.set(queue, componentIdentity);
          else {
            for (queue = action; null !== queue.next; ) queue = queue.next;
            queue.next = componentIdentity;
          }
      }
      function unsupportedStartTransition() {
        throw Error("startTransition cannot be called during server rendering.");
      }
      function unsupportedSetOptimisticState() {
        throw Error("Cannot update optimistic state while rendering.");
      }
      function createPostbackActionStateKey(permalink, componentKeyPath, hookIndex) {
        if (void 0 !== permalink) return "p" + permalink;
        permalink = JSON.stringify([componentKeyPath, null, hookIndex]);
        componentKeyPath = crypto.createHash("md5");
        componentKeyPath.update(permalink);
        return "k" + componentKeyPath.digest("hex");
      }
      function useActionState(action, initialState, permalink) {
        resolveCurrentlyRenderingComponent();
        var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
        if ("function" === typeof action.$$FORM_ACTION) {
          var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
          request = request.formState;
          var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
          if (null !== request && "function" === typeof isSignatureEqual) {
            var postbackKey = request[1];
            isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = createPostbackActionStateKey(
              permalink,
              componentKeyPath,
              actionStateHookIndex
            ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
          }
          var boundAction = action.bind(null, initialState);
          action = function(payload) {
            boundAction(payload);
          };
          "function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix2) {
            prefix2 = boundAction.$$FORM_ACTION(prefix2);
            void 0 !== permalink && (checkAttributeStringCoercion(permalink, "target"), permalink += "", prefix2.action = permalink);
            var formData = prefix2.data;
            formData && (null === nextPostbackStateKey && (nextPostbackStateKey = createPostbackActionStateKey(
              permalink,
              componentKeyPath,
              actionStateHookIndex
            )), formData.append("$ACTION_KEY", nextPostbackStateKey));
            return prefix2;
          });
          return [initialState, action, false];
        }
        var _boundAction = action.bind(null, initialState);
        return [
          initialState,
          function(payload) {
            _boundAction(payload);
          },
          false
        ];
      }
      function unwrapThenable(thenable) {
        var index = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        return trackUsedThenable(thenableState, thenable, index);
      }
      function unsupportedRefresh() {
        throw Error("Cache cannot be refreshed during server rendering.");
      }
      function noop$1() {
      }
      function disabledLog() {
      }
      function disableLogs() {
        if (0 === disabledDepth) {
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd;
          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          };
          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
        }
        disabledDepth++;
      }
      function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
          var props = { configurable: true, enumerable: true, writable: true };
          Object.defineProperties(console, {
            log: assign({}, props, { value: prevLog }),
            info: assign({}, props, { value: prevInfo }),
            warn: assign({}, props, { value: prevWarn }),
            error: assign({}, props, { value: prevError }),
            group: assign({}, props, { value: prevGroup }),
            groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
            groupEnd: assign({}, props, { value: prevGroupEnd })
          });
        }
        0 > disabledDepth && console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
      }
      function prepareStackTrace(error, structuredStackTrace) {
        error = (error.name || "Error") + ": " + (error.message || "");
        for (var i = 0; i < structuredStackTrace.length; i++)
          error += "\n    at " + structuredStackTrace[i].toString();
        return error;
      }
      function describeBuiltInComponentFrame(name2) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name2 + suffix;
      }
      function describeNativeComponentFrame(fn4, construct) {
        if (!fn4 || reentry) return "";
        var frame = componentFrameCache.get(fn4);
        if (void 0 !== frame) return frame;
        reentry = true;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = prepareStackTrace;
        var previousDispatcher2 = null;
        previousDispatcher2 = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn4, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$0) {
                      control = x$0;
                    }
                    fn4.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$1) {
                    control = x$1;
                  }
                  (Fake = fn4()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            ); )
              _RunInRootFrame$Deter++;
            if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
              for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                _RunInRootFrame$Deter--;
            for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
              if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                  do
                    if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                      var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                      fn4.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn4.displayName));
                      "function" === typeof fn4 && componentFrameCache.set(fn4, _frame);
                      return _frame;
                    }
                  while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                }
                break;
              }
          }
        } finally {
          reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn4 ? fn4.displayName || fn4.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn4 && componentFrameCache.set(fn4, sampleLines);
        return sampleLines;
      }
      function formatOwnerStack(error) {
        var prevPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = prepareStackTrace;
        error = error.stack;
        Error.prepareStackTrace = prevPrepareStackTrace;
        error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
        prevPrepareStackTrace = error.indexOf("\n");
        -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
        prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
        -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
          "\n",
          prevPrepareStackTrace
        ));
        if (-1 !== prevPrepareStackTrace)
          error = error.slice(0, prevPrepareStackTrace);
        else return "";
        return error;
      }
      function describeComponentStackByType(type) {
        if ("string" === typeof type) return describeBuiltInComponentFrame(type);
        if ("function" === typeof type)
          return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame(type, true) : describeNativeComponentFrame(type, false);
        if ("object" === typeof type && null !== type) {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeNativeComponentFrame(type.render, false);
            case REACT_MEMO_TYPE:
              return describeNativeComponentFrame(type.type, false);
            case REACT_LAZY_TYPE:
              var lazyComponent = type, payload = lazyComponent._payload;
              lazyComponent = lazyComponent._init;
              try {
                type = lazyComponent(payload);
              } catch (x) {
                return describeBuiltInComponentFrame("Lazy");
              }
              return describeComponentStackByType(type);
          }
          if ("string" === typeof type.name)
            return payload = type.env, describeBuiltInComponentFrame(
              type.name + (payload ? " [" + payload + "]" : "")
            );
        }
        switch (type) {
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
        }
        return "";
      }
      function defaultErrorHandler(error) {
        if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
          var JSCompiler_inline_result = error.environmentName;
          error = [error].slice(0);
          "string" === typeof error[0] ? error.splice(
            0,
            1,
            "\x1B[0m\x1B[7m%c%s\x1B[0m%c " + error[0],
            "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
            " " + JSCompiler_inline_result + " ",
            ""
          ) : error.splice(
            0,
            0,
            "\x1B[0m\x1B[7m%c%s\x1B[0m%c ",
            "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
            " " + JSCompiler_inline_result + " ",
            ""
          );
          error.unshift(console);
          JSCompiler_inline_result = bind.apply(console.error, error);
          JSCompiler_inline_result();
        } else console.error(error);
        return null;
      }
      function noop() {
      }
      function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
        var abortSet = /* @__PURE__ */ new Set();
        this.destination = null;
        this.flushScheduled = false;
        this.resumableState = resumableState;
        this.renderState = renderState;
        this.rootFormatContext = rootFormatContext;
        this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
        this.status = 10;
        this.fatalError = null;
        this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
        this.completedPreambleSegments = this.completedRootSegment = null;
        this.abortableTasks = abortSet;
        this.pingedTasks = [];
        this.clientRenderedBoundaries = [];
        this.completedBoundaries = [];
        this.partialBoundaries = [];
        this.trackedPostpones = null;
        this.onError = void 0 === onError ? defaultErrorHandler : onError;
        this.onPostpone = void 0 === onPostpone ? noop : onPostpone;
        this.onAllReady = void 0 === onAllReady ? noop : onAllReady;
        this.onShellReady = void 0 === onShellReady ? noop : onShellReady;
        this.onShellError = void 0 === onShellError ? noop : onShellError;
        this.onFatalError = void 0 === onFatalError ? noop : onFatalError;
        this.formState = void 0 === formState ? null : formState;
        this.didWarnForKey = null;
      }
      function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
        var now = getCurrentTime();
        1e3 < now - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = now);
        resumableState = new RequestInstance(
          resumableState,
          renderState,
          rootFormatContext,
          progressiveChunkSize,
          onError,
          onAllReady,
          onShellReady,
          onShellError,
          onFatalError,
          onPostpone,
          formState
        );
        renderState = createPendingSegment(
          resumableState,
          0,
          null,
          rootFormatContext,
          false,
          false
        );
        renderState.parentFlushed = true;
        children = createRenderTask(
          resumableState,
          null,
          children,
          -1,
          null,
          renderState,
          null,
          null,
          resumableState.abortableTasks,
          null,
          rootFormatContext,
          null,
          emptyTreeContext,
          null,
          false,
          emptyContextObject,
          null
        );
        pushComponentStack(children);
        resumableState.pingedTasks.push(children);
        return resumableState;
      }
      function createPrerenderRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
        children = createRequest(
          children,
          resumableState,
          renderState,
          rootFormatContext,
          progressiveChunkSize,
          onError,
          onAllReady,
          onShellReady,
          onShellError,
          onFatalError,
          onPostpone,
          void 0
        );
        children.trackedPostpones = {
          workingMap: /* @__PURE__ */ new Map(),
          rootNodes: [],
          rootSlots: null
        };
        return children;
      }
      function resolveRequest() {
        if (currentRequest) return currentRequest;
        var store = requestStorage.getStore();
        return store ? store : null;
      }
      function pingTask(request, task) {
        request.pingedTasks.push(task);
        1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, null !== request.trackedPostpones || 10 === request.status ? scheduleMicrotask(function() {
          return performWork(request);
        }) : setImmediate(function() {
          return performWork(request);
        }));
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
        return {
          status: PENDING,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null,
          contentState: createHoistableState(),
          fallbackState: createHoistableState(),
          contentPreamble,
          fallbackPreamble,
          trackedContentKeyPath: null,
          trackedFallbackNode: null,
          errorMessage: null,
          errorStack: null,
          errorComponentStack: null
        };
      }
      function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
        request.allPendingTasks++;
        null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        var task = {
          replay: null,
          node,
          childIndex,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          blockedPreamble,
          hoistableState,
          abortSet,
          keyPath,
          formatContext,
          context,
          treeContext,
          componentStack,
          thenableState: thenableState2,
          isFallback
        };
        task.debugTask = debugTask;
        abortSet.add(task);
        return task;
      }
      function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
        request.allPendingTasks++;
        null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        replay.pendingTasks++;
        var task = {
          replay,
          node,
          childIndex,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment: null,
          blockedPreamble: null,
          hoistableState,
          abortSet,
          keyPath,
          formatContext,
          context,
          treeContext,
          componentStack,
          thenableState: thenableState2,
          isFallback
        };
        task.debugTask = debugTask;
        abortSet.add(task);
        return task;
      }
      function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          parentFlushed: false,
          id: -1,
          index,
          chunks: [],
          children: [],
          preambleChildren: [],
          parentFormatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      function getCurrentStackInDEV() {
        if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
          return "";
        var componentStack = currentTaskInDEV.componentStack;
        try {
          var info = "";
          if ("string" === typeof componentStack.type)
            info += describeBuiltInComponentFrame(componentStack.type);
          else if ("function" === typeof componentStack.type) {
            if (!componentStack.owner) {
              var JSCompiler_temp_const = info, fn4 = componentStack.type, name2 = fn4 ? fn4.displayName || fn4.name : "";
              var JSCompiler_inline_result = name2 ? describeBuiltInComponentFrame(name2) : "";
              info = JSCompiler_temp_const + JSCompiler_inline_result;
            }
          } else
            componentStack.owner || (info += describeComponentStackByType(componentStack.type));
          for (; componentStack; )
            JSCompiler_temp_const = null, null != componentStack.debugStack ? JSCompiler_temp_const = formatOwnerStack(
              componentStack.debugStack
            ) : (JSCompiler_inline_result = componentStack, null != JSCompiler_inline_result.stack && (JSCompiler_temp_const = "string" !== typeof JSCompiler_inline_result.stack ? JSCompiler_inline_result.stack = formatOwnerStack(
              JSCompiler_inline_result.stack
            ) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += "\n" + JSCompiler_temp_const);
          var JSCompiler_inline_result$jscomp$0 = info;
        } catch (x) {
          JSCompiler_inline_result$jscomp$0 = "\nError generating stack: " + x.message + "\n" + x.stack;
        }
        return JSCompiler_inline_result$jscomp$0;
      }
      function pushServerComponentStack(task, debugInfo) {
        if (null != debugInfo)
          for (var i = 0; i < debugInfo.length; i++) {
            var componentInfo = debugInfo[i];
            "string" === typeof componentInfo.name && void 0 !== componentInfo.debugStack && (task.componentStack = {
              parent: task.componentStack,
              type: componentInfo,
              owner: componentInfo.owner,
              stack: componentInfo.debugStack
            }, task.debugTask = componentInfo.debugTask);
          }
      }
      function pushComponentStack(task) {
        var node = task.node;
        if ("object" === typeof node && null !== node)
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = node.type, owner = node._owner, stack = node._debugStack;
              pushServerComponentStack(task, node._debugInfo);
              task.debugTask = node._debugTask;
              task.componentStack = {
                parent: task.componentStack,
                type,
                owner,
                stack
              };
              break;
            case REACT_LAZY_TYPE:
              pushServerComponentStack(task, node._debugInfo);
              break;
            default:
              "function" === typeof node.then && pushServerComponentStack(task, node._debugInfo);
          }
      }
      function getThrownInfo(node$jscomp$0) {
        var errorInfo = {};
        node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
          configurable: true,
          enumerable: true,
          get: function() {
            try {
              var info = "", node = node$jscomp$0;
              do
                info += describeComponentStackByType(node.type), node = node.parent;
              while (node);
              var stack = info;
            } catch (x) {
              stack = "\nError generating stack: " + x.message + "\n" + x.stack;
            }
            Object.defineProperty(errorInfo, "componentStack", {
              value: stack
            });
            return stack;
          }
        });
        return errorInfo;
      }
      function encodeErrorForBoundary(boundary, digest, error, thrownInfo, wasAborted) {
        boundary.errorDigest = digest;
        error instanceof Error ? (digest = String(error.message), error = String(error.stack)) : (digest = "object" === typeof error && null !== error ? describeObjectForErrorMessage(error) : String(error), error = null);
        wasAborted = wasAborted ? "Switched to client rendering because the server rendering aborted due to:\n\n" : "Switched to client rendering because the server rendering errored:\n\n";
        boundary.errorMessage = wasAborted + digest;
        boundary.errorStack = null !== error ? wasAborted + error : null;
        boundary.errorComponentStack = thrownInfo.componentStack;
      }
      function logRecoverableError(request, error, errorInfo, debugTask) {
        request = request.onError;
        error = debugTask ? debugTask.run(request.bind(null, error, errorInfo)) : request(error, errorInfo);
        if (null != error && "string" !== typeof error)
          console.error(
            'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
            typeof error
          );
        else return error;
      }
      function fatalError(request, error, errorInfo, debugTask) {
        errorInfo = request.onShellError;
        var onFatalError = request.onFatalError;
        debugTask ? (debugTask.run(errorInfo.bind(null, error)), debugTask.run(onFatalError.bind(null, error))) : (errorInfo(error), onFatalError(error));
        null !== request.destination ? (request.status = CLOSED, request.destination.destroy(error)) : (request.status = 13, request.fatalError = error);
      }
      function renderWithHooks(request, task, keyPath, Component, props, secondArg) {
        var prevThenableState = task.thenableState;
        task.thenableState = null;
        currentlyRenderingComponent = {};
        currentlyRenderingTask = task;
        currentlyRenderingRequest = request;
        currentlyRenderingKeyPath = keyPath;
        isInHookUserCodeInDev = false;
        actionStateCounter = localIdCounter = 0;
        actionStateMatchingIndex = -1;
        thenableIndexCounter = 0;
        thenableState = prevThenableState;
        for (request = callComponentInDEV(Component, props, secondArg); didScheduleRenderPhaseUpdate; )
          didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);
        resetHooksState();
        return request;
      }
      function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
        var didEmitActionStateMarkers = false;
        if (0 !== actionStateCount && null !== request.formState) {
          var segment = task.blockedSegment;
          if (null !== segment) {
            didEmitActionStateMarkers = true;
            segment = segment.chunks;
            for (var i = 0; i < actionStateCount; i++)
              i === actionStateMatchingIndex2 ? segment.push(formStateMarkerIsMatching) : segment.push(formStateMarkerIsNotMatching);
          }
        }
        actionStateCount = task.keyPath;
        task.keyPath = keyPath;
        hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode2(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode2(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
        task.keyPath = actionStateCount;
      }
      function renderElement(request, task, keyPath, type, props, ref) {
        if ("function" === typeof type)
          if (type.prototype && type.prototype.isReactComponent) {
            var newProps = props;
            if ("ref" in props) {
              newProps = {};
              for (var propName in props)
                "ref" !== propName && (newProps[propName] = props[propName]);
            }
            var defaultProps = type.defaultProps;
            if (defaultProps) {
              newProps === props && (newProps = assign({}, newProps, props));
              for (var _propName in defaultProps)
                void 0 === newProps[_propName] && (newProps[_propName] = defaultProps[_propName]);
            }
            var resolvedProps = newProps;
            var context = emptyContextObject, contextType = type.contextType;
            if ("contextType" in type && null !== contextType && (void 0 === contextType || contextType.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(type)) {
              didWarnAboutInvalidateContextType.add(type);
              var addendum = void 0 === contextType ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof contextType ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              console.error(
                "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
                getComponentNameFromType(type) || "Component",
                addendum
              );
            }
            "object" === typeof contextType && null !== contextType && (context = contextType._currentValue);
            var instance = new type(resolvedProps, context);
            if ("function" === typeof type.getDerivedStateFromProps && (null === instance.state || void 0 === instance.state)) {
              var componentName = getComponentNameFromType(type) || "Component";
              didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), console.error(
                "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
                componentName,
                null === instance.state ? "null" : "undefined",
                componentName
              ));
            }
            if ("function" === typeof type.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate) {
              var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
              "function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning ? foundWillMountName = "componentWillMount" : "function" === typeof instance.UNSAFE_componentWillMount && (foundWillMountName = "UNSAFE_componentWillMount");
              "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning ? foundWillReceivePropsName = "componentWillReceiveProps" : "function" === typeof instance.UNSAFE_componentWillReceiveProps && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
              "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== foundWillMountName || null !== foundWillReceivePropsName || null !== foundWillUpdateName) {
                var _componentName = getComponentNameFromType(type) || "Component", newApiName = "function" === typeof type.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(
                  _componentName
                ), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _componentName,
                  newApiName,
                  null !== foundWillMountName ? "\n  " + foundWillMountName : "",
                  null !== foundWillReceivePropsName ? "\n  " + foundWillReceivePropsName : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            var name2 = getComponentNameFromType(type) || "Component";
            instance.render || (type.prototype && "function" === typeof type.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              name2
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              name2
            ));
            !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              name2
            );
            instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              name2
            );
            instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              name2
            );
            type.childContextTypes && !didWarnAboutChildContextTypes.has(type) && (didWarnAboutChildContextTypes.add(type), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              name2
            ));
            type.contextTypes && !didWarnAboutContextTypes$1.has(type) && (didWarnAboutContextTypes$1.add(type), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              name2
            ));
            "function" === typeof instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              name2
            );
            type.prototype && type.prototype.isPureReactComponent && "undefined" !== typeof instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(type) || "A pure component"
            );
            "function" === typeof instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              name2
            );
            "function" === typeof instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              name2
            );
            "function" === typeof instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              name2
            );
            "function" === typeof instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              name2
            );
            var hasMutatedProps = instance.props !== resolvedProps;
            void 0 !== instance.props && hasMutatedProps && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              name2
            );
            instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              name2,
              name2
            );
            "function" !== typeof instance.getSnapshotBeforeUpdate || "function" === typeof instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(type)
            ));
            "function" === typeof instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              name2
            );
            "function" === typeof instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              name2
            );
            "function" === typeof type.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              name2
            );
            var state = instance.state;
            state && ("object" !== typeof state || isArrayImpl(state)) && console.error("%s.state: must be set to an object or null", name2);
            "function" === typeof instance.getChildContext && "object" !== typeof type.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              name2
            );
            var initialState = void 0 !== instance.state ? instance.state : null;
            instance.updater = classComponentUpdater;
            instance.props = resolvedProps;
            instance.state = initialState;
            var internalInstance = { queue: [], replace: false };
            instance._reactInternals = internalInstance;
            var contextType$jscomp$0 = type.contextType;
            instance.context = "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 ? contextType$jscomp$0._currentValue : emptyContextObject;
            if (instance.state === resolvedProps) {
              var componentName$jscomp$0 = getComponentNameFromType(type) || "Component";
              didWarnAboutDirectlyAssigningPropsToState.has(
                componentName$jscomp$0
              ) || (didWarnAboutDirectlyAssigningPropsToState.add(
                componentName$jscomp$0
              ), console.error(
                "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
                componentName$jscomp$0
              ));
            }
            var getDerivedStateFromProps = type.getDerivedStateFromProps;
            if ("function" === typeof getDerivedStateFromProps) {
              var partialState = getDerivedStateFromProps(
                resolvedProps,
                initialState
              );
              if (void 0 === partialState) {
                var componentName$jscomp$1 = getComponentNameFromType(type) || "Component";
                didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1), console.error(
                  "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
                  componentName$jscomp$1
                ));
              }
              var JSCompiler_inline_result = null === partialState || void 0 === partialState ? initialState : assign({}, initialState, partialState);
              instance.state = JSCompiler_inline_result;
            }
            if ("function" !== typeof type.getDerivedStateFromProps && "function" !== typeof instance.getSnapshotBeforeUpdate && ("function" === typeof instance.UNSAFE_componentWillMount || "function" === typeof instance.componentWillMount)) {
              var oldState = instance.state;
              if ("function" === typeof instance.componentWillMount) {
                if (true !== instance.componentWillMount.__suppressDeprecationWarning) {
                  var componentName$jscomp$2 = getComponentNameFromType(type) || "Unknown";
                  didWarnAboutDeprecatedWillMount[componentName$jscomp$2] || (console.warn(
                    "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName$jscomp$2
                  ), didWarnAboutDeprecatedWillMount[componentName$jscomp$2] = true);
                }
                instance.componentWillMount();
              }
              "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount();
              oldState !== instance.state && (console.error(
                "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
                getComponentNameFromType(type) || "Component"
              ), classComponentUpdater.enqueueReplaceState(
                instance,
                instance.state,
                null
              ));
              if (null !== internalInstance.queue && 0 < internalInstance.queue.length) {
                var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
                internalInstance.queue = null;
                internalInstance.replace = false;
                if (oldReplace && 1 === oldQueue.length)
                  instance.state = oldQueue[0];
                else {
                  for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = true, i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                    var partial = oldQueue[i], partialState$jscomp$0 = "function" === typeof partial ? partial.call(
                      instance,
                      nextState,
                      resolvedProps,
                      void 0
                    ) : partial;
                    null != partialState$jscomp$0 && (dontMutate ? (dontMutate = false, nextState = assign(
                      {},
                      nextState,
                      partialState$jscomp$0
                    )) : assign(nextState, partialState$jscomp$0));
                  }
                  instance.state = nextState;
                }
              } else internalInstance.queue = null;
            }
            var nextChildren = callRenderInDEV(instance);
            if (12 === request.status) throw null;
            instance.props !== resolvedProps && (didWarnAboutReassigningProps || console.error(
              "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
              getComponentNameFromType(type) || "a component"
            ), didWarnAboutReassigningProps = true);
            var prevKeyPath = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, nextChildren, -1);
            task.keyPath = prevKeyPath;
          } else {
            if (type.prototype && "function" === typeof type.prototype.render) {
              var componentName$jscomp$3 = getComponentNameFromType(type) || "Unknown";
              didWarnAboutBadClass[componentName$jscomp$3] || (console.error(
                "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
                componentName$jscomp$3,
                componentName$jscomp$3
              ), didWarnAboutBadClass[componentName$jscomp$3] = true);
            }
            var value = renderWithHooks(
              request,
              task,
              keyPath,
              type,
              props,
              void 0
            );
            if (12 === request.status) throw null;
            var hasId = 0 !== localIdCounter, actionStateCount = actionStateCounter, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;
            if (type.contextTypes) {
              var _componentName$jscomp$0 = getComponentNameFromType(type) || "Unknown";
              didWarnAboutContextTypes[_componentName$jscomp$0] || (didWarnAboutContextTypes[_componentName$jscomp$0] = true, console.error(
                "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
                _componentName$jscomp$0
              ));
            }
            type && type.childContextTypes && console.error(
              "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
              type.displayName || type.name || "Component"
            );
            if ("function" === typeof type.getDerivedStateFromProps) {
              var _componentName2 = getComponentNameFromType(type) || "Unknown";
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] || (console.error(
                "%s: Function components do not support getDerivedStateFromProps.",
                _componentName2
              ), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true);
            }
            if ("object" === typeof type.contextType && null !== type.contextType) {
              var _componentName3 = getComponentNameFromType(type) || "Unknown";
              didWarnAboutContextTypeOnFunctionComponent[_componentName3] || (console.error(
                "%s: Function components do not support contextType.",
                _componentName3
              ), didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true);
            }
            finishFunctionComponent(
              request,
              task,
              keyPath,
              value,
              hasId,
              actionStateCount,
              actionStateMatchingIndex$jscomp$0
            );
          }
        else if ("string" === typeof type) {
          var segment = task.blockedSegment;
          if (null === segment) {
            var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
            task.formatContext = getChildFormatContext(prevContext, type, props);
            task.keyPath = keyPath;
            renderNode2(request, task, children, -1);
            task.formatContext = prevContext;
            task.keyPath = prevKeyPath$jscomp$0;
          } else {
            var _children = pushStartInstance(
              segment.chunks,
              type,
              props,
              request.resumableState,
              request.renderState,
              task.blockedPreamble,
              task.hoistableState,
              task.formatContext,
              segment.lastPushedText,
              task.isFallback
            );
            segment.lastPushedText = false;
            var _prevContext = task.formatContext, _prevKeyPath2 = task.keyPath;
            task.keyPath = keyPath;
            if ((task.formatContext = getChildFormatContext(
              _prevContext,
              type,
              props
            )).insertionMode === HTML_HEAD_MODE) {
              var preambleSegment = createPendingSegment(
                request,
                0,
                null,
                task.formatContext,
                false,
                false
              );
              segment.preambleChildren.push(preambleSegment);
              var preambleTask = createRenderTask(
                request,
                null,
                _children,
                -1,
                task.blockedBoundary,
                preambleSegment,
                task.blockedPreamble,
                task.hoistableState,
                request.abortableTasks,
                task.keyPath,
                task.formatContext,
                task.context,
                task.treeContext,
                task.componentStack,
                task.isFallback,
                emptyContextObject,
                task.debugTask
              );
              pushComponentStack(preambleTask);
              request.pingedTasks.push(preambleTask);
            } else renderNode2(request, task, _children, -1);
            task.formatContext = _prevContext;
            task.keyPath = _prevKeyPath2;
            a: {
              var target = segment.chunks, resumableState = request.resumableState;
              switch (type) {
                case "title":
                case "style":
                case "script":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "img":
                case "input":
                case "keygen":
                case "link":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                  break a;
                case "body":
                  if (_prevContext.insertionMode <= HTML_HTML_MODE) {
                    resumableState.hasBody = true;
                    break a;
                  }
                  break;
                case "html":
                  if (_prevContext.insertionMode === ROOT_HTML_MODE) {
                    resumableState.hasHtml = true;
                    break a;
                  }
                  break;
                case "head":
                  if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;
              }
              target.push(endChunkForTag(type));
            }
            segment.lastPushedText = false;
          }
        } else {
          switch (type) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE:
              var prevKeyPath$jscomp$1 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, props.children, -1);
              task.keyPath = prevKeyPath$jscomp$1;
              return;
            case REACT_ACTIVITY_TYPE:
              if ("hidden" !== props.mode) {
                var prevKeyPath$jscomp$2 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, props.children, -1);
                task.keyPath = prevKeyPath$jscomp$2;
              }
              return;
            case REACT_SUSPENSE_LIST_TYPE:
              var _prevKeyPath3 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, props.children, -1);
              task.keyPath = _prevKeyPath3;
              return;
            case REACT_VIEW_TRANSITION_TYPE:
            case REACT_SCOPE_TYPE:
              throw Error(
                "ReactDOMServer does not yet support scope components."
              );
            case REACT_SUSPENSE_TYPE:
              a: if (null !== task.replay) {
                var _prevKeyPath = task.keyPath;
                task.keyPath = keyPath;
                var _content = props.children;
                try {
                  renderNode2(request, task, _content, -1);
                } finally {
                  task.keyPath = _prevKeyPath;
                }
              } else {
                var prevKeyPath$jscomp$3 = task.keyPath, parentBoundary = task.blockedBoundary, parentPreamble = task.blockedPreamble, parentHoistableState = task.hoistableState, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set();
                var newBoundary = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  createPreambleState(),
                  createPreambleState()
                ) : createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  null,
                  null
                );
                null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
                var boundarySegment = createPendingSegment(
                  request,
                  parentSegment.chunks.length,
                  newBoundary,
                  task.formatContext,
                  false,
                  false
                );
                parentSegment.children.push(boundarySegment);
                parentSegment.lastPushedText = false;
                var contentRootSegment = createPendingSegment(
                  request,
                  0,
                  null,
                  task.formatContext,
                  false,
                  false
                );
                contentRootSegment.parentFlushed = true;
                if (null !== request.trackedPostpones) {
                  var fallbackKeyPath = [
                    keyPath[0],
                    "Suspense Fallback",
                    keyPath[2]
                  ], fallbackReplayNode = [
                    fallbackKeyPath[1],
                    fallbackKeyPath[2],
                    [],
                    null
                  ];
                  request.trackedPostpones.workingMap.set(
                    fallbackKeyPath,
                    fallbackReplayNode
                  );
                  newBoundary.trackedFallbackNode = fallbackReplayNode;
                  task.blockedSegment = boundarySegment;
                  task.blockedPreamble = newBoundary.fallbackPreamble;
                  task.keyPath = fallbackKeyPath;
                  boundarySegment.status = 6;
                  try {
                    renderNode2(request, task, fallback, -1), boundarySegment.lastPushedText && boundarySegment.textEmbedded && boundarySegment.chunks.push(textSeparator), boundarySegment.status = COMPLETED;
                  } catch (thrownValue) {
                    throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;
                  } finally {
                    task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$3;
                  }
                  var suspendedPrimaryTask = createRenderTask(
                    request,
                    null,
                    content,
                    -1,
                    newBoundary,
                    contentRootSegment,
                    newBoundary.contentPreamble,
                    newBoundary.contentState,
                    task.abortSet,
                    keyPath,
                    task.formatContext,
                    task.context,
                    task.treeContext,
                    task.componentStack,
                    task.isFallback,
                    emptyContextObject,
                    task.debugTask
                  );
                  pushComponentStack(suspendedPrimaryTask);
                  request.pingedTasks.push(suspendedPrimaryTask);
                } else {
                  task.blockedBoundary = newBoundary;
                  task.blockedPreamble = newBoundary.contentPreamble;
                  task.hoistableState = newBoundary.contentState;
                  task.blockedSegment = contentRootSegment;
                  task.keyPath = keyPath;
                  contentRootSegment.status = 6;
                  try {
                    if (renderNode2(request, task, content, -1), contentRootSegment.lastPushedText && contentRootSegment.textEmbedded && contentRootSegment.chunks.push(textSeparator), contentRootSegment.status = COMPLETED, queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && newBoundary.status === PENDING) {
                      newBoundary.status = COMPLETED;
                      0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);
                      break a;
                    }
                  } catch (thrownValue$2) {
                    newBoundary.status = CLIENT_RENDERED;
                    if (12 === request.status) {
                      contentRootSegment.status = 3;
                      var error = request.fatalError;
                    } else
                      contentRootSegment.status = 4, error = thrownValue$2;
                    var thrownInfo = getThrownInfo(task.componentStack);
                    var errorDigest = logRecoverableError(
                      request,
                      error,
                      thrownInfo,
                      task.debugTask
                    );
                    encodeErrorForBoundary(
                      newBoundary,
                      errorDigest,
                      error,
                      thrownInfo,
                      false
                    );
                    untrackBoundary(request, newBoundary);
                  } finally {
                    task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$3;
                  }
                  var suspendedFallbackTask = createRenderTask(
                    request,
                    null,
                    fallback,
                    -1,
                    parentBoundary,
                    boundarySegment,
                    newBoundary.fallbackPreamble,
                    newBoundary.fallbackState,
                    fallbackAbortSet,
                    [keyPath[0], "Suspense Fallback", keyPath[2]],
                    task.formatContext,
                    task.context,
                    task.treeContext,
                    task.componentStack,
                    true,
                    emptyContextObject,
                    task.debugTask
                  );
                  pushComponentStack(suspendedFallbackTask);
                  request.pingedTasks.push(suspendedFallbackTask);
                }
              }
              return;
          }
          if ("object" === typeof type && null !== type)
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                if ("ref" in props) {
                  var propsWithoutRef = {};
                  for (var key in props)
                    "ref" !== key && (propsWithoutRef[key] = props[key]);
                } else propsWithoutRef = props;
                var children$jscomp$0 = renderWithHooks(
                  request,
                  task,
                  keyPath,
                  type.render,
                  propsWithoutRef,
                  ref
                );
                finishFunctionComponent(
                  request,
                  task,
                  keyPath,
                  children$jscomp$0,
                  0 !== localIdCounter,
                  actionStateCounter,
                  actionStateMatchingIndex
                );
                return;
              case REACT_MEMO_TYPE:
                renderElement(request, task, keyPath, type.type, props, ref);
                return;
              case REACT_PROVIDER_TYPE:
              case REACT_CONTEXT_TYPE:
                var value$jscomp$0 = props.value, children$jscomp$1 = props.children;
                var prevSnapshot = task.context;
                var prevKeyPath$jscomp$4 = task.keyPath;
                var prevValue = type._currentValue;
                type._currentValue = value$jscomp$0;
                void 0 !== type._currentRenderer && null !== type._currentRenderer && type._currentRenderer !== rendererSigil && console.error(
                  "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                );
                type._currentRenderer = rendererSigil;
                var prevNode = currentActiveSnapshot, newNode = {
                  parent: prevNode,
                  depth: null === prevNode ? 0 : prevNode.depth + 1,
                  context: type,
                  parentValue: prevValue,
                  value: value$jscomp$0
                };
                currentActiveSnapshot = newNode;
                task.context = newNode;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, children$jscomp$1, -1);
                var prevSnapshot$jscomp$0 = currentActiveSnapshot;
                if (null === prevSnapshot$jscomp$0)
                  throw Error(
                    "Tried to pop a Context at the root of the app. This is a bug in React."
                  );
                prevSnapshot$jscomp$0.context !== type && console.error(
                  "The parent context is not the expected context. This is probably a bug in React."
                );
                prevSnapshot$jscomp$0.context._currentValue = prevSnapshot$jscomp$0.parentValue;
                void 0 !== type._currentRenderer && null !== type._currentRenderer && type._currentRenderer !== rendererSigil && console.error(
                  "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                );
                type._currentRenderer = rendererSigil;
                var JSCompiler_inline_result$jscomp$0 = currentActiveSnapshot = prevSnapshot$jscomp$0.parent;
                task.context = JSCompiler_inline_result$jscomp$0;
                task.keyPath = prevKeyPath$jscomp$4;
                prevSnapshot !== task.context && console.error(
                  "Popping the context provider did not return back to the original snapshot. This is a bug in React."
                );
                return;
              case REACT_CONSUMER_TYPE:
                var context$jscomp$0 = type._context, render3 = props.children;
                "function" !== typeof render3 && console.error(
                  "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
                );
                var newChildren = render3(context$jscomp$0._currentValue), prevKeyPath$jscomp$5 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, newChildren, -1);
                task.keyPath = prevKeyPath$jscomp$5;
                return;
              case REACT_LAZY_TYPE:
                var Component = callLazyInitInDEV(type);
                if (12 === request.status) throw null;
                renderElement(request, task, keyPath, Component, props, ref);
                return;
            }
          var info = "";
          if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          throw Error(
            "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type ? type : typeof type) + "." + info)
          );
        }
      }
      function resumeNode(request, task, segmentId, node, childIndex) {
        var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(
          request,
          0,
          null,
          task.formatContext,
          false,
          false
        );
        resumedSegment.id = segmentId;
        resumedSegment.parentFlushed = true;
        try {
          task.replay = null, task.blockedSegment = resumedSegment, renderNode2(request, task, node, childIndex), resumedSegment.status = COMPLETED, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
        } finally {
          task.replay = prevReplay, task.blockedSegment = null;
        }
      }
      function replayElement(request, task, keyPath, name2, keyOrIndex, childIndex, type, props, ref, replay) {
        childIndex = replay.nodes;
        for (var i = 0; i < childIndex.length; i++) {
          var node = childIndex[i];
          if (keyOrIndex === node[1]) {
            if (4 === node.length) {
              if (null !== name2 && name2 !== node[0])
                throw Error(
                  "Expected the resume to render <" + node[0] + "> in this slot but instead it rendered <" + name2 + ">. The tree doesn't match so React will fallback to client rendering."
                );
              var childNodes = node[2];
              node = node[3];
              name2 = task.node;
              task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };
              try {
                renderElement(request, task, keyPath, type, props, ref);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(
                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                  );
                task.replay.pendingTasks--;
              } catch (x) {
                if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                  throw task.node === name2 && (task.replay = replay), x;
                task.replay.pendingTasks--;
                type = getThrownInfo(task.componentStack);
                props = request;
                request = task.blockedBoundary;
                keyPath = x;
                ref = node;
                node = logRecoverableError(props, keyPath, type, task.debugTask);
                abortRemainingReplayNodes(
                  props,
                  request,
                  childNodes,
                  ref,
                  keyPath,
                  node,
                  type,
                  false
                );
              }
              task.replay = replay;
            } else {
              if (type !== REACT_SUSPENSE_TYPE)
                throw Error(
                  "Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering."
                );
              a: {
                replay = void 0;
                type = node[5];
                ref = node[2];
                name2 = node[3];
                keyOrIndex = null === node[4] ? [] : node[4][2];
                node = null === node[4] ? null : node[4][3];
                var prevKeyPath = task.keyPath, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
                props = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  createPreambleState(),
                  createPreambleState()
                ) : createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  null,
                  null
                );
                props.parentFlushed = true;
                props.rootSegmentID = type;
                task.blockedBoundary = props;
                task.hoistableState = props.contentState;
                task.keyPath = keyPath;
                task.replay = { nodes: ref, slots: name2, pendingTasks: 1 };
                try {
                  renderNode2(request, task, content, -1);
                  if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                    throw Error(
                      "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                    );
                  task.replay.pendingTasks--;
                  if (0 === props.pendingTasks && props.status === PENDING) {
                    props.status = COMPLETED;
                    request.completedBoundaries.push(props);
                    break a;
                  }
                } catch (error) {
                  props.status = CLIENT_RENDERED, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(
                    request,
                    error,
                    childNodes,
                    task.debugTask
                  ), encodeErrorForBoundary(props, replay, error, childNodes, false), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
                } finally {
                  task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath;
                }
                props = createReplayTask(
                  request,
                  null,
                  { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
                  fallback,
                  -1,
                  parentBoundary,
                  props.fallbackState,
                  fallbackAbortSet,
                  [keyPath[0], "Suspense Fallback", keyPath[2]],
                  task.formatContext,
                  task.context,
                  task.treeContext,
                  task.componentStack,
                  true,
                  emptyContextObject,
                  task.debugTask
                );
                pushComponentStack(props);
                request.pingedTasks.push(props);
              }
            }
            childIndex.splice(i, 1);
            break;
          }
        }
      }
      function renderNodeDestructive(request, task, node, childIndex) {
        null !== task.replay && "number" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, childIndex = task.debugTask, pushComponentStack(task), retryNode(request, task), task.componentStack = node, task.debugTask = childIndex);
      }
      function retryNode(request, task) {
        var node = task.node, childIndex = task.childIndex;
        if (null !== node) {
          if ("object" === typeof node) {
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = node.type, key = node.key;
                node = node.props;
                var refProp = node.ref;
                refProp = void 0 !== refProp ? refProp : null;
                var debugTask = task.debugTask, name2 = getComponentNameFromType(type);
                key = null == key ? -1 === childIndex ? 0 : childIndex : key;
                var keyPath = [task.keyPath, name2, key];
                null !== task.replay ? debugTask ? debugTask.run(
                  replayElement.bind(
                    null,
                    request,
                    task,
                    keyPath,
                    name2,
                    key,
                    childIndex,
                    type,
                    node,
                    refProp,
                    task.replay
                  )
                ) : replayElement(
                  request,
                  task,
                  keyPath,
                  name2,
                  key,
                  childIndex,
                  type,
                  node,
                  refProp,
                  task.replay
                ) : debugTask ? debugTask.run(
                  renderElement.bind(
                    null,
                    request,
                    task,
                    keyPath,
                    type,
                    node,
                    refProp
                  )
                ) : renderElement(request, task, keyPath, type, node, refProp);
                return;
              case REACT_PORTAL_TYPE:
                throw Error(
                  "Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render."
                );
              case REACT_LAZY_TYPE:
                node = callLazyInitInDEV(node);
                if (12 === request.status) throw null;
                renderNodeDestructive(request, task, node, childIndex);
                return;
            }
            if (isArrayImpl(node)) {
              renderChildrenArray(request, task, node, childIndex);
              return;
            }
            null === node || "object" !== typeof node ? key = null : (type = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], key = "function" === typeof type ? type : null);
            if (key && (type = key.call(node))) {
              if (type === node) {
                if (-1 !== childIndex || null === task.componentStack || "function" !== typeof task.componentStack.type || "[object GeneratorFunction]" !== Object.prototype.toString.call(task.componentStack.type) || "[object Generator]" !== Object.prototype.toString.call(type))
                  didWarnAboutGenerators || console.error(
                    "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                  ), didWarnAboutGenerators = true;
              } else
                node.entries !== key || didWarnAboutMaps || (console.error(
                  "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                ), didWarnAboutMaps = true);
              node = type.next();
              if (!node.done) {
                key = [];
                do
                  key.push(node.value), node = type.next();
                while (!node.done);
                renderChildrenArray(request, task, key, childIndex);
              }
              return;
            }
            if ("function" === typeof node.then)
              return task.thenableState = null, renderNodeDestructive(
                request,
                task,
                unwrapThenable(node),
                childIndex
              );
            if (node.$$typeof === REACT_CONTEXT_TYPE)
              return renderNodeDestructive(
                request,
                task,
                node._currentValue,
                childIndex
              );
            request = Object.prototype.toString.call(node);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === request ? "object with keys {" + Object.keys(node).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          "string" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
            task.chunks,
            node,
            request.renderState,
            task.lastPushedText
          ))) : "number" === typeof node || "bigint" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
            task.chunks,
            "" + node,
            request.renderState,
            task.lastPushedText
          ))) : ("function" === typeof node && (request = node.displayName || node.name || "Component", console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
            request,
            request
          )), "symbol" === typeof node && console.error(
            "Symbols are not valid as a React child.\n  %s",
            String(node)
          ));
        }
      }
      function renderChildrenArray(request, task, children, childIndex) {
        var prevKeyPath = task.keyPath, previousComponentStack = task.componentStack;
        var previousDebugTask = task.debugTask;
        pushServerComponentStack(task, task.node._debugInfo);
        if (-1 !== childIndex && (task.keyPath = [task.keyPath, "Fragment", childIndex], null !== task.replay)) {
          for (var replay = task.replay, replayNodes = replay.nodes, j3 = 0; j3 < replayNodes.length; j3++) {
            var node = replayNodes[j3];
            if (node[1] === childIndex) {
              childIndex = node[2];
              node = node[3];
              task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
              try {
                renderChildrenArray(request, task, children, -1);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(
                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                  );
                task.replay.pendingTasks--;
              } catch (x) {
                if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                  throw x;
                task.replay.pendingTasks--;
                var thrownInfo = getThrownInfo(task.componentStack);
                children = task.blockedBoundary;
                var error = x, resumeSlots = node;
                node = logRecoverableError(
                  request,
                  error,
                  thrownInfo,
                  task.debugTask
                );
                abortRemainingReplayNodes(
                  request,
                  children,
                  childIndex,
                  resumeSlots,
                  error,
                  node,
                  thrownInfo,
                  false
                );
              }
              task.replay = replay;
              replayNodes.splice(j3, 1);
              break;
            }
          }
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          return;
        }
        replay = task.treeContext;
        replayNodes = children.length;
        if (null !== task.replay && (j3 = task.replay.slots, null !== j3 && "object" === typeof j3)) {
          for (childIndex = 0; childIndex < replayNodes; childIndex++)
            node = children[childIndex], task.treeContext = pushTreeContext(
              replay,
              replayNodes,
              childIndex
            ), error = j3[childIndex], "number" === typeof error ? (resumeNode(request, task, error, node, childIndex), delete j3[childIndex]) : renderNode2(request, task, node, childIndex);
          task.treeContext = replay;
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          return;
        }
        for (j3 = 0; j3 < replayNodes; j3++) {
          childIndex = children[j3];
          resumeSlots = request;
          node = task;
          error = childIndex;
          if (null !== error && "object" === typeof error && (error.$$typeof === REACT_ELEMENT_TYPE || error.$$typeof === REACT_PORTAL_TYPE) && error._store && (!error._store.validated && null == error.key || 2 === error._store.validated)) {
            if ("object" !== typeof error._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            error._store.validated = 1;
            thrownInfo = resumeSlots.didWarnForKey;
            null == thrownInfo && (thrownInfo = resumeSlots.didWarnForKey = /* @__PURE__ */ new WeakSet());
            resumeSlots = node.componentStack;
            if (null !== resumeSlots && !thrownInfo.has(resumeSlots)) {
              thrownInfo.add(resumeSlots);
              var componentName = getComponentNameFromType(error.type);
              thrownInfo = error._owner;
              var parentOwner = resumeSlots.owner;
              resumeSlots = "";
              if (parentOwner && "undefined" !== typeof parentOwner.type) {
                var name2 = getComponentNameFromType(parentOwner.type);
                name2 && (resumeSlots = "\n\nCheck the render method of `" + name2 + "`.");
              }
              resumeSlots || componentName && (resumeSlots = "\n\nCheck the top-level render call using <" + componentName + ">.");
              componentName = "";
              null != thrownInfo && parentOwner !== thrownInfo && (parentOwner = null, "undefined" !== typeof thrownInfo.type ? parentOwner = getComponentNameFromType(thrownInfo.type) : "string" === typeof thrownInfo.name && (parentOwner = thrownInfo.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
              thrownInfo = node.componentStack;
              node.componentStack = {
                parent: node.componentStack,
                type: error.type,
                owner: error._owner,
                stack: error._debugStack
              };
              console.error(
                'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                resumeSlots,
                componentName
              );
              node.componentStack = thrownInfo;
            }
          }
          task.treeContext = pushTreeContext(replay, replayNodes, j3);
          renderNode2(request, task, childIndex, j3);
        }
        task.treeContext = replay;
        task.keyPath = prevKeyPath;
        task.componentStack = previousComponentStack;
        task.debugTask = previousDebugTask;
      }
      function untrackBoundary(request, boundary) {
        request = request.trackedPostpones;
        null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
      }
      function spawnNewSuspendedReplayTask(request, task, thenableState2) {
        return createReplayTask(
          request,
          thenableState2,
          task.replay,
          task.node,
          task.childIndex,
          task.blockedBoundary,
          task.hoistableState,
          task.abortSet,
          task.keyPath,
          task.formatContext,
          task.context,
          task.treeContext,
          task.componentStack,
          task.isFallback,
          emptyContextObject,
          task.debugTask
        );
      }
      function spawnNewSuspendedRenderTask(request, task, thenableState2) {
        var segment = task.blockedSegment, newSegment = createPendingSegment(
          request,
          segment.chunks.length,
          null,
          task.formatContext,
          segment.lastPushedText,
          true
        );
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        return createRenderTask(
          request,
          thenableState2,
          task.node,
          task.childIndex,
          task.blockedBoundary,
          newSegment,
          task.blockedPreamble,
          task.hoistableState,
          task.abortSet,
          task.keyPath,
          task.formatContext,
          task.context,
          task.treeContext,
          task.componentStack,
          task.isFallback,
          emptyContextObject,
          task.debugTask
        );
      }
      function renderNode2(request, task, node, childIndex) {
        var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, previousDebugTask = task.debugTask, segment = task.blockedSegment;
        if (null === segment)
          try {
            return renderNodeDestructive(request, task, node, childIndex);
          } catch (thrownValue) {
            if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, "object" === typeof node && null !== node) {
              if ("function" === typeof node.then) {
                childIndex = getThenableStateAfterSuspending();
                request = spawnNewSuspendedReplayTask(
                  request,
                  task,
                  childIndex
                ).ping;
                node.then(request, request);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
              if ("Maximum call stack size exceeded" === node.message) {
                node = getThenableStateAfterSuspending();
                node = spawnNewSuspendedReplayTask(request, task, node);
                request.pingedTasks.push(node);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
            }
          }
        else {
          var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
          try {
            return renderNodeDestructive(request, task, node, childIndex);
          } catch (thrownValue$3) {
            if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$3 === SuspenseException ? getSuspendedThenable() : thrownValue$3, "object" === typeof node && null !== node) {
              if ("function" === typeof node.then) {
                childIndex = getThenableStateAfterSuspending();
                request = spawnNewSuspendedRenderTask(
                  request,
                  task,
                  childIndex
                ).ping;
                node.then(request, request);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
              if ("Maximum call stack size exceeded" === node.message) {
                node = getThenableStateAfterSuspending();
                node = spawnNewSuspendedRenderTask(request, task, node);
                request.pingedTasks.push(node);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
            }
          }
        }
        task.formatContext = previousFormatContext;
        task.context = previousContext;
        task.keyPath = previousKeyPath;
        task.treeContext = previousTreeContext;
        switchContext(previousContext);
        throw node;
      }
      function abortTaskSoft(task) {
        var boundary = task.blockedBoundary;
        task = task.blockedSegment;
        null !== task && (task.status = 3, finishedTask(this, boundary, task));
      }
      function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted) {
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (4 === node.length)
            abortRemainingReplayNodes(
              request$jscomp$0,
              boundary,
              node[2],
              node[3],
              error$jscomp$0,
              errorDigest$jscomp$0,
              errorInfo$jscomp$0,
              aborted
            );
          else {
            var request = request$jscomp$0;
            node = node[5];
            var error = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted, resumedBoundary = createSuspenseBoundary(
              request,
              /* @__PURE__ */ new Set(),
              null,
              null
            );
            resumedBoundary.parentFlushed = true;
            resumedBoundary.rootSegmentID = node;
            resumedBoundary.status = CLIENT_RENDERED;
            encodeErrorForBoundary(
              resumedBoundary,
              errorDigest,
              error,
              errorInfo,
              wasAborted
            );
            resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
          }
        }
        nodes.length = 0;
        if (null !== slots) {
          if (null === boundary)
            throw Error(
              "We should not have any resumable nodes in the shell. This is a bug in React."
            );
          boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(
            boundary,
            errorDigest$jscomp$0,
            error$jscomp$0,
            errorInfo$jscomp$0,
            aborted
          ), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
          if ("object" === typeof slots)
            for (var index in slots) delete slots[index];
        }
      }
      function abortTask(task, request, error) {
        var boundary = task.blockedBoundary, segment = task.blockedSegment;
        if (null !== segment) {
          if (6 === segment.status) return;
          segment.status = 3;
        }
        segment = getThrownInfo(task.componentStack);
        if (null === boundary) {
          if (13 !== request.status && request.status !== CLOSED) {
            boundary = task.replay;
            if (null === boundary) {
              logRecoverableError(request, error, segment, null);
              fatalError(request, error, segment, null);
              return;
            }
            boundary.pendingTasks--;
            0 === boundary.pendingTasks && 0 < boundary.nodes.length && (task = logRecoverableError(request, error, segment, null), abortRemainingReplayNodes(
              request,
              null,
              boundary.nodes,
              boundary.slots,
              error,
              task,
              segment,
              true
            ));
            request.pendingRootTasks--;
            0 === request.pendingRootTasks && completeShell(request);
          }
        } else
          boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, task = logRecoverableError(request, error, segment, null), boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(boundary, task, error, segment, true), untrackBoundary(request, boundary), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary)), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, error);
          }), boundary.fallbackAbortableTasks.clear();
        request.allPendingTasks--;
        0 === request.allPendingTasks && completeAll(request);
      }
      function safelyEmitEarlyPreloads(request, shellComplete) {
        try {
          var renderState = request.renderState, onHeaders = renderState.onHeaders;
          if (onHeaders) {
            var headers = renderState.headers;
            if (headers) {
              renderState.headers = null;
              var linkHeader = headers.preconnects;
              headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
              headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
              if (!shellComplete) {
                var queueIter = renderState.styles.values(), queueStep = queueIter.next();
                b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
                  for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                    var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
                    var header = getPreloadAsHeader(
                      props$jscomp$0.href,
                      "style",
                      {
                        crossOrigin: props$jscomp$0.crossOrigin,
                        integrity: props$jscomp$0.integrity,
                        nonce: props$jscomp$0.nonce,
                        type: props$jscomp$0.type,
                        fetchPriority: props$jscomp$0.fetchPriority,
                        referrerPolicy: props$jscomp$0.referrerPolicy,
                        media: props$jscomp$0.media
                      }
                    );
                    if (0 <= (headers.remainingCapacity -= header.length + 2))
                      renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                    else break b;
                  }
              }
              linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
            }
          }
        } catch (error) {
          logRecoverableError(request, error, {}, null);
        }
      }
      function completeShell(request) {
        null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);
        null === request.trackedPostpones && preparePreamble(request);
        request.onShellError = noop;
        request = request.onShellReady;
        request();
      }
      function completeAll(request) {
        safelyEmitEarlyPreloads(
          request,
          null === request.trackedPostpones ? true : null === request.completedRootSegment || request.completedRootSegment.status !== POSTPONED
        );
        preparePreamble(request);
        request = request.onAllReady;
        request();
      }
      function queueCompletedSegment(boundary, segment) {
        if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          childSegment.status === COMPLETED && queueCompletedSegment(boundary, childSegment);
        } else boundary.completedSegments.push(segment);
      }
      function finishedTask(request, boundary, segment) {
        if (null === boundary) {
          if (null !== segment && segment.parentFlushed) {
            if (null !== request.completedRootSegment)
              throw Error(
                "There can only be one root segment. This is a bug in React."
              );
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          0 === request.pendingRootTasks && completeShell(request);
        } else
          boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (0 === boundary.pendingTasks ? (boundary.status === PENDING && (boundary.status = COMPLETED), null !== segment && segment.parentFlushed && segment.status === COMPLETED && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED && (boundary.fallbackAbortableTasks.forEach(
            abortTaskSoft,
            request
          ), boundary.fallbackAbortableTasks.clear(), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request))) : null !== segment && segment.parentFlushed && segment.status === COMPLETED && (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)));
        request.allPendingTasks--;
        0 === request.allPendingTasks && completeAll(request);
      }
      function performWork(request$jscomp$2) {
        if (request$jscomp$2.status !== CLOSED && 13 !== request$jscomp$2.status) {
          var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = HooksDispatcher;
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          var prevRequest = currentRequest;
          currentRequest = request$jscomp$2;
          var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;
          ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
          var prevResumableState = currentResumableState;
          currentResumableState = request$jscomp$2.resumableState;
          try {
            var pingedTasks = request$jscomp$2.pingedTasks, i;
            for (i = 0; i < pingedTasks.length; i++) {
              var request = request$jscomp$2, task = pingedTasks[i], segment = task.blockedSegment;
              if (null === segment) {
                var prevTaskInDEV = void 0, request$jscomp$0 = request;
                request = task;
                if (0 !== request.replay.pendingTasks) {
                  switchContext(request.context);
                  prevTaskInDEV = currentTaskInDEV;
                  currentTaskInDEV = request;
                  try {
                    "number" === typeof request.replay.slots ? resumeNode(
                      request$jscomp$0,
                      request,
                      request.replay.slots,
                      request.node,
                      request.childIndex
                    ) : retryNode(request$jscomp$0, request);
                    if (1 === request.replay.pendingTasks && 0 < request.replay.nodes.length)
                      throw Error(
                        "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                      );
                    request.replay.pendingTasks--;
                    request.abortSet.delete(request);
                    finishedTask(request$jscomp$0, request.blockedBoundary, null);
                  } catch (thrownValue) {
                    resetHooksState();
                    var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                    if ("object" === typeof x && null !== x && "function" === typeof x.then) {
                      var ping = request.ping;
                      x.then(ping, ping);
                      request.thenableState = getThenableStateAfterSuspending();
                    } else {
                      request.replay.pendingTasks--;
                      request.abortSet.delete(request);
                      var errorInfo = getThrownInfo(request.componentStack), errorDigest = void 0, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
                      errorDigest = logRecoverableError(
                        request$jscomp$1,
                        error$jscomp$0,
                        errorInfo$jscomp$0,
                        request.debugTask
                      );
                      abortRemainingReplayNodes(
                        request$jscomp$1,
                        boundary,
                        replayNodes,
                        resumeSlots,
                        error$jscomp$0,
                        errorDigest,
                        errorInfo$jscomp$0,
                        false
                      );
                      request$jscomp$0.pendingRootTasks--;
                      0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);
                      request$jscomp$0.allPendingTasks--;
                      0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);
                    }
                  } finally {
                    currentTaskInDEV = prevTaskInDEV;
                  }
                }
              } else if (request$jscomp$0 = prevTaskInDEV = void 0, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING) {
                request$jscomp$1.status = 6;
                switchContext(errorDigest.context);
                request$jscomp$0 = currentTaskInDEV;
                currentTaskInDEV = errorDigest;
                var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
                try {
                  retryNode(request, errorDigest), request$jscomp$1.lastPushedText && request$jscomp$1.textEmbedded && request$jscomp$1.chunks.push(textSeparator), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED, finishedTask(
                    request,
                    errorDigest.blockedBoundary,
                    request$jscomp$1
                  );
                } catch (thrownValue) {
                  resetHooksState();
                  request$jscomp$1.children.length = childrenLength;
                  request$jscomp$1.chunks.length = chunkLength;
                  var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;
                  if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
                    request$jscomp$1.status = PENDING;
                    errorDigest.thenableState = getThenableStateAfterSuspending();
                    var ping$jscomp$0 = errorDigest.ping;
                    x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
                  } else {
                    var errorInfo$jscomp$1 = getThrownInfo(
                      errorDigest.componentStack
                    );
                    errorDigest.abortSet.delete(errorDigest);
                    request$jscomp$1.status = 4;
                    var boundary$jscomp$0 = errorDigest.blockedBoundary, debugTask = errorDigest.debugTask;
                    prevTaskInDEV = logRecoverableError(
                      request,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      debugTask
                    );
                    null === boundary$jscomp$0 ? fatalError(
                      request,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      debugTask
                    ) : (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED && (boundary$jscomp$0.status = CLIENT_RENDERED, encodeErrorForBoundary(
                      boundary$jscomp$0,
                      prevTaskInDEV,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      false
                    ), untrackBoundary(request, boundary$jscomp$0), boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(
                      boundary$jscomp$0
                    ), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request)));
                    request.allPendingTasks--;
                    0 === request.allPendingTasks && completeAll(request);
                  }
                } finally {
                  currentTaskInDEV = request$jscomp$0;
                }
              }
            }
            pingedTasks.splice(0, i);
            null !== request$jscomp$2.destination && flushCompletedQueues(
              request$jscomp$2,
              request$jscomp$2.destination
            );
          } catch (error) {
            pingedTasks = {}, logRecoverableError(request$jscomp$2, error, pingedTasks, null), fatalError(request$jscomp$2, error, pingedTasks, null);
          } finally {
            currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
          }
        }
      }
      function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
        segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
        for (var pendingPreambles = false, i = 0; i < segment.children.length; i++)
          pendingPreambles = preparePreambleFromSegment(
            request,
            segment.children[i],
            collectedPreambleSegments
          ) || pendingPreambles;
        return pendingPreambles;
      }
      function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
        var boundary = segment.boundary;
        if (null === boundary)
          return preparePreambleFromSubtree(
            request,
            segment,
            collectedPreambleSegments
          );
        var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
        if (null === preamble || null === fallbackPreamble) return false;
        switch (boundary.status) {
          case COMPLETED:
            hoistPreambleState(request.renderState, preamble);
            segment = boundary.completedSegments[0];
            if (!segment)
              throw Error(
                "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
              );
            return preparePreambleFromSubtree(
              request,
              segment,
              collectedPreambleSegments
            );
          case POSTPONED:
            if (null !== request.trackedPostpones) return true;
          case CLIENT_RENDERED:
            if (segment.status === COMPLETED)
              return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(
                request,
                segment,
                collectedPreambleSegments
              );
          default:
            return true;
        }
      }
      function preparePreamble(request) {
        if (request.completedRootSegment && null === request.completedPreambleSegments) {
          var collectedPreambleSegments = [], hasPendingPreambles = preparePreambleFromSegment(
            request,
            request.completedRootSegment,
            collectedPreambleSegments
          ), preamble = request.renderState.preamble;
          if (false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks)
            request.completedPreambleSegments = collectedPreambleSegments;
        }
      }
      function flushSubtree(request, destination, segment, hoistableState) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING:
            segment.id = request.nextSegmentId++;
          case POSTPONED:
            return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, writeChunk(destination, placeholder1), writeChunk(destination, request.placeholderPrefix), request = hoistableState.toString(16), writeChunk(destination, request), writeChunkAndReturn(destination, placeholder2);
          case COMPLETED:
            segment.status = FLUSHED;
            var r2 = true, chunks = segment.chunks, chunkIdx = 0;
            segment = segment.children;
            for (var childIdx = 0; childIdx < segment.length; childIdx++) {
              for (r2 = segment[childIdx]; chunkIdx < r2.index; chunkIdx++)
                writeChunk(destination, chunks[chunkIdx]);
              r2 = flushSegment(request, destination, r2, hoistableState);
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++)
              writeChunk(destination, chunks[chunkIdx]);
            chunkIdx < chunks.length && (r2 = writeChunkAndReturn(destination, chunks[chunkIdx]));
            return r2;
          default:
            throw Error(
              "Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React."
            );
        }
      }
      function flushSegment(request, destination, segment, hoistableState) {
        var boundary = segment.boundary;
        if (null === boundary)
          return flushSubtree(request, destination, segment, hoistableState);
        boundary.parentFlushed = true;
        if (boundary.status === CLIENT_RENDERED) {
          var errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
          writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
          writeChunk(destination, clientRenderedSuspenseBoundaryError1);
          errorDigest && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(destination, escapeTextForBrowser(errorDigest)), writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial
          ));
          errorMessage && (writeChunk(destination, clientRenderedSuspenseBoundaryError1B), writeChunk(destination, escapeTextForBrowser(errorMessage)), writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial
          ));
          errorStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1C), writeChunk(destination, escapeTextForBrowser(errorStack)), writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial
          ));
          errorComponentStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1D), writeChunk(destination, escapeTextForBrowser(errorComponentStack)), writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial
          ));
          writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
          flushSubtree(request, destination, segment, hoistableState);
          (request = boundary.fallbackPreamble) && writePreambleContribution(destination, request);
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        if (boundary.status !== COMPLETED)
          return boundary.status === PENDING && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
            destination,
            request.renderState,
            boundary.rootSegmentID
          ), hoistableState && (boundary = boundary.fallbackState, boundary.styles.forEach(hoistStyleQueueDependency, hoistableState), boundary.stylesheets.forEach(
            hoistStylesheetDependency,
            hoistableState
          )), flushSubtree(request, destination, segment, hoistableState), writeChunkAndReturn(destination, endSuspenseBoundary);
        if (boundary.byteSize > request.progressiveChunkSize)
          return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
            destination,
            request.renderState,
            boundary.rootSegmentID
          ), flushSubtree(request, destination, segment, hoistableState), writeChunkAndReturn(destination, endSuspenseBoundary);
        hoistableState && (segment = boundary.contentState, segment.styles.forEach(hoistStyleQueueDependency, hoistableState), segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));
        writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
        segment = boundary.completedSegments;
        if (1 !== segment.length)
          throw Error(
            "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
          );
        flushSegment(request, destination, segment[0], hoistableState);
        (request = boundary.contentPreamble) && writePreambleContribution(destination, request);
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function flushSegmentContainer(request, destination, segment, hoistableState) {
        writeStartSegment(
          destination,
          request.renderState,
          segment.parentFormatContext,
          segment.id
        );
        flushSegment(request, destination, segment, hoistableState);
        return writeEndSegment(destination, segment.parentFormatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++)
          flushPartiallyCompletedSegment(
            request,
            destination,
            boundary,
            completedSegments[i]
          );
        completedSegments.length = 0;
        writeHoistablesForBoundary(
          destination,
          boundary.contentState,
          request.renderState
        );
        completedSegments = request.resumableState;
        request = request.renderState;
        i = boundary.rootSegmentID;
        boundary = boundary.contentState;
        var requiresStyleInsertion = request.stylesToHoist;
        request.stylesToHoist = false;
        writeChunk(destination, request.startInlineScript);
        requiresStyleInsertion ? (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions = completedSegments.instructions | SentStyleInsertionFunction | SentCompleteBoundaryFunction, writeChunk(destination, completeBoundaryWithStylesScript1FullBoth)) : (completedSegments.instructions & SentStyleInsertionFunction) === NothingSent ? (completedSegments.instructions |= SentStyleInsertionFunction, writeChunk(
          destination,
          completeBoundaryWithStylesScript1FullPartial
        )) : writeChunk(destination, completeBoundaryWithStylesScript1Partial) : (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions |= SentCompleteBoundaryFunction, writeChunk(destination, completeBoundaryScript1Full)) : writeChunk(destination, completeBoundaryScript1Partial);
        completedSegments = i.toString(16);
        writeChunk(destination, request.boundaryPrefix);
        writeChunk(destination, completedSegments);
        writeChunk(destination, completeBoundaryScript2);
        writeChunk(destination, request.segmentPrefix);
        writeChunk(destination, completedSegments);
        requiresStyleInsertion ? (writeChunk(destination, completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : writeChunk(destination, completeBoundaryScript3b);
        boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
        return writeBootstrap(destination, request) && boundary;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) return true;
        var hoistableState = boundary.contentState, segmentID = segment.id;
        if (-1 === segmentID) {
          if (-1 === (segment.id = boundary.rootSegmentID))
            throw Error(
              "A root segment ID must have been assigned by now. This is a bug in React."
            );
          return flushSegmentContainer(
            request,
            destination,
            segment,
            hoistableState
          );
        }
        if (segmentID === boundary.rootSegmentID)
          return flushSegmentContainer(
            request,
            destination,
            segment,
            hoistableState
          );
        flushSegmentContainer(request, destination, segment, hoistableState);
        boundary = request.resumableState;
        request = request.renderState;
        writeChunk(destination, request.startInlineScript);
        (boundary.instructions & SentCompleteSegmentFunction) === NothingSent ? (boundary.instructions |= SentCompleteSegmentFunction, writeChunk(destination, completeSegmentScript1Full)) : writeChunk(destination, completeSegmentScript1Partial);
        writeChunk(destination, request.segmentPrefix);
        segmentID = segmentID.toString(16);
        writeChunk(destination, segmentID);
        writeChunk(destination, completeSegmentScript2);
        writeChunk(destination, request.placeholderPrefix);
        writeChunk(destination, segmentID);
        destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);
        return destination;
      }
      function flushCompletedQueues(request, destination) {
        currentView = new Uint8Array(2048);
        writtenBytes = 0;
        destinationHasCapacity$1 = true;
        try {
          if (!(0 < request.pendingRootTasks)) {
            var i, completedRootSegment = request.completedRootSegment;
            if (null !== completedRootSegment) {
              if (completedRootSegment.status === POSTPONED) return;
              var completedPreambleSegments = request.completedPreambleSegments;
              if (null === completedPreambleSegments) return;
              var renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
              if (htmlChunks) {
                for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
                  writeChunk(destination, htmlChunks[i$jscomp$0]);
                if (headChunks)
                  for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                    writeChunk(destination, headChunks[i$jscomp$0]);
                else
                  writeChunk(destination, startChunkForTag("head")), writeChunk(destination, endOfStartTag);
              } else if (headChunks)
                for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                  writeChunk(destination, headChunks[i$jscomp$0]);
              var charsetChunks = renderState.charsetChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
                writeChunk(destination, charsetChunks[i$jscomp$0]);
              charsetChunks.length = 0;
              renderState.preconnects.forEach(flushResource, destination);
              renderState.preconnects.clear();
              var viewportChunks = renderState.viewportChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
                writeChunk(destination, viewportChunks[i$jscomp$0]);
              viewportChunks.length = 0;
              renderState.fontPreloads.forEach(flushResource, destination);
              renderState.fontPreloads.clear();
              renderState.highImagePreloads.forEach(flushResource, destination);
              renderState.highImagePreloads.clear();
              renderState.styles.forEach(flushStylesInPreamble, destination);
              var importMapChunks = renderState.importMapChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
                writeChunk(destination, importMapChunks[i$jscomp$0]);
              importMapChunks.length = 0;
              renderState.bootstrapScripts.forEach(flushResource, destination);
              renderState.scripts.forEach(flushResource, destination);
              renderState.scripts.clear();
              renderState.bulkPreloads.forEach(flushResource, destination);
              renderState.bulkPreloads.clear();
              var hoistableChunks = renderState.hoistableChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
                writeChunk(destination, hoistableChunks[i$jscomp$0]);
              for (renderState = hoistableChunks.length = 0; renderState < completedPreambleSegments.length; renderState++) {
                var segments = completedPreambleSegments[renderState];
                for (preamble = 0; preamble < segments.length; preamble++)
                  flushSegment(request, destination, segments[preamble], null);
              }
              var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
              (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) && writeChunk(destination, endChunkForTag("head"));
              var bodyChunks = preamble$jscomp$0.bodyChunks;
              if (bodyChunks)
                for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
                  writeChunk(destination, bodyChunks[completedPreambleSegments]);
              flushSegment(request, destination, completedRootSegment, null);
              request.completedRootSegment = null;
              writeBootstrap(destination, request.renderState);
            }
            var renderState$jscomp$0 = request.renderState;
            completedRootSegment = 0;
            var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;
            for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
              writeChunk(
                destination,
                viewportChunks$jscomp$0[completedRootSegment]
              );
            viewportChunks$jscomp$0.length = 0;
            renderState$jscomp$0.preconnects.forEach(flushResource, destination);
            renderState$jscomp$0.preconnects.clear();
            renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);
            renderState$jscomp$0.fontPreloads.clear();
            renderState$jscomp$0.highImagePreloads.forEach(
              flushResource,
              destination
            );
            renderState$jscomp$0.highImagePreloads.clear();
            renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);
            renderState$jscomp$0.scripts.forEach(flushResource, destination);
            renderState$jscomp$0.scripts.clear();
            renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);
            renderState$jscomp$0.bulkPreloads.clear();
            var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;
            for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
              writeChunk(
                destination,
                hoistableChunks$jscomp$0[completedRootSegment]
              );
            hoistableChunks$jscomp$0.length = 0;
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            for (i = 0; i < clientRenderedBoundaries.length; i++) {
              var boundary = clientRenderedBoundaries[i];
              renderState$jscomp$0 = destination;
              var resumableState = request.resumableState, renderState$jscomp$1 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
              writeChunk(
                renderState$jscomp$0,
                renderState$jscomp$1.startInlineScript
              );
              (resumableState.instructions & SentClientRenderFunction) === NothingSent ? (resumableState.instructions |= SentClientRenderFunction, writeChunk(renderState$jscomp$0, clientRenderScript1Full)) : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);
              writeChunk(
                renderState$jscomp$0,
                renderState$jscomp$1.boundaryPrefix
              );
              writeChunk(renderState$jscomp$0, id.toString(16));
              writeChunk(renderState$jscomp$0, clientRenderScript1A);
              if (errorDigest || errorMessage || errorStack || errorComponentStack)
                writeChunk(
                  renderState$jscomp$0,
                  clientRenderErrorScriptArgInterstitial
                ), writeChunk(
                  renderState$jscomp$0,
                  escapeJSStringsForInstructionScripts(errorDigest || "")
                );
              if (errorMessage || errorStack || errorComponentStack)
                writeChunk(
                  renderState$jscomp$0,
                  clientRenderErrorScriptArgInterstitial
                ), writeChunk(
                  renderState$jscomp$0,
                  escapeJSStringsForInstructionScripts(errorMessage || "")
                );
              if (errorStack || errorComponentStack)
                writeChunk(
                  renderState$jscomp$0,
                  clientRenderErrorScriptArgInterstitial
                ), writeChunk(
                  renderState$jscomp$0,
                  escapeJSStringsForInstructionScripts(errorStack || "")
                );
              errorComponentStack && (writeChunk(
                renderState$jscomp$0,
                clientRenderErrorScriptArgInterstitial
              ), writeChunk(
                renderState$jscomp$0,
                escapeJSStringsForInstructionScripts(errorComponentStack)
              ));
              var JSCompiler_inline_result = writeChunkAndReturn(
                renderState$jscomp$0,
                clientRenderScriptEnd
              );
              if (!JSCompiler_inline_result) {
                request.destination = null;
                i++;
                clientRenderedBoundaries.splice(0, i);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i);
            var completedBoundaries = request.completedBoundaries;
            for (i = 0; i < completedBoundaries.length; i++)
              if (!flushCompletedBoundary(
                request,
                destination,
                completedBoundaries[i]
              )) {
                request.destination = null;
                i++;
                completedBoundaries.splice(0, i);
                return;
              }
            completedBoundaries.splice(0, i);
            completeWriting(destination);
            currentView = new Uint8Array(2048);
            writtenBytes = 0;
            destinationHasCapacity$1 = true;
            var partialBoundaries = request.partialBoundaries;
            for (i = 0; i < partialBoundaries.length; i++) {
              a: {
                clientRenderedBoundaries = request;
                boundary = destination;
                var boundary$jscomp$0 = partialBoundaries[i], completedSegments = boundary$jscomp$0.completedSegments;
                for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
                  if (!flushPartiallyCompletedSegment(
                    clientRenderedBoundaries,
                    boundary,
                    boundary$jscomp$0,
                    completedSegments[JSCompiler_inline_result]
                  )) {
                    JSCompiler_inline_result++;
                    completedSegments.splice(0, JSCompiler_inline_result);
                    var JSCompiler_inline_result$jscomp$0 = false;
                    break a;
                  }
                completedSegments.splice(0, JSCompiler_inline_result);
                JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
                  boundary,
                  boundary$jscomp$0.contentState,
                  clientRenderedBoundaries.renderState
                );
              }
              if (!JSCompiler_inline_result$jscomp$0) {
                request.destination = null;
                i++;
                partialBoundaries.splice(0, i);
                return;
              }
            }
            partialBoundaries.splice(0, i);
            var largeBoundaries = request.completedBoundaries;
            for (i = 0; i < largeBoundaries.length; i++)
              if (!flushCompletedBoundary(request, destination, largeBoundaries[i])) {
                request.destination = null;
                i++;
                largeBoundaries.splice(0, i);
                return;
              }
            largeBoundaries.splice(0, i);
          }
        } finally {
          0 === request.allPendingTasks && 0 === request.pingedTasks.length && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length ? (request.flushScheduled = false, i = request.resumableState, i.hasBody && writeChunk(destination, endChunkForTag("body")), i.hasHtml && writeChunk(destination, endChunkForTag("html")), completeWriting(destination), flushBuffered(destination), 0 !== request.abortableTasks.size && console.error(
            "There was still abortable task at the root when we closed. This is a bug in React."
          ), request.status = CLOSED, destination.end(), request.destination = null) : (completeWriting(destination), flushBuffered(destination));
        }
      }
      function startWork(request) {
        request.flushScheduled = null !== request.destination;
        scheduleMicrotask(function() {
          return requestStorage.run(request, performWork, request);
        });
        setImmediate(function() {
          10 === request.status && (request.status = 11);
          null === request.trackedPostpones && requestStorage.run(
            request,
            enqueueEarlyPreloadsAfterInitialWork,
            request
          );
        });
      }
      function enqueueEarlyPreloadsAfterInitialWork(request) {
        safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);
      }
      function enqueueFlush(request) {
        false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination && (request.flushScheduled = true, setImmediate(function() {
          var destination = request.destination;
          destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
        }));
      }
      function startFlowing(request, destination) {
        if (13 === request.status)
          request.status = CLOSED, destination.destroy(request.fatalError);
        else if (request.status !== CLOSED && null === request.destination) {
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error) {
            destination = {}, logRecoverableError(request, error, destination, null), fatalError(request, error, destination, null);
          }
        }
      }
      function abort(request, reason) {
        if (11 === request.status || 10 === request.status) request.status = 12;
        try {
          var abortableTasks = request.abortableTasks;
          if (0 < abortableTasks.size) {
            var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
            request.fatalError = error;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, error);
            });
            abortableTasks.clear();
          }
          null !== request.destination && flushCompletedQueues(request, request.destination);
        } catch (error$4) {
          reason = {}, logRecoverableError(request, error$4, reason, null), fatalError(request, error$4, reason, null);
        }
      }
      function ensureCorrectIsomorphicReactVersion() {
        var isomorphicReactPackageVersion = React12.version;
        if ("19.1.1" !== isomorphicReactPackageVersion)
          throw Error(
            'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.1.1\nLearn more: https://react.dev/warnings/version-mismatch")
          );
      }
      function createDrainHandler(destination, request) {
        return function() {
          return startFlowing(request, destination);
        };
      }
      function createCancelHandler(request, reason) {
        return function() {
          request.destination = null;
          abort(request, Error(reason));
        };
      }
      function createRequestImpl(children, options) {
        var resumableState = createResumableState(
          options ? options.identifierPrefix : void 0,
          options ? options.unstable_externalRuntimeSrc : void 0,
          options ? options.bootstrapScriptContent : void 0,
          options ? options.bootstrapScripts : void 0,
          options ? options.bootstrapModules : void 0
        );
        return createRequest(
          children,
          resumableState,
          createRenderState(
            resumableState,
            options ? options.nonce : void 0,
            options ? options.unstable_externalRuntimeSrc : void 0,
            options ? options.importMap : void 0,
            options ? options.onHeaders : void 0,
            options ? options.maxHeadersLength : void 0
          ),
          createRootFormatContext(options ? options.namespaceURI : void 0),
          options ? options.progressiveChunkSize : void 0,
          options ? options.onError : void 0,
          options ? options.onAllReady : void 0,
          options ? options.onShellReady : void 0,
          options ? options.onShellError : void 0,
          void 0,
          options ? options.onPostpone : void 0,
          options ? options.formState : void 0
        );
      }
      function createFakeWritable(readable) {
        return {
          write: function(chunk) {
            return readable.push(chunk);
          },
          end: function() {
            readable.push(null);
          },
          destroy: function(error) {
            readable.destroy(error);
          }
        };
      }
      var util = require("util"), crypto = require("crypto"), async_hooks = require("async_hooks"), React12 = require_react(), ReactDOM = require_react_dom(), stream = require("stream"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, isArrayImpl = Array.isArray, jsxPropsParents = /* @__PURE__ */ new WeakMap(), jsxChildrenParents = /* @__PURE__ */ new WeakMap(), CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"), scheduleMicrotask = queueMicrotask, currentView = null, writtenBytes = 0, destinationHasCapacity$1 = true, textEncoder = new util.TextEncoder(), assign = Object.assign, hasOwnProperty = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      ), aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]), hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      }, ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      }, warnedProperties$1 = {}, rARIA$1 = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel$1 = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), didWarnValueNull = false, possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        fetchpriority: "fetchPriority",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        inert: "inert",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        popover: "popover",
        popovertarget: "popoverTarget",
        popovertargetaction: "popoverTargetAction",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        transformorigin: "transformOrigin",
        "transform-origin": "transformOrigin",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      }, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern$1 = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, matchHtmlRegExp = /["'&<>]/, uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, ReactSharedInternals = React12.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
        pending: false,
        data: null,
        method: null,
        action: null
      }), previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: previousDispatcher.f,
        r: previousDispatcher.r,
        D: function(href) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if ("string" === typeof href && href) {
              if (!resumableState.dnsResources.hasOwnProperty(href)) {
                resumableState.dnsResources[href] = EXISTS;
                resumableState = renderState.headers;
                var header, JSCompiler_temp;
                if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
                  JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
                JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
              }
              enqueueFlush(request);
            }
          } else previousDispatcher.D(href);
        },
        C: function(href, crossOrigin) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if ("string" === typeof href && href) {
              var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
              if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
                resumableState.connectResources[bucket][href] = EXISTS;
                resumableState = renderState.headers;
                var header, JSCompiler_temp;
                if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
                  JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=preconnect";
                  if ("string" === typeof crossOrigin) {
                    var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(
                      crossOrigin,
                      "crossOrigin"
                    );
                    JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
                  }
                  JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
                }
                JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
                  rel: "preconnect",
                  href,
                  crossOrigin
                }), renderState.preconnects.add(bucket));
              }
              enqueueFlush(request);
            }
          } else previousDispatcher.C(href, crossOrigin);
        },
        L: function(href, as3, options) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (as3 && href) {
              switch (as3) {
                case "image":
                  if (options) {
                    var imageSrcSet = options.imageSrcSet;
                    var imageSizes = options.imageSizes;
                    var fetchPriority = options.fetchPriority;
                  }
                  var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
                  if (resumableState.imageResources.hasOwnProperty(key)) return;
                  resumableState.imageResources[key] = PRELOAD_NO_CREDS;
                  resumableState = renderState.headers;
                  var header;
                  resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader(href, as3, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(
                    resumableState,
                    assign(
                      {
                        rel: "preload",
                        href: imageSrcSet ? void 0 : href,
                        as: as3
                      },
                      options
                    )
                  ), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
                  break;
                case "style":
                  if (resumableState.styleResources.hasOwnProperty(href)) return;
                  imageSrcSet = [];
                  pushLinkImpl(
                    imageSrcSet,
                    assign({ rel: "preload", href, as: as3 }, options)
                  );
                  resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                  renderState.preloads.stylesheets.set(href, imageSrcSet);
                  renderState.bulkPreloads.add(imageSrcSet);
                  break;
                case "script":
                  if (resumableState.scriptResources.hasOwnProperty(href)) return;
                  imageSrcSet = [];
                  renderState.preloads.scripts.set(href, imageSrcSet);
                  renderState.bulkPreloads.add(imageSrcSet);
                  pushLinkImpl(
                    imageSrcSet,
                    assign({ rel: "preload", href, as: as3 }, options)
                  );
                  resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                  break;
                default:
                  if (resumableState.unknownResources.hasOwnProperty(as3)) {
                    if (imageSrcSet = resumableState.unknownResources[as3], imageSrcSet.hasOwnProperty(href))
                      return;
                  } else
                    imageSrcSet = {}, resumableState.unknownResources[as3] = imageSrcSet;
                  imageSrcSet[href] = PRELOAD_NO_CREDS;
                  if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as3 && (key = getPreloadAsHeader(href, as3, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
                    renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
                  else
                    switch (resumableState = [], href = assign(
                      { rel: "preload", href, as: as3 },
                      options
                    ), pushLinkImpl(resumableState, href), as3) {
                      case "font":
                        renderState.fontPreloads.add(resumableState);
                        break;
                      default:
                        renderState.bulkPreloads.add(resumableState);
                    }
              }
              enqueueFlush(request);
            }
          } else previousDispatcher.L(href, as3, options);
        },
        m: function(href, options) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (href) {
              var as3 = options && "string" === typeof options.as ? options.as : "script";
              switch (as3) {
                case "script":
                  if (resumableState.moduleScriptResources.hasOwnProperty(href))
                    return;
                  as3 = [];
                  resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                  renderState.preloads.moduleScripts.set(href, as3);
                  break;
                default:
                  if (resumableState.moduleUnknownResources.hasOwnProperty(as3)) {
                    var resources = resumableState.unknownResources[as3];
                    if (resources.hasOwnProperty(href)) return;
                  } else
                    resources = {}, resumableState.moduleUnknownResources[as3] = resources;
                  as3 = [];
                  resources[href] = PRELOAD_NO_CREDS;
              }
              pushLinkImpl(
                as3,
                assign({ rel: "modulepreload", href }, options)
              );
              renderState.bulkPreloads.add(as3);
              enqueueFlush(request);
            }
          } else previousDispatcher.m(href, options);
        },
        X: function(src, options) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (src) {
              var resourceState = resumableState.scriptResources.hasOwnProperty(
                src
              ) ? resumableState.scriptResources[src] : void 0;
              resourceState !== EXISTS && (resumableState.scriptResources[src] = EXISTS, options = assign({ src, async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
            }
          } else previousDispatcher.X(src, options);
        },
        S: function(href, precedence, options) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (href) {
              precedence = precedence || "default";
              var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
              resourceState !== EXISTS && (resumableState.styleResources[href] = EXISTS, styleQueue || (styleQueue = {
                precedence: escapeTextForBrowser(precedence),
                rules: [],
                hrefs: [],
                sheets: /* @__PURE__ */ new Map()
              }, renderState.styles.set(precedence, styleQueue)), precedence = {
                state: PENDING$1,
                props: assign(
                  {
                    rel: "stylesheet",
                    href,
                    "data-precedence": precedence
                  },
                  options
                )
              }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
            }
          } else previousDispatcher.S(href, precedence, options);
        },
        M: function(src, options) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (src) {
              var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : void 0;
              resourceState !== EXISTS && (resumableState.moduleScriptResources[src] = EXISTS, options = assign(
                { src, type: "module", async: true },
                options
              ), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
            }
          } else previousDispatcher.M(src, options);
        }
      };
      var NothingSent = 0, SentCompleteSegmentFunction = 1, SentCompleteBoundaryFunction = 2, SentClientRenderFunction = 4, SentStyleInsertionFunction = 8, EXISTS = null, PRELOAD_NO_CREDS = [];
      Object.freeze(PRELOAD_NO_CREDS);
      stringToPrecomputedChunk('"></template>');
      var startInlineScript = stringToPrecomputedChunk("<script>"), endInlineScript = stringToPrecomputedChunk("</script>"), startScriptSrc = stringToPrecomputedChunk('<script src="'), startModuleSrc = stringToPrecomputedChunk('<script type="module" src="'), scriptNonce = stringToPrecomputedChunk('" nonce="'), scriptIntegirty = stringToPrecomputedChunk('" integrity="'), scriptCrossOrigin = stringToPrecomputedChunk('" crossorigin="'), endAsyncScript = stringToPrecomputedChunk('" async=""></script>'), scriptRegex = /(<\/|<)(s)(cript)/gi, importMapScriptStart = stringToPrecomputedChunk(
        '<script type="importmap">'
      ), importMapScriptEnd = stringToPrecomputedChunk("</script>");
      var didWarnForNewBooleanPropsWithEmptyValue = {};
      var NoContribution = 0, ROOT_HTML_MODE = 0, HTML_HTML_MODE = 1, HTML_MODE = 2, HTML_HEAD_MODE = 3, SVG_MODE = 4, MATHML_MODE = 5, HTML_TABLE_MODE = 6, HTML_TABLE_BODY_MODE = 7, HTML_TABLE_ROW_MODE = 8, HTML_COLGROUP_MODE = 9, textSeparator = stringToPrecomputedChunk("<!-- -->"), styleNameCache = /* @__PURE__ */ new Map(), styleAttributeStart = stringToPrecomputedChunk(' style="'), styleAssign = stringToPrecomputedChunk(":"), styleSeparator = stringToPrecomputedChunk(";"), attributeSeparator = stringToPrecomputedChunk(" "), attributeAssign = stringToPrecomputedChunk('="'), attributeEnd = stringToPrecomputedChunk('"'), attributeEmptyString = stringToPrecomputedChunk('=""'), actionJavaScriptURL = stringToPrecomputedChunk(
        escapeTextForBrowser(
          "javascript:throw new Error('React form unexpectedly submitted.')"
        )
      ), startHiddenInputChunk = stringToPrecomputedChunk('<input type="hidden"'), endOfStartTag = stringToPrecomputedChunk(">"), endOfStartTagSelfClosing = stringToPrecomputedChunk("/>"), didWarnDefaultInputValue = false, didWarnDefaultChecked = false, didWarnDefaultSelectValue = false, didWarnDefaultTextareaValue = false, didWarnInvalidOptionChildren = false, didWarnInvalidOptionInnerHTML = false, didWarnSelectedSetOnOption = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""'), formReplayingRuntimeScript = stringToPrecomputedChunk(
        `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`
      ), formStateMarkerIsMatching = stringToPrecomputedChunk("<!--F!-->"), formStateMarkerIsNotMatching = stringToPrecomputedChunk("<!--F-->"), styleRegex = /(<\/|<)(s)(tyle)/gi, leadingNewline = stringToPrecomputedChunk("\n"), VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map(), doctypeChunk = stringToPrecomputedChunk("<!DOCTYPE html>"), endTagCache = /* @__PURE__ */ new Map(), placeholder1 = stringToPrecomputedChunk('<template id="'), placeholder2 = stringToPrecomputedChunk('"></template>'), startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->"), startPendingSuspenseBoundary1 = stringToPrecomputedChunk(
        '<!--$?--><template id="'
      ), startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>'), startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->"), endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->"), clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template"), clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"'), clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="'), clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="'), clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="'), clientRenderedSuspenseBoundaryError1D = stringToPrecomputedChunk(' data-cstck="'), clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>"), boundaryPreambleContributionChunkStart = stringToPrecomputedChunk("<!--"), boundaryPreambleContributionChunkEnd = stringToPrecomputedChunk("-->"), startSegmentHTML = stringToPrecomputedChunk('<div hidden id="'), startSegmentHTML2 = stringToPrecomputedChunk('">'), endSegmentHTML = stringToPrecomputedChunk("</div>"), startSegmentSVG = stringToPrecomputedChunk(
        '<svg aria-hidden="true" style="display:none" id="'
      ), startSegmentSVG2 = stringToPrecomputedChunk('">'), endSegmentSVG = stringToPrecomputedChunk("</svg>"), startSegmentMathML = stringToPrecomputedChunk(
        '<math aria-hidden="true" style="display:none" id="'
      ), startSegmentMathML2 = stringToPrecomputedChunk('">'), endSegmentMathML = stringToPrecomputedChunk("</math>"), startSegmentTable = stringToPrecomputedChunk('<table hidden id="'), startSegmentTable2 = stringToPrecomputedChunk('">'), endSegmentTable = stringToPrecomputedChunk("</table>"), startSegmentTableBody = stringToPrecomputedChunk(
        '<table hidden><tbody id="'
      ), startSegmentTableBody2 = stringToPrecomputedChunk('">'), endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>"), startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="'), startSegmentTableRow2 = stringToPrecomputedChunk('">'), endSegmentTableRow = stringToPrecomputedChunk("</tr></table>"), startSegmentColGroup = stringToPrecomputedChunk(
        '<table hidden><colgroup id="'
      ), startSegmentColGroup2 = stringToPrecomputedChunk('">'), endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>"), completeSegmentScript1Full = stringToPrecomputedChunk(
        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
      ), completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("'), completeSegmentScript2 = stringToPrecomputedChunk('","'), completeSegmentScriptEnd = stringToPrecomputedChunk('")</script>');
      stringToPrecomputedChunk('<template data-rsi="" data-sid="');
      stringToPrecomputedChunk('" data-pid="');
      var completeBoundaryScript1Full = stringToPrecomputedChunk(
        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
      ), completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("'), completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(
        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
      ), completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(
        '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
      ), completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR("'), completeBoundaryScript2 = stringToPrecomputedChunk('","'), completeBoundaryScript3a = stringToPrecomputedChunk('",'), completeBoundaryScript3b = stringToPrecomputedChunk('"'), completeBoundaryScriptEnd = stringToPrecomputedChunk(")</script>");
      stringToPrecomputedChunk('<template data-rci="" data-bid="');
      stringToPrecomputedChunk('<template data-rri="" data-bid="');
      stringToPrecomputedChunk('" data-sid="');
      stringToPrecomputedChunk('" data-sty="');
      var clientRenderScript1Full = stringToPrecomputedChunk(
        '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
      ), clientRenderScript1Partial = stringToPrecomputedChunk('$RX("'), clientRenderScript1A = stringToPrecomputedChunk('"'), clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(","), clientRenderScriptEnd = stringToPrecomputedChunk(")</script>");
      stringToPrecomputedChunk('<template data-rxi="" data-bid="');
      stringToPrecomputedChunk('" data-dgst="');
      stringToPrecomputedChunk('" data-msg="');
      stringToPrecomputedChunk('" data-stck="');
      stringToPrecomputedChunk('" data-cstck="');
      var regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g, regexForJSStringsInScripts = /[&><\u2028\u2029]/g, lateStyleTagResourceOpen1 = stringToPrecomputedChunk(
        '<style media="not all" data-precedence="'
      ), lateStyleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="'), lateStyleTagResourceOpen3 = stringToPrecomputedChunk('">'), lateStyleTagTemplateClose = stringToPrecomputedChunk("</style>"), currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true, stylesheetFlushingQueue = [], styleTagResourceOpen1 = stringToPrecomputedChunk(
        '<style data-precedence="'
      ), styleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="'), spaceSeparator = stringToPrecomputedChunk(" "), styleTagResourceOpen3 = stringToPrecomputedChunk('">'), styleTagResourceClose = stringToPrecomputedChunk("</style>"), arrayFirstOpenBracket = stringToPrecomputedChunk("["), arraySubsequentOpenBracket = stringToPrecomputedChunk(",["), arrayInterstitial = stringToPrecomputedChunk(","), arrayCloseBracket = stringToPrecomputedChunk("]"), PENDING$1 = 0, PRELOADED = 1, PREAMBLE = 2, LATE = 3, regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g, regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g, bind = Function.prototype.bind, requestStorage = new async_hooks.AsyncLocalStorage(), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), emptyContextObject = {};
      Object.freeze(emptyContextObject);
      var rendererSigil = {};
      var currentActiveSnapshot = null, didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
      var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
      var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
      var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
      var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
      var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          var internals = inst._reactInternals;
          null === internals.queue ? warnNoop(inst, "setState") : (internals.queue.push(payload), void 0 !== callback && null !== callback && warnOnInvalidCallback(callback));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          inst.replace = true;
          inst.queue = [payload];
          void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
        },
        enqueueForceUpdate: function(inst, callback) {
          null === inst._reactInternals.queue ? warnNoop(inst, "forceUpdate") : void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
        }
      }, emptyTreeContext = { id: 1, overflow: "" }, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, SuspenseException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
      ), suspendedThenable = null, objectIs = "function" === typeof Object.is ? Object.is : is3, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0, isInHookUserCodeInDev = false, currentHookNameInDev, HooksDispatcher = {
        readContext,
        use: function(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then)
              return unwrapThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE)
              return readContext(usable);
          }
          throw Error(
            "An unsupported type was passed to use(): " + String(usable)
          );
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          resolveCurrentlyRenderingComponent();
          return context._currentValue;
        },
        useMemo,
        useReducer,
        useRef: function(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          return null === previousRef ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook.memoizedState = initialValue) : previousRef;
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState";
          return useReducer(basicStateReducer, initialState);
        },
        useInsertionEffect: noop$1,
        useLayoutEffect: noop$1,
        useCallback: function(callback, deps) {
          return useMemo(function() {
            return callback;
          }, deps);
        },
        useImperativeHandle: noop$1,
        useEffect: noop$1,
        useDebugValue: noop$1,
        useDeferredValue: function(value, initialValue) {
          resolveCurrentlyRenderingComponent();
          return void 0 !== initialValue ? initialValue : value;
        },
        useTransition: function() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        },
        useId: function() {
          var treeId = currentlyRenderingTask.treeContext;
          var overflow = treeId.overflow;
          treeId = treeId.id;
          treeId = (treeId & ~(1 << 32 - clz32(treeId) - 1)).toString(32) + overflow;
          var resumableState = currentResumableState;
          if (null === resumableState)
            throw Error(
              "Invalid hook call. Hooks can only be called inside of the body of a function component."
            );
          overflow = localIdCounter++;
          treeId = "\xAB" + resumableState.idPrefix + "R" + treeId;
          0 < overflow && (treeId += "H" + overflow.toString(32));
          return treeId + "\xBB";
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          if (void 0 === getServerSnapshot)
            throw Error(
              "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
            );
          return getServerSnapshot();
        },
        useOptimistic: function(passthrough) {
          resolveCurrentlyRenderingComponent();
          return [passthrough, unsupportedSetOptimisticState];
        },
        useActionState,
        useFormState: useActionState,
        useHostTransitionStatus: function() {
          resolveCurrentlyRenderingComponent();
          return NotPending;
        },
        useMemoCache: function(size) {
          for (var data = Array(size), i = 0; i < size; i++)
            data[i] = REACT_MEMO_CACHE_SENTINEL;
          return data;
        },
        useCacheRefresh: function() {
          return unsupportedRefresh;
        }
      }, currentResumableState = null, currentTaskInDEV = null, DefaultAsyncDispatcher = {
        getCacheForType: function() {
          throw Error("Not implemented.");
        },
        getOwner: function() {
          return null === currentTaskInDEV ? null : currentTaskInDEV.componentStack;
        }
      }, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      disabledLog.__reactDisabledLog = true;
      var prefix, suffix, reentry = false;
      var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
      var callComponent = {
        react_stack_bottom_frame: function(Component, props, secondArg) {
          return Component(props, secondArg);
        }
      }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
        react_stack_bottom_frame: function(instance) {
          return instance.render();
        }
      }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callLazyInit = {
        react_stack_bottom_frame: function(lazy) {
          var init = lazy._init;
          return init(lazy._payload);
        }
      }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), lastResetTime = 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        var getCurrentTime = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date;
        getCurrentTime = function() {
          return localDate.now();
        };
      }
      var CLIENT_RENDERED = 4, PENDING = 0, COMPLETED = 1, FLUSHED = 2, POSTPONED = 5, CLOSED = 14, currentRequest = null, didWarnAboutBadClass = {}, didWarnAboutContextTypes = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = false, didWarnAboutGenerators = false, didWarnAboutMaps = false;
      ensureCorrectIsomorphicReactVersion();
      ensureCorrectIsomorphicReactVersion();
      exports2.prerenderToNodeStream = function(children, options) {
        return new Promise(function(resolve, reject) {
          var resumableState = createResumableState(
            options ? options.identifierPrefix : void 0,
            options ? options.unstable_externalRuntimeSrc : void 0,
            options ? options.bootstrapScriptContent : void 0,
            options ? options.bootstrapScripts : void 0,
            options ? options.bootstrapModules : void 0
          ), request = createPrerenderRequest(
            children,
            resumableState,
            createRenderState(
              resumableState,
              void 0,
              options ? options.unstable_externalRuntimeSrc : void 0,
              options ? options.importMap : void 0,
              options ? options.onHeaders : void 0,
              options ? options.maxHeadersLength : void 0
            ),
            createRootFormatContext(options ? options.namespaceURI : void 0),
            options ? options.progressiveChunkSize : void 0,
            options ? options.onError : void 0,
            function() {
              var readable = new stream.Readable({
                read: function() {
                  startFlowing(request, writable);
                }
              }), writable = createFakeWritable(readable);
              resolve({ prelude: readable });
            },
            void 0,
            void 0,
            reject,
            options ? options.onPostpone : void 0
          );
          if (options && options.signal) {
            var signal = options.signal;
            if (signal.aborted) abort(request, signal.reason);
            else {
              var listener = function() {
                abort(request, signal.reason);
                signal.removeEventListener("abort", listener);
              };
              signal.addEventListener("abort", listener);
            }
          }
          startWork(request);
        });
      };
      exports2.renderToPipeableStream = function(children, options) {
        var request = createRequestImpl(children, options), hasStartedFlowing = false;
        startWork(request);
        return {
          pipe: function(destination) {
            if (hasStartedFlowing)
              throw Error(
                "React currently only supports piping to one writable stream."
              );
            hasStartedFlowing = true;
            safelyEmitEarlyPreloads(
              request,
              null === request.trackedPostpones ? 0 === request.pendingRootTasks : null === request.completedRootSegment ? 0 === request.pendingRootTasks : request.completedRootSegment.status !== POSTPONED
            );
            startFlowing(request, destination);
            destination.on("drain", createDrainHandler(destination, request));
            destination.on(
              "error",
              createCancelHandler(
                request,
                "The destination stream errored while writing data."
              )
            );
            destination.on(
              "close",
              createCancelHandler(request, "The destination stream closed early.")
            );
            return destination;
          },
          abort: function(reason) {
            abort(request, reason);
          }
        };
      };
      exports2.version = "19.1.1";
    })();
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS({
  "node_modules/react-dom/server.node.js"(exports2) {
    "use strict";
    var l2;
    var s2;
    if (process.env.NODE_ENV === "production") {
      l2 = require_react_dom_server_legacy_node_production();
      s2 = require_react_dom_server_node_production();
    } else {
      l2 = require_react_dom_server_legacy_node_development();
      s2 = require_react_dom_server_node_development();
    }
    exports2.version = l2.version;
    exports2.renderToString = l2.renderToString;
    exports2.renderToStaticMarkup = l2.renderToStaticMarkup;
    exports2.renderToPipeableStream = s2.renderToPipeableStream;
    if (s2.resumeToPipeableStream) {
      exports2.resumeToPipeableStream = s2.resumeToPipeableStream;
    }
  }
});

// emails/Farcaster.jsx
var Farcaster_exports = {};
__export(Farcaster_exports, {
  default: () => FarcasterEmail,
  reactEmailCreateReactElement: () => import_react4.createElement,
  render: () => render2
});
module.exports = __toCommonJS(Farcaster_exports);
var import_react3 = __toESM(require_react(), 1);

// node_modules/@react-email/body/dist/index.mjs
var React = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp2.call(b3, prop))
      __defNormalProp(a, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop))
        __defNormalProp(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps = (a, b3) => __defProps(a, __getOwnPropDescs(b3));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Body = React.forwardRef(
  (_a4, ref) => {
    var _b = _a4, { children, style } = _b, props = __objRest(_b, ["children", "style"]);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "body",
      __spreadProps(__spreadValues({}, props), {
        style: {
          background: style == null ? void 0 : style.background,
          backgroundColor: style == null ? void 0 : style.backgroundColor
        },
        ref,
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          "table",
          {
            border: 0,
            width: "100%",
            cellPadding: "0",
            cellSpacing: "0",
            role: "presentation",
            align: "center",
            children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tbody", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tr", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("td", { style, children }) }) })
          }
        )
      })
    );
  }
);
Body.displayName = "Body";

// node_modules/@react-email/column/dist/index.mjs
var React2 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var __defProp3 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp3.call(b3, prop))
      __defNormalProp2(a, prop, b3[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b3)) {
      if (__propIsEnum2.call(b3, prop))
        __defNormalProp2(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b3) => __defProps2(a, __getOwnPropDescs2(b3));
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Column = React2.forwardRef(
  (_a4, ref) => {
    var _b = _a4, { children, style } = _b, props = __objRest2(_b, ["children", "style"]);
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("td", __spreadProps2(__spreadValues2({}, props), { "data-id": "__react-email-column", ref, style, children }));
  }
);
Column.displayName = "Column";

// node_modules/@react-email/container/dist/index.mjs
var React3 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var __defProp4 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp4.call(b3, prop))
      __defNormalProp3(a, prop, b3[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b3)) {
      if (__propIsEnum3.call(b3, prop))
        __defNormalProp3(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps3 = (a, b3) => __defProps3(a, __getOwnPropDescs3(b3));
var __objRest3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Container = React3.forwardRef(
  (_a4, ref) => {
    var _b = _a4, { children, style } = _b, props = __objRest3(_b, ["children", "style"]);
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      "table",
      __spreadProps3(__spreadValues3({
        align: "center",
        width: "100%"
      }, props), {
        border: 0,
        cellPadding: "0",
        cellSpacing: "0",
        ref,
        role: "presentation",
        style: __spreadValues3({ maxWidth: "37.5em" }, style),
        children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("tbody", { children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("tr", { style: { width: "100%" }, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("td", { children }) }) })
      })
    );
  }
);
Container.displayName = "Container";

// node_modules/@react-email/head/dist/index.mjs
var React4 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var __defProp5 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp5.call(b3, prop))
      __defNormalProp4(a, prop, b3[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b3)) {
      if (__propIsEnum4.call(b3, prop))
        __defNormalProp4(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps4 = (a, b3) => __defProps4(a, __getOwnPropDescs4(b3));
var __objRest4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Head = React4.forwardRef(
  (_a4, ref) => {
    var _b = _a4, { children } = _b, props = __objRest4(_b, ["children"]);
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("head", __spreadProps4(__spreadValues4({}, props), { ref, children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("meta", { content: "text/html; charset=UTF-8", httpEquiv: "Content-Type" }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("meta", { name: "x-apple-disable-message-reformatting" }),
      children
    ] }));
  }
);
Head.displayName = "Head";

// node_modules/@react-email/html/dist/index.mjs
var React5 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var __defProp6 = Object.defineProperty;
var __defProps5 = Object.defineProperties;
var __getOwnPropDescs5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp6 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues5 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp6.call(b3, prop))
      __defNormalProp5(a, prop, b3[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b3)) {
      if (__propIsEnum5.call(b3, prop))
        __defNormalProp5(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps5 = (a, b3) => __defProps5(a, __getOwnPropDescs5(b3));
var __objRest5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Html = React5.forwardRef(
  (_a4, ref) => {
    var _b = _a4, { children, lang = "en", dir = "ltr" } = _b, props = __objRest5(_b, ["children", "lang", "dir"]);
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("html", __spreadProps5(__spreadValues5({}, props), { dir, lang, ref, children }));
  }
);
Html.displayName = "Html";

// node_modules/@react-email/img/dist/index.mjs
var React6 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var __defProp7 = Object.defineProperty;
var __defProps6 = Object.defineProperties;
var __getOwnPropDescs6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols6 = Object.getOwnPropertySymbols;
var __hasOwnProp7 = Object.prototype.hasOwnProperty;
var __propIsEnum6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues6 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp7.call(b3, prop))
      __defNormalProp6(a, prop, b3[prop]);
  if (__getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(b3)) {
      if (__propIsEnum6.call(b3, prop))
        __defNormalProp6(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps6 = (a, b3) => __defProps6(a, __getOwnPropDescs6(b3));
var __objRest6 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp7.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Img = React6.forwardRef(
  (_a4, ref) => {
    var _b = _a4, { alt, src, width, height, style } = _b, props = __objRest6(_b, ["alt", "src", "width", "height", "style"]);
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
      "img",
      __spreadProps6(__spreadValues6({}, props), {
        alt,
        height,
        ref,
        src,
        style: __spreadValues6({
          display: "block",
          outline: "none",
          border: "none",
          textDecoration: "none"
        }, style),
        width
      })
    );
  }
);
Img.displayName = "Img";

// node_modules/@react-email/link/dist/index.mjs
var React7 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var __defProp8 = Object.defineProperty;
var __defProps7 = Object.defineProperties;
var __getOwnPropDescs7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols7 = Object.getOwnPropertySymbols;
var __hasOwnProp8 = Object.prototype.hasOwnProperty;
var __propIsEnum7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues7 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp8.call(b3, prop))
      __defNormalProp7(a, prop, b3[prop]);
  if (__getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(b3)) {
      if (__propIsEnum7.call(b3, prop))
        __defNormalProp7(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps7 = (a, b3) => __defProps7(a, __getOwnPropDescs7(b3));
var __objRest7 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp8.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum7.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Link = React7.forwardRef(
  (_a4, ref) => {
    var _b = _a4, { target = "_blank", style } = _b, props = __objRest7(_b, ["target", "style"]);
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      "a",
      __spreadProps7(__spreadValues7({}, props), {
        ref,
        style: __spreadValues7({
          color: "#067df7",
          textDecorationLine: "none"
        }, style),
        target,
        children: props.children
      })
    );
  }
);
Link.displayName = "Link";

// node_modules/@react-email/render/dist/node/index.mjs
var import_react = __toESM(require_react(), 1);

// node_modules/prettier/plugins/html.mjs
var html_exports = {};
__export(html_exports, {
  default: () => ym,
  languages: () => Hs,
  options: () => Us,
  parsers: () => tn,
  printers: () => uu
});
var on = Object.defineProperty;
var un = (t8) => {
  throw TypeError(t8);
};
var Ai = (t8, e2, r2) => e2 in t8 ? on(t8, e2, { enumerable: true, configurable: true, writable: true, value: r2 }) : t8[e2] = r2;
var ln = (t8, e2) => {
  for (var r2 in e2) on(t8, r2, { get: e2[r2], enumerable: true });
};
var lr = (t8, e2, r2) => Ai(t8, typeof e2 != "symbol" ? e2 + "" : e2, r2);
var cn = (t8, e2, r2) => e2.has(t8) || un("Cannot " + r2);
var R = (t8, e2, r2) => (cn(t8, e2, "read from private field"), r2 ? r2.call(t8) : e2.get(t8));
var At = (t8, e2, r2) => e2.has(t8) ? un("Cannot add the same private member more than once") : e2 instanceof WeakSet ? e2.add(t8) : e2.set(t8, r2);
var pn = (t8, e2, r2, n2) => (cn(t8, e2, "write to private field"), n2 ? n2.call(t8, r2) : e2.set(t8, r2), r2);
var rn = {};
ln(rn, { languages: () => Hs, options: () => Us, parsers: () => tn, printers: () => uu });
var Di = (t8, e2, r2, n2) => {
  if (!(t8 && e2 == null)) return e2.replaceAll ? e2.replaceAll(r2, n2) : r2.global ? e2.replace(r2, n2) : e2.split(r2).join(n2);
};
var w = Di;
var we = "string";
var ze = "array";
var Ye = "cursor";
var be = "indent";
var Te = "align";
var je = "trim";
var xe = "group";
var ke = "fill";
var ce = "if-break";
var Be = "indent-if-break";
var Ke = "line-suffix";
var Xe = "line-suffix-boundary";
var j = "line";
var Qe = "label";
var Le = "break-parent";
var Dt = /* @__PURE__ */ new Set([Ye, be, Te, je, xe, ke, ce, Be, Ke, Xe, j, Qe, Le]);
var vi = (t8, e2, r2) => {
  if (!(t8 && e2 == null)) return Array.isArray(e2) || typeof e2 == "string" ? e2[r2 < 0 ? e2.length + r2 : r2] : e2.at(r2);
};
var K = vi;
function yi(t8) {
  if (typeof t8 == "string") return we;
  if (Array.isArray(t8)) return ze;
  if (!t8) return;
  let { type: e2 } = t8;
  if (Dt.has(e2)) return e2;
}
var Fe = yi;
var wi = (t8) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t8);
function bi(t8) {
  let e2 = t8 === null ? "null" : typeof t8;
  if (e2 !== "string" && e2 !== "object") return `Unexpected doc '${e2}', 
Expected it to be 'string' or 'object'.`;
  if (Fe(t8)) throw new Error("doc is valid.");
  let r2 = Object.prototype.toString.call(t8);
  if (r2 !== "[object Object]") return `Unexpected doc '${r2}'.`;
  let n2 = wi([...Dt].map((s2) => `'${s2}'`));
  return `Unexpected doc.type '${t8.type}'.
Expected it to be ${n2}.`;
}
var cr = class extends Error {
  name = "InvalidDocError";
  constructor(e2) {
    super(bi(e2)), this.doc = e2;
  }
};
var pr = cr;
function hr(t8, e2) {
  if (typeof t8 == "string") return e2(t8);
  let r2 = /* @__PURE__ */ new Map();
  return n2(t8);
  function n2(i) {
    if (r2.has(i)) return r2.get(i);
    let a = s2(i);
    return r2.set(i, a), a;
  }
  function s2(i) {
    switch (Fe(i)) {
      case ze:
        return e2(i.map(n2));
      case ke:
        return e2({ ...i, parts: i.parts.map(n2) });
      case ce:
        return e2({ ...i, breakContents: n2(i.breakContents), flatContents: n2(i.flatContents) });
      case xe: {
        let { expandedStates: a, contents: o2 } = i;
        return a ? (a = a.map(n2), o2 = a[0]) : o2 = n2(o2), e2({ ...i, contents: o2, expandedStates: a });
      }
      case Te:
      case be:
      case Be:
      case Qe:
      case Ke:
        return e2({ ...i, contents: n2(i.contents) });
      case we:
      case Ye:
      case je:
      case Xe:
      case j:
      case Le:
        return e2(i);
      default:
        throw new pr(i);
    }
  }
}
function B(t8, e2 = hn) {
  return hr(t8, (r2) => typeof r2 == "string" ? H(e2, r2.split(`
`)) : r2);
}
var mr = () => {
};
var re = mr;
var fr = mr;
var mn = mr;
function k(t8) {
  return re(t8), { type: be, contents: t8 };
}
function fn(t8, e2) {
  return re(e2), { type: Te, contents: e2, n: t8 };
}
function E(t8, e2 = {}) {
  return re(t8), fr(e2.expandedStates, true), { type: xe, id: e2.id, contents: t8, break: !!e2.shouldBreak, expandedStates: e2.expandedStates };
}
function dn(t8) {
  return fn(Number.NEGATIVE_INFINITY, t8);
}
function gn(t8) {
  return fn({ type: "root" }, t8);
}
function vt(t8) {
  return mn(t8), { type: ke, parts: t8 };
}
function pe(t8, e2 = "", r2 = {}) {
  return re(t8), e2 !== "" && re(e2), { type: ce, breakContents: t8, flatContents: e2, groupId: r2.groupId };
}
function Cn(t8, e2) {
  return re(t8), { type: Be, contents: t8, groupId: e2.groupId, negate: e2.negate };
}
var ne = { type: Le };
var xi = { type: j, hard: true };
var ki = { type: j, hard: true, literal: true };
var _ = { type: j };
var v = { type: j, soft: true };
var S = [xi, ne];
var hn = [ki, ne];
function H(t8, e2) {
  re(t8), fr(e2);
  let r2 = [];
  for (let n2 = 0; n2 < e2.length; n2++) n2 !== 0 && r2.push(t8), r2.push(e2[n2]);
  return r2;
}
var yt = "'";
var Sn = '"';
function Bi(t8, e2) {
  let r2 = e2 === true || e2 === yt ? yt : Sn, n2 = r2 === yt ? Sn : yt, s2 = 0, i = 0;
  for (let a of t8) a === r2 ? s2++ : a === n2 && i++;
  return s2 > i ? n2 : r2;
}
var _n = Bi;
function dr(t8) {
  if (typeof t8 != "string") throw new TypeError("Expected a string");
  return t8.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var V;
var gr = class {
  constructor(e2) {
    At(this, V);
    pn(this, V, new Set(e2));
  }
  getLeadingWhitespaceCount(e2) {
    let r2 = R(this, V), n2 = 0;
    for (let s2 = 0; s2 < e2.length && r2.has(e2.charAt(s2)); s2++) n2++;
    return n2;
  }
  getTrailingWhitespaceCount(e2) {
    let r2 = R(this, V), n2 = 0;
    for (let s2 = e2.length - 1; s2 >= 0 && r2.has(e2.charAt(s2)); s2--) n2++;
    return n2;
  }
  getLeadingWhitespace(e2) {
    let r2 = this.getLeadingWhitespaceCount(e2);
    return e2.slice(0, r2);
  }
  getTrailingWhitespace(e2) {
    let r2 = this.getTrailingWhitespaceCount(e2);
    return e2.slice(e2.length - r2);
  }
  hasLeadingWhitespace(e2) {
    return R(this, V).has(e2.charAt(0));
  }
  hasTrailingWhitespace(e2) {
    return R(this, V).has(K(false, e2, -1));
  }
  trimStart(e2) {
    let r2 = this.getLeadingWhitespaceCount(e2);
    return e2.slice(r2);
  }
  trimEnd(e2) {
    let r2 = this.getTrailingWhitespaceCount(e2);
    return e2.slice(0, e2.length - r2);
  }
  trim(e2) {
    return this.trimEnd(this.trimStart(e2));
  }
  split(e2, r2 = false) {
    let n2 = `[${dr([...R(this, V)].join(""))}]+`, s2 = new RegExp(r2 ? `(${n2})` : n2, "u");
    return e2.split(s2);
  }
  hasWhitespaceCharacter(e2) {
    let r2 = R(this, V);
    return Array.prototype.some.call(e2, (n2) => r2.has(n2));
  }
  hasNonWhitespaceCharacter(e2) {
    let r2 = R(this, V);
    return Array.prototype.some.call(e2, (n2) => !r2.has(n2));
  }
  isWhitespaceOnly(e2) {
    let r2 = R(this, V);
    return Array.prototype.every.call(e2, (n2) => r2.has(n2));
  }
};
V = /* @__PURE__ */ new WeakMap();
var En = gr;
var Li = ["	", `
`, "\f", "\r", " "];
var Fi = new En(Li);
var O = Fi;
var Cr = class extends Error {
  name = "UnexpectedNodeError";
  constructor(e2, r2, n2 = "type") {
    super(`Unexpected ${r2} node ${n2}: ${JSON.stringify(e2[n2])}.`), this.node = e2;
  }
};
var An = Cr;
function Pi(t8) {
  return (t8 == null ? void 0 : t8.type) === "front-matter";
}
var Pe = Pi;
var Ni = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]);
var Ii = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function Dn(t8, e2) {
  var r2;
  if (t8.type === "text" || t8.type === "comment" || Pe(t8) || t8.type === "yaml" || t8.type === "toml") return null;
  if (t8.type === "attribute" && delete e2.value, t8.type === "docType" && delete e2.value, t8.type === "angularControlFlowBlock" && ((r2 = t8.parameters) != null && r2.children)) for (let n2 of e2.parameters.children) Ii.has(t8.name) ? delete n2.expression : n2.expression = n2.expression.trim();
  t8.type === "angularIcuExpression" && (e2.switchValue = t8.switchValue.trim()), t8.type === "angularLetDeclarationInitializer" && delete e2.value;
}
Dn.ignoredProperties = Ni;
var vn = Dn;
async function Ri(t8, e2) {
  if (t8.language === "yaml") {
    let r2 = t8.value.trim(), n2 = r2 ? await e2(r2, { parser: "yaml" }) : "";
    return gn([t8.startDelimiter, t8.explicitLanguage, S, n2, n2 ? S : "", t8.endDelimiter]);
  }
}
var yn = Ri;
function he(t8, e2 = true) {
  return [k([v, t8]), e2 ? v : ""];
}
function X(t8, e2) {
  let r2 = t8.type === "NGRoot" ? t8.node.type === "NGMicrosyntax" && t8.node.body.length === 1 && t8.node.body[0].type === "NGMicrosyntaxExpression" ? t8.node.body[0].expression : t8.node : t8.type === "JsExpressionRoot" ? t8.node : t8;
  return r2 && (r2.type === "ObjectExpression" || r2.type === "ArrayExpression" || (e2.parser === "__vue_expression" || e2.parser === "__vue_ts_expression") && (r2.type === "TemplateLiteral" || r2.type === "StringLiteral"));
}
async function T(t8, e2, r2, n2) {
  r2 = { __isInHtmlAttribute: true, __embeddedInHtml: true, ...r2 };
  let s2 = true;
  n2 && (r2.__onHtmlBindingRoot = (a, o2) => {
    s2 = n2(a, o2);
  });
  let i = await e2(t8, r2, e2);
  return s2 ? E(i) : he(i);
}
function $i(t8, e2, r2, n2) {
  let { node: s2 } = r2, i = n2.originalText.slice(s2.sourceSpan.start.offset, s2.sourceSpan.end.offset);
  return /^\s*$/u.test(i) ? "" : T(i, t8, { parser: "__ng_directive", __isInHtmlAttribute: false }, X);
}
var wn = $i;
var Oi = (t8, e2) => {
  if (!(t8 && e2 == null)) return e2.toReversed || !Array.isArray(e2) ? e2.toReversed() : [...e2].reverse();
};
var bn = Oi;
function Mi(t8) {
  return Array.isArray(t8) && t8.length > 0;
}
var me = Mi;
var Tn;
var xn;
var kn;
var Bn;
var Ln;
var qi = ((Tn = globalThis.Deno) == null ? void 0 : Tn.build.os) === "windows" || ((kn = (xn = globalThis.navigator) == null ? void 0 : xn.platform) == null ? void 0 : kn.startsWith("Win")) || ((Ln = (Bn = globalThis.process) == null ? void 0 : Bn.platform) == null ? void 0 : Ln.startsWith("win")) || false;
function Fn(t8) {
  if (t8 = t8 instanceof URL ? t8 : new URL(t8), t8.protocol !== "file:") throw new TypeError(`URL must be a file URL: received "${t8.protocol}"`);
  return t8;
}
function Hi(t8) {
  return t8 = Fn(t8), decodeURIComponent(t8.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function Vi(t8) {
  t8 = Fn(t8);
  let e2 = decodeURIComponent(t8.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return t8.hostname !== "" && (e2 = `\\\\${t8.hostname}${e2}`), e2;
}
function Pn(t8) {
  return qi ? Vi(t8) : Hi(t8);
}
var Nn = Pn;
var Ui = (t8) => String(t8).split(/[/\\]/u).pop();
function In(t8, e2) {
  if (!e2) return;
  let r2 = Ui(e2).toLowerCase();
  return t8.find(({ filenames: n2 }) => n2 == null ? void 0 : n2.some((s2) => s2.toLowerCase() === r2)) ?? t8.find(({ extensions: n2 }) => n2 == null ? void 0 : n2.some((s2) => r2.endsWith(s2)));
}
function Wi(t8, e2) {
  if (e2) return t8.find(({ name: r2 }) => r2.toLowerCase() === e2) ?? t8.find(({ aliases: r2 }) => r2 == null ? void 0 : r2.includes(e2)) ?? t8.find(({ extensions: r2 }) => r2 == null ? void 0 : r2.includes(`.${e2}`));
}
function Rn(t8, e2) {
  if (e2) {
    if (String(e2).startsWith("file:")) try {
      e2 = Nn(e2);
    } catch {
      return;
    }
    if (typeof e2 == "string") return t8.find(({ isSupported: r2 }) => r2 == null ? void 0 : r2({ filepath: e2 }));
  }
}
function Gi(t8, e2) {
  let r2 = bn(false, t8.plugins).flatMap((s2) => s2.languages ?? []), n2 = Wi(r2, e2.language) ?? In(r2, e2.physicalFile) ?? In(r2, e2.file) ?? Rn(r2, e2.physicalFile) ?? Rn(r2, e2.file) ?? (e2.physicalFile, void 0);
  return n2 == null ? void 0 : n2.parsers[0];
}
var Ne = Gi;
var $n = "inline";
var Sr = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", details: "block", summary: "block", marquee: "inline-block", source: "block", track: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" };
var On = "normal";
var _r = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
function zi(t8) {
  return t8.type === "element" && !t8.hasExplicitNamespace && !["html", "svg"].includes(t8.namespace);
}
var fe = zi;
var Yi = (t8) => w(false, t8, /^[\t\f\r ]*\n/gu, "");
var Er = (t8) => Yi(O.trimEnd(t8));
var Mn = (t8) => {
  let e2 = t8, r2 = O.getLeadingWhitespace(e2);
  r2 && (e2 = e2.slice(r2.length));
  let n2 = O.getTrailingWhitespace(e2);
  return n2 && (e2 = e2.slice(0, -n2.length)), { leadingWhitespace: r2, trailingWhitespace: n2, text: e2 };
};
function wt(t8, e2) {
  return !!(t8.type === "ieConditionalComment" && t8.lastChild && !t8.lastChild.isSelfClosing && !t8.lastChild.endSourceSpan || t8.type === "ieConditionalComment" && !t8.complete || de(t8) && t8.children.some((r2) => r2.type !== "text" && r2.type !== "interpolation") || xt(t8, e2) && !W(t8, e2) && t8.type !== "interpolation");
}
function ge(t8) {
  return t8.type === "attribute" || !t8.parent || !t8.prev ? false : ji(t8.prev);
}
function ji(t8) {
  return t8.type === "comment" && t8.value.trim() === "prettier-ignore";
}
function $(t8) {
  return t8.type === "text" || t8.type === "comment";
}
function W(t8, e2) {
  return t8.type === "element" && (t8.fullName === "script" || t8.fullName === "style" || t8.fullName === "svg:style" || t8.fullName === "svg:script" || t8.fullName === "mj-style" && e2.parser === "mjml" || fe(t8) && (t8.name === "script" || t8.name === "style"));
}
function qn(t8, e2) {
  return t8.children && !W(t8, e2);
}
function Hn(t8, e2) {
  return W(t8, e2) || t8.type === "interpolation" || Ar(t8);
}
function Ar(t8) {
  return Jn(t8).startsWith("pre");
}
function Vn(t8, e2) {
  var s2, i;
  let r2 = n2();
  if (r2 && !t8.prev && ((i = (s2 = t8.parent) == null ? void 0 : s2.tagDefinition) != null && i.ignoreFirstLf)) return t8.type === "interpolation";
  return r2;
  function n2() {
    return Pe(t8) || t8.type === "angularControlFlowBlock" ? false : (t8.type === "text" || t8.type === "interpolation") && t8.prev && (t8.prev.type === "text" || t8.prev.type === "interpolation") ? true : !t8.parent || t8.parent.cssDisplay === "none" ? false : de(t8.parent) ? true : !(!t8.prev && (t8.parent.type === "root" || de(t8) && t8.parent || W(t8.parent, e2) || et(t8.parent, e2) || !ea(t8.parent.cssDisplay)) || t8.prev && !na(t8.prev.cssDisplay));
  }
}
function Un(t8, e2) {
  return Pe(t8) || t8.type === "angularControlFlowBlock" ? false : (t8.type === "text" || t8.type === "interpolation") && t8.next && (t8.next.type === "text" || t8.next.type === "interpolation") ? true : !t8.parent || t8.parent.cssDisplay === "none" ? false : de(t8.parent) ? true : !(!t8.next && (t8.parent.type === "root" || de(t8) && t8.parent || W(t8.parent, e2) || et(t8.parent, e2) || !ta(t8.parent.cssDisplay)) || t8.next && !ra(t8.next.cssDisplay));
}
function Wn(t8, e2) {
  return sa(t8.cssDisplay) && !W(t8, e2);
}
function Je(t8) {
  return Pe(t8) || t8.next && t8.sourceSpan.end && t8.sourceSpan.end.line + 1 < t8.next.sourceSpan.start.line;
}
function Gn(t8) {
  return Dr(t8) || t8.type === "element" && t8.children.length > 0 && (["body", "script", "style"].includes(t8.name) || t8.children.some((e2) => Xi(e2))) || t8.firstChild && t8.firstChild === t8.lastChild && t8.firstChild.type !== "text" && Yn(t8.firstChild) && (!t8.lastChild.isTrailingSpaceSensitive || jn(t8.lastChild));
}
function Dr(t8) {
  return t8.type === "element" && t8.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(t8.name) || t8.cssDisplay.startsWith("table") && t8.cssDisplay !== "table-cell");
}
function bt(t8) {
  return Kn(t8) || t8.prev && Ki(t8.prev) || zn(t8);
}
function Ki(t8) {
  return Kn(t8) || t8.type === "element" && t8.fullName === "br" || zn(t8);
}
function zn(t8) {
  return Yn(t8) && jn(t8);
}
function Yn(t8) {
  return t8.hasLeadingSpaces && (t8.prev ? t8.prev.sourceSpan.end.line < t8.sourceSpan.start.line : t8.parent.type === "root" || t8.parent.startSourceSpan.end.line < t8.sourceSpan.start.line);
}
function jn(t8) {
  return t8.hasTrailingSpaces && (t8.next ? t8.next.sourceSpan.start.line > t8.sourceSpan.end.line : t8.parent.type === "root" || t8.parent.endSourceSpan && t8.parent.endSourceSpan.start.line > t8.sourceSpan.end.line);
}
function Kn(t8) {
  switch (t8.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return true;
    case "element":
      return ["script", "select"].includes(t8.name);
  }
  return false;
}
function Tt(t8) {
  return t8.lastChild ? Tt(t8.lastChild) : t8;
}
function Xi(t8) {
  var e2;
  return (e2 = t8.children) == null ? void 0 : e2.some((r2) => r2.type !== "text");
}
function Xn(t8) {
  if (t8) switch (t8) {
    case "module":
    case "text/javascript":
    case "text/babel":
    case "text/jsx":
    case "application/javascript":
      return "babel";
    case "application/x-typescript":
      return "typescript";
    case "text/markdown":
      return "markdown";
    case "text/html":
      return "html";
    case "text/x-handlebars-template":
      return "glimmer";
    default:
      if (t8.endsWith("json") || t8.endsWith("importmap") || t8 === "speculationrules") return "json";
  }
}
function Qi(t8, e2) {
  let { name: r2, attrMap: n2 } = t8;
  if (r2 !== "script" || Object.prototype.hasOwnProperty.call(n2, "src")) return;
  let { type: s2, lang: i } = t8.attrMap;
  return !i && !s2 ? "babel" : Ne(e2, { language: i }) ?? Xn(s2);
}
function Ji(t8, e2) {
  if (!xt(t8, e2)) return;
  let { attrMap: r2 } = t8;
  if (Object.prototype.hasOwnProperty.call(r2, "src")) return;
  let { type: n2, lang: s2 } = r2;
  return Ne(e2, { language: s2 }) ?? Xn(n2);
}
function Zi(t8, e2) {
  if (t8.name === "style") {
    let { lang: r2 } = t8.attrMap;
    return r2 ? Ne(e2, { language: r2 }) : "css";
  }
  if (t8.name === "mj-style" && e2.parser === "mjml") return "css";
}
function vr(t8, e2) {
  return Qi(t8, e2) ?? Zi(t8, e2) ?? Ji(t8, e2);
}
function Ze(t8) {
  return t8 === "block" || t8 === "list-item" || t8.startsWith("table");
}
function ea(t8) {
  return !Ze(t8) && t8 !== "inline-block";
}
function ta(t8) {
  return !Ze(t8) && t8 !== "inline-block";
}
function ra(t8) {
  return !Ze(t8);
}
function na(t8) {
  return !Ze(t8);
}
function sa(t8) {
  return !Ze(t8) && t8 !== "inline-block";
}
function de(t8) {
  return Jn(t8).startsWith("pre");
}
function ia(t8, e2) {
  let r2 = t8;
  for (; r2; ) {
    if (e2(r2)) return true;
    r2 = r2.parent;
  }
  return false;
}
function Qn(t8, e2) {
  var n2;
  if (Ce(t8, e2)) return "block";
  if (((n2 = t8.prev) == null ? void 0 : n2.type) === "comment") {
    let s2 = t8.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/u);
    if (s2) return s2[1];
  }
  let r2 = false;
  if (t8.type === "element" && t8.namespace === "svg") if (ia(t8, (s2) => s2.fullName === "svg:foreignObject")) r2 = true;
  else return t8.name === "svg" ? "inline-block" : "block";
  switch (e2.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      if (t8.type === "element" && (!t8.namespace || r2 || fe(t8)) && Object.prototype.hasOwnProperty.call(Sr, t8.name)) return Sr[t8.name];
  }
  return $n;
}
function Jn(t8) {
  return t8.type === "element" && (!t8.namespace || fe(t8)) && Object.prototype.hasOwnProperty.call(_r, t8.name) ? _r[t8.name] : On;
}
function aa(t8) {
  let e2 = Number.POSITIVE_INFINITY;
  for (let r2 of t8.split(`
`)) {
    if (r2.length === 0) continue;
    let n2 = O.getLeadingWhitespaceCount(r2);
    if (n2 === 0) return 0;
    r2.length !== n2 && n2 < e2 && (e2 = n2);
  }
  return e2 === Number.POSITIVE_INFINITY ? 0 : e2;
}
function yr(t8, e2 = aa(t8)) {
  return e2 === 0 ? t8 : t8.split(`
`).map((r2) => r2.slice(e2)).join(`
`);
}
function wr(t8) {
  return w(false, w(false, t8, "&apos;", "'"), "&quot;", '"');
}
function P(t8) {
  return wr(t8.value);
}
var oa = /* @__PURE__ */ new Set(["template", "style", "script"]);
function et(t8, e2) {
  return Ce(t8, e2) && !oa.has(t8.fullName);
}
function Ce(t8, e2) {
  return e2.parser === "vue" && t8.type === "element" && t8.parent.type === "root" && t8.fullName.toLowerCase() !== "html";
}
function xt(t8, e2) {
  return Ce(t8, e2) && (et(t8, e2) || t8.attrMap.lang && t8.attrMap.lang !== "html");
}
function Zn(t8) {
  let e2 = t8.fullName;
  return e2.charAt(0) === "#" || e2 === "slot-scope" || e2 === "v-slot" || e2.startsWith("v-slot:");
}
function es(t8, e2) {
  let r2 = t8.parent;
  if (!Ce(r2, e2)) return false;
  let n2 = r2.fullName, s2 = t8.fullName;
  return n2 === "script" && s2 === "setup" || n2 === "style" && s2 === "vars";
}
function kt(t8, e2 = t8.value) {
  return t8.parent.isWhitespaceSensitive ? t8.parent.isIndentationSensitive ? B(e2) : B(yr(Er(e2)), S) : H(_, O.split(e2));
}
function Bt(t8, e2) {
  return Ce(t8, e2) && t8.name === "script";
}
var br = /\{\{(.+?)\}\}/su;
async function ts(t8, e2) {
  let r2 = [];
  for (let [n2, s2] of t8.split(br).entries()) if (n2 % 2 === 0) r2.push(B(s2));
  else try {
    r2.push(E(["{{", k([_, await T(s2, e2, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), _, "}}"]));
  } catch {
    r2.push("{{", B(s2), "}}");
  }
  return r2;
}
function Tr({ parser: t8 }) {
  return (e2, r2, n2) => T(P(n2.node), e2, { parser: t8 }, X);
}
var ua = Tr({ parser: "__ng_action" });
var la = Tr({ parser: "__ng_binding" });
var ca = Tr({ parser: "__ng_directive" });
function pa(t8, e2) {
  if (e2.parser !== "angular") return;
  let { node: r2 } = t8, n2 = r2.fullName;
  if (n2.startsWith("(") && n2.endsWith(")") || n2.startsWith("on-")) return ua;
  if (n2.startsWith("[") && n2.endsWith("]") || /^bind(?:on)?-/u.test(n2) || /^ng-(?:if|show|hide|class|style)$/u.test(n2)) return la;
  if (n2.startsWith("*")) return ca;
  let s2 = P(r2);
  if (/^i18n(?:-.+)?$/u.test(n2)) return () => he(vt(kt(r2, s2.trim())), !s2.includes("@@"));
  if (br.test(s2)) return (i) => ts(s2, i);
}
var rs = pa;
function ha(t8, e2) {
  let { node: r2 } = t8, n2 = P(r2);
  if (r2.fullName === "class" && !e2.parentParser && !n2.includes("{{")) return () => n2.trim().split(/\s+/u).join(" ");
}
var ns = ha;
function ss(t8) {
  return t8 === "	" || t8 === `
` || t8 === "\f" || t8 === "\r" || t8 === " ";
}
var ma = /^[ \t\n\r\u000c]+/;
var fa = /^[, \t\n\r\u000c]+/;
var da = /^[^ \t\n\r\u000c]+/;
var ga = /[,]+$/;
var is = /^\d+$/;
var Ca = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
function Sa(t8) {
  let e2 = t8.length, r2, n2, s2, i, a, o2 = 0, u;
  function p(C) {
    let A, D = C.exec(t8.substring(o2));
    if (D) return [A] = D, o2 += A.length, A;
  }
  let l2 = [];
  for (; ; ) {
    if (p(fa), o2 >= e2) {
      if (l2.length === 0) throw new Error("Must contain one or more image candidate strings.");
      return l2;
    }
    u = o2, r2 = p(da), n2 = [], r2.slice(-1) === "," ? (r2 = r2.replace(ga, ""), f()) : m();
  }
  function m() {
    for (p(ma), s2 = "", i = "in descriptor"; ; ) {
      if (a = t8.charAt(o2), i === "in descriptor") if (ss(a)) s2 && (n2.push(s2), s2 = "", i = "after descriptor");
      else if (a === ",") {
        o2 += 1, s2 && n2.push(s2), f();
        return;
      } else if (a === "(") s2 += a, i = "in parens";
      else if (a === "") {
        s2 && n2.push(s2), f();
        return;
      } else s2 += a;
      else if (i === "in parens") if (a === ")") s2 += a, i = "in descriptor";
      else if (a === "") {
        n2.push(s2), f();
        return;
      } else s2 += a;
      else if (i === "after descriptor" && !ss(a)) if (a === "") {
        f();
        return;
      } else i = "in descriptor", o2 -= 1;
      o2 += 1;
    }
  }
  function f() {
    let C = false, A, D, I3, F, c2 = {}, g2, y2, q2, x, U2;
    for (F = 0; F < n2.length; F++) g2 = n2[F], y2 = g2[g2.length - 1], q2 = g2.substring(0, g2.length - 1), x = parseInt(q2, 10), U2 = parseFloat(q2), is.test(q2) && y2 === "w" ? ((A || D) && (C = true), x === 0 ? C = true : A = x) : Ca.test(q2) && y2 === "x" ? ((A || D || I3) && (C = true), U2 < 0 ? C = true : D = U2) : is.test(q2) && y2 === "h" ? ((I3 || D) && (C = true), x === 0 ? C = true : I3 = x) : C = true;
    if (!C) c2.source = { value: r2, startOffset: u }, A && (c2.width = { value: A }), D && (c2.density = { value: D }), I3 && (c2.height = { value: I3 }), l2.push(c2);
    else throw new Error(`Invalid srcset descriptor found in "${t8}" at "${g2}".`);
  }
}
var as = Sa;
function _a(t8) {
  if (t8.node.fullName === "srcset" && (t8.parent.fullName === "img" || t8.parent.fullName === "source")) return () => Aa(P(t8.node));
}
var os = { width: "w", height: "h", density: "x" };
var Ea = Object.keys(os);
function Aa(t8) {
  let e2 = as(t8), r2 = Ea.filter((l2) => e2.some((m) => Object.prototype.hasOwnProperty.call(m, l2)));
  if (r2.length > 1) throw new Error("Mixed descriptor in srcset is not supported");
  let [n2] = r2, s2 = os[n2], i = e2.map((l2) => l2.source.value), a = Math.max(...i.map((l2) => l2.length)), o2 = e2.map((l2) => l2[n2] ? String(l2[n2].value) : ""), u = o2.map((l2) => {
    let m = l2.indexOf(".");
    return m === -1 ? l2.length : m;
  }), p = Math.max(...u);
  return he(H([",", _], i.map((l2, m) => {
    let f = [l2], C = o2[m];
    if (C) {
      let A = a - l2.length + 1, D = p - u[m], I3 = " ".repeat(A + D);
      f.push(pe(I3, " "), C + s2);
    }
    return f;
  })));
}
var us = _a;
function ls(t8, e2) {
  let { node: r2 } = t8, n2 = P(t8.node).trim();
  if (r2.fullName === "style" && !e2.parentParser && !n2.includes("{{")) return async (s2) => he(await s2(n2, { parser: "css", __isHTMLStyleAttribute: true }));
}
var xr = /* @__PURE__ */ new WeakMap();
function Da(t8, e2) {
  let { root: r2 } = t8;
  return xr.has(r2) || xr.set(r2, r2.children.some((n2) => Bt(n2, e2) && ["ts", "typescript"].includes(n2.attrMap.lang))), xr.get(r2);
}
var Ie = Da;
function cs(t8, e2, r2) {
  let { node: n2 } = r2, s2 = P(n2);
  return T(`type T<${s2}> = any`, t8, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: true }, X);
}
function ps(t8, e2, { parseWithTs: r2 }) {
  return T(`function _(${t8}) {}`, e2, { parser: r2 ? "babel-ts" : "babel", __isVueBindings: true });
}
async function hs(t8, e2, r2, n2) {
  let s2 = P(r2.node), { left: i, operator: a, right: o2 } = va(s2), u = Ie(r2, n2);
  return [E(await T(`function _(${i}) {}`, t8, { parser: u ? "babel-ts" : "babel", __isVueForBindingLeft: true })), " ", a, " ", await T(o2, t8, { parser: u ? "__ts_expression" : "__js_expression" })];
}
function va(t8) {
  let e2 = /(.*?)\s+(in|of)\s+(.*)/su, r2 = /,([^,\]}]*)(?:,([^,\]}]*))?$/u, n2 = /^\(|\)$/gu, s2 = t8.match(e2);
  if (!s2) return;
  let i = {};
  if (i.for = s2[3].trim(), !i.for) return;
  let a = w(false, s2[1].trim(), n2, ""), o2 = a.match(r2);
  o2 ? (i.alias = a.replace(r2, ""), i.iterator1 = o2[1].trim(), o2[2] && (i.iterator2 = o2[2].trim())) : i.alias = a;
  let u = [i.alias, i.iterator1, i.iterator2];
  if (!u.some((p, l2) => !p && (l2 === 0 || u.slice(l2 + 1).some(Boolean)))) return { left: u.filter(Boolean).join(","), operator: s2[2], right: i.for };
}
function ya(t8, e2) {
  if (e2.parser !== "vue") return;
  let { node: r2 } = t8, n2 = r2.fullName;
  if (n2 === "v-for") return hs;
  if (n2 === "generic" && Bt(r2.parent, e2)) return cs;
  let s2 = P(r2), i = Ie(t8, e2);
  if (Zn(r2) || es(r2, e2)) return (a) => ps(s2, a, { parseWithTs: i });
  if (n2.startsWith("@") || n2.startsWith("v-on:")) return (a) => wa(s2, a, { parseWithTs: i });
  if (n2.startsWith(":") || n2.startsWith(".") || n2.startsWith("v-bind:")) return (a) => ba(s2, a, { parseWithTs: i });
  if (n2.startsWith("v-")) return (a) => ms(s2, a, { parseWithTs: i });
}
async function wa(t8, e2, { parseWithTs: r2 }) {
  var n2;
  try {
    return await ms(t8, e2, { parseWithTs: r2 });
  } catch (s2) {
    if (((n2 = s2.cause) == null ? void 0 : n2.code) !== "BABEL_PARSER_SYNTAX_ERROR") throw s2;
  }
  return T(t8, e2, { parser: r2 ? "__vue_ts_event_binding" : "__vue_event_binding" }, X);
}
function ba(t8, e2, { parseWithTs: r2 }) {
  return T(t8, e2, { parser: r2 ? "__vue_ts_expression" : "__vue_expression" }, X);
}
function ms(t8, e2, { parseWithTs: r2 }) {
  return T(t8, e2, { parser: r2 ? "__ts_expression" : "__js_expression" }, X);
}
var fs = ya;
function Ta(t8, e2) {
  let { node: r2 } = t8;
  if (r2.value) {
    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(e2.originalText.slice(r2.valueSpan.start.offset, r2.valueSpan.end.offset)) || e2.parser === "lwc" && r2.value.startsWith("{") && r2.value.endsWith("}")) return [r2.rawName, "=", r2.value];
    for (let n2 of [us, ls, ns, fs, rs]) {
      let s2 = n2(t8, e2);
      if (s2) return xa(s2);
    }
  }
}
function xa(t8) {
  return async (e2, r2, n2, s2) => {
    let i = await t8(e2, r2, n2, s2);
    if (i) return i = hr(i, (a) => typeof a == "string" ? w(false, a, '"', "&quot;") : a), [n2.node.rawName, '="', E(i), '"'];
  };
}
var ds = Ta;
var ka = new Proxy(() => {
}, { get: () => ka });
function J(t8) {
  return t8.sourceSpan.start.offset;
}
function se(t8) {
  return t8.sourceSpan.end.offset;
}
function tt(t8, e2) {
  return [t8.isSelfClosing ? "" : Ba(t8, e2), Se(t8, e2)];
}
function Ba(t8, e2) {
  return t8.lastChild && Ae(t8.lastChild) ? "" : [La(t8, e2), Lt(t8, e2)];
}
function Se(t8, e2) {
  return (t8.next ? Q(t8.next) : Ee(t8.parent)) ? "" : [_e(t8, e2), G(t8, e2)];
}
function La(t8, e2) {
  return Ee(t8) ? _e(t8.lastChild, e2) : "";
}
function G(t8, e2) {
  return Ae(t8) ? Lt(t8.parent, e2) : rt(t8) ? Ft(t8.next, e2) : "";
}
function Lt(t8, e2) {
  if (Cs(t8, e2)) return "";
  switch (t8.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (t8.hasHtmComponentClosingTag) return "<//";
    default:
      return `</${t8.rawName}`;
  }
}
function _e(t8, e2) {
  if (Cs(t8, e2)) return "";
  switch (t8.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "angularIcuExpression":
      return "}";
    case "element":
      if (t8.isSelfClosing) return "/>";
    default:
      return ">";
  }
}
function Cs(t8, e2) {
  return !t8.isSelfClosing && !t8.endSourceSpan && (ge(t8) || wt(t8.parent, e2));
}
function Q(t8) {
  return t8.prev && t8.prev.type !== "docType" && t8.type !== "angularControlFlowBlock" && !$(t8.prev) && t8.isLeadingSpaceSensitive && !t8.hasLeadingSpaces;
}
function Ee(t8) {
  var e2;
  return ((e2 = t8.lastChild) == null ? void 0 : e2.isTrailingSpaceSensitive) && !t8.lastChild.hasTrailingSpaces && !$(Tt(t8.lastChild)) && !de(t8);
}
function Ae(t8) {
  return !t8.next && !t8.hasTrailingSpaces && t8.isTrailingSpaceSensitive && $(Tt(t8));
}
function rt(t8) {
  return t8.next && !$(t8.next) && $(t8) && t8.isTrailingSpaceSensitive && !t8.hasTrailingSpaces;
}
function Fa(t8) {
  let e2 = t8.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/su);
  return e2 ? e2[1] ? e2[1].split(/\s+/u) : true : false;
}
function nt(t8) {
  return !t8.prev && t8.isLeadingSpaceSensitive && !t8.hasLeadingSpaces;
}
function Pa(t8, e2, r2) {
  var m;
  let { node: n2 } = t8;
  if (!me(n2.attrs)) return n2.isSelfClosing ? " " : "";
  let s2 = ((m = n2.prev) == null ? void 0 : m.type) === "comment" && Fa(n2.prev.value), i = typeof s2 == "boolean" ? () => s2 : Array.isArray(s2) ? (f) => s2.includes(f.rawName) : () => false, a = t8.map(({ node: f }) => i(f) ? B(e2.originalText.slice(J(f), se(f))) : r2(), "attrs"), o2 = n2.type === "element" && n2.fullName === "script" && n2.attrs.length === 1 && n2.attrs[0].fullName === "src" && n2.children.length === 0, p = e2.singleAttributePerLine && n2.attrs.length > 1 && !Ce(n2, e2) ? S : _, l2 = [k([o2 ? " " : _, H(p, a)])];
  return n2.firstChild && nt(n2.firstChild) || n2.isSelfClosing && Ee(n2.parent) || o2 ? l2.push(n2.isSelfClosing ? " " : "") : l2.push(e2.bracketSameLine ? n2.isSelfClosing ? " " : "" : n2.isSelfClosing ? _ : v), l2;
}
function Na(t8) {
  return t8.firstChild && nt(t8.firstChild) ? "" : Pt(t8);
}
function st(t8, e2, r2) {
  let { node: n2 } = t8;
  return [De(n2, e2), Pa(t8, e2, r2), n2.isSelfClosing ? "" : Na(n2)];
}
function De(t8, e2) {
  return t8.prev && rt(t8.prev) ? "" : [z(t8, e2), Ft(t8, e2)];
}
function z(t8, e2) {
  return nt(t8) ? Pt(t8.parent) : Q(t8) ? _e(t8.prev, e2) : "";
}
var gs = "<!doctype";
function Ft(t8, e2) {
  switch (t8.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${t8.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType": {
      if (t8.value === "html") {
        let { filepath: n2 } = e2;
        if (n2 && /\.html?$/u.test(n2)) return gs;
      }
      let r2 = J(t8);
      return e2.originalText.slice(r2, r2 + gs.length);
    }
    case "angularIcuExpression":
      return "{";
    case "element":
      if (t8.condition) return `<!--[if ${t8.condition}]><!--><${t8.rawName}`;
    default:
      return `<${t8.rawName}`;
  }
}
function Pt(t8) {
  switch (t8.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (t8.condition) return "><!--<![endif]-->";
    default:
      return ">";
  }
}
function Ia(t8, e2) {
  if (!t8.endSourceSpan) return "";
  let r2 = t8.startSourceSpan.end.offset;
  t8.firstChild && nt(t8.firstChild) && (r2 -= Pt(t8).length);
  let n2 = t8.endSourceSpan.start.offset;
  return t8.lastChild && Ae(t8.lastChild) ? n2 += Lt(t8, e2).length : Ee(t8) && (n2 -= _e(t8.lastChild, e2).length), e2.originalText.slice(r2, n2);
}
var Nt = Ia;
var Ra = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function $a(t8, e2) {
  let { node: r2 } = t8;
  switch (r2.type) {
    case "element":
      if (W(r2, e2) || r2.type === "interpolation") return;
      if (!r2.isSelfClosing && xt(r2, e2)) {
        let n2 = vr(r2, e2);
        return n2 ? async (s2, i) => {
          let a = Nt(r2, e2), o2 = /^\s*$/u.test(a), u = "";
          return o2 || (u = await s2(Er(a), { parser: n2, __embeddedInHtml: true }), o2 = u === ""), [z(r2, e2), E(st(t8, e2, i)), o2 ? "" : S, u, o2 ? "" : S, tt(r2, e2), G(r2, e2)];
        } : void 0;
      }
      break;
    case "text":
      if (W(r2.parent, e2)) {
        let n2 = vr(r2.parent, e2);
        if (n2) return async (s2) => {
          let i = n2 === "markdown" ? yr(r2.value.replace(/^[^\S\n]*\n/u, "")) : r2.value, a = { parser: n2, __embeddedInHtml: true };
          if (e2.parser === "html" && n2 === "babel") {
            let o2 = "script", { attrMap: u } = r2.parent;
            u && (u.type === "module" || (u.type === "text/babel" || u.type === "text/jsx") && u["data-type"] === "module") && (o2 = "module"), a.__babelSourceType = o2;
          }
          return [ne, z(r2, e2), await s2(i, a), G(r2, e2)];
        };
      } else if (r2.parent.type === "interpolation") return async (n2) => {
        let s2 = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
        return e2.parser === "angular" ? s2.parser = "__ng_interpolation" : e2.parser === "vue" ? s2.parser = Ie(t8, e2) ? "__vue_ts_expression" : "__vue_expression" : s2.parser = "__js_expression", [k([_, await n2(r2.value, s2)]), r2.parent.next && Q(r2.parent.next) ? " " : _];
      };
      break;
    case "attribute":
      return ds(t8, e2);
    case "front-matter":
      return (n2) => yn(r2, n2);
    case "angularControlFlowBlockParameters":
      return Ra.has(t8.parent.name) ? wn : void 0;
    case "angularLetDeclarationInitializer":
      return (n2) => T(r2.value, n2, { parser: "__ng_binding", __isInHtmlAttribute: false });
  }
}
var Ss = $a;
var it = null;
function at(t8) {
  if (it !== null && typeof it.property) {
    let e2 = it;
    return it = at.prototype = null, e2;
  }
  return it = at.prototype = t8 ?? /* @__PURE__ */ Object.create(null), new at();
}
var Oa = 10;
for (let t8 = 0; t8 <= Oa; t8++) at();
function kr(t8) {
  return at(t8);
}
function Ma(t8, e2 = "type") {
  kr(t8);
  function r2(n2) {
    let s2 = n2[e2], i = t8[s2];
    if (!Array.isArray(i)) throw Object.assign(new Error(`Missing visitor keys for '${s2}'.`), { node: n2 });
    return i;
  }
  return r2;
}
var _s = Ma;
var qa = { "front-matter": [], root: ["children"], element: ["attrs", "children"], ieConditionalComment: ["children"], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ["children"], text: ["children"], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: ["children"], angularControlFlowBlockParameter: [], angularLetDeclaration: ["init"], angularLetDeclarationInitializer: [], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] };
var Es = qa;
var Ha = _s(Es);
var As = Ha;
var Ds = "format";
var vs = /^\s*<!--\s*@(?:noformat|noprettier)\s*-->/u;
var ys = /^\s*<!--\s*@(?:format|prettier)\s*-->/u;
function ws(t8) {
  return ys.test(t8);
}
function bs(t8) {
  return vs.test(t8);
}
function Ts(t8) {
  return `<!-- @${Ds} -->

${t8}`;
}
var xs = /* @__PURE__ */ new Map([["if", /* @__PURE__ */ new Set(["else if", "else"])], ["else if", /* @__PURE__ */ new Set(["else if", "else"])], ["for", /* @__PURE__ */ new Set(["empty"])], ["defer", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["placeholder", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["error", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["loading", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])]]);
function ks(t8) {
  let e2 = se(t8);
  return t8.type === "element" && !t8.endSourceSpan && me(t8.children) ? Math.max(e2, ks(K(false, t8.children, -1))) : e2;
}
function ot(t8, e2, r2) {
  let n2 = t8.node;
  if (ge(n2)) {
    let s2 = ks(n2);
    return [z(n2, e2), B(O.trimEnd(e2.originalText.slice(J(n2) + (n2.prev && rt(n2.prev) ? Ft(n2).length : 0), s2 - (n2.next && Q(n2.next) ? _e(n2, e2).length : 0)))), G(n2, e2)];
  }
  return r2();
}
function It(t8, e2) {
  return $(t8) && $(e2) ? t8.isTrailingSpaceSensitive ? t8.hasTrailingSpaces ? bt(e2) ? S : _ : "" : bt(e2) ? S : v : rt(t8) && (ge(e2) || e2.firstChild || e2.isSelfClosing || e2.type === "element" && e2.attrs.length > 0) || t8.type === "element" && t8.isSelfClosing && Q(e2) ? "" : !e2.isLeadingSpaceSensitive || bt(e2) || Q(e2) && t8.lastChild && Ae(t8.lastChild) && t8.lastChild.lastChild && Ae(t8.lastChild.lastChild) ? S : e2.hasLeadingSpaces ? _ : v;
}
function Re(t8, e2, r2) {
  let { node: n2 } = t8;
  if (Dr(n2)) return [ne, ...t8.map((i) => {
    let a = i.node, o2 = a.prev ? It(a.prev, a) : "";
    return [o2 ? [o2, Je(a.prev) ? S : ""] : "", ot(i, e2, r2)];
  }, "children")];
  let s2 = n2.children.map(() => Symbol(""));
  return t8.map((i, a) => {
    let o2 = i.node;
    if ($(o2)) {
      if (o2.prev && $(o2.prev)) {
        let A = It(o2.prev, o2);
        if (A) return Je(o2.prev) ? [S, S, ot(i, e2, r2)] : [A, ot(i, e2, r2)];
      }
      return ot(i, e2, r2);
    }
    let u = [], p = [], l2 = [], m = [], f = o2.prev ? It(o2.prev, o2) : "", C = o2.next ? It(o2, o2.next) : "";
    return f && (Je(o2.prev) ? u.push(S, S) : f === S ? u.push(S) : $(o2.prev) ? p.push(f) : p.push(pe("", v, { groupId: s2[a - 1] }))), C && (Je(o2) ? $(o2.next) && m.push(S, S) : C === S ? $(o2.next) && m.push(S) : l2.push(C)), [...u, E([...p, E([ot(i, e2, r2), ...l2], { id: s2[a] })]), ...m];
  }, "children");
}
function Bs(t8, e2, r2) {
  let { node: n2 } = t8, s2 = [];
  Va(t8) && s2.push("} "), s2.push("@", n2.name), n2.parameters && s2.push(" (", E(r2("parameters")), ")"), s2.push(" {");
  let i = Ls(n2);
  return n2.children.length > 0 ? (n2.firstChild.hasLeadingSpaces = true, n2.lastChild.hasTrailingSpaces = true, s2.push(k([S, Re(t8, e2, r2)])), i && s2.push(S, "}")) : i && s2.push("}"), E(s2, { shouldBreak: true });
}
function Ls(t8) {
  var e2, r2;
  return !(((e2 = t8.next) == null ? void 0 : e2.type) === "angularControlFlowBlock" && ((r2 = xs.get(t8.name)) != null && r2.has(t8.next.name)));
}
function Va(t8) {
  let { previous: e2 } = t8;
  return (e2 == null ? void 0 : e2.type) === "angularControlFlowBlock" && !ge(e2) && !Ls(e2);
}
function Fs(t8, e2, r2) {
  return [k([v, H([";", _], t8.map(r2, "children"))]), v];
}
function Ps(t8, e2, r2) {
  let { node: n2 } = t8;
  return [De(n2, e2), E([n2.switchValue.trim(), ", ", n2.clause, n2.cases.length > 0 ? [",", k([_, H(_, t8.map(r2, "cases"))])] : "", v]), Se(n2, e2)];
}
function Ns(t8, e2, r2) {
  let { node: n2 } = t8;
  return [n2.value, " {", E([k([v, t8.map(({ node: s2, isLast: i }) => {
    let a = [r2()];
    return s2.type === "text" && (s2.hasLeadingSpaces && a.unshift(_), s2.hasTrailingSpaces && !i && a.push(_)), a;
  }, "expression")]), v]), "}"];
}
function Is(t8, e2, r2) {
  let { node: n2 } = t8;
  if (wt(n2, e2)) return [z(n2, e2), E(st(t8, e2, r2)), B(Nt(n2, e2)), ...tt(n2, e2), G(n2, e2)];
  let s2 = n2.children.length === 1 && (n2.firstChild.type === "interpolation" || n2.firstChild.type === "angularIcuExpression") && n2.firstChild.isLeadingSpaceSensitive && !n2.firstChild.hasLeadingSpaces && n2.lastChild.isTrailingSpaceSensitive && !n2.lastChild.hasTrailingSpaces, i = Symbol("element-attr-group-id"), a = (l2) => E([E(st(t8, e2, r2), { id: i }), l2, tt(n2, e2)]), o2 = (l2) => s2 ? Cn(l2, { groupId: i }) : (W(n2, e2) || et(n2, e2)) && n2.parent.type === "root" && e2.parser === "vue" && !e2.vueIndentScriptAndStyle ? l2 : k(l2), u = () => s2 ? pe(v, "", { groupId: i }) : n2.firstChild.hasLeadingSpaces && n2.firstChild.isLeadingSpaceSensitive ? _ : n2.firstChild.type === "text" && n2.isWhitespaceSensitive && n2.isIndentationSensitive ? dn(v) : v, p = () => (n2.next ? Q(n2.next) : Ee(n2.parent)) ? n2.lastChild.hasTrailingSpaces && n2.lastChild.isTrailingSpaceSensitive ? " " : "" : s2 ? pe(v, "", { groupId: i }) : n2.lastChild.hasTrailingSpaces && n2.lastChild.isTrailingSpaceSensitive ? _ : (n2.lastChild.type === "comment" || n2.lastChild.type === "text" && n2.isWhitespaceSensitive && n2.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${e2.tabWidth * (t8.ancestors.length - 1)}}$`, "u").test(n2.lastChild.value) ? "" : v;
  return n2.children.length === 0 ? a(n2.hasDanglingSpaces && n2.isDanglingSpaceSensitive ? _ : "") : a([Gn(n2) ? ne : "", o2([u(), Re(t8, e2, r2)]), p()]);
}
function ut(t8) {
  return t8 >= 9 && t8 <= 32 || t8 == 160;
}
function Rt(t8) {
  return 48 <= t8 && t8 <= 57;
}
function lt(t8) {
  return t8 >= 97 && t8 <= 122 || t8 >= 65 && t8 <= 90;
}
function Rs(t8) {
  return t8 >= 97 && t8 <= 102 || t8 >= 65 && t8 <= 70 || Rt(t8);
}
function $t(t8) {
  return t8 === 10 || t8 === 13;
}
function Br(t8) {
  return 48 <= t8 && t8 <= 55;
}
function Ot(t8) {
  return t8 === 39 || t8 === 34 || t8 === 96;
}
var Ua = /-+([a-z0-9])/g;
function Os(t8) {
  return t8.replace(Ua, (...e2) => e2[1].toUpperCase());
}
var ie = class t {
  constructor(e2, r2, n2, s2) {
    this.file = e2, this.offset = r2, this.line = n2, this.col = s2;
  }
  toString() {
    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
  }
  moveBy(e2) {
    let r2 = this.file.content, n2 = r2.length, s2 = this.offset, i = this.line, a = this.col;
    for (; s2 > 0 && e2 < 0; ) if (s2--, e2++, r2.charCodeAt(s2) == 10) {
      i--;
      let u = r2.substring(0, s2 - 1).lastIndexOf(String.fromCharCode(10));
      a = u > 0 ? s2 - u : s2;
    } else a--;
    for (; s2 < n2 && e2 > 0; ) {
      let o2 = r2.charCodeAt(s2);
      s2++, e2--, o2 == 10 ? (i++, a = 0) : a++;
    }
    return new t(this.file, s2, i, a);
  }
  getContext(e2, r2) {
    let n2 = this.file.content, s2 = this.offset;
    if (s2 != null) {
      s2 > n2.length - 1 && (s2 = n2.length - 1);
      let i = s2, a = 0, o2 = 0;
      for (; a < e2 && s2 > 0 && (s2--, a++, !(n2[s2] == `
` && ++o2 == r2)); ) ;
      for (a = 0, o2 = 0; a < e2 && i < n2.length - 1 && (i++, a++, !(n2[i] == `
` && ++o2 == r2)); ) ;
      return { before: n2.substring(s2, this.offset), after: n2.substring(this.offset, i + 1) };
    }
    return null;
  }
};
var ve = class {
  constructor(e2, r2) {
    this.content = e2, this.url = r2;
  }
};
var h = class {
  constructor(e2, r2, n2 = e2, s2 = null) {
    this.start = e2, this.end = r2, this.fullStart = n2, this.details = s2;
  }
  toString() {
    return this.start.file.content.substring(this.start.offset, this.end.offset);
  }
};
var Mt;
(function(t8) {
  t8[t8.WARNING = 0] = "WARNING", t8[t8.ERROR = 1] = "ERROR";
})(Mt || (Mt = {}));
var Oe = class {
  constructor(e2, r2, n2 = Mt.ERROR, s2) {
    this.span = e2, this.msg = r2, this.level = n2, this.relatedError = s2;
  }
  contextualMessage() {
    let e2 = this.span.start.getContext(100, 3);
    return e2 ? `${this.msg} ("${e2.before}[${Mt[this.level]} ->]${e2.after}")` : this.msg;
  }
  toString() {
    let e2 = this.span.details ? `, ${this.span.details}` : "";
    return `${this.contextualMessage()}: ${this.span.start}${e2}`;
  }
};
var Wa = [za, Ya, Ka, Qa, Ja, to, Za, eo, ro, Xa];
function Ga(t8, e2) {
  for (let r2 of Wa) r2(t8, e2);
  return t8;
}
function za(t8) {
  t8.walk((e2) => {
    if (e2.type === "element" && e2.tagDefinition.ignoreFirstLf && e2.children.length > 0 && e2.children[0].type === "text" && e2.children[0].value[0] === `
`) {
      let r2 = e2.children[0];
      r2.value.length === 1 ? e2.removeChild(r2) : r2.value = r2.value.slice(1);
    }
  });
}
function Ya(t8) {
  let e2 = (r2) => {
    var n2, s2;
    return r2.type === "element" && ((n2 = r2.prev) == null ? void 0 : n2.type) === "ieConditionalStartComment" && r2.prev.sourceSpan.end.offset === r2.startSourceSpan.start.offset && ((s2 = r2.firstChild) == null ? void 0 : s2.type) === "ieConditionalEndComment" && r2.firstChild.sourceSpan.start.offset === r2.startSourceSpan.end.offset;
  };
  t8.walk((r2) => {
    if (r2.children) for (let n2 = 0; n2 < r2.children.length; n2++) {
      let s2 = r2.children[n2];
      if (!e2(s2)) continue;
      let i = s2.prev, a = s2.firstChild;
      r2.removeChild(i), n2--;
      let o2 = new h(i.sourceSpan.start, a.sourceSpan.end), u = new h(o2.start, s2.sourceSpan.end);
      s2.condition = i.condition, s2.sourceSpan = u, s2.startSourceSpan = o2, s2.removeChild(a);
    }
  });
}
function ja(t8, e2, r2) {
  t8.walk((n2) => {
    if (n2.children) for (let s2 = 0; s2 < n2.children.length; s2++) {
      let i = n2.children[s2];
      if (i.type !== "text" && !e2(i)) continue;
      i.type !== "text" && (i.type = "text", i.value = r2(i));
      let a = i.prev;
      !a || a.type !== "text" || (a.value += i.value, a.sourceSpan = new h(a.sourceSpan.start, i.sourceSpan.end), n2.removeChild(i), s2--);
    }
  });
}
function Ka(t8) {
  return ja(t8, (e2) => e2.type === "cdata", (e2) => `<![CDATA[${e2.value}]]>`);
}
function Xa(t8) {
  let e2 = (r2) => {
    var n2, s2;
    return r2.type === "element" && r2.attrs.length === 0 && r2.children.length === 1 && r2.firstChild.type === "text" && !O.hasWhitespaceCharacter(r2.children[0].value) && !r2.firstChild.hasLeadingSpaces && !r2.firstChild.hasTrailingSpaces && r2.isLeadingSpaceSensitive && !r2.hasLeadingSpaces && r2.isTrailingSpaceSensitive && !r2.hasTrailingSpaces && ((n2 = r2.prev) == null ? void 0 : n2.type) === "text" && ((s2 = r2.next) == null ? void 0 : s2.type) === "text";
  };
  t8.walk((r2) => {
    if (r2.children) for (let n2 = 0; n2 < r2.children.length; n2++) {
      let s2 = r2.children[n2];
      if (!e2(s2)) continue;
      let i = s2.prev, a = s2.next;
      i.value += `<${s2.rawName}>` + s2.firstChild.value + `</${s2.rawName}>` + a.value, i.sourceSpan = new h(i.sourceSpan.start, a.sourceSpan.end), i.isTrailingSpaceSensitive = a.isTrailingSpaceSensitive, i.hasTrailingSpaces = a.hasTrailingSpaces, r2.removeChild(s2), n2--, r2.removeChild(a);
    }
  });
}
function Qa(t8, e2) {
  if (e2.parser === "html") return;
  let r2 = /\{\{(.+?)\}\}/su;
  t8.walk((n2) => {
    if (qn(n2, e2)) for (let s2 of n2.children) {
      if (s2.type !== "text") continue;
      let i = s2.sourceSpan.start, a = null, o2 = s2.value.split(r2);
      for (let u = 0; u < o2.length; u++, i = a) {
        let p = o2[u];
        if (u % 2 === 0) {
          a = i.moveBy(p.length), p.length > 0 && n2.insertChildBefore(s2, { type: "text", value: p, sourceSpan: new h(i, a) });
          continue;
        }
        a = i.moveBy(p.length + 4), n2.insertChildBefore(s2, { type: "interpolation", sourceSpan: new h(i, a), children: p.length === 0 ? [] : [{ type: "text", value: p, sourceSpan: new h(i.moveBy(2), a.moveBy(-2)) }] });
      }
      n2.removeChild(s2);
    }
  });
}
function Ja(t8, e2) {
  t8.walk((r2) => {
    let n2 = r2.$children;
    if (!n2) return;
    if (n2.length === 0 || n2.length === 1 && n2[0].type === "text" && O.trim(n2[0].value).length === 0) {
      r2.hasDanglingSpaces = n2.length > 0, r2.$children = [];
      return;
    }
    let s2 = Hn(r2, e2), i = Ar(r2);
    if (!s2) for (let a = 0; a < n2.length; a++) {
      let o2 = n2[a];
      if (o2.type !== "text") continue;
      let { leadingWhitespace: u, text: p, trailingWhitespace: l2 } = Mn(o2.value), m = o2.prev, f = o2.next;
      p ? (o2.value = p, o2.sourceSpan = new h(o2.sourceSpan.start.moveBy(u.length), o2.sourceSpan.end.moveBy(-l2.length)), u && (m && (m.hasTrailingSpaces = true), o2.hasLeadingSpaces = true), l2 && (o2.hasTrailingSpaces = true, f && (f.hasLeadingSpaces = true))) : (r2.removeChild(o2), a--, (u || l2) && (m && (m.hasTrailingSpaces = true), f && (f.hasLeadingSpaces = true)));
    }
    r2.isWhitespaceSensitive = s2, r2.isIndentationSensitive = i;
  });
}
function Za(t8) {
  t8.walk((e2) => {
    e2.isSelfClosing = !e2.children || e2.type === "element" && (e2.tagDefinition.isVoid || e2.endSourceSpan && e2.startSourceSpan.start === e2.endSourceSpan.start && e2.startSourceSpan.end === e2.endSourceSpan.end);
  });
}
function eo(t8, e2) {
  t8.walk((r2) => {
    r2.type === "element" && (r2.hasHtmComponentClosingTag = r2.endSourceSpan && /^<\s*\/\s*\/\s*>$/u.test(e2.originalText.slice(r2.endSourceSpan.start.offset, r2.endSourceSpan.end.offset)));
  });
}
function to(t8, e2) {
  t8.walk((r2) => {
    r2.cssDisplay = Qn(r2, e2);
  });
}
function ro(t8, e2) {
  t8.walk((r2) => {
    let { children: n2 } = r2;
    if (n2) {
      if (n2.length === 0) {
        r2.isDanglingSpaceSensitive = Wn(r2, e2);
        return;
      }
      for (let s2 of n2) s2.isLeadingSpaceSensitive = Vn(s2, e2), s2.isTrailingSpaceSensitive = Un(s2, e2);
      for (let s2 = 0; s2 < n2.length; s2++) {
        let i = n2[s2];
        i.isLeadingSpaceSensitive = (s2 === 0 || i.prev.isTrailingSpaceSensitive) && i.isLeadingSpaceSensitive, i.isTrailingSpaceSensitive = (s2 === n2.length - 1 || i.next.isLeadingSpaceSensitive) && i.isTrailingSpaceSensitive;
      }
    }
  });
}
var Ms = Ga;
function no(t8, e2, r2) {
  let { node: n2 } = t8;
  switch (n2.type) {
    case "front-matter":
      return B(n2.raw);
    case "root":
      return e2.__onHtmlRoot && e2.__onHtmlRoot(n2), [E(Re(t8, e2, r2)), S];
    case "element":
    case "ieConditionalComment":
      return Is(t8, e2, r2);
    case "angularControlFlowBlock":
      return Bs(t8, e2, r2);
    case "angularControlFlowBlockParameters":
      return Fs(t8, e2, r2);
    case "angularControlFlowBlockParameter":
      return O.trim(n2.expression);
    case "angularLetDeclaration":
      return E(["@let ", E([n2.id, " =", E(k([_, r2("init")]))]), ";"]);
    case "angularLetDeclarationInitializer":
      return n2.value;
    case "angularIcuExpression":
      return Ps(t8, e2, r2);
    case "angularIcuCase":
      return Ns(t8, e2, r2);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [De(n2), Se(n2)];
    case "interpolation":
      return [De(n2, e2), ...t8.map(r2, "children"), Se(n2, e2)];
    case "text": {
      if (n2.parent.type === "interpolation") {
        let o2 = /\n[^\S\n]*$/u, u = o2.test(n2.value), p = u ? n2.value.replace(o2, "") : n2.value;
        return [B(p), u ? S : ""];
      }
      let s2 = z(n2, e2), i = kt(n2), a = G(n2, e2);
      return i[0] = [s2, i[0]], i.push([i.pop(), a]), vt(i);
    }
    case "docType":
      return [E([De(n2, e2), " ", w(false, n2.value.replace(/^html\b/iu, "html"), /\s+/gu, " ")]), Se(n2, e2)];
    case "comment":
      return [z(n2, e2), B(e2.originalText.slice(J(n2), se(n2))), G(n2, e2)];
    case "attribute": {
      if (n2.value === null) return n2.rawName;
      let s2 = wr(n2.value), i = _n(s2, '"');
      return [n2.rawName, "=", i, B(i === '"' ? w(false, s2, '"', "&quot;") : w(false, s2, "'", "&apos;")), i];
    }
    case "cdata":
    default:
      throw new An(n2, "HTML");
  }
}
var so = { preprocess: Ms, print: no, insertPragma: Ts, massageAstNode: vn, embed: Ss, getVisitorKeys: As };
var qs = so;
var Hs = [{ name: "Angular", type: "markup", extensions: [".component.html"], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [], linguistLanguageId: 146 }, { name: "HTML", type: "markup", extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["html"], vscodeLanguageIds: ["html"], linguistLanguageId: 146 }, { name: "Lightning Web Components", type: "markup", extensions: [], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [], linguistLanguageId: 146 }, { name: "MJML", type: "markup", extensions: [".mjml"], tmScope: "text.mjml.basic", aceMode: "html", aliases: ["MJML", "mjml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["mjml"], filenames: [], vscodeLanguageIds: ["mjml"], linguistLanguageId: 146 }, { name: "Vue", type: "markup", extensions: [".vue"], tmScope: "source.vue", aceMode: "html", parsers: ["vue"], vscodeLanguageIds: ["vue"], linguistLanguageId: 391 }];
var Lr = { bracketSpacing: { category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, objectWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap object literals.", choices: [{ value: "preserve", description: "Keep as multi-line, if there is a newline between the opening brace and first property." }, { value: "collapse", description: "Fit to a single line when possible." }] }, singleQuote: { category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
var Vs = "HTML";
var io = { bracketSameLine: Lr.bracketSameLine, htmlWhitespaceSensitivity: { category: Vs, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: Lr.singleAttributePerLine, vueIndentScriptAndStyle: { category: Vs, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
var Us = io;
var tn = {};
ln(tn, { angular: () => iu, html: () => ru, lwc: () => ou, mjml: () => su, vue: () => au });
var ah = new RegExp(`(\\:not\\()|(([\\.\\#]?)[-\\w]+)|(?:\\[([-.\\w*\\\\$]+)(?:=(["']?)([^\\]"']*)\\5)?\\])|(\\))|(\\s*,\\s*)`, "g");
var Ws;
(function(t8) {
  t8[t8.Emulated = 0] = "Emulated", t8[t8.None = 2] = "None", t8[t8.ShadowDom = 3] = "ShadowDom";
})(Ws || (Ws = {}));
var Gs;
(function(t8) {
  t8[t8.OnPush = 0] = "OnPush", t8[t8.Default = 1] = "Default";
})(Gs || (Gs = {}));
var zs;
(function(t8) {
  t8[t8.None = 0] = "None", t8[t8.SignalBased = 1] = "SignalBased", t8[t8.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform";
})(zs || (zs = {}));
var Fr = { name: "custom-elements" };
var Pr = { name: "no-errors-schema" };
var Z;
(function(t8) {
  t8[t8.NONE = 0] = "NONE", t8[t8.HTML = 1] = "HTML", t8[t8.STYLE = 2] = "STYLE", t8[t8.SCRIPT = 3] = "SCRIPT", t8[t8.URL = 4] = "URL", t8[t8.RESOURCE_URL = 5] = "RESOURCE_URL";
})(Z || (Z = {}));
var Ys;
(function(t8) {
  t8[t8.Error = 0] = "Error", t8[t8.Warning = 1] = "Warning", t8[t8.Ignore = 2] = "Ignore";
})(Ys || (Ys = {}));
var N;
(function(t8) {
  t8[t8.RAW_TEXT = 0] = "RAW_TEXT", t8[t8.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t8[t8.PARSABLE_DATA = 2] = "PARSABLE_DATA";
})(N || (N = {}));
function ct(t8, e2 = true) {
  if (t8[0] != ":") return [null, t8];
  let r2 = t8.indexOf(":", 1);
  if (r2 === -1) {
    if (e2) throw new Error(`Unsupported format "${t8}" expecting ":namespace:name"`);
    return [null, t8];
  }
  return [t8.slice(1, r2), t8.slice(r2 + 1)];
}
function Nr(t8) {
  return ct(t8)[1] === "ng-container";
}
function Ir(t8) {
  return ct(t8)[1] === "ng-content";
}
function Me(t8) {
  return t8 === null ? null : ct(t8)[0];
}
function qe(t8, e2) {
  return t8 ? `:${t8}:${e2}` : e2;
}
var Ht;
function Rr() {
  return Ht || (Ht = {}, qt(Z.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), qt(Z.STYLE, ["*|style"]), qt(Z.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), qt(Z.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), Ht;
}
function qt(t8, e2) {
  for (let r2 of e2) Ht[r2.toLowerCase()] = t8;
}
var Vt = class {
};
var ao = "boolean";
var oo = "number";
var uo = "string";
var lo = "object";
var co = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|", ":math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":math:math^:math:|", ":math:maction^:math:|", ":math:menclose^:math:|", ":math:merror^:math:|", ":math:mfenced^:math:|", ":math:mfrac^:math:|", ":math:mi^:math:|", ":math:mmultiscripts^:math:|", ":math:mn^:math:|", ":math:mo^:math:|", ":math:mover^:math:|", ":math:mpadded^:math:|", ":math:mphantom^:math:|", ":math:mroot^:math:|", ":math:mrow^:math:|", ":math:ms^:math:|", ":math:mspace^:math:|", ":math:msqrt^:math:|", ":math:mstyle^:math:|", ":math:msub^:math:|", ":math:msubsup^:math:|", ":math:msup^:math:|", ":math:mtable^:math:|", ":math:mtd^:math:|", ":math:mtext^:math:|", ":math:mtr^:math:|", ":math:munder^:math:|", ":math:munderover^:math:|", ":math:semantics^:math:|"];
var js = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" }));
var po = Array.from(js).reduce((t8, [e2, r2]) => (t8.set(e2, r2), t8), /* @__PURE__ */ new Map());
var Ut = class extends Vt {
  constructor() {
    super(), this._schema = /* @__PURE__ */ new Map(), this._eventSchema = /* @__PURE__ */ new Map(), co.forEach((e2) => {
      let r2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Set(), [s2, i] = e2.split("|"), a = i.split(","), [o2, u] = s2.split("^");
      o2.split(",").forEach((l2) => {
        this._schema.set(l2.toLowerCase(), r2), this._eventSchema.set(l2.toLowerCase(), n2);
      });
      let p = u && this._schema.get(u.toLowerCase());
      if (p) {
        for (let [l2, m] of p) r2.set(l2, m);
        for (let l2 of this._eventSchema.get(u.toLowerCase())) n2.add(l2);
      }
      a.forEach((l2) => {
        if (l2.length > 0) switch (l2[0]) {
          case "*":
            n2.add(l2.substring(1));
            break;
          case "!":
            r2.set(l2.substring(1), ao);
            break;
          case "#":
            r2.set(l2.substring(1), oo);
            break;
          case "%":
            r2.set(l2.substring(1), lo);
            break;
          default:
            r2.set(l2, uo);
        }
      });
    });
  }
  hasProperty(e2, r2, n2) {
    if (n2.some((i) => i.name === Pr.name)) return true;
    if (e2.indexOf("-") > -1) {
      if (Nr(e2) || Ir(e2)) return false;
      if (n2.some((i) => i.name === Fr.name)) return true;
    }
    return (this._schema.get(e2.toLowerCase()) || this._schema.get("unknown")).has(r2);
  }
  hasElement(e2, r2) {
    return r2.some((n2) => n2.name === Pr.name) || e2.indexOf("-") > -1 && (Nr(e2) || Ir(e2) || r2.some((n2) => n2.name === Fr.name)) ? true : this._schema.has(e2.toLowerCase());
  }
  securityContext(e2, r2, n2) {
    n2 && (r2 = this.getMappedPropName(r2)), e2 = e2.toLowerCase(), r2 = r2.toLowerCase();
    let s2 = Rr()[e2 + "|" + r2];
    return s2 || (s2 = Rr()["*|" + r2], s2 || Z.NONE);
  }
  getMappedPropName(e2) {
    return js.get(e2) ?? e2;
  }
  getDefaultComponentElementName() {
    return "ng-component";
  }
  validateProperty(e2) {
    return e2.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event property '${e2}' is disallowed for security reasons, please use (${e2.slice(2)})=...
If '${e2}' is a directive input, make sure the directive is imported by the current module.` } : { error: false };
  }
  validateAttribute(e2) {
    return e2.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event attribute '${e2}' is disallowed for security reasons, please use (${e2.slice(2)})=...` } : { error: false };
  }
  allKnownElementNames() {
    return Array.from(this._schema.keys());
  }
  allKnownAttributesOfElement(e2) {
    let r2 = this._schema.get(e2.toLowerCase()) || this._schema.get("unknown");
    return Array.from(r2.keys()).map((n2) => po.get(n2) ?? n2);
  }
  allKnownEventsOfElement(e2) {
    return Array.from(this._eventSchema.get(e2.toLowerCase()) ?? []);
  }
  normalizeAnimationStyleProperty(e2) {
    return Os(e2);
  }
  normalizeAnimationStyleValue(e2, r2, n2) {
    let s2 = "", i = n2.toString().trim(), a = null;
    if (ho(e2) && n2 !== 0 && n2 !== "0") if (typeof n2 == "number") s2 = "px";
    else {
      let o2 = n2.match(/^[+-]?[\d\.]+([a-z]*)$/);
      o2 && o2[1].length == 0 && (a = `Please provide a CSS unit value for ${r2}:${n2}`);
    }
    return { error: a, value: i + s2 };
  }
};
function ho(t8) {
  switch (t8) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent":
      return true;
    default:
      return false;
  }
}
var d = class {
  constructor({ closedByChildren: e2, implicitNamespacePrefix: r2, contentType: n2 = N.PARSABLE_DATA, closedByParent: s2 = false, isVoid: i = false, ignoreFirstLf: a = false, preventNamespaceInheritance: o2 = false, canSelfClose: u = false } = {}) {
    this.closedByChildren = {}, this.closedByParent = false, e2 && e2.length > 0 && e2.forEach((p) => this.closedByChildren[p] = true), this.isVoid = i, this.closedByParent = s2 || i, this.implicitNamespacePrefix = r2 || null, this.contentType = n2, this.ignoreFirstLf = a, this.preventNamespaceInheritance = o2, this.canSelfClose = u ?? i;
  }
  isClosedByChild(e2) {
    return this.isVoid || e2.toLowerCase() in this.closedByChildren;
  }
  getContentType(e2) {
    return typeof this.contentType == "object" ? (e2 === void 0 ? void 0 : this.contentType[e2]) ?? this.contentType.default : this.contentType;
  }
};
var Ks;
var pt;
function He(t8) {
  return pt || (Ks = new d({ canSelfClose: true }), pt = Object.assign(/* @__PURE__ */ Object.create(null), { base: new d({ isVoid: true }), meta: new d({ isVoid: true }), area: new d({ isVoid: true }), embed: new d({ isVoid: true }), link: new d({ isVoid: true }), img: new d({ isVoid: true }), input: new d({ isVoid: true }), param: new d({ isVoid: true }), hr: new d({ isVoid: true }), br: new d({ isVoid: true }), source: new d({ isVoid: true }), track: new d({ isVoid: true }), wbr: new d({ isVoid: true }), p: new d({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true }), thead: new d({ closedByChildren: ["tbody", "tfoot"] }), tbody: new d({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }), tfoot: new d({ closedByChildren: ["tbody"], closedByParent: true }), tr: new d({ closedByChildren: ["tr"], closedByParent: true }), td: new d({ closedByChildren: ["td", "th"], closedByParent: true }), th: new d({ closedByChildren: ["td", "th"], closedByParent: true }), col: new d({ isVoid: true }), svg: new d({ implicitNamespacePrefix: "svg" }), foreignObject: new d({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: true }), math: new d({ implicitNamespacePrefix: "math" }), li: new d({ closedByChildren: ["li"], closedByParent: true }), dt: new d({ closedByChildren: ["dt", "dd"] }), dd: new d({ closedByChildren: ["dt", "dd"], closedByParent: true }), rb: new d({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rt: new d({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rtc: new d({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }), rp: new d({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), optgroup: new d({ closedByChildren: ["optgroup"], closedByParent: true }), option: new d({ closedByChildren: ["option", "optgroup"], closedByParent: true }), pre: new d({ ignoreFirstLf: true }), listing: new d({ ignoreFirstLf: true }), style: new d({ contentType: N.RAW_TEXT }), script: new d({ contentType: N.RAW_TEXT }), title: new d({ contentType: { default: N.ESCAPABLE_RAW_TEXT, svg: N.PARSABLE_DATA } }), textarea: new d({ contentType: N.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }) }), new Ut().allKnownElementNames().forEach((e2) => {
    !pt[e2] && Me(e2) === null && (pt[e2] = new d({ canSelfClose: false }));
  })), pt[t8] ?? Ks;
}
var ae = class {
  constructor(e2, r2) {
    this.sourceSpan = e2, this.i18n = r2;
  }
};
var Wt = class extends ae {
  constructor(e2, r2, n2, s2) {
    super(r2, s2), this.value = e2, this.tokens = n2, this.type = "text";
  }
  visit(e2, r2) {
    return e2.visitText(this, r2);
  }
};
var Gt = class extends ae {
  constructor(e2, r2, n2, s2) {
    super(r2, s2), this.value = e2, this.tokens = n2, this.type = "cdata";
  }
  visit(e2, r2) {
    return e2.visitCdata(this, r2);
  }
};
var zt = class extends ae {
  constructor(e2, r2, n2, s2, i, a) {
    super(s2, a), this.switchValue = e2, this.type = r2, this.cases = n2, this.switchValueSourceSpan = i;
  }
  visit(e2, r2) {
    return e2.visitExpansion(this, r2);
  }
};
var Yt = class {
  constructor(e2, r2, n2, s2, i) {
    this.value = e2, this.expression = r2, this.sourceSpan = n2, this.valueSourceSpan = s2, this.expSourceSpan = i, this.type = "expansionCase";
  }
  visit(e2, r2) {
    return e2.visitExpansionCase(this, r2);
  }
};
var jt = class extends ae {
  constructor(e2, r2, n2, s2, i, a, o2) {
    super(n2, o2), this.name = e2, this.value = r2, this.keySpan = s2, this.valueSpan = i, this.valueTokens = a, this.type = "attribute";
  }
  visit(e2, r2) {
    return e2.visitAttribute(this, r2);
  }
  get nameSpan() {
    return this.keySpan;
  }
};
var Y = class extends ae {
  constructor(e2, r2, n2, s2, i, a = null, o2 = null, u) {
    super(s2, u), this.name = e2, this.attrs = r2, this.children = n2, this.startSourceSpan = i, this.endSourceSpan = a, this.nameSpan = o2, this.type = "element";
  }
  visit(e2, r2) {
    return e2.visitElement(this, r2);
  }
};
var Kt = class {
  constructor(e2, r2) {
    this.value = e2, this.sourceSpan = r2, this.type = "comment";
  }
  visit(e2, r2) {
    return e2.visitComment(this, r2);
  }
};
var Xt = class {
  constructor(e2, r2) {
    this.value = e2, this.sourceSpan = r2, this.type = "docType";
  }
  visit(e2, r2) {
    return e2.visitDocType(this, r2);
  }
};
var ee = class extends ae {
  constructor(e2, r2, n2, s2, i, a, o2 = null, u) {
    super(s2, u), this.name = e2, this.parameters = r2, this.children = n2, this.nameSpan = i, this.startSourceSpan = a, this.endSourceSpan = o2, this.type = "block";
  }
  visit(e2, r2) {
    return e2.visitBlock(this, r2);
  }
};
var ht = class {
  constructor(e2, r2) {
    this.expression = e2, this.sourceSpan = r2, this.type = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e2, r2) {
    return e2.visitBlockParameter(this, r2);
  }
};
var mt = class {
  constructor(e2, r2, n2, s2, i) {
    this.name = e2, this.value = r2, this.sourceSpan = n2, this.nameSpan = s2, this.valueSpan = i, this.type = "letDeclaration", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e2, r2) {
    return e2.visitLetDeclaration(this, r2);
  }
};
function Qt(t8, e2, r2 = null) {
  let n2 = [], s2 = t8.visit ? (i) => t8.visit(i, r2) || i.visit(t8, r2) : (i) => i.visit(t8, r2);
  return e2.forEach((i) => {
    let a = s2(i);
    a && n2.push(a);
  }), n2;
}
var ft = class {
  constructor() {
  }
  visitElement(e2, r2) {
    this.visitChildren(r2, (n2) => {
      n2(e2.attrs), n2(e2.children);
    });
  }
  visitAttribute(e2, r2) {
  }
  visitText(e2, r2) {
  }
  visitCdata(e2, r2) {
  }
  visitComment(e2, r2) {
  }
  visitDocType(e2, r2) {
  }
  visitExpansion(e2, r2) {
    return this.visitChildren(r2, (n2) => {
      n2(e2.cases);
    });
  }
  visitExpansionCase(e2, r2) {
  }
  visitBlock(e2, r2) {
    this.visitChildren(r2, (n2) => {
      n2(e2.parameters), n2(e2.children);
    });
  }
  visitBlockParameter(e2, r2) {
  }
  visitLetDeclaration(e2, r2) {
  }
  visitChildren(e2, r2) {
    let n2 = [], s2 = this;
    function i(a) {
      a && n2.push(Qt(s2, a, e2));
    }
    return r2(i), Array.prototype.concat.apply([], n2);
  }
};
var Ve = { AElig: "\xC6", AMP: "&", amp: "&", Aacute: "\xC1", Abreve: "\u0102", Acirc: "\xC2", Acy: "\u0410", Afr: "\u{1D504}", Agrave: "\xC0", Alpha: "\u0391", Amacr: "\u0100", And: "\u2A53", Aogon: "\u0104", Aopf: "\u{1D538}", ApplyFunction: "\u2061", af: "\u2061", Aring: "\xC5", angst: "\xC5", Ascr: "\u{1D49C}", Assign: "\u2254", colone: "\u2254", coloneq: "\u2254", Atilde: "\xC3", Auml: "\xC4", Backslash: "\u2216", setminus: "\u2216", setmn: "\u2216", smallsetminus: "\u2216", ssetmn: "\u2216", Barv: "\u2AE7", Barwed: "\u2306", doublebarwedge: "\u2306", Bcy: "\u0411", Because: "\u2235", becaus: "\u2235", because: "\u2235", Bernoullis: "\u212C", Bscr: "\u212C", bernou: "\u212C", Beta: "\u0392", Bfr: "\u{1D505}", Bopf: "\u{1D539}", Breve: "\u02D8", breve: "\u02D8", Bumpeq: "\u224E", HumpDownHump: "\u224E", bump: "\u224E", CHcy: "\u0427", COPY: "\xA9", copy: "\xA9", Cacute: "\u0106", Cap: "\u22D2", CapitalDifferentialD: "\u2145", DD: "\u2145", Cayleys: "\u212D", Cfr: "\u212D", Ccaron: "\u010C", Ccedil: "\xC7", Ccirc: "\u0108", Cconint: "\u2230", Cdot: "\u010A", Cedilla: "\xB8", cedil: "\xB8", CenterDot: "\xB7", centerdot: "\xB7", middot: "\xB7", Chi: "\u03A7", CircleDot: "\u2299", odot: "\u2299", CircleMinus: "\u2296", ominus: "\u2296", CirclePlus: "\u2295", oplus: "\u2295", CircleTimes: "\u2297", otimes: "\u2297", ClockwiseContourIntegral: "\u2232", cwconint: "\u2232", CloseCurlyDoubleQuote: "\u201D", rdquo: "\u201D", rdquor: "\u201D", CloseCurlyQuote: "\u2019", rsquo: "\u2019", rsquor: "\u2019", Colon: "\u2237", Proportion: "\u2237", Colone: "\u2A74", Congruent: "\u2261", equiv: "\u2261", Conint: "\u222F", DoubleContourIntegral: "\u222F", ContourIntegral: "\u222E", conint: "\u222E", oint: "\u222E", Copf: "\u2102", complexes: "\u2102", Coproduct: "\u2210", coprod: "\u2210", CounterClockwiseContourIntegral: "\u2233", awconint: "\u2233", Cross: "\u2A2F", Cscr: "\u{1D49E}", Cup: "\u22D3", CupCap: "\u224D", asympeq: "\u224D", DDotrahd: "\u2911", DJcy: "\u0402", DScy: "\u0405", DZcy: "\u040F", Dagger: "\u2021", ddagger: "\u2021", Darr: "\u21A1", Dashv: "\u2AE4", DoubleLeftTee: "\u2AE4", Dcaron: "\u010E", Dcy: "\u0414", Del: "\u2207", nabla: "\u2207", Delta: "\u0394", Dfr: "\u{1D507}", DiacriticalAcute: "\xB4", acute: "\xB4", DiacriticalDot: "\u02D9", dot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", dblac: "\u02DD", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "\u02DC", tilde: "\u02DC", Diamond: "\u22C4", diam: "\u22C4", diamond: "\u22C4", DifferentialD: "\u2146", dd: "\u2146", Dopf: "\u{1D53B}", Dot: "\xA8", DoubleDot: "\xA8", die: "\xA8", uml: "\xA8", DotDot: "\u20DC", DotEqual: "\u2250", doteq: "\u2250", esdot: "\u2250", DoubleDownArrow: "\u21D3", Downarrow: "\u21D3", dArr: "\u21D3", DoubleLeftArrow: "\u21D0", Leftarrow: "\u21D0", lArr: "\u21D0", DoubleLeftRightArrow: "\u21D4", Leftrightarrow: "\u21D4", hArr: "\u21D4", iff: "\u21D4", DoubleLongLeftArrow: "\u27F8", Longleftarrow: "\u27F8", xlArr: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", Longleftrightarrow: "\u27FA", xhArr: "\u27FA", DoubleLongRightArrow: "\u27F9", Longrightarrow: "\u27F9", xrArr: "\u27F9", DoubleRightArrow: "\u21D2", Implies: "\u21D2", Rightarrow: "\u21D2", rArr: "\u21D2", DoubleRightTee: "\u22A8", vDash: "\u22A8", DoubleUpArrow: "\u21D1", Uparrow: "\u21D1", uArr: "\u21D1", DoubleUpDownArrow: "\u21D5", Updownarrow: "\u21D5", vArr: "\u21D5", DoubleVerticalBar: "\u2225", par: "\u2225", parallel: "\u2225", shortparallel: "\u2225", spar: "\u2225", DownArrow: "\u2193", ShortDownArrow: "\u2193", darr: "\u2193", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", duarr: "\u21F5", DownBreve: "\u0311", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", leftharpoondown: "\u21BD", lhard: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", rhard: "\u21C1", rightharpoondown: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", top: "\u22A4", DownTeeArrow: "\u21A7", mapstodown: "\u21A7", Dscr: "\u{1D49F}", Dstrok: "\u0110", ENG: "\u014A", ETH: "\xD0", Eacute: "\xC9", Ecaron: "\u011A", Ecirc: "\xCA", Ecy: "\u042D", Edot: "\u0116", Efr: "\u{1D508}", Egrave: "\xC8", Element: "\u2208", in: "\u2208", isin: "\u2208", isinv: "\u2208", Emacr: "\u0112", EmptySmallSquare: "\u25FB", EmptyVerySmallSquare: "\u25AB", Eogon: "\u0118", Eopf: "\u{1D53C}", Epsilon: "\u0395", Equal: "\u2A75", EqualTilde: "\u2242", eqsim: "\u2242", esim: "\u2242", Equilibrium: "\u21CC", rightleftharpoons: "\u21CC", rlhar: "\u21CC", Escr: "\u2130", expectation: "\u2130", Esim: "\u2A73", Eta: "\u0397", Euml: "\xCB", Exists: "\u2203", exist: "\u2203", ExponentialE: "\u2147", ee: "\u2147", exponentiale: "\u2147", Fcy: "\u0424", Ffr: "\u{1D509}", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", blacksquare: "\u25AA", squarf: "\u25AA", squf: "\u25AA", Fopf: "\u{1D53D}", ForAll: "\u2200", forall: "\u2200", Fouriertrf: "\u2131", Fscr: "\u2131", GJcy: "\u0403", GT: ">", gt: ">", Gamma: "\u0393", Gammad: "\u03DC", Gbreve: "\u011E", Gcedil: "\u0122", Gcirc: "\u011C", Gcy: "\u0413", Gdot: "\u0120", Gfr: "\u{1D50A}", Gg: "\u22D9", ggg: "\u22D9", Gopf: "\u{1D53E}", GreaterEqual: "\u2265", ge: "\u2265", geq: "\u2265", GreaterEqualLess: "\u22DB", gel: "\u22DB", gtreqless: "\u22DB", GreaterFullEqual: "\u2267", gE: "\u2267", geqq: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", gl: "\u2277", gtrless: "\u2277", GreaterSlantEqual: "\u2A7E", geqslant: "\u2A7E", ges: "\u2A7E", GreaterTilde: "\u2273", gsim: "\u2273", gtrsim: "\u2273", Gscr: "\u{1D4A2}", Gt: "\u226B", NestedGreaterGreater: "\u226B", gg: "\u226B", HARDcy: "\u042A", Hacek: "\u02C7", caron: "\u02C7", Hat: "^", Hcirc: "\u0124", Hfr: "\u210C", Poincareplane: "\u210C", HilbertSpace: "\u210B", Hscr: "\u210B", hamilt: "\u210B", Hopf: "\u210D", quaternions: "\u210D", HorizontalLine: "\u2500", boxh: "\u2500", Hstrok: "\u0126", HumpEqual: "\u224F", bumpe: "\u224F", bumpeq: "\u224F", IEcy: "\u0415", IJlig: "\u0132", IOcy: "\u0401", Iacute: "\xCD", Icirc: "\xCE", Icy: "\u0418", Idot: "\u0130", Ifr: "\u2111", Im: "\u2111", image: "\u2111", imagpart: "\u2111", Igrave: "\xCC", Imacr: "\u012A", ImaginaryI: "\u2148", ii: "\u2148", Int: "\u222C", Integral: "\u222B", int: "\u222B", Intersection: "\u22C2", bigcap: "\u22C2", xcap: "\u22C2", InvisibleComma: "\u2063", ic: "\u2063", InvisibleTimes: "\u2062", it: "\u2062", Iogon: "\u012E", Iopf: "\u{1D540}", Iota: "\u0399", Iscr: "\u2110", imagline: "\u2110", Itilde: "\u0128", Iukcy: "\u0406", Iuml: "\xCF", Jcirc: "\u0134", Jcy: "\u0419", Jfr: "\u{1D50D}", Jopf: "\u{1D541}", Jscr: "\u{1D4A5}", Jsercy: "\u0408", Jukcy: "\u0404", KHcy: "\u0425", KJcy: "\u040C", Kappa: "\u039A", Kcedil: "\u0136", Kcy: "\u041A", Kfr: "\u{1D50E}", Kopf: "\u{1D542}", Kscr: "\u{1D4A6}", LJcy: "\u0409", LT: "<", lt: "<", Lacute: "\u0139", Lambda: "\u039B", Lang: "\u27EA", Laplacetrf: "\u2112", Lscr: "\u2112", lagran: "\u2112", Larr: "\u219E", twoheadleftarrow: "\u219E", Lcaron: "\u013D", Lcedil: "\u013B", Lcy: "\u041B", LeftAngleBracket: "\u27E8", lang: "\u27E8", langle: "\u27E8", LeftArrow: "\u2190", ShortLeftArrow: "\u2190", larr: "\u2190", leftarrow: "\u2190", slarr: "\u2190", LeftArrowBar: "\u21E4", larrb: "\u21E4", LeftArrowRightArrow: "\u21C6", leftrightarrows: "\u21C6", lrarr: "\u21C6", LeftCeiling: "\u2308", lceil: "\u2308", LeftDoubleBracket: "\u27E6", lobrk: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", dharl: "\u21C3", downharpoonleft: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", lfloor: "\u230A", LeftRightArrow: "\u2194", harr: "\u2194", leftrightarrow: "\u2194", LeftRightVector: "\u294E", LeftTee: "\u22A3", dashv: "\u22A3", LeftTeeArrow: "\u21A4", mapstoleft: "\u21A4", LeftTeeVector: "\u295A", LeftTriangle: "\u22B2", vartriangleleft: "\u22B2", vltri: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", ltrie: "\u22B4", trianglelefteq: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", uharl: "\u21BF", upharpoonleft: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", leftharpoonup: "\u21BC", lharu: "\u21BC", LeftVectorBar: "\u2952", LessEqualGreater: "\u22DA", leg: "\u22DA", lesseqgtr: "\u22DA", LessFullEqual: "\u2266", lE: "\u2266", leqq: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", lg: "\u2276", LessLess: "\u2AA1", LessSlantEqual: "\u2A7D", leqslant: "\u2A7D", les: "\u2A7D", LessTilde: "\u2272", lesssim: "\u2272", lsim: "\u2272", Lfr: "\u{1D50F}", Ll: "\u22D8", Lleftarrow: "\u21DA", lAarr: "\u21DA", Lmidot: "\u013F", LongLeftArrow: "\u27F5", longleftarrow: "\u27F5", xlarr: "\u27F5", LongLeftRightArrow: "\u27F7", longleftrightarrow: "\u27F7", xharr: "\u27F7", LongRightArrow: "\u27F6", longrightarrow: "\u27F6", xrarr: "\u27F6", Lopf: "\u{1D543}", LowerLeftArrow: "\u2199", swarr: "\u2199", swarrow: "\u2199", LowerRightArrow: "\u2198", searr: "\u2198", searrow: "\u2198", Lsh: "\u21B0", lsh: "\u21B0", Lstrok: "\u0141", Lt: "\u226A", NestedLessLess: "\u226A", ll: "\u226A", Map: "\u2905", Mcy: "\u041C", MediumSpace: "\u205F", Mellintrf: "\u2133", Mscr: "\u2133", phmmat: "\u2133", Mfr: "\u{1D510}", MinusPlus: "\u2213", mnplus: "\u2213", mp: "\u2213", Mopf: "\u{1D544}", Mu: "\u039C", NJcy: "\u040A", Nacute: "\u0143", Ncaron: "\u0147", Ncedil: "\u0145", Ncy: "\u041D", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", ZeroWidthSpace: "\u200B", NewLine: `
`, Nfr: "\u{1D511}", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nbsp: "\xA0", Nopf: "\u2115", naturals: "\u2115", Not: "\u2AEC", NotCongruent: "\u2262", nequiv: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", npar: "\u2226", nparallel: "\u2226", nshortparallel: "\u2226", nspar: "\u2226", NotElement: "\u2209", notin: "\u2209", notinva: "\u2209", NotEqual: "\u2260", ne: "\u2260", NotEqualTilde: "\u2242\u0338", nesim: "\u2242\u0338", NotExists: "\u2204", nexist: "\u2204", nexists: "\u2204", NotGreater: "\u226F", ngt: "\u226F", ngtr: "\u226F", NotGreaterEqual: "\u2271", nge: "\u2271", ngeq: "\u2271", NotGreaterFullEqual: "\u2267\u0338", ngE: "\u2267\u0338", ngeqq: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", nGtv: "\u226B\u0338", NotGreaterLess: "\u2279", ntgl: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", NotGreaterTilde: "\u2275", ngsim: "\u2275", NotHumpDownHump: "\u224E\u0338", nbump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", nbumpe: "\u224F\u0338", NotLeftTriangle: "\u22EA", nltri: "\u22EA", ntriangleleft: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", nltrie: "\u22EC", ntrianglelefteq: "\u22EC", NotLess: "\u226E", nless: "\u226E", nlt: "\u226E", NotLessEqual: "\u2270", nle: "\u2270", nleq: "\u2270", NotLessGreater: "\u2278", ntlg: "\u2278", NotLessLess: "\u226A\u0338", nLtv: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", NotLessTilde: "\u2274", nlsim: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", NotPrecedes: "\u2280", npr: "\u2280", nprec: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", npre: "\u2AAF\u0338", npreceq: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", nprcue: "\u22E0", NotReverseElement: "\u220C", notni: "\u220C", notniva: "\u220C", NotRightTriangle: "\u22EB", nrtri: "\u22EB", ntriangleright: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", nrtrie: "\u22ED", ntrianglerighteq: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", nsqsube: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", nsqsupe: "\u22E3", NotSubset: "\u2282\u20D2", nsubset: "\u2282\u20D2", vnsub: "\u2282\u20D2", NotSubsetEqual: "\u2288", nsube: "\u2288", nsubseteq: "\u2288", NotSucceeds: "\u2281", nsc: "\u2281", nsucc: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", nsce: "\u2AB0\u0338", nsucceq: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", nsccue: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", nsupset: "\u2283\u20D2", vnsup: "\u2283\u20D2", NotSupersetEqual: "\u2289", nsupe: "\u2289", nsupseteq: "\u2289", NotTilde: "\u2241", nsim: "\u2241", NotTildeEqual: "\u2244", nsime: "\u2244", nsimeq: "\u2244", NotTildeFullEqual: "\u2247", ncong: "\u2247", NotTildeTilde: "\u2249", nap: "\u2249", napprox: "\u2249", NotVerticalBar: "\u2224", nmid: "\u2224", nshortmid: "\u2224", nsmid: "\u2224", Nscr: "\u{1D4A9}", Ntilde: "\xD1", Nu: "\u039D", OElig: "\u0152", Oacute: "\xD3", Ocirc: "\xD4", Ocy: "\u041E", Odblac: "\u0150", Ofr: "\u{1D512}", Ograve: "\xD2", Omacr: "\u014C", Omega: "\u03A9", ohm: "\u03A9", Omicron: "\u039F", Oopf: "\u{1D546}", OpenCurlyDoubleQuote: "\u201C", ldquo: "\u201C", OpenCurlyQuote: "\u2018", lsquo: "\u2018", Or: "\u2A54", Oscr: "\u{1D4AA}", Oslash: "\xD8", Otilde: "\xD5", Otimes: "\u2A37", Ouml: "\xD6", OverBar: "\u203E", oline: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", tbrk: "\u23B4", OverParenthesis: "\u23DC", PartialD: "\u2202", part: "\u2202", Pcy: "\u041F", Pfr: "\u{1D513}", Phi: "\u03A6", Pi: "\u03A0", PlusMinus: "\xB1", plusmn: "\xB1", pm: "\xB1", Popf: "\u2119", primes: "\u2119", Pr: "\u2ABB", Precedes: "\u227A", pr: "\u227A", prec: "\u227A", PrecedesEqual: "\u2AAF", pre: "\u2AAF", preceq: "\u2AAF", PrecedesSlantEqual: "\u227C", prcue: "\u227C", preccurlyeq: "\u227C", PrecedesTilde: "\u227E", precsim: "\u227E", prsim: "\u227E", Prime: "\u2033", Product: "\u220F", prod: "\u220F", Proportional: "\u221D", prop: "\u221D", propto: "\u221D", varpropto: "\u221D", vprop: "\u221D", Pscr: "\u{1D4AB}", Psi: "\u03A8", QUOT: '"', quot: '"', Qfr: "\u{1D514}", Qopf: "\u211A", rationals: "\u211A", Qscr: "\u{1D4AC}", RBarr: "\u2910", drbkarow: "\u2910", REG: "\xAE", circledR: "\xAE", reg: "\xAE", Racute: "\u0154", Rang: "\u27EB", Rarr: "\u21A0", twoheadrightarrow: "\u21A0", Rarrtl: "\u2916", Rcaron: "\u0158", Rcedil: "\u0156", Rcy: "\u0420", Re: "\u211C", Rfr: "\u211C", real: "\u211C", realpart: "\u211C", ReverseElement: "\u220B", SuchThat: "\u220B", ni: "\u220B", niv: "\u220B", ReverseEquilibrium: "\u21CB", leftrightharpoons: "\u21CB", lrhar: "\u21CB", ReverseUpEquilibrium: "\u296F", duhar: "\u296F", Rho: "\u03A1", RightAngleBracket: "\u27E9", rang: "\u27E9", rangle: "\u27E9", RightArrow: "\u2192", ShortRightArrow: "\u2192", rarr: "\u2192", rightarrow: "\u2192", srarr: "\u2192", RightArrowBar: "\u21E5", rarrb: "\u21E5", RightArrowLeftArrow: "\u21C4", rightleftarrows: "\u21C4", rlarr: "\u21C4", RightCeiling: "\u2309", rceil: "\u2309", RightDoubleBracket: "\u27E7", robrk: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", dharr: "\u21C2", downharpoonright: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rfloor: "\u230B", RightTee: "\u22A2", vdash: "\u22A2", RightTeeArrow: "\u21A6", map: "\u21A6", mapsto: "\u21A6", RightTeeVector: "\u295B", RightTriangle: "\u22B3", vartriangleright: "\u22B3", vrtri: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", rtrie: "\u22B5", trianglerighteq: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", uharr: "\u21BE", upharpoonright: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", rharu: "\u21C0", rightharpoonup: "\u21C0", RightVectorBar: "\u2953", Ropf: "\u211D", reals: "\u211D", RoundImplies: "\u2970", Rrightarrow: "\u21DB", rAarr: "\u21DB", Rscr: "\u211B", realine: "\u211B", Rsh: "\u21B1", rsh: "\u21B1", RuleDelayed: "\u29F4", SHCHcy: "\u0429", SHcy: "\u0428", SOFTcy: "\u042C", Sacute: "\u015A", Sc: "\u2ABC", Scaron: "\u0160", Scedil: "\u015E", Scirc: "\u015C", Scy: "\u0421", Sfr: "\u{1D516}", ShortUpArrow: "\u2191", UpArrow: "\u2191", uarr: "\u2191", uparrow: "\u2191", Sigma: "\u03A3", SmallCircle: "\u2218", compfn: "\u2218", Sopf: "\u{1D54A}", Sqrt: "\u221A", radic: "\u221A", Square: "\u25A1", squ: "\u25A1", square: "\u25A1", SquareIntersection: "\u2293", sqcap: "\u2293", SquareSubset: "\u228F", sqsub: "\u228F", sqsubset: "\u228F", SquareSubsetEqual: "\u2291", sqsube: "\u2291", sqsubseteq: "\u2291", SquareSuperset: "\u2290", sqsup: "\u2290", sqsupset: "\u2290", SquareSupersetEqual: "\u2292", sqsupe: "\u2292", sqsupseteq: "\u2292", SquareUnion: "\u2294", sqcup: "\u2294", Sscr: "\u{1D4AE}", Star: "\u22C6", sstarf: "\u22C6", Sub: "\u22D0", Subset: "\u22D0", SubsetEqual: "\u2286", sube: "\u2286", subseteq: "\u2286", Succeeds: "\u227B", sc: "\u227B", succ: "\u227B", SucceedsEqual: "\u2AB0", sce: "\u2AB0", succeq: "\u2AB0", SucceedsSlantEqual: "\u227D", sccue: "\u227D", succcurlyeq: "\u227D", SucceedsTilde: "\u227F", scsim: "\u227F", succsim: "\u227F", Sum: "\u2211", sum: "\u2211", Sup: "\u22D1", Supset: "\u22D1", Superset: "\u2283", sup: "\u2283", supset: "\u2283", SupersetEqual: "\u2287", supe: "\u2287", supseteq: "\u2287", THORN: "\xDE", TRADE: "\u2122", trade: "\u2122", TSHcy: "\u040B", TScy: "\u0426", Tab: "	", Tau: "\u03A4", Tcaron: "\u0164", Tcedil: "\u0162", Tcy: "\u0422", Tfr: "\u{1D517}", Therefore: "\u2234", there4: "\u2234", therefore: "\u2234", Theta: "\u0398", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", Tilde: "\u223C", sim: "\u223C", thicksim: "\u223C", thksim: "\u223C", TildeEqual: "\u2243", sime: "\u2243", simeq: "\u2243", TildeFullEqual: "\u2245", cong: "\u2245", TildeTilde: "\u2248", ap: "\u2248", approx: "\u2248", asymp: "\u2248", thickapprox: "\u2248", thkap: "\u2248", Topf: "\u{1D54B}", TripleDot: "\u20DB", tdot: "\u20DB", Tscr: "\u{1D4AF}", Tstrok: "\u0166", Uacute: "\xDA", Uarr: "\u219F", Uarrocir: "\u2949", Ubrcy: "\u040E", Ubreve: "\u016C", Ucirc: "\xDB", Ucy: "\u0423", Udblac: "\u0170", Ufr: "\u{1D518}", Ugrave: "\xD9", Umacr: "\u016A", UnderBar: "_", lowbar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", bbrk: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", bigcup: "\u22C3", xcup: "\u22C3", UnionPlus: "\u228E", uplus: "\u228E", Uogon: "\u0172", Uopf: "\u{1D54C}", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", udarr: "\u21C5", UpDownArrow: "\u2195", updownarrow: "\u2195", varr: "\u2195", UpEquilibrium: "\u296E", udhar: "\u296E", UpTee: "\u22A5", bot: "\u22A5", bottom: "\u22A5", perp: "\u22A5", UpTeeArrow: "\u21A5", mapstoup: "\u21A5", UpperLeftArrow: "\u2196", nwarr: "\u2196", nwarrow: "\u2196", UpperRightArrow: "\u2197", nearr: "\u2197", nearrow: "\u2197", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", Uring: "\u016E", Uscr: "\u{1D4B0}", Utilde: "\u0168", Uuml: "\xDC", VDash: "\u22AB", Vbar: "\u2AEB", Vcy: "\u0412", Vdash: "\u22A9", Vdashl: "\u2AE6", Vee: "\u22C1", bigvee: "\u22C1", xvee: "\u22C1", Verbar: "\u2016", Vert: "\u2016", VerticalBar: "\u2223", mid: "\u2223", shortmid: "\u2223", smid: "\u2223", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", wr: "\u2240", wreath: "\u2240", VeryThinSpace: "\u200A", hairsp: "\u200A", Vfr: "\u{1D519}", Vopf: "\u{1D54D}", Vscr: "\u{1D4B1}", Vvdash: "\u22AA", Wcirc: "\u0174", Wedge: "\u22C0", bigwedge: "\u22C0", xwedge: "\u22C0", Wfr: "\u{1D51A}", Wopf: "\u{1D54E}", Wscr: "\u{1D4B2}", Xfr: "\u{1D51B}", Xi: "\u039E", Xopf: "\u{1D54F}", Xscr: "\u{1D4B3}", YAcy: "\u042F", YIcy: "\u0407", YUcy: "\u042E", Yacute: "\xDD", Ycirc: "\u0176", Ycy: "\u042B", Yfr: "\u{1D51C}", Yopf: "\u{1D550}", Yscr: "\u{1D4B4}", Yuml: "\u0178", ZHcy: "\u0416", Zacute: "\u0179", Zcaron: "\u017D", Zcy: "\u0417", Zdot: "\u017B", Zeta: "\u0396", Zfr: "\u2128", zeetrf: "\u2128", Zopf: "\u2124", integers: "\u2124", Zscr: "\u{1D4B5}", aacute: "\xE1", abreve: "\u0103", ac: "\u223E", mstpos: "\u223E", acE: "\u223E\u0333", acd: "\u223F", acirc: "\xE2", acy: "\u0430", aelig: "\xE6", afr: "\u{1D51E}", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", amacr: "\u0101", amalg: "\u2A3F", and: "\u2227", wedge: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", angle: "\u2220", ange: "\u29A4", angmsd: "\u2221", measuredangle: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angzarr: "\u237C", aogon: "\u0105", aopf: "\u{1D552}", apE: "\u2A70", apacir: "\u2A6F", ape: "\u224A", approxeq: "\u224A", apid: "\u224B", apos: "'", aring: "\xE5", ascr: "\u{1D4B6}", ast: "*", midast: "*", atilde: "\xE3", auml: "\xE4", awint: "\u2A11", bNot: "\u2AED", backcong: "\u224C", bcong: "\u224C", backepsilon: "\u03F6", bepsi: "\u03F6", backprime: "\u2035", bprime: "\u2035", backsim: "\u223D", bsim: "\u223D", backsimeq: "\u22CD", bsime: "\u22CD", barvee: "\u22BD", barwed: "\u2305", barwedge: "\u2305", bbrktbrk: "\u23B6", bcy: "\u0431", bdquo: "\u201E", ldquor: "\u201E", bemptyv: "\u29B0", beta: "\u03B2", beth: "\u2136", between: "\u226C", twixt: "\u226C", bfr: "\u{1D51F}", bigcirc: "\u25EF", xcirc: "\u25EF", bigodot: "\u2A00", xodot: "\u2A00", bigoplus: "\u2A01", xoplus: "\u2A01", bigotimes: "\u2A02", xotime: "\u2A02", bigsqcup: "\u2A06", xsqcup: "\u2A06", bigstar: "\u2605", starf: "\u2605", bigtriangledown: "\u25BD", xdtri: "\u25BD", bigtriangleup: "\u25B3", xutri: "\u25B3", biguplus: "\u2A04", xuplus: "\u2A04", bkarow: "\u290D", rbarr: "\u290D", blacklozenge: "\u29EB", lozf: "\u29EB", blacktriangle: "\u25B4", utrif: "\u25B4", blacktriangledown: "\u25BE", dtrif: "\u25BE", blacktriangleleft: "\u25C2", ltrif: "\u25C2", blacktriangleright: "\u25B8", rtrif: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bopf: "\u{1D553}", bowtie: "\u22C8", boxDL: "\u2557", boxDR: "\u2554", boxDl: "\u2556", boxDr: "\u2553", boxH: "\u2550", boxHD: "\u2566", boxHU: "\u2569", boxHd: "\u2564", boxHu: "\u2567", boxUL: "\u255D", boxUR: "\u255A", boxUl: "\u255C", boxUr: "\u2559", boxV: "\u2551", boxVH: "\u256C", boxVL: "\u2563", boxVR: "\u2560", boxVh: "\u256B", boxVl: "\u2562", boxVr: "\u255F", boxbox: "\u29C9", boxdL: "\u2555", boxdR: "\u2552", boxdl: "\u2510", boxdr: "\u250C", boxhD: "\u2565", boxhU: "\u2568", boxhd: "\u252C", boxhu: "\u2534", boxminus: "\u229F", minusb: "\u229F", boxplus: "\u229E", plusb: "\u229E", boxtimes: "\u22A0", timesb: "\u22A0", boxuL: "\u255B", boxuR: "\u2558", boxul: "\u2518", boxur: "\u2514", boxv: "\u2502", boxvH: "\u256A", boxvL: "\u2561", boxvR: "\u255E", boxvh: "\u253C", boxvl: "\u2524", boxvr: "\u251C", brvbar: "\xA6", bscr: "\u{1D4B7}", bsemi: "\u204F", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bumpE: "\u2AAE", cacute: "\u0107", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", caps: "\u2229\uFE00", caret: "\u2041", ccaps: "\u2A4D", ccaron: "\u010D", ccedil: "\xE7", ccirc: "\u0109", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", cemptyv: "\u29B2", cent: "\xA2", cfr: "\u{1D520}", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", cir: "\u25CB", cirE: "\u29C3", circ: "\u02C6", circeq: "\u2257", cire: "\u2257", circlearrowleft: "\u21BA", olarr: "\u21BA", circlearrowright: "\u21BB", orarr: "\u21BB", circledS: "\u24C8", oS: "\u24C8", circledast: "\u229B", oast: "\u229B", circledcirc: "\u229A", ocir: "\u229A", circleddash: "\u229D", odash: "\u229D", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", clubs: "\u2663", clubsuit: "\u2663", colon: ":", comma: ",", commat: "@", comp: "\u2201", complement: "\u2201", congdot: "\u2A6D", copf: "\u{1D554}", copysr: "\u2117", crarr: "\u21B5", cross: "\u2717", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", curlyeqprec: "\u22DE", cuesc: "\u22DF", curlyeqsucc: "\u22DF", cularr: "\u21B6", curvearrowleft: "\u21B6", cularrp: "\u293D", cup: "\u222A", cupbrcap: "\u2A48", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curvearrowright: "\u21B7", curarrm: "\u293C", curlyvee: "\u22CE", cuvee: "\u22CE", curlywedge: "\u22CF", cuwed: "\u22CF", curren: "\xA4", cwint: "\u2231", cylcty: "\u232D", dHar: "\u2965", dagger: "\u2020", daleth: "\u2138", dash: "\u2010", hyphen: "\u2010", dbkarow: "\u290F", rBarr: "\u290F", dcaron: "\u010F", dcy: "\u0434", ddarr: "\u21CA", downdownarrows: "\u21CA", ddotseq: "\u2A77", eDDot: "\u2A77", deg: "\xB0", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\u{1D521}", diamondsuit: "\u2666", diams: "\u2666", digamma: "\u03DD", gammad: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", dlcorn: "\u231E", llcorner: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\u{1D555}", doteqdot: "\u2251", eDot: "\u2251", dotminus: "\u2238", minusd: "\u2238", dotplus: "\u2214", plusdo: "\u2214", dotsquare: "\u22A1", sdotb: "\u22A1", drcorn: "\u231F", lrcorner: "\u231F", drcrop: "\u230C", dscr: "\u{1D4B9}", dscy: "\u0455", dsol: "\u29F6", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", triangledown: "\u25BF", dwangle: "\u29A6", dzcy: "\u045F", dzigrarr: "\u27FF", eacute: "\xE9", easter: "\u2A6E", ecaron: "\u011B", ecir: "\u2256", eqcirc: "\u2256", ecirc: "\xEA", ecolon: "\u2255", eqcolon: "\u2255", ecy: "\u044D", edot: "\u0117", efDot: "\u2252", fallingdotseq: "\u2252", efr: "\u{1D522}", eg: "\u2A9A", egrave: "\xE8", egs: "\u2A96", eqslantgtr: "\u2A96", egsdot: "\u2A98", el: "\u2A99", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", eqslantless: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", emptyv: "\u2205", varnothing: "\u2205", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", eng: "\u014B", ensp: "\u2002", eogon: "\u0119", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", epsiv: "\u03F5", straightepsilon: "\u03F5", varepsilon: "\u03F5", equals: "=", equest: "\u225F", questeq: "\u225F", equivDD: "\u2A78", eqvparsl: "\u29E5", erDot: "\u2253", risingdotseq: "\u2253", erarr: "\u2971", escr: "\u212F", eta: "\u03B7", eth: "\xF0", euml: "\xEB", euro: "\u20AC", excl: "!", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\u{1D523}", filig: "\uFB01", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\u{1D557}", fork: "\u22D4", pitchfork: "\u22D4", forkv: "\u2AD9", fpartint: "\u2A0D", frac12: "\xBD", half: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", sfrown: "\u2322", fscr: "\u{1D4BB}", gEl: "\u2A8C", gtreqqless: "\u2A8C", gacute: "\u01F5", gamma: "\u03B3", gap: "\u2A86", gtrapprox: "\u2A86", gbreve: "\u011F", gcirc: "\u011D", gcy: "\u0433", gdot: "\u0121", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\u{1D524}", gimel: "\u2137", gjcy: "\u0453", glE: "\u2A92", gla: "\u2AA5", glj: "\u2AA4", gnE: "\u2269", gneqq: "\u2269", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gneq: "\u2A88", gnsim: "\u22E7", gopf: "\u{1D558}", gscr: "\u210A", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtrdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrarr: "\u2978", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", hardcy: "\u044A", harrcir: "\u2948", harrw: "\u21AD", leftrightsquigarrow: "\u21AD", hbar: "\u210F", hslash: "\u210F", planck: "\u210F", plankv: "\u210F", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", mldr: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", hksearow: "\u2925", searhk: "\u2925", hkswarow: "\u2926", swarhk: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", larrhk: "\u21A9", hookrightarrow: "\u21AA", rarrhk: "\u21AA", hopf: "\u{1D559}", horbar: "\u2015", hscr: "\u{1D4BD}", hstrok: "\u0127", hybull: "\u2043", iacute: "\xED", icirc: "\xEE", icy: "\u0438", iecy: "\u0435", iexcl: "\xA1", ifr: "\u{1D526}", igrave: "\xEC", iiiint: "\u2A0C", qint: "\u2A0C", iiint: "\u222D", tint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", imacr: "\u012B", imath: "\u0131", inodot: "\u0131", imof: "\u22B7", imped: "\u01B5", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", intcal: "\u22BA", intercal: "\u22BA", intlarhk: "\u2A17", intprod: "\u2A3C", iprod: "\u2A3C", iocy: "\u0451", iogon: "\u012F", iopf: "\u{1D55A}", iota: "\u03B9", iquest: "\xBF", iscr: "\u{1D4BE}", isinE: "\u22F9", isindot: "\u22F5", isins: "\u22F4", isinsv: "\u22F3", itilde: "\u0129", iukcy: "\u0456", iuml: "\xEF", jcirc: "\u0135", jcy: "\u0439", jfr: "\u{1D527}", jmath: "\u0237", jopf: "\u{1D55B}", jscr: "\u{1D4BF}", jsercy: "\u0458", jukcy: "\u0454", kappa: "\u03BA", kappav: "\u03F0", varkappa: "\u03F0", kcedil: "\u0137", kcy: "\u043A", kfr: "\u{1D528}", kgreen: "\u0138", khcy: "\u0445", kjcy: "\u045C", kopf: "\u{1D55C}", kscr: "\u{1D4C0}", lAtail: "\u291B", lBarr: "\u290E", lEg: "\u2A8B", lesseqqgtr: "\u2A8B", lHar: "\u2962", lacute: "\u013A", laemptyv: "\u29B4", lambda: "\u03BB", langd: "\u2991", lap: "\u2A85", lessapprox: "\u2A85", laquo: "\xAB", larrbfs: "\u291F", larrfs: "\u291D", larrlp: "\u21AB", looparrowleft: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", leftarrowtail: "\u21A2", lat: "\u2AAB", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", lcedil: "\u013C", lcy: "\u043B", ldca: "\u2936", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", leq: "\u2264", leftleftarrows: "\u21C7", llarr: "\u21C7", leftthreetimes: "\u22CB", lthree: "\u22CB", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessdot: "\u22D6", ltdot: "\u22D6", lfisht: "\u297C", lfr: "\u{1D529}", lgE: "\u2A91", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnE: "\u2268", lneqq: "\u2268", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lneq: "\u2A87", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", longmapsto: "\u27FC", xmap: "\u27FC", looparrowright: "\u21AC", rarrlp: "\u21AC", lopar: "\u2985", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", loz: "\u25CA", lozenge: "\u25CA", lpar: "(", lparlt: "\u2993", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", lsime: "\u2A8D", lsimg: "\u2A8F", lsquor: "\u201A", sbquo: "\u201A", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltrPar: "\u2996", ltri: "\u25C3", triangleleft: "\u25C3", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", mDDot: "\u223A", macr: "\xAF", strns: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", mdash: "\u2014", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midcir: "\u2AF0", minus: "\u2212", minusdu: "\u2A2A", mlcp: "\u2ADB", models: "\u22A7", mopf: "\u{1D55E}", mscr: "\u{1D4C2}", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nGg: "\u22D9\u0338", nGt: "\u226B\u20D2", nLeftarrow: "\u21CD", nlArr: "\u21CD", nLeftrightarrow: "\u21CE", nhArr: "\u21CE", nLl: "\u22D8\u0338", nLt: "\u226A\u20D2", nRightarrow: "\u21CF", nrArr: "\u21CF", nVDash: "\u22AF", nVdash: "\u22AE", nacute: "\u0144", nang: "\u2220\u20D2", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", natur: "\u266E", natural: "\u266E", ncap: "\u2A43", ncaron: "\u0148", ncedil: "\u0146", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", ndash: "\u2013", neArr: "\u21D7", nearhk: "\u2924", nedot: "\u2250\u0338", nesear: "\u2928", toea: "\u2928", nfr: "\u{1D52B}", nharr: "\u21AE", nleftrightarrow: "\u21AE", nhpar: "\u2AF2", nis: "\u22FC", nisd: "\u22FA", njcy: "\u045A", nlE: "\u2266\u0338", nleqq: "\u2266\u0338", nlarr: "\u219A", nleftarrow: "\u219A", nldr: "\u2025", nopf: "\u{1D55F}", not: "\xAC", notinE: "\u22F9\u0338", notindot: "\u22F5\u0338", notinvb: "\u22F7", notinvc: "\u22F6", notnivb: "\u22FE", notnivc: "\u22FD", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", nrarr: "\u219B", nrightarrow: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nscr: "\u{1D4C3}", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsubseteqq: "\u2AC5\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupseteqq: "\u2AC6\u0338", ntilde: "\xF1", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvDash: "\u22AD", nvHarr: "\u2904", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwArr: "\u21D6", nwarhk: "\u2923", nwnear: "\u2927", oacute: "\xF3", ocirc: "\xF4", ocy: "\u043E", odblac: "\u0151", odiv: "\u2A38", odsold: "\u29BC", oelig: "\u0153", ofcir: "\u29BF", ofr: "\u{1D52C}", ogon: "\u02DB", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", olcir: "\u29BE", olcross: "\u29BB", olt: "\u29C0", omacr: "\u014D", omega: "\u03C9", omicron: "\u03BF", omid: "\u29B6", oopf: "\u{1D560}", opar: "\u29B7", operp: "\u29B9", or: "\u2228", vee: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", oscr: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oslash: "\xF8", osol: "\u2298", otilde: "\xF5", otimesas: "\u2A36", ouml: "\xF6", ovbar: "\u233D", para: "\xB6", parsim: "\u2AF3", parsl: "\u2AFD", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", pertenk: "\u2031", pfr: "\u{1D52D}", phi: "\u03C6", phiv: "\u03D5", straightphi: "\u03D5", varphi: "\u03D5", phone: "\u260E", pi: "\u03C0", piv: "\u03D6", varpi: "\u03D6", planckh: "\u210E", plus: "+", plusacir: "\u2A23", pluscir: "\u2A22", plusdu: "\u2A25", pluse: "\u2A72", plussim: "\u2A26", plustwo: "\u2A27", pointint: "\u2A15", popf: "\u{1D561}", pound: "\xA3", prE: "\u2AB3", prap: "\u2AB7", precapprox: "\u2AB7", precnapprox: "\u2AB9", prnap: "\u2AB9", precneqq: "\u2AB5", prnE: "\u2AB5", precnsim: "\u22E8", prnsim: "\u22E8", prime: "\u2032", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prurel: "\u22B0", pscr: "\u{1D4C5}", psi: "\u03C8", puncsp: "\u2008", qfr: "\u{1D52E}", qopf: "\u{1D562}", qprime: "\u2057", qscr: "\u{1D4C6}", quatint: "\u2A16", quest: "?", rAtail: "\u291C", rHar: "\u2964", race: "\u223D\u0331", racute: "\u0155", raemptyv: "\u29B3", rangd: "\u2992", range: "\u29A5", raquo: "\xBB", rarrap: "\u2975", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", rightarrowtail: "\u21A3", rarrw: "\u219D", rightsquigarrow: "\u219D", ratail: "\u291A", ratio: "\u2236", rbbrk: "\u2773", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", rcedil: "\u0157", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdsh: "\u21B3", rect: "\u25AD", rfisht: "\u297D", rfr: "\u{1D52F}", rharul: "\u296C", rho: "\u03C1", rhov: "\u03F1", varrho: "\u03F1", rightrightarrows: "\u21C9", rrarr: "\u21C9", rightthreetimes: "\u22CC", rthree: "\u22CC", ring: "\u02DA", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", ropar: "\u2986", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rsaquo: "\u203A", rscr: "\u{1D4C7}", rtimes: "\u22CA", rtri: "\u25B9", triangleright: "\u25B9", rtriltri: "\u29CE", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", scE: "\u2AB4", scap: "\u2AB8", succapprox: "\u2AB8", scaron: "\u0161", scedil: "\u015F", scirc: "\u015D", scnE: "\u2AB6", succneqq: "\u2AB6", scnap: "\u2ABA", succnapprox: "\u2ABA", scnsim: "\u22E9", succnsim: "\u22E9", scpolint: "\u2A13", scy: "\u0441", sdot: "\u22C5", sdote: "\u2A66", seArr: "\u21D8", sect: "\xA7", semi: ";", seswar: "\u2929", tosa: "\u2929", sext: "\u2736", sfr: "\u{1D530}", sharp: "\u266F", shchcy: "\u0449", shcy: "\u0448", shy: "\xAD", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", varsigma: "\u03C2", simdot: "\u2A6A", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", smashp: "\u2A33", smeparsl: "\u29E4", smile: "\u2323", ssmile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", sqcaps: "\u2293\uFE00", sqcups: "\u2294\uFE00", sscr: "\u{1D4C8}", star: "\u2606", sub: "\u2282", subset: "\u2282", subE: "\u2AC5", subseteqq: "\u2AC5", subdot: "\u2ABD", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subsetneqq: "\u2ACB", subne: "\u228A", subsetneq: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supE: "\u2AC6", supseteqq: "\u2AC6", supdot: "\u2ABE", supdsub: "\u2AD8", supedot: "\u2AC4", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supsetneqq: "\u2ACC", supne: "\u228B", supsetneq: "\u228B", supplus: "\u2AC0", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swArr: "\u21D9", swnwar: "\u292A", szlig: "\xDF", target: "\u2316", tau: "\u03C4", tcaron: "\u0165", tcedil: "\u0163", tcy: "\u0442", telrec: "\u2315", tfr: "\u{1D531}", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", vartheta: "\u03D1", thorn: "\xFE", times: "\xD7", timesbar: "\u2A31", timesd: "\u2A30", topbot: "\u2336", topcir: "\u2AF1", topf: "\u{1D565}", topfork: "\u2ADA", tprime: "\u2034", triangle: "\u25B5", utri: "\u25B5", triangleq: "\u225C", trie: "\u225C", tridot: "\u25EC", triminus: "\u2A3A", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\u{1D4C9}", tscy: "\u0446", tshcy: "\u045B", tstrok: "\u0167", uHar: "\u2963", uacute: "\xFA", ubrcy: "\u045E", ubreve: "\u016D", ucirc: "\xFB", ucy: "\u0443", udblac: "\u0171", ufisht: "\u297E", ufr: "\u{1D532}", ugrave: "\xF9", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", uogon: "\u0173", uopf: "\u{1D566}", upsi: "\u03C5", upsilon: "\u03C5", upuparrows: "\u21C8", uuarr: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", urtri: "\u25F9", uscr: "\u{1D4CA}", utdot: "\u22F0", utilde: "\u0169", uuml: "\xFC", uwangle: "\u29A7", vBar: "\u2AE8", vBarv: "\u2AE9", vangrt: "\u299C", varsubsetneq: "\u228A\uFE00", vsubne: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", vsubnE: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", vsupne: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vsupnE: "\u2ACC\uFE00", vcy: "\u0432", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", vfr: "\u{1D533}", vopf: "\u{1D567}", vscr: "\u{1D4CB}", vzigzag: "\u299A", wcirc: "\u0175", wedbar: "\u2A5F", wedgeq: "\u2259", weierp: "\u2118", wp: "\u2118", wfr: "\u{1D534}", wopf: "\u{1D568}", wscr: "\u{1D4CC}", xfr: "\u{1D535}", xi: "\u03BE", xnis: "\u22FB", xopf: "\u{1D569}", xscr: "\u{1D4CD}", yacute: "\xFD", yacy: "\u044F", ycirc: "\u0177", ycy: "\u044B", yen: "\xA5", yfr: "\u{1D536}", yicy: "\u0457", yopf: "\u{1D56A}", yscr: "\u{1D4CE}", yucy: "\u044E", yuml: "\xFF", zacute: "\u017A", zcaron: "\u017E", zcy: "\u0437", zdot: "\u017C", zeta: "\u03B6", zfr: "\u{1D537}", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
var fo = "\uE500";
Ve.ngsp = fo;
var go = [/@/, /^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
function Xs(t8, e2) {
  if (e2 != null && !(Array.isArray(e2) && e2.length == 2)) throw new Error(`Expected '${t8}' to be an array, [start, end].`);
  if (e2 != null) {
    let r2 = e2[0], n2 = e2[1];
    go.forEach((s2) => {
      if (s2.test(r2) || s2.test(n2)) throw new Error(`['${r2}', '${n2}'] contains unusable interpolation symbol.`);
    });
  }
}
var $r = class t2 {
  static fromArray(e2) {
    return e2 ? (Xs("interpolation", e2), new t2(e2[0], e2[1])) : Or;
  }
  constructor(e2, r2) {
    this.start = e2, this.end = r2;
  }
};
var Or = new $r("{{", "}}");
var gt = class extends Oe {
  constructor(e2, r2, n2) {
    super(n2, e2), this.tokenType = r2;
  }
};
var Ur = class {
  constructor(e2, r2, n2) {
    this.tokens = e2, this.errors = r2, this.nonNormalizedIcuExpressions = n2;
  }
};
function li(t8, e2, r2, n2 = {}) {
  let s2 = new Wr(new ve(t8, e2), r2, n2);
  return s2.tokenize(), new Ur(Vo(s2.tokens), s2.errors, s2.nonNormalizedIcuExpressions);
}
var Io = /\r\n?/g;
function Ue(t8) {
  return `Unexpected character "${t8 === 0 ? "EOF" : String.fromCharCode(t8)}"`;
}
function ti(t8) {
  return `Unknown entity "${t8}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function Ro(t8, e2) {
  return `Unable to parse entity "${e2}" - ${t8} character reference entities must end with ";"`;
}
var rr;
(function(t8) {
  t8.HEX = "hexadecimal", t8.DEC = "decimal";
})(rr || (rr = {}));
var Ct = class {
  constructor(e2) {
    this.error = e2;
  }
};
var Wr = class {
  constructor(e2, r2, n2) {
    this._getTagContentType = r2, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = n2.tokenizeExpansionForms || false, this._interpolationConfig = n2.interpolationConfig || Or, this._leadingTriviaCodePoints = n2.leadingTriviaChars && n2.leadingTriviaChars.map((i) => i.codePointAt(0) || 0), this._canSelfClose = n2.canSelfClose || false, this._allowHtmComponentClosingTags = n2.allowHtmComponentClosingTags || false;
    let s2 = n2.range || { endPos: e2.content.length, startPos: 0, startLine: 0, startCol: 0 };
    this._cursor = n2.escapedString ? new Gr(e2, s2) : new nr(e2, s2), this._preserveLineEndings = n2.preserveLineEndings || false, this._i18nNormalizeLineEndingsInICUs = n2.i18nNormalizeLineEndingsInICUs || false, this._tokenizeBlocks = n2.tokenizeBlocks ?? true, this._tokenizeLet = n2.tokenizeLet ?? true;
    try {
      this._cursor.init();
    } catch (i) {
      this.handleError(i);
    }
  }
  _processCarriageReturns(e2) {
    return this._preserveLineEndings ? e2 : e2.replace(Io, `
`);
  }
  tokenize() {
    for (; this._cursor.peek() !== 0; ) {
      let e2 = this._cursor.clone();
      try {
        if (this._attemptCharCode(60)) if (this._attemptCharCode(33)) this._attemptStr("[CDATA[") ? this._consumeCdata(e2) : this._attemptStr("--") ? this._consumeComment(e2) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e2) : this._consumeBogusComment(e2);
        else if (this._attemptCharCode(47)) this._consumeTagClose(e2);
        else {
          let r2 = this._cursor.clone();
          this._attemptCharCode(63) ? (this._cursor = r2, this._consumeBogusComment(e2)) : this._consumeTagOpen(e2);
        }
        else this._tokenizeLet && this._cursor.peek() === 64 && !this._inInterpolation && this._attemptStr("@let") ? this._consumeLetDeclaration(e2) : this._tokenizeBlocks && this._attemptCharCode(64) ? this._consumeBlockStart(e2) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(e2) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
      } catch (r2) {
        this.handleError(r2);
      }
    }
    this._beginToken(34), this._endToken([]);
  }
  _getBlockName() {
    let e2 = false, r2 = this._cursor.clone();
    return this._attemptCharCodeUntilFn((n2) => ut(n2) ? !e2 : si(n2) ? (e2 = true, false) : true), this._cursor.getChars(r2).trim();
  }
  _consumeBlockStart(e2) {
    this._beginToken(25, e2);
    let r2 = this._endToken([this._getBlockName()]);
    if (this._cursor.peek() === 40) if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(b), this._attemptCharCode(41)) this._attemptCharCodeUntilFn(b);
    else {
      r2.type = 29;
      return;
    }
    this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : r2.type = 29;
  }
  _consumeBlockEnd(e2) {
    this._beginToken(27, e2), this._endToken([]);
  }
  _consumeBlockParameters() {
    for (this._attemptCharCodeUntilFn(ii); this._cursor.peek() !== 41 && this._cursor.peek() !== 0; ) {
      this._beginToken(28);
      let e2 = this._cursor.clone(), r2 = null, n2 = 0;
      for (; this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || r2 !== null; ) {
        let s2 = this._cursor.peek();
        if (s2 === 92) this._cursor.advance();
        else if (s2 === r2) r2 = null;
        else if (r2 === null && Ot(s2)) r2 = s2;
        else if (s2 === 40 && r2 === null) n2++;
        else if (s2 === 41 && r2 === null) {
          if (n2 === 0) break;
          n2 > 0 && n2--;
        }
        this._cursor.advance();
      }
      this._endToken([this._cursor.getChars(e2)]), this._attemptCharCodeUntilFn(ii);
    }
  }
  _consumeLetDeclaration(e2) {
    if (this._beginToken(30, e2), ut(this._cursor.peek())) this._attemptCharCodeUntilFn(b);
    else {
      let s2 = this._endToken([this._cursor.getChars(e2)]);
      s2.type = 33;
      return;
    }
    let r2 = this._endToken([this._getLetDeclarationName()]);
    if (this._attemptCharCodeUntilFn(b), !this._attemptCharCode(61)) {
      r2.type = 33;
      return;
    }
    this._attemptCharCodeUntilFn((s2) => b(s2) && !$t(s2)), this._consumeLetDeclarationValue(), this._cursor.peek() === 59 ? (this._beginToken(32), this._endToken([]), this._cursor.advance()) : (r2.type = 33, r2.sourceSpan = this._cursor.getSpan(e2));
  }
  _getLetDeclarationName() {
    let e2 = this._cursor.clone(), r2 = false;
    return this._attemptCharCodeUntilFn((n2) => lt(n2) || n2 === 36 || n2 === 95 || r2 && Rt(n2) ? (r2 = true, false) : true), this._cursor.getChars(e2).trim();
  }
  _consumeLetDeclarationValue() {
    let e2 = this._cursor.clone();
    for (this._beginToken(31, e2); this._cursor.peek() !== 0; ) {
      let r2 = this._cursor.peek();
      if (r2 === 59) break;
      Ot(r2) && (this._cursor.advance(), this._attemptCharCodeUntilFn((n2) => n2 === 92 ? (this._cursor.advance(), false) : n2 === r2)), this._cursor.advance();
    }
    this._endToken([this._cursor.getChars(e2)]);
  }
  _tokenizeExpansionForm() {
    if (this.isExpansionFormStart()) return this._consumeExpansionFormStart(), true;
    if (qo(this._cursor.peek()) && this._isInExpansionForm()) return this._consumeExpansionCaseStart(), true;
    if (this._cursor.peek() === 125) {
      if (this._isInExpansionCase()) return this._consumeExpansionCaseEnd(), true;
      if (this._isInExpansionForm()) return this._consumeExpansionFormEnd(), true;
    }
    return false;
  }
  _beginToken(e2, r2 = this._cursor.clone()) {
    this._currentTokenStart = r2, this._currentTokenType = e2;
  }
  _endToken(e2, r2) {
    if (this._currentTokenStart === null) throw new gt("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(r2));
    if (this._currentTokenType === null) throw new gt("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
    let n2 = { type: this._currentTokenType, parts: e2, sourceSpan: (r2 ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
    return this.tokens.push(n2), this._currentTokenStart = null, this._currentTokenType = null, n2;
  }
  _createError(e2, r2) {
    this._isInExpansionForm() && (e2 += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
    let n2 = new gt(e2, this._currentTokenType, r2);
    return this._currentTokenStart = null, this._currentTokenType = null, new Ct(n2);
  }
  handleError(e2) {
    if (e2 instanceof St && (e2 = this._createError(e2.msg, this._cursor.getSpan(e2.cursor))), e2 instanceof Ct) this.errors.push(e2.error);
    else throw e2;
  }
  _attemptCharCode(e2) {
    return this._cursor.peek() === e2 ? (this._cursor.advance(), true) : false;
  }
  _attemptCharCodeCaseInsensitive(e2) {
    return Ho(this._cursor.peek(), e2) ? (this._cursor.advance(), true) : false;
  }
  _requireCharCode(e2) {
    let r2 = this._cursor.clone();
    if (!this._attemptCharCode(e2)) throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r2));
  }
  _attemptStr(e2) {
    let r2 = e2.length;
    if (this._cursor.charsLeft() < r2) return false;
    let n2 = this._cursor.clone();
    for (let s2 = 0; s2 < r2; s2++) if (!this._attemptCharCode(e2.charCodeAt(s2))) return this._cursor = n2, false;
    return true;
  }
  _attemptStrCaseInsensitive(e2) {
    for (let r2 = 0; r2 < e2.length; r2++) if (!this._attemptCharCodeCaseInsensitive(e2.charCodeAt(r2))) return false;
    return true;
  }
  _requireStr(e2) {
    let r2 = this._cursor.clone();
    if (!this._attemptStr(e2)) throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r2));
  }
  _requireStrCaseInsensitive(e2) {
    let r2 = this._cursor.clone();
    if (!this._attemptStrCaseInsensitive(e2)) throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r2));
  }
  _attemptCharCodeUntilFn(e2) {
    for (; !e2(this._cursor.peek()); ) this._cursor.advance();
  }
  _requireCharCodeUntilFn(e2, r2) {
    let n2 = this._cursor.clone();
    if (this._attemptCharCodeUntilFn(e2), this._cursor.diff(n2) < r2) throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(n2));
  }
  _attemptUntilChar(e2) {
    for (; this._cursor.peek() !== e2; ) this._cursor.advance();
  }
  _readChar() {
    let e2 = String.fromCodePoint(this._cursor.peek());
    return this._cursor.advance(), e2;
  }
  _consumeEntity(e2) {
    this._beginToken(9);
    let r2 = this._cursor.clone();
    if (this._cursor.advance(), this._attemptCharCode(35)) {
      let n2 = this._attemptCharCode(120) || this._attemptCharCode(88), s2 = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Oo), this._cursor.peek() != 59) {
        this._cursor.advance();
        let a = n2 ? rr.HEX : rr.DEC;
        throw this._createError(Ro(a, this._cursor.getChars(r2)), this._cursor.getSpan());
      }
      let i = this._cursor.getChars(s2);
      this._cursor.advance();
      try {
        let a = parseInt(i, n2 ? 16 : 10);
        this._endToken([String.fromCharCode(a), this._cursor.getChars(r2)]);
      } catch {
        throw this._createError(ti(this._cursor.getChars(r2)), this._cursor.getSpan());
      }
    } else {
      let n2 = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Mo), this._cursor.peek() != 59) this._beginToken(e2, r2), this._cursor = n2, this._endToken(["&"]);
      else {
        let s2 = this._cursor.getChars(n2);
        this._cursor.advance();
        let i = Ve[s2];
        if (!i) throw this._createError(ti(s2), this._cursor.getSpan(r2));
        this._endToken([i, `&${s2};`]);
      }
    }
  }
  _consumeRawText(e2, r2) {
    this._beginToken(e2 ? 6 : 7);
    let n2 = [];
    for (; ; ) {
      let s2 = this._cursor.clone(), i = r2();
      if (this._cursor = s2, i) break;
      e2 && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(n2.join(""))]), n2.length = 0, this._consumeEntity(6), this._beginToken(6)) : n2.push(this._readChar());
    }
    this._endToken([this._processCarriageReturns(n2.join(""))]);
  }
  _consumeComment(e2) {
    this._beginToken(10, e2), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]);
  }
  _consumeBogusComment(e2) {
    this._beginToken(10, e2), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(11), this._cursor.advance(), this._endToken([]);
  }
  _consumeCdata(e2) {
    this._beginToken(12, e2), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
  }
  _consumeDocType(e2) {
    this._beginToken(18, e2), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(19), this._cursor.advance(), this._endToken([]);
  }
  _consumePrefixAndName() {
    let e2 = this._cursor.clone(), r2 = "";
    for (; this._cursor.peek() !== 58 && !$o(this._cursor.peek()); ) this._cursor.advance();
    let n2;
    this._cursor.peek() === 58 ? (r2 = this._cursor.getChars(e2), this._cursor.advance(), n2 = this._cursor.clone()) : n2 = e2, this._requireCharCodeUntilFn(ri, r2 === "" ? 0 : 1);
    let s2 = this._cursor.getChars(n2);
    return [r2, s2];
  }
  _consumeTagOpen(e2) {
    let r2, n2, s2, i = [];
    try {
      if (!lt(this._cursor.peek())) throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(e2));
      for (s2 = this._consumeTagOpenStart(e2), n2 = s2.parts[0], r2 = s2.parts[1], this._attemptCharCodeUntilFn(b); this._cursor.peek() !== 47 && this._cursor.peek() !== 62 && this._cursor.peek() !== 60 && this._cursor.peek() !== 0; ) {
        let [o2, u] = this._consumeAttributeName();
        if (this._attemptCharCodeUntilFn(b), this._attemptCharCode(61)) {
          this._attemptCharCodeUntilFn(b);
          let p = this._consumeAttributeValue();
          i.push({ prefix: o2, name: u, value: p });
        } else i.push({ prefix: o2, name: u });
        this._attemptCharCodeUntilFn(b);
      }
      this._consumeTagOpenEnd();
    } catch (o2) {
      if (o2 instanceof Ct) {
        s2 ? s2.type = 4 : (this._beginToken(5, e2), this._endToken(["<"]));
        return;
      }
      throw o2;
    }
    if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === 2) return;
    let a = this._getTagContentType(r2, n2, this._fullNameStack.length > 0, i);
    this._handleFullNameStackForTagOpen(n2, r2), a === N.RAW_TEXT ? this._consumeRawTextWithTagClose(n2, r2, false) : a === N.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(n2, r2, true);
  }
  _consumeRawTextWithTagClose(e2, r2, n2) {
    this._consumeRawText(n2, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(b), !this._attemptStrCaseInsensitive(e2 ? `${e2}:${r2}` : r2)) ? false : (this._attemptCharCodeUntilFn(b), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((s2) => s2 === 62, 3), this._cursor.advance(), this._endToken([e2, r2]), this._handleFullNameStackForTagClose(e2, r2);
  }
  _consumeTagOpenStart(e2) {
    this._beginToken(0, e2);
    let r2 = this._consumePrefixAndName();
    return this._endToken(r2);
  }
  _consumeAttributeName() {
    let e2 = this._cursor.peek();
    if (e2 === 39 || e2 === 34) throw this._createError(Ue(e2), this._cursor.getSpan());
    this._beginToken(14);
    let r2 = this._consumePrefixAndName();
    return this._endToken(r2), r2;
  }
  _consumeAttributeValue() {
    let e2;
    if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
      let r2 = this._cursor.peek();
      this._consumeQuote(r2);
      let n2 = () => this._cursor.peek() === r2;
      e2 = this._consumeWithInterpolation(16, 17, n2, n2), this._consumeQuote(r2);
    } else {
      let r2 = () => ri(this._cursor.peek());
      e2 = this._consumeWithInterpolation(16, 17, r2, r2);
    }
    return e2;
  }
  _consumeQuote(e2) {
    this._beginToken(15), this._requireCharCode(e2), this._endToken([String.fromCodePoint(e2)]);
  }
  _consumeTagOpenEnd() {
    let e2 = this._attemptCharCode(47) ? 2 : 1;
    this._beginToken(e2), this._requireCharCode(62), this._endToken([]);
  }
  _consumeTagClose(e2) {
    if (this._beginToken(3, e2), this._attemptCharCodeUntilFn(b), this._allowHtmComponentClosingTags && this._attemptCharCode(47)) this._attemptCharCodeUntilFn(b), this._requireCharCode(62), this._endToken([]);
    else {
      let [r2, n2] = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(b), this._requireCharCode(62), this._endToken([r2, n2]), this._handleFullNameStackForTagClose(r2, n2);
    }
  }
  _consumeExpansionFormStart() {
    this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
    let e2 = this._readUntil(44), r2 = this._processCarriageReturns(e2);
    if (this._i18nNormalizeLineEndingsInICUs) this._endToken([r2]);
    else {
      let s2 = this._endToken([e2]);
      r2 !== e2 && this.nonNormalizedIcuExpressions.push(s2);
    }
    this._requireCharCode(44), this._attemptCharCodeUntilFn(b), this._beginToken(7);
    let n2 = this._readUntil(44);
    this._endToken([n2]), this._requireCharCode(44), this._attemptCharCodeUntilFn(b);
  }
  _consumeExpansionCaseStart() {
    this._beginToken(21);
    let e2 = this._readUntil(123).trim();
    this._endToken([e2]), this._attemptCharCodeUntilFn(b), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(b), this._expansionCaseStack.push(22);
  }
  _consumeExpansionCaseEnd() {
    this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(b), this._expansionCaseStack.pop();
  }
  _consumeExpansionFormEnd() {
    this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
  }
  _consumeWithInterpolation(e2, r2, n2, s2) {
    this._beginToken(e2);
    let i = [];
    for (; !n2(); ) {
      let o2 = this._cursor.clone();
      this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(i.join(""))], o2), i.length = 0, this._consumeInterpolation(r2, o2, s2), this._beginToken(e2)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(i.join(""))]), i.length = 0, this._consumeEntity(e2), this._beginToken(e2)) : i.push(this._readChar());
    }
    this._inInterpolation = false;
    let a = this._processCarriageReturns(i.join(""));
    return this._endToken([a]), a;
  }
  _consumeInterpolation(e2, r2, n2) {
    let s2 = [];
    this._beginToken(e2, r2), s2.push(this._interpolationConfig.start);
    let i = this._cursor.clone(), a = null, o2 = false;
    for (; this._cursor.peek() !== 0 && (n2 === null || !n2()); ) {
      let u = this._cursor.clone();
      if (this._isTagStart()) {
        this._cursor = u, s2.push(this._getProcessedChars(i, u)), this._endToken(s2);
        return;
      }
      if (a === null) if (this._attemptStr(this._interpolationConfig.end)) {
        s2.push(this._getProcessedChars(i, u)), s2.push(this._interpolationConfig.end), this._endToken(s2);
        return;
      } else this._attemptStr("//") && (o2 = true);
      let p = this._cursor.peek();
      this._cursor.advance(), p === 92 ? this._cursor.advance() : p === a ? a = null : !o2 && a === null && Ot(p) && (a = p);
    }
    s2.push(this._getProcessedChars(i, this._cursor)), this._endToken(s2);
  }
  _getProcessedChars(e2, r2) {
    return this._processCarriageReturns(r2.getChars(e2));
  }
  _isTextEnd() {
    return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._cursor.peek() === 64 || this._cursor.peek() === 125));
  }
  _isTagStart() {
    if (this._cursor.peek() === 60) {
      let e2 = this._cursor.clone();
      e2.advance();
      let r2 = e2.peek();
      if (97 <= r2 && r2 <= 122 || 65 <= r2 && r2 <= 90 || r2 === 47 || r2 === 33) return true;
    }
    return false;
  }
  _isBlockStart() {
    if (this._tokenizeBlocks && this._cursor.peek() === 64) {
      let e2 = this._cursor.clone();
      if (e2.advance(), si(e2.peek())) return true;
    }
    return false;
  }
  _readUntil(e2) {
    let r2 = this._cursor.clone();
    return this._attemptUntilChar(e2), this._cursor.getChars(r2);
  }
  _isInExpansion() {
    return this._isInExpansionCase() || this._isInExpansionForm();
  }
  _isInExpansionCase() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 22;
  }
  _isInExpansionForm() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 20;
  }
  isExpansionFormStart() {
    if (this._cursor.peek() !== 123) return false;
    if (this._interpolationConfig) {
      let e2 = this._cursor.clone(), r2 = this._attemptStr(this._interpolationConfig.start);
      return this._cursor = e2, !r2;
    }
    return true;
  }
  _handleFullNameStackForTagOpen(e2, r2) {
    let n2 = qe(e2, r2);
    (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === n2) && this._fullNameStack.push(n2);
  }
  _handleFullNameStackForTagClose(e2, r2) {
    let n2 = qe(e2, r2);
    this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === n2 && this._fullNameStack.pop();
  }
};
function b(t8) {
  return !ut(t8) || t8 === 0;
}
function ri(t8) {
  return ut(t8) || t8 === 62 || t8 === 60 || t8 === 47 || t8 === 39 || t8 === 34 || t8 === 61 || t8 === 0;
}
function $o(t8) {
  return (t8 < 97 || 122 < t8) && (t8 < 65 || 90 < t8) && (t8 < 48 || t8 > 57);
}
function Oo(t8) {
  return t8 === 59 || t8 === 0 || !Rs(t8);
}
function Mo(t8) {
  return t8 === 59 || t8 === 0 || !lt(t8);
}
function qo(t8) {
  return t8 !== 125;
}
function Ho(t8, e2) {
  return ni(t8) === ni(e2);
}
function ni(t8) {
  return t8 >= 97 && t8 <= 122 ? t8 - 97 + 65 : t8;
}
function si(t8) {
  return lt(t8) || Rt(t8) || t8 === 95;
}
function ii(t8) {
  return t8 !== 59 && b(t8);
}
function Vo(t8) {
  let e2 = [], r2;
  for (let n2 = 0; n2 < t8.length; n2++) {
    let s2 = t8[n2];
    r2 && r2.type === 5 && s2.type === 5 || r2 && r2.type === 16 && s2.type === 16 ? (r2.parts[0] += s2.parts[0], r2.sourceSpan.end = s2.sourceSpan.end) : (r2 = s2, e2.push(r2));
  }
  return e2;
}
var nr = class t3 {
  constructor(e2, r2) {
    if (e2 instanceof t3) {
      this.file = e2.file, this.input = e2.input, this.end = e2.end;
      let n2 = e2.state;
      this.state = { peek: n2.peek, offset: n2.offset, line: n2.line, column: n2.column };
    } else {
      if (!r2) throw new Error("Programming error: the range argument must be provided with a file argument.");
      this.file = e2, this.input = e2.content, this.end = r2.endPos, this.state = { peek: -1, offset: r2.startPos, line: r2.startLine, column: r2.startCol };
    }
  }
  clone() {
    return new t3(this);
  }
  peek() {
    return this.state.peek;
  }
  charsLeft() {
    return this.end - this.state.offset;
  }
  diff(e2) {
    return this.state.offset - e2.state.offset;
  }
  advance() {
    this.advanceState(this.state);
  }
  init() {
    this.updatePeek(this.state);
  }
  getSpan(e2, r2) {
    e2 = e2 || this;
    let n2 = e2;
    if (r2) for (; this.diff(e2) > 0 && r2.indexOf(e2.peek()) !== -1; ) n2 === e2 && (e2 = e2.clone()), e2.advance();
    let s2 = this.locationFromCursor(e2), i = this.locationFromCursor(this), a = n2 !== e2 ? this.locationFromCursor(n2) : s2;
    return new h(s2, i, a);
  }
  getChars(e2) {
    return this.input.substring(e2.state.offset, this.state.offset);
  }
  charAt(e2) {
    return this.input.charCodeAt(e2);
  }
  advanceState(e2) {
    if (e2.offset >= this.end) throw this.state = e2, new St('Unexpected character "EOF"', this);
    let r2 = this.charAt(e2.offset);
    r2 === 10 ? (e2.line++, e2.column = 0) : $t(r2) || e2.column++, e2.offset++, this.updatePeek(e2);
  }
  updatePeek(e2) {
    e2.peek = e2.offset >= this.end ? 0 : this.charAt(e2.offset);
  }
  locationFromCursor(e2) {
    return new ie(e2.file, e2.state.offset, e2.state.line, e2.state.column);
  }
};
var Gr = class t4 extends nr {
  constructor(e2, r2) {
    e2 instanceof t4 ? (super(e2), this.internalState = { ...e2.internalState }) : (super(e2, r2), this.internalState = this.state);
  }
  advance() {
    this.state = this.internalState, super.advance(), this.processEscapeSequence();
  }
  init() {
    super.init(), this.processEscapeSequence();
  }
  clone() {
    return new t4(this);
  }
  getChars(e2) {
    let r2 = e2.clone(), n2 = "";
    for (; r2.internalState.offset < this.internalState.offset; ) n2 += String.fromCodePoint(r2.peek()), r2.advance();
    return n2;
  }
  processEscapeSequence() {
    let e2 = () => this.internalState.peek;
    if (e2() === 92) if (this.internalState = { ...this.state }, this.advanceState(this.internalState), e2() === 110) this.state.peek = 10;
    else if (e2() === 114) this.state.peek = 13;
    else if (e2() === 118) this.state.peek = 11;
    else if (e2() === 116) this.state.peek = 9;
    else if (e2() === 98) this.state.peek = 8;
    else if (e2() === 102) this.state.peek = 12;
    else if (e2() === 117) if (this.advanceState(this.internalState), e2() === 123) {
      this.advanceState(this.internalState);
      let r2 = this.clone(), n2 = 0;
      for (; e2() !== 125; ) this.advanceState(this.internalState), n2++;
      this.state.peek = this.decodeHexDigits(r2, n2);
    } else {
      let r2 = this.clone();
      this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r2, 4);
    }
    else if (e2() === 120) {
      this.advanceState(this.internalState);
      let r2 = this.clone();
      this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r2, 2);
    } else if (Br(e2())) {
      let r2 = "", n2 = 0, s2 = this.clone();
      for (; Br(e2()) && n2 < 3; ) s2 = this.clone(), r2 += String.fromCodePoint(e2()), this.advanceState(this.internalState), n2++;
      this.state.peek = parseInt(r2, 8), this.internalState = s2.internalState;
    } else $t(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
  }
  decodeHexDigits(e2, r2) {
    let n2 = this.input.slice(e2.internalState.offset, e2.internalState.offset + r2), s2 = parseInt(n2, 16);
    if (isNaN(s2)) throw e2.state = e2.internalState, new St("Invalid hexadecimal escape sequence", e2);
    return s2;
  }
};
var St = class {
  constructor(e2, r2) {
    this.msg = e2, this.cursor = r2;
  }
};
var L = class t5 extends Oe {
  static create(e2, r2, n2) {
    return new t5(e2, r2, n2);
  }
  constructor(e2, r2, n2) {
    super(r2, n2), this.elementName = e2;
  }
};
var jr = class {
  constructor(e2, r2) {
    this.rootNodes = e2, this.errors = r2;
  }
};
var sr = class {
  constructor(e2) {
    this.getTagDefinition = e2;
  }
  parse(e2, r2, n2, s2 = false, i) {
    let a = (D) => (I3, ...F) => D(I3.toLowerCase(), ...F), o2 = s2 ? this.getTagDefinition : a(this.getTagDefinition), u = (D) => o2(D).getContentType(), p = s2 ? i : a(i), m = li(e2, r2, i ? (D, I3, F, c2) => {
      let g2 = p(D, I3, F, c2);
      return g2 !== void 0 ? g2 : u(D);
    } : u, n2), f = n2 && n2.canSelfClose || false, C = n2 && n2.allowHtmComponentClosingTags || false, A = new Kr(m.tokens, o2, f, C, s2);
    return A.build(), new jr(A.rootNodes, m.errors.concat(A.errors));
  }
};
var Kr = class t6 {
  constructor(e2, r2, n2, s2, i) {
    this.tokens = e2, this.getTagDefinition = r2, this.canSelfClose = n2, this.allowHtmComponentClosingTags = s2, this.isTagNameCaseSensitive = i, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
  }
  build() {
    for (; this._peek.type !== 34; ) this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 20 ? this._consumeExpansion(this._advance()) : this._peek.type === 25 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 27 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 30 ? (this._closeVoidElement(), this._consumeLet(this._advance())) : this._peek.type === 18 ? this._consumeDocType(this._advance()) : this._peek.type === 33 ? (this._closeVoidElement(), this._consumeIncompleteLet(this._advance())) : this._advance();
    for (let e2 of this._containerStack) e2 instanceof ee && this.errors.push(L.create(e2.name, e2.sourceSpan, `Unclosed block "${e2.name}"`));
  }
  _advance() {
    let e2 = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e2;
  }
  _advanceIf(e2) {
    return this._peek.type === e2 ? this._advance() : null;
  }
  _consumeCdata(e2) {
    let r2 = this._advance(), n2 = this._getText(r2), s2 = this._advanceIf(13);
    this._addToParent(new Gt(n2, new h(e2.sourceSpan.start, (s2 || r2).sourceSpan.end), [r2]));
  }
  _consumeComment(e2) {
    let r2 = this._advanceIf(7), n2 = this._advanceIf(11), s2 = r2 != null ? r2.parts[0].trim() : null, i = n2 == null ? e2.sourceSpan : new h(e2.sourceSpan.start, n2.sourceSpan.end, e2.sourceSpan.fullStart);
    this._addToParent(new Kt(s2, i));
  }
  _consumeDocType(e2) {
    let r2 = this._advanceIf(7), n2 = this._advanceIf(19), s2 = r2 != null ? r2.parts[0].trim() : null, i = new h(e2.sourceSpan.start, (n2 || r2 || e2).sourceSpan.end);
    this._addToParent(new Xt(s2, i));
  }
  _consumeExpansion(e2) {
    let r2 = this._advance(), n2 = this._advance(), s2 = [];
    for (; this._peek.type === 21; ) {
      let a = this._parseExpansionCase();
      if (!a) return;
      s2.push(a);
    }
    if (this._peek.type !== 24) {
      this.errors.push(L.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      return;
    }
    let i = new h(e2.sourceSpan.start, this._peek.sourceSpan.end, e2.sourceSpan.fullStart);
    this._addToParent(new zt(r2.parts[0], n2.parts[0], s2, i, r2.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    let e2 = this._advance();
    if (this._peek.type !== 22) return this.errors.push(L.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    let r2 = this._advance(), n2 = this._collectExpansionExpTokens(r2);
    if (!n2) return null;
    let s2 = this._advance();
    n2.push({ type: 34, parts: [], sourceSpan: s2.sourceSpan });
    let i = new t6(n2, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
    if (i.build(), i.errors.length > 0) return this.errors = this.errors.concat(i.errors), null;
    let a = new h(e2.sourceSpan.start, s2.sourceSpan.end, e2.sourceSpan.fullStart), o2 = new h(r2.sourceSpan.start, s2.sourceSpan.end, r2.sourceSpan.fullStart);
    return new Yt(e2.parts[0], i.rootNodes, a, e2.sourceSpan, o2);
  }
  _collectExpansionExpTokens(e2) {
    let r2 = [], n2 = [22];
    for (; ; ) {
      if ((this._peek.type === 20 || this._peek.type === 22) && n2.push(this._peek.type), this._peek.type === 23) if (ci(n2, 22)) {
        if (n2.pop(), n2.length === 0) return r2;
      } else return this.errors.push(L.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 24) if (ci(n2, 20)) n2.pop();
      else return this.errors.push(L.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 34) return this.errors.push(L.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      r2.push(this._advance());
    }
  }
  _getText(e2) {
    let r2 = e2.parts[0];
    if (r2.length > 0 && r2[0] == `
`) {
      let n2 = this._getClosestParentElement();
      n2 != null && n2.children.length == 0 && this.getTagDefinition(n2.name).ignoreFirstLf && (r2 = r2.substring(1));
    }
    return r2;
  }
  _consumeText(e2) {
    let r2 = [e2], n2 = e2.sourceSpan, s2 = e2.parts[0];
    if (s2.length > 0 && s2[0] === `
`) {
      let i = this._getContainer();
      i != null && i.children.length === 0 && this.getTagDefinition(i.name).ignoreFirstLf && (s2 = s2.substring(1), r2[0] = { type: e2.type, sourceSpan: e2.sourceSpan, parts: [s2] });
    }
    for (; this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9; ) e2 = this._advance(), r2.push(e2), e2.type === 8 ? s2 += e2.parts.join("").replace(/&([^;]+);/g, pi) : e2.type === 9 ? s2 += e2.parts[0] : s2 += e2.parts.join("");
    if (s2.length > 0) {
      let i = e2.sourceSpan;
      this._addToParent(new Wt(s2, new h(n2.start, i.end, n2.fullStart, n2.details), r2));
    }
  }
  _closeVoidElement() {
    let e2 = this._getContainer();
    e2 instanceof Y && this.getTagDefinition(e2.name).isVoid && this._containerStack.pop();
  }
  _consumeStartTag(e2) {
    let [r2, n2] = e2.parts, s2 = [];
    for (; this._peek.type === 14; ) s2.push(this._consumeAttr(this._advance()));
    let i = this._getElementFullName(r2, n2, this._getClosestParentElement()), a = false;
    if (this._peek.type === 2) {
      this._advance(), a = true;
      let C = this.getTagDefinition(i);
      this.canSelfClose || C.canSelfClose || Me(i) !== null || C.isVoid || this.errors.push(L.create(i, e2.sourceSpan, `Only void, custom and foreign elements can be self closed "${e2.parts[1]}"`));
    } else this._peek.type === 1 && (this._advance(), a = false);
    let o2 = this._peek.sourceSpan.fullStart, u = new h(e2.sourceSpan.start, o2, e2.sourceSpan.fullStart), p = new h(e2.sourceSpan.start, o2, e2.sourceSpan.fullStart), l2 = new h(e2.sourceSpan.start.moveBy(1), e2.sourceSpan.end), m = new Y(i, s2, [], u, p, void 0, l2), f = this._getContainer();
    this._pushContainer(m, f instanceof Y && this.getTagDefinition(f.name).isClosedByChild(m.name)), a ? this._popContainer(i, Y, u) : e2.type === 4 && (this._popContainer(i, Y, null), this.errors.push(L.create(i, u, `Opening tag "${i}" not terminated.`)));
  }
  _pushContainer(e2, r2) {
    r2 && this._containerStack.pop(), this._addToParent(e2), this._containerStack.push(e2);
  }
  _consumeEndTag(e2) {
    let r2 = this.allowHtmComponentClosingTags && e2.parts.length === 0 ? null : this._getElementFullName(e2.parts[0], e2.parts[1], this._getClosestParentElement());
    if (r2 && this.getTagDefinition(r2).isVoid) this.errors.push(L.create(r2, e2.sourceSpan, `Void elements do not have end tags "${e2.parts[1]}"`));
    else if (!this._popContainer(r2, Y, e2.sourceSpan)) {
      let n2 = `Unexpected closing tag "${r2}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this.errors.push(L.create(r2, e2.sourceSpan, n2));
    }
  }
  _popContainer(e2, r2, n2) {
    let s2 = false;
    for (let i = this._containerStack.length - 1; i >= 0; i--) {
      let a = this._containerStack[i];
      if (Me(a.name) ? a.name === e2 : (e2 == null || a.name.toLowerCase() === e2.toLowerCase()) && a instanceof r2) return a.endSourceSpan = n2, a.sourceSpan.end = n2 !== null ? n2.end : a.sourceSpan.end, this._containerStack.splice(i, this._containerStack.length - i), !s2;
      (a instanceof ee || a instanceof Y && !this.getTagDefinition(a.name).closedByParent) && (s2 = true);
    }
    return false;
  }
  _consumeAttr(e2) {
    let r2 = qe(e2.parts[0], e2.parts[1]), n2 = e2.sourceSpan.end, s2;
    this._peek.type === 15 && (s2 = this._advance());
    let i = "", a = [], o2, u;
    if (this._peek.type === 16) for (o2 = this._peek.sourceSpan, u = this._peek.sourceSpan.end; this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9; ) {
      let m = this._advance();
      a.push(m), m.type === 17 ? i += m.parts.join("").replace(/&([^;]+);/g, pi) : m.type === 9 ? i += m.parts[0] : i += m.parts.join(""), u = n2 = m.sourceSpan.end;
    }
    this._peek.type === 15 && (u = n2 = this._advance().sourceSpan.end);
    let l2 = o2 && u && new h((s2 == null ? void 0 : s2.sourceSpan.start) ?? o2.start, u, (s2 == null ? void 0 : s2.sourceSpan.fullStart) ?? o2.fullStart);
    return new jt(r2, i, new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), e2.sourceSpan, l2, a.length > 0 ? a : void 0, void 0);
  }
  _consumeBlockOpen(e2) {
    let r2 = [];
    for (; this._peek.type === 28; ) {
      let o2 = this._advance();
      r2.push(new ht(o2.parts[0], o2.sourceSpan));
    }
    this._peek.type === 26 && this._advance();
    let n2 = this._peek.sourceSpan.fullStart, s2 = new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), i = new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), a = new ee(e2.parts[0], r2, [], s2, e2.sourceSpan, i);
    this._pushContainer(a, false);
  }
  _consumeBlockClose(e2) {
    this._popContainer(null, ee, e2.sourceSpan) || this.errors.push(L.create(null, e2.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
  }
  _consumeIncompleteBlock(e2) {
    let r2 = [];
    for (; this._peek.type === 28; ) {
      let o2 = this._advance();
      r2.push(new ht(o2.parts[0], o2.sourceSpan));
    }
    let n2 = this._peek.sourceSpan.fullStart, s2 = new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), i = new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), a = new ee(e2.parts[0], r2, [], s2, e2.sourceSpan, i);
    this._pushContainer(a, false), this._popContainer(null, ee, null), this.errors.push(L.create(e2.parts[0], s2, `Incomplete block "${e2.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
  }
  _consumeLet(e2) {
    let r2 = e2.parts[0], n2, s2;
    if (this._peek.type !== 31) {
      this.errors.push(L.create(e2.parts[0], e2.sourceSpan, `Invalid @let declaration "${r2}". Declaration must have a value.`));
      return;
    } else n2 = this._advance();
    if (this._peek.type !== 32) {
      this.errors.push(L.create(e2.parts[0], e2.sourceSpan, `Unterminated @let declaration "${r2}". Declaration must be terminated with a semicolon.`));
      return;
    } else s2 = this._advance();
    let i = s2.sourceSpan.fullStart, a = new h(e2.sourceSpan.start, i, e2.sourceSpan.fullStart), o2 = e2.sourceSpan.toString().lastIndexOf(r2), u = e2.sourceSpan.start.moveBy(o2), p = new h(u, e2.sourceSpan.end), l2 = new mt(r2, n2.parts[0], a, p, n2.sourceSpan);
    this._addToParent(l2);
  }
  _consumeIncompleteLet(e2) {
    let r2 = e2.parts[0] ?? "", n2 = r2 ? ` "${r2}"` : "";
    if (r2.length > 0) {
      let s2 = e2.sourceSpan.toString().lastIndexOf(r2), i = e2.sourceSpan.start.moveBy(s2), a = new h(i, e2.sourceSpan.end), o2 = new h(e2.sourceSpan.start, e2.sourceSpan.start.moveBy(0)), u = new mt(r2, "", e2.sourceSpan, a, o2);
      this._addToParent(u);
    }
    this.errors.push(L.create(e2.parts[0], e2.sourceSpan, `Incomplete @let declaration${n2}. @let declarations must be written as \`@let <name> = <value>;\``));
  }
  _getContainer() {
    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
  }
  _getClosestParentElement() {
    for (let e2 = this._containerStack.length - 1; e2 > -1; e2--) if (this._containerStack[e2] instanceof Y) return this._containerStack[e2];
    return null;
  }
  _addToParent(e2) {
    let r2 = this._getContainer();
    r2 === null ? this.rootNodes.push(e2) : r2.children.push(e2);
  }
  _getElementFullName(e2, r2, n2) {
    if (e2 === "" && (e2 = this.getTagDefinition(r2).implicitNamespacePrefix || "", e2 === "" && n2 != null)) {
      let s2 = ct(n2.name)[1];
      this.getTagDefinition(s2).preventNamespaceInheritance || (e2 = Me(n2.name));
    }
    return qe(e2, r2);
  }
};
function ci(t8, e2) {
  return t8.length > 0 && t8[t8.length - 1] === e2;
}
function pi(t8, e2) {
  return Ve[e2] !== void 0 ? Ve[e2] || t8 : /^#x[a-f0-9]+$/i.test(e2) ? String.fromCodePoint(parseInt(e2.slice(2), 16)) : /^#\d+$/.test(e2) ? String.fromCodePoint(parseInt(e2.slice(1), 10)) : t8;
}
var ir = class extends sr {
  constructor() {
    super(He);
  }
  parse(e2, r2, n2, s2 = false, i) {
    return super.parse(e2, r2, n2, s2, i);
  }
};
var Xr = null;
var Uo = () => (Xr || (Xr = new ir()), Xr);
function Qr(t8, e2 = {}) {
  let { canSelfClose: r2 = false, allowHtmComponentClosingTags: n2 = false, isTagNameCaseSensitive: s2 = false, getTagContentType: i, tokenizeAngularBlocks: a = false, tokenizeAngularLetDeclaration: o2 = false } = e2;
  return Uo().parse(t8, "angular-html-parser", { tokenizeExpansionForms: a, interpolationConfig: void 0, canSelfClose: r2, allowHtmComponentClosingTags: n2, tokenizeBlocks: a, tokenizeLet: o2 }, s2, i);
}
function Wo(t8, e2) {
  let r2 = new SyntaxError(t8 + " (" + e2.loc.start.line + ":" + e2.loc.start.column + ")");
  return Object.assign(r2, e2);
}
var hi = Wo;
var _t = 3;
function Go(t8) {
  let e2 = t8.slice(0, _t);
  if (e2 !== "---" && e2 !== "+++") return;
  let r2 = t8.indexOf(`
`, _t);
  if (r2 === -1) return;
  let n2 = t8.slice(_t, r2).trim(), s2 = t8.indexOf(`
${e2}`, r2), i = n2;
  if (i || (i = e2 === "+++" ? "toml" : "yaml"), s2 === -1 && e2 === "---" && i === "yaml" && (s2 = t8.indexOf(`
...`, r2)), s2 === -1) return;
  let a = s2 + 1 + _t, o2 = t8.charAt(a + 1);
  if (!/\s?/u.test(o2)) return;
  let u = t8.slice(0, a);
  return { type: "front-matter", language: i, explicitLanguage: n2, value: t8.slice(r2 + 1, s2), startDelimiter: e2, endDelimiter: u.slice(-_t), raw: u };
}
function zo(t8) {
  let e2 = Go(t8);
  if (!e2) return { content: t8 };
  let { raw: r2 } = e2;
  return { frontMatter: e2, content: w(false, r2, /[^\n]/gu, " ") + t8.slice(r2.length) };
}
var mi = zo;
var ar = { attrs: true, children: true, cases: true, expression: true };
var fi = /* @__PURE__ */ new Set(["parent"]);
var le;
var Jr;
var Zr;
var Ge = class Ge2 {
  constructor(e2 = {}) {
    At(this, le);
    lr(this, "type");
    lr(this, "parent");
    for (let r2 of /* @__PURE__ */ new Set([...fi, ...Object.keys(e2)])) this.setProperty(r2, e2[r2]);
  }
  setProperty(e2, r2) {
    if (this[e2] !== r2) {
      if (e2 in ar && (r2 = r2.map((n2) => this.createChild(n2))), !fi.has(e2)) {
        this[e2] = r2;
        return;
      }
      Object.defineProperty(this, e2, { value: r2, enumerable: false, configurable: true });
    }
  }
  map(e2) {
    let r2;
    for (let n2 in ar) {
      let s2 = this[n2];
      if (s2) {
        let i = Yo(s2, (a) => a.map(e2));
        r2 !== s2 && (r2 || (r2 = new Ge2({ parent: this.parent })), r2.setProperty(n2, i));
      }
    }
    if (r2) for (let n2 in this) n2 in ar || (r2[n2] = this[n2]);
    return e2(r2 || this);
  }
  walk(e2) {
    for (let r2 in ar) {
      let n2 = this[r2];
      if (n2) for (let s2 = 0; s2 < n2.length; s2++) n2[s2].walk(e2);
    }
    e2(this);
  }
  createChild(e2) {
    let r2 = e2 instanceof Ge2 ? e2.clone() : new Ge2(e2);
    return r2.setProperty("parent", this), r2;
  }
  insertChildBefore(e2, r2) {
    let n2 = this.$children;
    n2.splice(n2.indexOf(e2), 0, this.createChild(r2));
  }
  removeChild(e2) {
    let r2 = this.$children;
    r2.splice(r2.indexOf(e2), 1);
  }
  replaceChild(e2, r2) {
    let n2 = this.$children;
    n2[n2.indexOf(e2)] = this.createChild(r2);
  }
  clone() {
    return new Ge2(this);
  }
  get $children() {
    return this[R(this, le, Jr)];
  }
  set $children(e2) {
    this[R(this, le, Jr)] = e2;
  }
  get firstChild() {
    var e2;
    return (e2 = this.$children) == null ? void 0 : e2[0];
  }
  get lastChild() {
    return K(true, this.$children, -1);
  }
  get prev() {
    let e2 = R(this, le, Zr);
    return e2[e2.indexOf(this) - 1];
  }
  get next() {
    let e2 = R(this, le, Zr);
    return e2[e2.indexOf(this) + 1];
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
  get attrMap() {
    return Object.fromEntries(this.attrs.map((e2) => [e2.fullName, e2.value]));
  }
};
le = /* @__PURE__ */ new WeakSet(), Jr = function() {
  return this.type === "angularIcuCase" ? "expression" : this.type === "angularIcuExpression" ? "cases" : "children";
}, Zr = function() {
  var e2;
  return ((e2 = this.parent) == null ? void 0 : e2.$children) ?? [];
};
var or = Ge;
function Yo(t8, e2) {
  let r2 = t8.map(e2);
  return r2.some((n2, s2) => n2 !== t8[s2]) ? r2 : t8;
}
var jo = [{ regex: /^(\[if([^\]]*)\]>)(.*?)<!\s*\[endif\]$/su, parse: Ko }, { regex: /^\[if([^\]]*)\]><!$/u, parse: Xo }, { regex: /^<!\s*\[endif\]$/u, parse: Qo }];
function di(t8, e2) {
  if (t8.value) for (let { regex: r2, parse: n2 } of jo) {
    let s2 = t8.value.match(r2);
    if (s2) return n2(t8, e2, s2);
  }
  return null;
}
function Ko(t8, e2, r2) {
  let [, n2, s2, i] = r2, a = 4 + n2.length, o2 = t8.sourceSpan.start.moveBy(a), u = o2.moveBy(i.length), [p, l2] = (() => {
    try {
      return [true, e2(i, o2).children];
    } catch {
      return [false, [{ type: "text", value: i, sourceSpan: new h(o2, u) }]];
    }
  })();
  return { type: "ieConditionalComment", complete: p, children: l2, condition: w(false, s2.trim(), /\s+/gu, " "), sourceSpan: t8.sourceSpan, startSourceSpan: new h(t8.sourceSpan.start, o2), endSourceSpan: new h(u, t8.sourceSpan.end) };
}
function Xo(t8, e2, r2) {
  let [, n2] = r2;
  return { type: "ieConditionalStartComment", condition: w(false, n2.trim(), /\s+/gu, " "), sourceSpan: t8.sourceSpan };
}
function Qo(t8) {
  return { type: "ieConditionalEndComment", sourceSpan: t8.sourceSpan };
}
var ur = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set(["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate", "writingsuggestions"])], ["a", /* @__PURE__ */ new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])], ["applet", /* @__PURE__ */ new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])], ["area", /* @__PURE__ */ new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])], ["audio", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])], ["base", /* @__PURE__ */ new Set(["href", "target"])], ["basefont", /* @__PURE__ */ new Set(["color", "face", "size"])], ["blockquote", /* @__PURE__ */ new Set(["cite"])], ["body", /* @__PURE__ */ new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])], ["br", /* @__PURE__ */ new Set(["clear"])], ["button", /* @__PURE__ */ new Set(["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])], ["canvas", /* @__PURE__ */ new Set(["height", "width"])], ["caption", /* @__PURE__ */ new Set(["align"])], ["col", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["colgroup", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["data", /* @__PURE__ */ new Set(["value"])], ["del", /* @__PURE__ */ new Set(["cite", "datetime"])], ["details", /* @__PURE__ */ new Set(["name", "open"])], ["dialog", /* @__PURE__ */ new Set(["open"])], ["dir", /* @__PURE__ */ new Set(["compact"])], ["div", /* @__PURE__ */ new Set(["align"])], ["dl", /* @__PURE__ */ new Set(["compact"])], ["embed", /* @__PURE__ */ new Set(["height", "src", "type", "width"])], ["fieldset", /* @__PURE__ */ new Set(["disabled", "form", "name"])], ["font", /* @__PURE__ */ new Set(["color", "face", "size"])], ["form", /* @__PURE__ */ new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])], ["frame", /* @__PURE__ */ new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])], ["frameset", /* @__PURE__ */ new Set(["cols", "rows"])], ["h1", /* @__PURE__ */ new Set(["align"])], ["h2", /* @__PURE__ */ new Set(["align"])], ["h3", /* @__PURE__ */ new Set(["align"])], ["h4", /* @__PURE__ */ new Set(["align"])], ["h5", /* @__PURE__ */ new Set(["align"])], ["h6", /* @__PURE__ */ new Set(["align"])], ["head", /* @__PURE__ */ new Set(["profile"])], ["hr", /* @__PURE__ */ new Set(["align", "noshade", "size", "width"])], ["html", /* @__PURE__ */ new Set(["manifest", "version"])], ["iframe", /* @__PURE__ */ new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])], ["img", /* @__PURE__ */ new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])], ["input", /* @__PURE__ */ new Set(["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])], ["ins", /* @__PURE__ */ new Set(["cite", "datetime"])], ["isindex", /* @__PURE__ */ new Set(["prompt"])], ["label", /* @__PURE__ */ new Set(["for", "form"])], ["legend", /* @__PURE__ */ new Set(["align"])], ["li", /* @__PURE__ */ new Set(["type", "value"])], ["link", /* @__PURE__ */ new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])], ["map", /* @__PURE__ */ new Set(["name"])], ["menu", /* @__PURE__ */ new Set(["compact"])], ["meta", /* @__PURE__ */ new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])], ["meter", /* @__PURE__ */ new Set(["high", "low", "max", "min", "optimum", "value"])], ["object", /* @__PURE__ */ new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])], ["ol", /* @__PURE__ */ new Set(["compact", "reversed", "start", "type"])], ["optgroup", /* @__PURE__ */ new Set(["disabled", "label"])], ["option", /* @__PURE__ */ new Set(["disabled", "label", "selected", "value"])], ["output", /* @__PURE__ */ new Set(["for", "form", "name"])], ["p", /* @__PURE__ */ new Set(["align"])], ["param", /* @__PURE__ */ new Set(["name", "type", "value", "valuetype"])], ["pre", /* @__PURE__ */ new Set(["width"])], ["progress", /* @__PURE__ */ new Set(["max", "value"])], ["q", /* @__PURE__ */ new Set(["cite"])], ["script", /* @__PURE__ */ new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])], ["select", /* @__PURE__ */ new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])], ["slot", /* @__PURE__ */ new Set(["name"])], ["source", /* @__PURE__ */ new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])], ["style", /* @__PURE__ */ new Set(["blocking", "media", "type"])], ["table", /* @__PURE__ */ new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])], ["tbody", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["td", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["template", /* @__PURE__ */ new Set(["shadowrootclonable", "shadowrootdelegatesfocus", "shadowrootmode"])], ["textarea", /* @__PURE__ */ new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])], ["tfoot", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["th", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["thead", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["time", /* @__PURE__ */ new Set(["datetime"])], ["tr", /* @__PURE__ */ new Set(["align", "bgcolor", "char", "charoff", "valign"])], ["track", /* @__PURE__ */ new Set(["default", "kind", "label", "src", "srclang"])], ["ul", /* @__PURE__ */ new Set(["compact", "type"])], ["video", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])]]);
var gi = /* @__PURE__ */ new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
function Jo(t8) {
  if (t8.type === "block") {
    if (t8.name = w(false, t8.name.toLowerCase(), /\s+/gu, " ").trim(), t8.type = "angularControlFlowBlock", !me(t8.parameters)) {
      delete t8.parameters;
      return;
    }
    for (let e2 of t8.parameters) e2.type = "angularControlFlowBlockParameter";
    t8.parameters = { type: "angularControlFlowBlockParameters", children: t8.parameters, sourceSpan: new h(t8.parameters[0].sourceSpan.start, K(false, t8.parameters, -1).sourceSpan.end) };
  }
}
function Zo(t8) {
  t8.type === "letDeclaration" && (t8.type = "angularLetDeclaration", t8.id = t8.name, t8.init = { type: "angularLetDeclarationInitializer", sourceSpan: new h(t8.valueSpan.start, t8.valueSpan.end), value: t8.value }, delete t8.name, delete t8.value);
}
function eu(t8) {
  (t8.type === "plural" || t8.type === "select") && (t8.clause = t8.type, t8.type = "angularIcuExpression"), t8.type === "expansionCase" && (t8.type = "angularIcuCase");
}
function Si(t8, e2, r2) {
  let { name: n2, canSelfClose: s2 = true, normalizeTagName: i = false, normalizeAttributeName: a = false, allowHtmComponentClosingTags: o2 = false, isTagNameCaseSensitive: u = false, shouldParseAsRawText: p } = e2, { rootNodes: l2, errors: m } = Qr(t8, { canSelfClose: s2, allowHtmComponentClosingTags: o2, isTagNameCaseSensitive: u, getTagContentType: p ? (...c2) => p(...c2) ? N.RAW_TEXT : void 0 : void 0, tokenizeAngularBlocks: n2 === "angular" ? true : void 0, tokenizeAngularLetDeclaration: n2 === "angular" ? true : void 0 });
  if (n2 === "vue") {
    if (l2.some((x) => x.type === "docType" && x.value === "html" || x.type === "element" && x.name.toLowerCase() === "html")) return Si(t8, en, r2);
    let g2, y2 = () => g2 ?? (g2 = Qr(t8, { canSelfClose: s2, allowHtmComponentClosingTags: o2, isTagNameCaseSensitive: u })), q2 = (x) => y2().rootNodes.find(({ startSourceSpan: U2 }) => U2 && U2.start.offset === x.startSourceSpan.start.offset) ?? x;
    for (let [x, U2] of l2.entries()) {
      let { endSourceSpan: nn3, startSourceSpan: Ei2 } = U2;
      if (nn3 === null) m = y2().errors, l2[x] = q2(U2);
      else if (tu(U2, r2)) {
        let sn3 = y2().errors.find((an3) => an3.span.start.offset > Ei2.start.offset && an3.span.start.offset < nn3.end.offset);
        sn3 && Ci(sn3), l2[x] = q2(U2);
      }
    }
  }
  m.length > 0 && Ci(m[0]);
  let f = (c2) => {
    let g2 = c2.name.startsWith(":") ? c2.name.slice(1).split(":")[0] : null, y2 = c2.nameSpan.toString(), q2 = g2 !== null && y2.startsWith(`${g2}:`), x = q2 ? y2.slice(g2.length + 1) : y2;
    c2.name = x, c2.namespace = g2, c2.hasExplicitNamespace = q2;
  }, C = (c2) => {
    switch (c2.type) {
      case "element":
        f(c2);
        for (let g2 of c2.attrs) f(g2), g2.valueSpan ? (g2.value = g2.valueSpan.toString(), /["']/u.test(g2.value[0]) && (g2.value = g2.value.slice(1, -1))) : g2.value = null;
        break;
      case "comment":
        c2.value = c2.sourceSpan.toString().slice(4, -3);
        break;
      case "text":
        c2.value = c2.sourceSpan.toString();
        break;
    }
  }, A = (c2, g2) => {
    let y2 = c2.toLowerCase();
    return g2(y2) ? y2 : c2;
  }, D = (c2) => {
    if (c2.type === "element" && (i && (!c2.namespace || c2.namespace === c2.tagDefinition.implicitNamespacePrefix || fe(c2)) && (c2.name = A(c2.name, (g2) => gi.has(g2))), a)) for (let g2 of c2.attrs) g2.namespace || (g2.name = A(g2.name, (y2) => ur.has(c2.name) && (ur.get("*").has(y2) || ur.get(c2.name).has(y2))));
  }, I3 = (c2) => {
    c2.sourceSpan && c2.endSourceSpan && (c2.sourceSpan = new h(c2.sourceSpan.start, c2.endSourceSpan.end));
  }, F = (c2) => {
    if (c2.type === "element") {
      let g2 = He(u ? c2.name : c2.name.toLowerCase());
      !c2.namespace || c2.namespace === g2.implicitNamespacePrefix || fe(c2) ? c2.tagDefinition = g2 : c2.tagDefinition = He("");
    }
  };
  return Qt(new class extends ft {
    visitExpansionCase(c2, g2) {
      n2 === "angular" && this.visitChildren(g2, (y2) => {
        y2(c2.expression);
      });
    }
    visit(c2) {
      C(c2), F(c2), D(c2), I3(c2);
    }
  }(), l2), l2;
}
function tu(t8, e2) {
  var n2;
  if (t8.type !== "element" || t8.name !== "template") return false;
  let r2 = (n2 = t8.attrs.find((s2) => s2.name === "lang")) == null ? void 0 : n2.value;
  return !r2 || Ne(e2, { language: r2 }) === "html";
}
function Ci(t8) {
  let { msg: e2, span: { start: r2, end: n2 } } = t8;
  throw hi(e2, { loc: { start: { line: r2.line + 1, column: r2.col + 1 }, end: { line: n2.line + 1, column: n2.col + 1 } }, cause: t8 });
}
function _i(t8, e2, r2 = {}, n2 = true) {
  let { frontMatter: s2, content: i } = n2 ? mi(t8) : { frontMatter: null, content: t8 }, a = new ve(t8, r2.filepath), o2 = new ie(a, 0, 0, 0), u = o2.moveBy(t8.length), p = { type: "root", sourceSpan: new h(o2, u), children: Si(i, e2, r2) };
  if (s2) {
    let f = new ie(a, 0, 0, 0), C = f.moveBy(s2.raw.length);
    s2.sourceSpan = new h(f, C), p.children.unshift(s2);
  }
  let l2 = new or(p), m = (f, C) => {
    let { offset: A } = C, D = w(false, t8.slice(0, A), /[^\n\r]/gu, " "), F = _i(D + f, e2, r2, false);
    F.sourceSpan = new h(C, K(false, F.children, -1).sourceSpan.end);
    let c2 = F.children[0];
    return c2.length === A ? F.children.shift() : (c2.sourceSpan = new h(c2.sourceSpan.start.moveBy(A), c2.sourceSpan.end), c2.value = c2.value.slice(A)), F;
  };
  return l2.walk((f) => {
    if (f.type === "comment") {
      let C = di(f, m);
      C && f.parent.replaceChild(f, C);
    }
    Jo(f), Zo(f), eu(f);
  }), l2;
}
function Et(t8) {
  return { parse: (e2, r2) => _i(e2, t8, r2), hasPragma: ws, hasIgnorePragma: bs, astFormat: "html", locStart: J, locEnd: se };
}
var en = { name: "html", normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true };
var ru = Et(en);
var nu = /* @__PURE__ */ new Set(["mj-style", "mj-raw"]);
var su = Et({ ...en, name: "mjml", shouldParseAsRawText: (t8) => nu.has(t8) });
var iu = Et({ name: "angular" });
var au = Et({ name: "vue", isTagNameCaseSensitive: true, shouldParseAsRawText(t8, e2, r2, n2) {
  return t8.toLowerCase() !== "html" && !r2 && (t8 !== "template" || n2.some(({ name: s2, value: i }) => s2 === "lang" && i !== "html" && i !== "" && i !== void 0));
} });
var ou = Et({ name: "lwc", canSelfClose: false });
var uu = { html: qs };
var ym = rn;

// node_modules/prettier/standalone.mjs
var Fu = Object.create;
var pt2 = Object.defineProperty;
var pu = Object.getOwnPropertyDescriptor;
var du = Object.getOwnPropertyNames;
var mu = Object.getPrototypeOf;
var Eu = Object.prototype.hasOwnProperty;
var er = (e2) => {
  throw TypeError(e2);
};
var Cu = (e2, t8) => () => (t8 || e2((t8 = { exports: {} }).exports, t8), t8.exports);
var dt = (e2, t8) => {
  for (var r2 in t8) pt2(e2, r2, { get: t8[r2], enumerable: true });
};
var hu = (e2, t8, r2, n2) => {
  if (t8 && typeof t8 == "object" || typeof t8 == "function") for (let u of du(t8)) !Eu.call(e2, u) && u !== r2 && pt2(e2, u, { get: () => t8[u], enumerable: !(n2 = pu(t8, u)) || n2.enumerable });
  return e2;
};
var gu = (e2, t8, r2) => (r2 = e2 != null ? Fu(mu(e2)) : {}, hu(t8 || !e2 || !e2.__esModule ? pt2(r2, "default", { value: e2, enumerable: true }) : r2, e2));
var yu = (e2, t8, r2) => t8.has(e2) || er("Cannot " + r2);
var tr = (e2, t8, r2) => t8.has(e2) ? er("Cannot add the same private member more than once") : t8 instanceof WeakSet ? t8.add(e2) : t8.set(e2, r2);
var fe2 = (e2, t8, r2) => (yu(e2, t8, "access private method"), r2);
var Pn2 = Cu((Mt3) => {
  "use strict";
  Object.defineProperty(Mt3, "__esModule", { value: true });
  function Co2() {
    return new Proxy({}, { get: () => (e2) => e2 });
  }
  var On3 = /\r\n|[\n\r\u2028\u2029]/;
  function ho3(e2, t8, r2) {
    let n2 = Object.assign({ column: 0, line: -1 }, e2.start), u = Object.assign({}, n2, e2.end), { linesAbove: o2 = 2, linesBelow: i = 3 } = r2 || {}, s2 = n2.line, a = n2.column, c2 = u.line, D = u.column, p = Math.max(s2 - (o2 + 1), 0), l2 = Math.min(t8.length, c2 + i);
    s2 === -1 && (p = 0), c2 === -1 && (l2 = t8.length);
    let F = c2 - s2, f = {};
    if (F) for (let d2 = 0; d2 <= F; d2++) {
      let m = d2 + s2;
      if (!a) f[m] = true;
      else if (d2 === 0) {
        let C = t8[m - 1].length;
        f[m] = [a, C - a + 1];
      } else if (d2 === F) f[m] = [0, D];
      else {
        let C = t8[m - d2].length;
        f[m] = [0, C];
      }
    }
    else a === D ? a ? f[s2] = [a, 0] : f[s2] = true : f[s2] = [a, D - a];
    return { start: p, end: l2, markerLines: f };
  }
  function go3(e2, t8, r2 = {}) {
    let u = Co2(false), o2 = e2.split(On3), { start: i, end: s2, markerLines: a } = ho3(t8, o2, r2), c2 = t8.start && typeof t8.start.column == "number", D = String(s2).length, l2 = e2.split(On3, s2).slice(i, s2).map((F, f) => {
      let d2 = i + 1 + f, C = ` ${` ${d2}`.slice(-D)} |`, E2 = a[d2], h2 = !a[d2 + 1];
      if (E2) {
        let x = "";
        if (Array.isArray(E2)) {
          let A = F.slice(0, Math.max(E2[0] - 1, 0)).replace(/[^\t]/g, " "), $2 = E2[1] || 1;
          x = [`
 `, u.gutter(C.replace(/\d/g, " ")), " ", A, u.marker("^").repeat($2)].join(""), h2 && r2.message && (x += " " + u.message(r2.message));
        }
        return [u.marker(">"), u.gutter(C), F.length > 0 ? ` ${F}` : "", x].join("");
      } else return ` ${u.gutter(C)}${F.length > 0 ? ` ${F}` : ""}`;
    }).join(`
`);
    return r2.message && !c2 && (l2 = `${" ".repeat(D + 1)}${r2.message}
${l2}`), l2;
  }
  Mt3.codeFrameColumns = go3;
});
var Zt = {};
dt(Zt, { __debug: () => ui, check: () => ri2, doc: () => qt2, format: () => fu, formatWithCursor: () => cu, getSupportInfo: () => ni2, util: () => Qt2, version: () => tu2 });
var Au = (e2, t8, r2, n2) => {
  if (!(e2 && t8 == null)) return t8.replaceAll ? t8.replaceAll(r2, n2) : r2.global ? t8.replace(r2, n2) : t8.split(r2).join(n2);
};
var te = Au;
var _e2 = class {
  diff(t8, r2, n2 = {}) {
    let u;
    typeof n2 == "function" ? (u = n2, n2 = {}) : "callback" in n2 && (u = n2.callback);
    let o2 = this.castInput(t8, n2), i = this.castInput(r2, n2), s2 = this.removeEmpty(this.tokenize(o2, n2)), a = this.removeEmpty(this.tokenize(i, n2));
    return this.diffWithOptionsObj(s2, a, n2, u);
  }
  diffWithOptionsObj(t8, r2, n2, u) {
    var o2;
    let i = (E2) => {
      if (E2 = this.postProcess(E2, n2), u) {
        setTimeout(function() {
          u(E2);
        }, 0);
        return;
      } else return E2;
    }, s2 = r2.length, a = t8.length, c2 = 1, D = s2 + a;
    n2.maxEditLength != null && (D = Math.min(D, n2.maxEditLength));
    let p = (o2 = n2.timeout) !== null && o2 !== void 0 ? o2 : 1 / 0, l2 = Date.now() + p, F = [{ oldPos: -1, lastComponent: void 0 }], f = this.extractCommon(F[0], r2, t8, 0, n2);
    if (F[0].oldPos + 1 >= a && f + 1 >= s2) return i(this.buildValues(F[0].lastComponent, r2, t8));
    let d2 = -1 / 0, m = 1 / 0, C = () => {
      for (let E2 = Math.max(d2, -c2); E2 <= Math.min(m, c2); E2 += 2) {
        let h2, x = F[E2 - 1], A = F[E2 + 1];
        x && (F[E2 - 1] = void 0);
        let $2 = false;
        if (A) {
          let Be3 = A.oldPos - E2;
          $2 = A && 0 <= Be3 && Be3 < s2;
        }
        let ue = x && x.oldPos + 1 < a;
        if (!$2 && !ue) {
          F[E2] = void 0;
          continue;
        }
        if (!ue || $2 && x.oldPos < A.oldPos ? h2 = this.addToPath(A, true, false, 0, n2) : h2 = this.addToPath(x, false, true, 1, n2), f = this.extractCommon(h2, r2, t8, E2, n2), h2.oldPos + 1 >= a && f + 1 >= s2) return i(this.buildValues(h2.lastComponent, r2, t8)) || true;
        F[E2] = h2, h2.oldPos + 1 >= a && (m = Math.min(m, E2 - 1)), f + 1 >= s2 && (d2 = Math.max(d2, E2 + 1));
      }
      c2++;
    };
    if (u) (function E2() {
      setTimeout(function() {
        if (c2 > D || Date.now() > l2) return u(void 0);
        C() || E2();
      }, 0);
    })();
    else for (; c2 <= D && Date.now() <= l2; ) {
      let E2 = C();
      if (E2) return E2;
    }
  }
  addToPath(t8, r2, n2, u, o2) {
    let i = t8.lastComponent;
    return i && !o2.oneChangePerToken && i.added === r2 && i.removed === n2 ? { oldPos: t8.oldPos + u, lastComponent: { count: i.count + 1, added: r2, removed: n2, previousComponent: i.previousComponent } } : { oldPos: t8.oldPos + u, lastComponent: { count: 1, added: r2, removed: n2, previousComponent: i } };
  }
  extractCommon(t8, r2, n2, u, o2) {
    let i = r2.length, s2 = n2.length, a = t8.oldPos, c2 = a - u, D = 0;
    for (; c2 + 1 < i && a + 1 < s2 && this.equals(n2[a + 1], r2[c2 + 1], o2); ) c2++, a++, D++, o2.oneChangePerToken && (t8.lastComponent = { count: 1, previousComponent: t8.lastComponent, added: false, removed: false });
    return D && !o2.oneChangePerToken && (t8.lastComponent = { count: D, previousComponent: t8.lastComponent, added: false, removed: false }), t8.oldPos = a, c2;
  }
  equals(t8, r2, n2) {
    return n2.comparator ? n2.comparator(t8, r2) : t8 === r2 || !!n2.ignoreCase && t8.toLowerCase() === r2.toLowerCase();
  }
  removeEmpty(t8) {
    let r2 = [];
    for (let n2 = 0; n2 < t8.length; n2++) t8[n2] && r2.push(t8[n2]);
    return r2;
  }
  castInput(t8, r2) {
    return t8;
  }
  tokenize(t8, r2) {
    return Array.from(t8);
  }
  join(t8) {
    return t8.join("");
  }
  postProcess(t8, r2) {
    return t8;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(t8, r2, n2) {
    let u = [], o2;
    for (; t8; ) u.push(t8), o2 = t8.previousComponent, delete t8.previousComponent, t8 = o2;
    u.reverse();
    let i = u.length, s2 = 0, a = 0, c2 = 0;
    for (; s2 < i; s2++) {
      let D = u[s2];
      if (D.removed) D.value = this.join(n2.slice(c2, c2 + D.count)), c2 += D.count;
      else {
        if (!D.added && this.useLongestToken) {
          let p = r2.slice(a, a + D.count);
          p = p.map(function(l2, F) {
            let f = n2[c2 + F];
            return f.length > l2.length ? f : l2;
          }), D.value = this.join(p);
        } else D.value = this.join(r2.slice(a, a + D.count));
        a += D.count, D.added || (c2 += D.count);
      }
    }
    return u;
  }
};
var mt2 = class extends _e2 {
  tokenize(t8) {
    return t8.slice();
  }
  join(t8) {
    return t8;
  }
  removeEmpty(t8) {
    return t8;
  }
};
var rr2 = new mt2();
function Et2(e2, t8, r2) {
  return rr2.diff(e2, t8, r2);
}
function nr2(e2) {
  let t8 = e2.indexOf("\r");
  return t8 !== -1 ? e2.charAt(t8 + 1) === `
` ? "crlf" : "cr" : "lf";
}
function xe2(e2) {
  switch (e2) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function Ct2(e2, t8) {
  let r2;
  switch (t8) {
    case `
`:
      r2 = /\n/gu;
      break;
    case "\r":
      r2 = /\r/gu;
      break;
    case `\r
`:
      r2 = /\r\n/gu;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t8)}.`);
  }
  let n2 = e2.match(r2);
  return n2 ? n2.length : 0;
}
function ur2(e2) {
  return te(false, e2, /\r\n?/gu, `
`);
}
var W2 = "string";
var Y2 = "array";
var j2 = "cursor";
var N2 = "indent";
var O2 = "align";
var P2 = "trim";
var B2 = "group";
var k2 = "fill";
var _2 = "if-break";
var v2 = "indent-if-break";
var L2 = "line-suffix";
var I = "line-suffix-boundary";
var g = "line";
var S2 = "label";
var w2 = "break-parent";
var Ue2 = /* @__PURE__ */ new Set([j2, N2, O2, P2, B2, k2, _2, v2, L2, I, g, S2, w2]);
var Bu = (e2, t8, r2) => {
  if (!(e2 && t8 == null)) return Array.isArray(t8) || typeof t8 == "string" ? t8[r2 < 0 ? t8.length + r2 : r2] : t8.at(r2);
};
var y = Bu;
function or2(e2) {
  let t8 = e2.length;
  for (; t8 > 0 && (e2[t8 - 1] === "\r" || e2[t8 - 1] === `
`); ) t8--;
  return t8 < e2.length ? e2.slice(0, t8) : e2;
}
function _u(e2) {
  if (typeof e2 == "string") return W2;
  if (Array.isArray(e2)) return Y2;
  if (!e2) return;
  let { type: t8 } = e2;
  if (Ue2.has(t8)) return t8;
}
var M = _u;
var xu = (e2) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e2);
function wu(e2) {
  let t8 = e2 === null ? "null" : typeof e2;
  if (t8 !== "string" && t8 !== "object") return `Unexpected doc '${t8}', 
Expected it to be 'string' or 'object'.`;
  if (M(e2)) throw new Error("doc is valid.");
  let r2 = Object.prototype.toString.call(e2);
  if (r2 !== "[object Object]") return `Unexpected doc '${r2}'.`;
  let n2 = xu([...Ue2].map((u) => `'${u}'`));
  return `Unexpected doc.type '${e2.type}'.
Expected it to be ${n2}.`;
}
var ht2 = class extends Error {
  name = "InvalidDocError";
  constructor(t8) {
    super(wu(t8)), this.doc = t8;
  }
};
var q = ht2;
var ir2 = {};
function bu(e2, t8, r2, n2) {
  let u = [e2];
  for (; u.length > 0; ) {
    let o2 = u.pop();
    if (o2 === ir2) {
      r2(u.pop());
      continue;
    }
    r2 && u.push(o2, ir2);
    let i = M(o2);
    if (!i) throw new q(o2);
    if ((t8 == null ? void 0 : t8(o2)) !== false) switch (i) {
      case Y2:
      case k2: {
        let s2 = i === Y2 ? o2 : o2.parts;
        for (let a = s2.length, c2 = a - 1; c2 >= 0; --c2) u.push(s2[c2]);
        break;
      }
      case _2:
        u.push(o2.flatContents, o2.breakContents);
        break;
      case B2:
        if (n2 && o2.expandedStates) for (let s2 = o2.expandedStates.length, a = s2 - 1; a >= 0; --a) u.push(o2.expandedStates[a]);
        else u.push(o2.contents);
        break;
      case O2:
      case N2:
      case v2:
      case S2:
      case L2:
        u.push(o2.contents);
        break;
      case W2:
      case j2:
      case P2:
      case I:
      case g:
      case w2:
        break;
      default:
        throw new q(o2);
    }
  }
}
var le2 = bu;
function be2(e2, t8) {
  if (typeof e2 == "string") return t8(e2);
  let r2 = /* @__PURE__ */ new Map();
  return n2(e2);
  function n2(o2) {
    if (r2.has(o2)) return r2.get(o2);
    let i = u(o2);
    return r2.set(o2, i), i;
  }
  function u(o2) {
    switch (M(o2)) {
      case Y2:
        return t8(o2.map(n2));
      case k2:
        return t8({ ...o2, parts: o2.parts.map(n2) });
      case _2:
        return t8({ ...o2, breakContents: n2(o2.breakContents), flatContents: n2(o2.flatContents) });
      case B2: {
        let { expandedStates: i, contents: s2 } = o2;
        return i ? (i = i.map(n2), s2 = i[0]) : s2 = n2(s2), t8({ ...o2, contents: s2, expandedStates: i });
      }
      case O2:
      case N2:
      case v2:
      case S2:
      case L2:
        return t8({ ...o2, contents: n2(o2.contents) });
      case W2:
      case j2:
      case P2:
      case I:
      case g:
      case w2:
        return t8(o2);
      default:
        throw new q(o2);
    }
  }
}
function Ve2(e2, t8, r2) {
  let n2 = r2, u = false;
  function o2(i) {
    if (u) return false;
    let s2 = t8(i);
    s2 !== void 0 && (u = true, n2 = s2);
  }
  return le2(e2, o2), n2;
}
function ku(e2) {
  if (e2.type === B2 && e2.break || e2.type === g && e2.hard || e2.type === w2) return true;
}
function Dr2(e2) {
  return Ve2(e2, ku, false);
}
function sr2(e2) {
  if (e2.length > 0) {
    let t8 = y(false, e2, -1);
    !t8.expandedStates && !t8.break && (t8.break = "propagated");
  }
  return null;
}
function cr2(e2) {
  let t8 = /* @__PURE__ */ new Set(), r2 = [];
  function n2(o2) {
    if (o2.type === w2 && sr2(r2), o2.type === B2) {
      if (r2.push(o2), t8.has(o2)) return false;
      t8.add(o2);
    }
  }
  function u(o2) {
    o2.type === B2 && r2.pop().break && sr2(r2);
  }
  le2(e2, n2, u, true);
}
function Su(e2) {
  return e2.type === g && !e2.hard ? e2.soft ? "" : " " : e2.type === _2 ? e2.flatContents : e2;
}
function fr2(e2) {
  return be2(e2, Su);
}
function ar2(e2) {
  for (e2 = [...e2]; e2.length >= 2 && y(false, e2, -2).type === g && y(false, e2, -1).type === w2; ) e2.length -= 2;
  if (e2.length > 0) {
    let t8 = we2(y(false, e2, -1));
    e2[e2.length - 1] = t8;
  }
  return e2;
}
function we2(e2) {
  switch (M(e2)) {
    case N2:
    case v2:
    case B2:
    case L2:
    case S2: {
      let t8 = we2(e2.contents);
      return { ...e2, contents: t8 };
    }
    case _2:
      return { ...e2, breakContents: we2(e2.breakContents), flatContents: we2(e2.flatContents) };
    case k2:
      return { ...e2, parts: ar2(e2.parts) };
    case Y2:
      return ar2(e2);
    case W2:
      return or2(e2);
    case O2:
    case j2:
    case P2:
    case I:
    case g:
    case w2:
      break;
    default:
      throw new q(e2);
  }
  return e2;
}
function $e(e2) {
  return we2(Nu(e2));
}
function Tu(e2) {
  switch (M(e2)) {
    case k2:
      if (e2.parts.every((t8) => t8 === "")) return "";
      break;
    case B2:
      if (!e2.contents && !e2.id && !e2.break && !e2.expandedStates) return "";
      if (e2.contents.type === B2 && e2.contents.id === e2.id && e2.contents.break === e2.break && e2.contents.expandedStates === e2.expandedStates) return e2.contents;
      break;
    case O2:
    case N2:
    case v2:
    case L2:
      if (!e2.contents) return "";
      break;
    case _2:
      if (!e2.flatContents && !e2.breakContents) return "";
      break;
    case Y2: {
      let t8 = [];
      for (let r2 of e2) {
        if (!r2) continue;
        let [n2, ...u] = Array.isArray(r2) ? r2 : [r2];
        typeof n2 == "string" && typeof y(false, t8, -1) == "string" ? t8[t8.length - 1] += n2 : t8.push(n2), t8.push(...u);
      }
      return t8.length === 0 ? "" : t8.length === 1 ? t8[0] : t8;
    }
    case W2:
    case j2:
    case P2:
    case I:
    case g:
    case S2:
    case w2:
      break;
    default:
      throw new q(e2);
  }
  return e2;
}
function Nu(e2) {
  return be2(e2, (t8) => Tu(t8));
}
function lr2(e2, t8 = We) {
  return be2(e2, (r2) => typeof r2 == "string" ? ke2(t8, r2.split(`
`)) : r2);
}
function Ou(e2) {
  if (e2.type === g) return true;
}
function Fr2(e2) {
  return Ve2(e2, Ou, false);
}
function Fe2(e2, t8) {
  return e2.type === S2 ? { ...e2, contents: t8(e2.contents) } : t8(e2);
}
var gt2 = () => {
};
var K2 = gt2;
var yt2 = gt2;
var pr2 = gt2;
function ie2(e2) {
  return K2(e2), { type: N2, contents: e2 };
}
function oe(e2, t8) {
  return K2(t8), { type: O2, contents: t8, n: e2 };
}
function At2(e2, t8 = {}) {
  return K2(e2), yt2(t8.expandedStates, true), { type: B2, id: t8.id, contents: e2, break: !!t8.shouldBreak, expandedStates: t8.expandedStates };
}
function dr2(e2) {
  return oe(Number.NEGATIVE_INFINITY, e2);
}
function mr2(e2) {
  return oe({ type: "root" }, e2);
}
function Er2(e2) {
  return oe(-1, e2);
}
function Cr2(e2, t8) {
  return At2(e2[0], { ...t8, expandedStates: e2 });
}
function hr2(e2) {
  return pr2(e2), { type: k2, parts: e2 };
}
function gr2(e2, t8 = "", r2 = {}) {
  return K2(e2), t8 !== "" && K2(t8), { type: _2, breakContents: e2, flatContents: t8, groupId: r2.groupId };
}
function yr2(e2, t8) {
  return K2(e2), { type: v2, contents: e2, groupId: t8.groupId, negate: t8.negate };
}
function Se2(e2) {
  return K2(e2), { type: L2, contents: e2 };
}
var Ar2 = { type: I };
var pe2 = { type: w2 };
var Br2 = { type: P2 };
var Te2 = { type: g, hard: true };
var Bt2 = { type: g, hard: true, literal: true };
var Me2 = { type: g };
var _r2 = { type: g, soft: true };
var z2 = [Te2, pe2];
var We = [Bt2, pe2];
var X2 = { type: j2 };
function ke2(e2, t8) {
  K2(e2), yt2(t8);
  let r2 = [];
  for (let n2 = 0; n2 < t8.length; n2++) n2 !== 0 && r2.push(e2), r2.push(t8[n2]);
  return r2;
}
function Ge3(e2, t8, r2) {
  K2(e2);
  let n2 = e2;
  if (t8 > 0) {
    for (let u = 0; u < Math.floor(t8 / r2); ++u) n2 = ie2(n2);
    n2 = oe(t8 % r2, n2), n2 = oe(Number.NEGATIVE_INFINITY, n2);
  }
  return n2;
}
function xr2(e2, t8) {
  return K2(t8), e2 ? { type: S2, label: e2, contents: t8 } : t8;
}
function Q2(e2) {
  var t8;
  if (!e2) return "";
  if (Array.isArray(e2)) {
    let r2 = [];
    for (let n2 of e2) if (Array.isArray(n2)) r2.push(...Q2(n2));
    else {
      let u = Q2(n2);
      u !== "" && r2.push(u);
    }
    return r2;
  }
  return e2.type === _2 ? { ...e2, breakContents: Q2(e2.breakContents), flatContents: Q2(e2.flatContents) } : e2.type === B2 ? { ...e2, contents: Q2(e2.contents), expandedStates: (t8 = e2.expandedStates) == null ? void 0 : t8.map(Q2) } : e2.type === k2 ? { type: "fill", parts: e2.parts.map(Q2) } : e2.contents ? { ...e2, contents: Q2(e2.contents) } : e2;
}
function wr2(e2) {
  let t8 = /* @__PURE__ */ Object.create(null), r2 = /* @__PURE__ */ new Set();
  return n2(Q2(e2));
  function n2(o2, i, s2) {
    var a, c2;
    if (typeof o2 == "string") return JSON.stringify(o2);
    if (Array.isArray(o2)) {
      let D = o2.map(n2).filter(Boolean);
      return D.length === 1 ? D[0] : `[${D.join(", ")}]`;
    }
    if (o2.type === g) {
      let D = ((a = s2 == null ? void 0 : s2[i + 1]) == null ? void 0 : a.type) === w2;
      return o2.literal ? D ? "literalline" : "literallineWithoutBreakParent" : o2.hard ? D ? "hardline" : "hardlineWithoutBreakParent" : o2.soft ? "softline" : "line";
    }
    if (o2.type === w2) return ((c2 = s2 == null ? void 0 : s2[i - 1]) == null ? void 0 : c2.type) === g && s2[i - 1].hard ? void 0 : "breakParent";
    if (o2.type === P2) return "trim";
    if (o2.type === N2) return "indent(" + n2(o2.contents) + ")";
    if (o2.type === O2) return o2.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n2(o2.contents) + ")" : o2.n < 0 ? "dedent(" + n2(o2.contents) + ")" : o2.n.type === "root" ? "markAsRoot(" + n2(o2.contents) + ")" : "align(" + JSON.stringify(o2.n) + ", " + n2(o2.contents) + ")";
    if (o2.type === _2) return "ifBreak(" + n2(o2.breakContents) + (o2.flatContents ? ", " + n2(o2.flatContents) : "") + (o2.groupId ? (o2.flatContents ? "" : ', ""') + `, { groupId: ${u(o2.groupId)} }` : "") + ")";
    if (o2.type === v2) {
      let D = [];
      o2.negate && D.push("negate: true"), o2.groupId && D.push(`groupId: ${u(o2.groupId)}`);
      let p = D.length > 0 ? `, { ${D.join(", ")} }` : "";
      return `indentIfBreak(${n2(o2.contents)}${p})`;
    }
    if (o2.type === B2) {
      let D = [];
      o2.break && o2.break !== "propagated" && D.push("shouldBreak: true"), o2.id && D.push(`id: ${u(o2.id)}`);
      let p = D.length > 0 ? `, { ${D.join(", ")} }` : "";
      return o2.expandedStates ? `conditionalGroup([${o2.expandedStates.map((l2) => n2(l2)).join(",")}]${p})` : `group(${n2(o2.contents)}${p})`;
    }
    if (o2.type === k2) return `fill([${o2.parts.map((D) => n2(D)).join(", ")}])`;
    if (o2.type === L2) return "lineSuffix(" + n2(o2.contents) + ")";
    if (o2.type === I) return "lineSuffixBoundary";
    if (o2.type === S2) return `label(${JSON.stringify(o2.label)}, ${n2(o2.contents)})`;
    if (o2.type === j2) return "cursor";
    throw new Error("Unknown doc type " + o2.type);
  }
  function u(o2) {
    if (typeof o2 != "symbol") return JSON.stringify(String(o2));
    if (o2 in t8) return t8[o2];
    let i = o2.description || "symbol";
    for (let s2 = 0; ; s2++) {
      let a = i + (s2 > 0 ? ` #${s2}` : "");
      if (!r2.has(a)) return r2.add(a), t8[o2] = `Symbol.for(${JSON.stringify(a)})`;
    }
  }
}
var br2 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function kr2(e2) {
  return e2 === 12288 || e2 >= 65281 && e2 <= 65376 || e2 >= 65504 && e2 <= 65510;
}
function Sr2(e2) {
  return e2 >= 4352 && e2 <= 4447 || e2 === 8986 || e2 === 8987 || e2 === 9001 || e2 === 9002 || e2 >= 9193 && e2 <= 9196 || e2 === 9200 || e2 === 9203 || e2 === 9725 || e2 === 9726 || e2 === 9748 || e2 === 9749 || e2 >= 9776 && e2 <= 9783 || e2 >= 9800 && e2 <= 9811 || e2 === 9855 || e2 >= 9866 && e2 <= 9871 || e2 === 9875 || e2 === 9889 || e2 === 9898 || e2 === 9899 || e2 === 9917 || e2 === 9918 || e2 === 9924 || e2 === 9925 || e2 === 9934 || e2 === 9940 || e2 === 9962 || e2 === 9970 || e2 === 9971 || e2 === 9973 || e2 === 9978 || e2 === 9981 || e2 === 9989 || e2 === 9994 || e2 === 9995 || e2 === 10024 || e2 === 10060 || e2 === 10062 || e2 >= 10067 && e2 <= 10069 || e2 === 10071 || e2 >= 10133 && e2 <= 10135 || e2 === 10160 || e2 === 10175 || e2 === 11035 || e2 === 11036 || e2 === 11088 || e2 === 11093 || e2 >= 11904 && e2 <= 11929 || e2 >= 11931 && e2 <= 12019 || e2 >= 12032 && e2 <= 12245 || e2 >= 12272 && e2 <= 12287 || e2 >= 12289 && e2 <= 12350 || e2 >= 12353 && e2 <= 12438 || e2 >= 12441 && e2 <= 12543 || e2 >= 12549 && e2 <= 12591 || e2 >= 12593 && e2 <= 12686 || e2 >= 12688 && e2 <= 12773 || e2 >= 12783 && e2 <= 12830 || e2 >= 12832 && e2 <= 12871 || e2 >= 12880 && e2 <= 42124 || e2 >= 42128 && e2 <= 42182 || e2 >= 43360 && e2 <= 43388 || e2 >= 44032 && e2 <= 55203 || e2 >= 63744 && e2 <= 64255 || e2 >= 65040 && e2 <= 65049 || e2 >= 65072 && e2 <= 65106 || e2 >= 65108 && e2 <= 65126 || e2 >= 65128 && e2 <= 65131 || e2 >= 94176 && e2 <= 94180 || e2 === 94192 || e2 === 94193 || e2 >= 94208 && e2 <= 100343 || e2 >= 100352 && e2 <= 101589 || e2 >= 101631 && e2 <= 101640 || e2 >= 110576 && e2 <= 110579 || e2 >= 110581 && e2 <= 110587 || e2 === 110589 || e2 === 110590 || e2 >= 110592 && e2 <= 110882 || e2 === 110898 || e2 >= 110928 && e2 <= 110930 || e2 === 110933 || e2 >= 110948 && e2 <= 110951 || e2 >= 110960 && e2 <= 111355 || e2 >= 119552 && e2 <= 119638 || e2 >= 119648 && e2 <= 119670 || e2 === 126980 || e2 === 127183 || e2 === 127374 || e2 >= 127377 && e2 <= 127386 || e2 >= 127488 && e2 <= 127490 || e2 >= 127504 && e2 <= 127547 || e2 >= 127552 && e2 <= 127560 || e2 === 127568 || e2 === 127569 || e2 >= 127584 && e2 <= 127589 || e2 >= 127744 && e2 <= 127776 || e2 >= 127789 && e2 <= 127797 || e2 >= 127799 && e2 <= 127868 || e2 >= 127870 && e2 <= 127891 || e2 >= 127904 && e2 <= 127946 || e2 >= 127951 && e2 <= 127955 || e2 >= 127968 && e2 <= 127984 || e2 === 127988 || e2 >= 127992 && e2 <= 128062 || e2 === 128064 || e2 >= 128066 && e2 <= 128252 || e2 >= 128255 && e2 <= 128317 || e2 >= 128331 && e2 <= 128334 || e2 >= 128336 && e2 <= 128359 || e2 === 128378 || e2 === 128405 || e2 === 128406 || e2 === 128420 || e2 >= 128507 && e2 <= 128591 || e2 >= 128640 && e2 <= 128709 || e2 === 128716 || e2 >= 128720 && e2 <= 128722 || e2 >= 128725 && e2 <= 128727 || e2 >= 128732 && e2 <= 128735 || e2 === 128747 || e2 === 128748 || e2 >= 128756 && e2 <= 128764 || e2 >= 128992 && e2 <= 129003 || e2 === 129008 || e2 >= 129292 && e2 <= 129338 || e2 >= 129340 && e2 <= 129349 || e2 >= 129351 && e2 <= 129535 || e2 >= 129648 && e2 <= 129660 || e2 >= 129664 && e2 <= 129673 || e2 >= 129679 && e2 <= 129734 || e2 >= 129742 && e2 <= 129756 || e2 >= 129759 && e2 <= 129769 || e2 >= 129776 && e2 <= 129784 || e2 >= 131072 && e2 <= 196605 || e2 >= 196608 && e2 <= 262141;
}
var Tr2 = (e2) => !(kr2(e2) || Sr2(e2));
var Pu = /[^\x20-\x7F]/u;
function vu(e2) {
  if (!e2) return 0;
  if (!Pu.test(e2)) return e2.length;
  e2 = e2.replace(br2(), "  ");
  let t8 = 0;
  for (let r2 of e2) {
    let n2 = r2.codePointAt(0);
    n2 <= 31 || n2 >= 127 && n2 <= 159 || n2 >= 768 && n2 <= 879 || (t8 += Tr2(n2) ? 1 : 2);
  }
  return t8;
}
var Ne2 = vu;
var R2 = Symbol("MODE_BREAK");
var H2 = Symbol("MODE_FLAT");
var de2 = Symbol("cursor");
var _t2 = Symbol("DOC_FILL_PRINTED_LENGTH");
function Nr2() {
  return { value: "", length: 0, queue: [] };
}
function Lu(e2, t8) {
  return xt2(e2, { type: "indent" }, t8);
}
function Iu(e2, t8, r2) {
  return t8 === Number.NEGATIVE_INFINITY ? e2.root || Nr2() : t8 < 0 ? xt2(e2, { type: "dedent" }, r2) : t8 ? t8.type === "root" ? { ...e2, root: e2 } : xt2(e2, { type: typeof t8 == "string" ? "stringAlign" : "numberAlign", n: t8 }, r2) : e2;
}
function xt2(e2, t8, r2) {
  let n2 = t8.type === "dedent" ? e2.queue.slice(0, -1) : [...e2.queue, t8], u = "", o2 = 0, i = 0, s2 = 0;
  for (let f of n2) switch (f.type) {
    case "indent":
      D(), r2.useTabs ? a(1) : c2(r2.tabWidth);
      break;
    case "stringAlign":
      D(), u += f.n, o2 += f.n.length;
      break;
    case "numberAlign":
      i += 1, s2 += f.n;
      break;
    default:
      throw new Error(`Unexpected type '${f.type}'`);
  }
  return l2(), { ...e2, value: u, length: o2, queue: n2 };
  function a(f) {
    u += "	".repeat(f), o2 += r2.tabWidth * f;
  }
  function c2(f) {
    u += " ".repeat(f), o2 += f;
  }
  function D() {
    r2.useTabs ? p() : l2();
  }
  function p() {
    i > 0 && a(i), F();
  }
  function l2() {
    s2 > 0 && c2(s2), F();
  }
  function F() {
    i = 0, s2 = 0;
  }
}
function wt2(e2) {
  let t8 = 0, r2 = 0, n2 = e2.length;
  e: for (; n2--; ) {
    let u = e2[n2];
    if (u === de2) {
      r2++;
      continue;
    }
    for (let o2 = u.length - 1; o2 >= 0; o2--) {
      let i = u[o2];
      if (i === " " || i === "	") t8++;
      else {
        e2[n2] = u.slice(0, o2 + 1);
        break e;
      }
    }
  }
  if (t8 > 0 || r2 > 0) for (e2.length = n2 + 1; r2-- > 0; ) e2.push(de2);
  return t8;
}
function Ke2(e2, t8, r2, n2, u, o2) {
  if (r2 === Number.POSITIVE_INFINITY) return true;
  let i = t8.length, s2 = [e2], a = [];
  for (; r2 >= 0; ) {
    if (s2.length === 0) {
      if (i === 0) return true;
      s2.push(t8[--i]);
      continue;
    }
    let { mode: c2, doc: D } = s2.pop(), p = M(D);
    switch (p) {
      case W2:
        a.push(D), r2 -= Ne2(D);
        break;
      case Y2:
      case k2: {
        let l2 = p === Y2 ? D : D.parts, F = D[_t2] ?? 0;
        for (let f = l2.length - 1; f >= F; f--) s2.push({ mode: c2, doc: l2[f] });
        break;
      }
      case N2:
      case O2:
      case v2:
      case S2:
        s2.push({ mode: c2, doc: D.contents });
        break;
      case P2:
        r2 += wt2(a);
        break;
      case B2: {
        if (o2 && D.break) return false;
        let l2 = D.break ? R2 : c2, F = D.expandedStates && l2 === R2 ? y(false, D.expandedStates, -1) : D.contents;
        s2.push({ mode: l2, doc: F });
        break;
      }
      case _2: {
        let F = (D.groupId ? u[D.groupId] || H2 : c2) === R2 ? D.breakContents : D.flatContents;
        F && s2.push({ mode: c2, doc: F });
        break;
      }
      case g:
        if (c2 === R2 || D.hard) return true;
        D.soft || (a.push(" "), r2--);
        break;
      case L2:
        n2 = true;
        break;
      case I:
        if (n2) return false;
        break;
    }
  }
  return false;
}
function me2(e2, t8) {
  let r2 = {}, n2 = t8.printWidth, u = xe2(t8.endOfLine), o2 = 0, i = [{ ind: Nr2(), mode: R2, doc: e2 }], s2 = [], a = false, c2 = [], D = 0;
  for (cr2(e2); i.length > 0; ) {
    let { ind: l2, mode: F, doc: f } = i.pop();
    switch (M(f)) {
      case W2: {
        let d2 = u !== `
` ? te(false, f, `
`, u) : f;
        s2.push(d2), i.length > 0 && (o2 += Ne2(d2));
        break;
      }
      case Y2:
        for (let d2 = f.length - 1; d2 >= 0; d2--) i.push({ ind: l2, mode: F, doc: f[d2] });
        break;
      case j2:
        if (D >= 2) throw new Error("There are too many 'cursor' in doc.");
        s2.push(de2), D++;
        break;
      case N2:
        i.push({ ind: Lu(l2, t8), mode: F, doc: f.contents });
        break;
      case O2:
        i.push({ ind: Iu(l2, f.n, t8), mode: F, doc: f.contents });
        break;
      case P2:
        o2 -= wt2(s2);
        break;
      case B2:
        switch (F) {
          case H2:
            if (!a) {
              i.push({ ind: l2, mode: f.break ? R2 : H2, doc: f.contents });
              break;
            }
          case R2: {
            a = false;
            let d2 = { ind: l2, mode: H2, doc: f.contents }, m = n2 - o2, C = c2.length > 0;
            if (!f.break && Ke2(d2, i, m, C, r2)) i.push(d2);
            else if (f.expandedStates) {
              let E2 = y(false, f.expandedStates, -1);
              if (f.break) {
                i.push({ ind: l2, mode: R2, doc: E2 });
                break;
              } else for (let h2 = 1; h2 < f.expandedStates.length + 1; h2++) if (h2 >= f.expandedStates.length) {
                i.push({ ind: l2, mode: R2, doc: E2 });
                break;
              } else {
                let x = f.expandedStates[h2], A = { ind: l2, mode: H2, doc: x };
                if (Ke2(A, i, m, C, r2)) {
                  i.push(A);
                  break;
                }
              }
            } else i.push({ ind: l2, mode: R2, doc: f.contents });
            break;
          }
        }
        f.id && (r2[f.id] = y(false, i, -1).mode);
        break;
      case k2: {
        let d2 = n2 - o2, m = f[_t2] ?? 0, { parts: C } = f, E2 = C.length - m;
        if (E2 === 0) break;
        let h2 = C[m + 0], x = C[m + 1], A = { ind: l2, mode: H2, doc: h2 }, $2 = { ind: l2, mode: R2, doc: h2 }, ue = Ke2(A, [], d2, c2.length > 0, r2, true);
        if (E2 === 1) {
          ue ? i.push(A) : i.push($2);
          break;
        }
        let Be3 = { ind: l2, mode: H2, doc: x }, lt3 = { ind: l2, mode: R2, doc: x };
        if (E2 === 2) {
          ue ? i.push(Be3, A) : i.push(lt3, $2);
          break;
        }
        let lu = C[m + 2], Ft3 = { ind: l2, mode: F, doc: { ...f, [_t2]: m + 2 } };
        Ke2({ ind: l2, mode: H2, doc: [h2, x, lu] }, [], d2, c2.length > 0, r2, true) ? i.push(Ft3, Be3, A) : ue ? i.push(Ft3, lt3, A) : i.push(Ft3, lt3, $2);
        break;
      }
      case _2:
      case v2: {
        let d2 = f.groupId ? r2[f.groupId] : F;
        if (d2 === R2) {
          let m = f.type === _2 ? f.breakContents : f.negate ? f.contents : ie2(f.contents);
          m && i.push({ ind: l2, mode: F, doc: m });
        }
        if (d2 === H2) {
          let m = f.type === _2 ? f.flatContents : f.negate ? ie2(f.contents) : f.contents;
          m && i.push({ ind: l2, mode: F, doc: m });
        }
        break;
      }
      case L2:
        c2.push({ ind: l2, mode: F, doc: f.contents });
        break;
      case I:
        c2.length > 0 && i.push({ ind: l2, mode: F, doc: Te2 });
        break;
      case g:
        switch (F) {
          case H2:
            if (f.hard) a = true;
            else {
              f.soft || (s2.push(" "), o2 += 1);
              break;
            }
          case R2:
            if (c2.length > 0) {
              i.push({ ind: l2, mode: F, doc: f }, ...c2.reverse()), c2.length = 0;
              break;
            }
            f.literal ? l2.root ? (s2.push(u, l2.root.value), o2 = l2.root.length) : (s2.push(u), o2 = 0) : (o2 -= wt2(s2), s2.push(u + l2.value), o2 = l2.length);
            break;
        }
        break;
      case S2:
        i.push({ ind: l2, mode: F, doc: f.contents });
        break;
      case w2:
        break;
      default:
        throw new q(f);
    }
    i.length === 0 && c2.length > 0 && (i.push(...c2.reverse()), c2.length = 0);
  }
  let p = s2.indexOf(de2);
  if (p !== -1) {
    let l2 = s2.indexOf(de2, p + 1);
    if (l2 === -1) return { formatted: s2.filter((m) => m !== de2).join("") };
    let F = s2.slice(0, p).join(""), f = s2.slice(p + 1, l2).join(""), d2 = s2.slice(l2 + 1).join("");
    return { formatted: F + f + d2, cursorNodeStart: F.length, cursorNodeText: f };
  }
  return { formatted: s2.join("") };
}
function Ru(e2, t8, r2 = 0) {
  let n2 = 0;
  for (let u = r2; u < e2.length; ++u) e2[u] === "	" ? n2 = n2 + t8 - n2 % t8 : n2++;
  return n2;
}
var Ee2 = Ru;
var Z2;
var kt2;
var ze2;
var bt2 = class {
  constructor(t8) {
    tr(this, Z2);
    this.stack = [t8];
  }
  get key() {
    let { stack: t8, siblings: r2 } = this;
    return y(false, t8, r2 === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : y(false, this.stack, -2);
  }
  get node() {
    return y(false, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: t8 } = this, r2 = y(false, t8, -3);
    return Array.isArray(r2) ? r2 : null;
  }
  get next() {
    let { siblings: t8 } = this;
    return t8 === null ? null : t8[this.index + 1];
  }
  get previous() {
    let { siblings: t8 } = this;
    return t8 === null ? null : t8[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: t8, index: r2 } = this;
    return t8 !== null && r2 === t8.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...fe2(this, Z2, ze2).call(this)];
  }
  getName() {
    let { stack: t8 } = this, { length: r2 } = t8;
    return r2 > 1 ? y(false, t8, -2) : null;
  }
  getValue() {
    return y(false, this.stack, -1);
  }
  getNode(t8 = 0) {
    let r2 = fe2(this, Z2, kt2).call(this, t8);
    return r2 === -1 ? null : this.stack[r2];
  }
  getParentNode(t8 = 0) {
    return this.getNode(t8 + 1);
  }
  call(t8, ...r2) {
    let { stack: n2 } = this, { length: u } = n2, o2 = y(false, n2, -1);
    for (let i of r2) o2 = o2[i], n2.push(i, o2);
    try {
      return t8(this);
    } finally {
      n2.length = u;
    }
  }
  callParent(t8, r2 = 0) {
    let n2 = fe2(this, Z2, kt2).call(this, r2 + 1), u = this.stack.splice(n2 + 1);
    try {
      return t8(this);
    } finally {
      this.stack.push(...u);
    }
  }
  each(t8, ...r2) {
    let { stack: n2 } = this, { length: u } = n2, o2 = y(false, n2, -1);
    for (let i of r2) o2 = o2[i], n2.push(i, o2);
    try {
      for (let i = 0; i < o2.length; ++i) n2.push(i, o2[i]), t8(this, i, o2), n2.length -= 2;
    } finally {
      n2.length = u;
    }
  }
  map(t8, ...r2) {
    let n2 = [];
    return this.each((u, o2, i) => {
      n2[o2] = t8(u, o2, i);
    }, ...r2), n2;
  }
  match(...t8) {
    let r2 = this.stack.length - 1, n2 = null, u = this.stack[r2--];
    for (let o2 of t8) {
      if (u === void 0) return false;
      let i = null;
      if (typeof n2 == "number" && (i = n2, n2 = this.stack[r2--], u = this.stack[r2--]), o2 && !o2(u, n2, i)) return false;
      n2 = this.stack[r2--], u = this.stack[r2--];
    }
    return true;
  }
  findAncestor(t8) {
    for (let r2 of fe2(this, Z2, ze2).call(this)) if (t8(r2)) return r2;
  }
  hasAncestor(t8) {
    for (let r2 of fe2(this, Z2, ze2).call(this)) if (t8(r2)) return true;
    return false;
  }
};
Z2 = /* @__PURE__ */ new WeakSet(), kt2 = function(t8) {
  let { stack: r2 } = this;
  for (let n2 = r2.length - 1; n2 >= 0; n2 -= 2) if (!Array.isArray(r2[n2]) && --t8 < 0) return n2;
  return -1;
}, ze2 = function* () {
  let { stack: t8 } = this;
  for (let r2 = t8.length - 3; r2 >= 0; r2 -= 2) {
    let n2 = t8[r2];
    Array.isArray(n2) || (yield n2);
  }
};
var Or2 = bt2;
var Pr2 = new Proxy(() => {
}, { get: () => Pr2 });
var Oe2 = Pr2;
function Yu(e2) {
  return e2 !== null && typeof e2 == "object";
}
var vr2 = Yu;
function* Ce2(e2, t8) {
  let { getVisitorKeys: r2, filter: n2 = () => true } = t8, u = (o2) => vr2(o2) && n2(o2);
  for (let o2 of r2(e2)) {
    let i = e2[o2];
    if (Array.isArray(i)) for (let s2 of i) u(s2) && (yield s2);
    else u(i) && (yield i);
  }
}
function* Lr2(e2, t8) {
  let r2 = [e2];
  for (let n2 = 0; n2 < r2.length; n2++) {
    let u = r2[n2];
    for (let o2 of Ce2(u, t8)) yield o2, r2.push(o2);
  }
}
function Ir2(e2, t8) {
  return Ce2(e2, t8).next().done;
}
function he2(e2) {
  return (t8, r2, n2) => {
    let u = !!(n2 != null && n2.backwards);
    if (r2 === false) return false;
    let { length: o2 } = t8, i = r2;
    for (; i >= 0 && i < o2; ) {
      let s2 = t8.charAt(i);
      if (e2 instanceof RegExp) {
        if (!e2.test(s2)) return i;
      } else if (!e2.includes(s2)) return i;
      u ? i-- : i++;
    }
    return i === -1 || i === o2 ? i : false;
  };
}
var Rr2 = he2(/\s/u);
var T2 = he2(" 	");
var He2 = he2(",; 	");
var Je2 = he2(/[^\n\r]/u);
function ju(e2, t8, r2) {
  let n2 = !!(r2 != null && r2.backwards);
  if (t8 === false) return false;
  let u = e2.charAt(t8);
  if (n2) {
    if (e2.charAt(t8 - 1) === "\r" && u === `
`) return t8 - 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t8 - 1;
  } else {
    if (u === "\r" && e2.charAt(t8 + 1) === `
`) return t8 + 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t8 + 1;
  }
  return t8;
}
var U = ju;
function Uu(e2, t8, r2 = {}) {
  let n2 = T2(e2, r2.backwards ? t8 - 1 : t8, r2), u = U(e2, n2, r2);
  return n2 !== u;
}
var G2 = Uu;
function Vu(e2) {
  return Array.isArray(e2) && e2.length > 0;
}
var qe2 = Vu;
var Yr = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]);
var $u = (e2) => Object.keys(e2).filter((t8) => !Yr.has(t8));
function Wu(e2) {
  return e2 ? (t8) => e2(t8, Yr) : $u;
}
var J2 = Wu;
function Mu(e2) {
  let t8 = e2.type || e2.kind || "(unknown type)", r2 = String(e2.name || e2.id && (typeof e2.id == "object" ? e2.id.name : e2.id) || e2.key && (typeof e2.key == "object" ? e2.key.name : e2.key) || e2.value && (typeof e2.value == "object" ? "" : String(e2.value)) || e2.operator || "");
  return r2.length > 20 && (r2 = r2.slice(0, 19) + "\u2026"), t8 + (r2 ? " " + r2 : "");
}
function St2(e2, t8) {
  (e2.comments ?? (e2.comments = [])).push(t8), t8.printed = false, t8.nodeDescription = Mu(e2);
}
function se2(e2, t8) {
  t8.leading = true, t8.trailing = false, St2(e2, t8);
}
function ee2(e2, t8, r2) {
  t8.leading = false, t8.trailing = false, r2 && (t8.marker = r2), St2(e2, t8);
}
function ae2(e2, t8) {
  t8.leading = false, t8.trailing = true, St2(e2, t8);
}
var Tt2 = /* @__PURE__ */ new WeakMap();
function Xe2(e2, t8) {
  if (Tt2.has(e2)) return Tt2.get(e2);
  let { printer: { getCommentChildNodes: r2, canAttachComment: n2, getVisitorKeys: u }, locStart: o2, locEnd: i } = t8;
  if (!n2) return [];
  let s2 = ((r2 == null ? void 0 : r2(e2, t8)) ?? [...Ce2(e2, { getVisitorKeys: J2(u) })]).flatMap((a) => n2(a) ? [a] : Xe2(a, t8));
  return s2.sort((a, c2) => o2(a) - o2(c2) || i(a) - i(c2)), Tt2.set(e2, s2), s2;
}
function Ur2(e2, t8, r2, n2) {
  let { locStart: u, locEnd: o2 } = r2, i = u(t8), s2 = o2(t8), a = Xe2(e2, r2), c2, D, p = 0, l2 = a.length;
  for (; p < l2; ) {
    let F = p + l2 >> 1, f = a[F], d2 = u(f), m = o2(f);
    if (d2 <= i && s2 <= m) return Ur2(f, t8, r2, f);
    if (m <= i) {
      c2 = f, p = F + 1;
      continue;
    }
    if (s2 <= d2) {
      D = f, l2 = F;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((n2 == null ? void 0 : n2.type) === "TemplateLiteral") {
    let { quasis: F } = n2, f = Ot2(F, t8, r2);
    c2 && Ot2(F, c2, r2) !== f && (c2 = null), D && Ot2(F, D, r2) !== f && (D = null);
  }
  return { enclosingNode: n2, precedingNode: c2, followingNode: D };
}
var Nt2 = () => false;
function Vr(e2, t8) {
  let { comments: r2 } = e2;
  if (delete e2.comments, !qe2(r2) || !t8.printer.canAttachComment) return;
  let n2 = [], { printer: { experimentalFeatures: { avoidAstMutation: u = false } = {}, handleComments: o2 = {} }, originalText: i } = t8, { ownLine: s2 = Nt2, endOfLine: a = Nt2, remaining: c2 = Nt2 } = o2, D = r2.map((p, l2) => ({ ...Ur2(e2, p, t8), comment: p, text: i, options: t8, ast: e2, isLastComment: r2.length - 1 === l2 }));
  for (let [p, l2] of D.entries()) {
    let { comment: F, precedingNode: f, enclosingNode: d2, followingNode: m, text: C, options: E2, ast: h2, isLastComment: x } = l2, A;
    if (u ? A = [l2] : (F.enclosingNode = d2, F.precedingNode = f, F.followingNode = m, A = [F, C, E2, h2, x]), Gu(C, E2, D, p)) F.placement = "ownLine", s2(...A) || (m ? se2(m, F) : f ? ae2(f, F) : d2 ? ee2(d2, F) : ee2(h2, F));
    else if (Ku(C, E2, D, p)) F.placement = "endOfLine", a(...A) || (f ? ae2(f, F) : m ? se2(m, F) : d2 ? ee2(d2, F) : ee2(h2, F));
    else if (F.placement = "remaining", !c2(...A)) if (f && m) {
      let $2 = n2.length;
      $2 > 0 && n2[$2 - 1].followingNode !== m && jr2(n2, E2), n2.push(l2);
    } else f ? ae2(f, F) : m ? se2(m, F) : d2 ? ee2(d2, F) : ee2(h2, F);
  }
  if (jr2(n2, t8), !u) for (let p of r2) delete p.precedingNode, delete p.enclosingNode, delete p.followingNode;
}
var $r2 = (e2) => !/[\S\n\u2028\u2029]/u.test(e2);
function Gu(e2, t8, r2, n2) {
  let { comment: u, precedingNode: o2 } = r2[n2], { locStart: i, locEnd: s2 } = t8, a = i(u);
  if (o2) for (let c2 = n2 - 1; c2 >= 0; c2--) {
    let { comment: D, precedingNode: p } = r2[c2];
    if (p !== o2 || !$r2(e2.slice(s2(D), a))) break;
    a = i(D);
  }
  return G2(e2, a, { backwards: true });
}
function Ku(e2, t8, r2, n2) {
  let { comment: u, followingNode: o2 } = r2[n2], { locStart: i, locEnd: s2 } = t8, a = s2(u);
  if (o2) for (let c2 = n2 + 1; c2 < r2.length; c2++) {
    let { comment: D, followingNode: p } = r2[c2];
    if (p !== o2 || !$r2(e2.slice(a, i(D)))) break;
    a = s2(D);
  }
  return G2(e2, a);
}
function jr2(e2, t8) {
  var s2, a;
  let r2 = e2.length;
  if (r2 === 0) return;
  let { precedingNode: n2, followingNode: u } = e2[0], o2 = t8.locStart(u), i;
  for (i = r2; i > 0; --i) {
    let { comment: c2, precedingNode: D, followingNode: p } = e2[i - 1];
    Oe2.strictEqual(D, n2), Oe2.strictEqual(p, u);
    let l2 = t8.originalText.slice(t8.locEnd(c2), o2);
    if (((a = (s2 = t8.printer).isGap) == null ? void 0 : a.call(s2, l2, t8)) ?? /^[\s(]*$/u.test(l2)) o2 = t8.locStart(c2);
    else break;
  }
  for (let [c2, { comment: D }] of e2.entries()) c2 < i ? ae2(n2, D) : se2(u, D);
  for (let c2 of [n2, u]) c2.comments && c2.comments.length > 1 && c2.comments.sort((D, p) => t8.locStart(D) - t8.locStart(p));
  e2.length = 0;
}
function Ot2(e2, t8, r2) {
  let n2 = r2.locStart(t8) - 1;
  for (let u = 1; u < e2.length; ++u) if (n2 < r2.locStart(e2[u])) return u - 1;
  return 0;
}
function zu(e2, t8) {
  let r2 = t8 - 1;
  r2 = T2(e2, r2, { backwards: true }), r2 = U(e2, r2, { backwards: true }), r2 = T2(e2, r2, { backwards: true });
  let n2 = U(e2, r2, { backwards: true });
  return r2 !== n2;
}
var Pe2 = zu;
function Wr2(e2, t8) {
  let r2 = e2.node;
  return r2.printed = true, t8.printer.printComment(e2, t8);
}
function Hu(e2, t8) {
  var D;
  let r2 = e2.node, n2 = [Wr2(e2, t8)], { printer: u, originalText: o2, locStart: i, locEnd: s2 } = t8;
  if ((D = u.isBlockComment) == null ? void 0 : D.call(u, r2)) {
    let p = G2(o2, s2(r2)) ? G2(o2, i(r2), { backwards: true }) ? z2 : Me2 : " ";
    n2.push(p);
  } else n2.push(z2);
  let c2 = U(o2, T2(o2, s2(r2)));
  return c2 !== false && G2(o2, c2) && n2.push(z2), n2;
}
function Ju(e2, t8, r2) {
  var c2;
  let n2 = e2.node, u = Wr2(e2, t8), { printer: o2, originalText: i, locStart: s2 } = t8, a = (c2 = o2.isBlockComment) == null ? void 0 : c2.call(o2, n2);
  if (r2 != null && r2.hasLineSuffix && !(r2 != null && r2.isBlock) || G2(i, s2(n2), { backwards: true })) {
    let D = Pe2(i, s2(n2));
    return { doc: Se2([z2, D ? z2 : "", u]), isBlock: a, hasLineSuffix: true };
  }
  return !a || r2 != null && r2.hasLineSuffix ? { doc: [Se2([" ", u]), pe2], isBlock: a, hasLineSuffix: true } : { doc: [" ", u], isBlock: a, hasLineSuffix: false };
}
function qu(e2, t8) {
  let r2 = e2.node;
  if (!r2) return {};
  let n2 = t8[Symbol.for("printedComments")];
  if ((r2.comments || []).filter((a) => !n2.has(a)).length === 0) return { leading: "", trailing: "" };
  let o2 = [], i = [], s2;
  return e2.each(() => {
    let a = e2.node;
    if (n2 != null && n2.has(a)) return;
    let { leading: c2, trailing: D } = a;
    c2 ? o2.push(Hu(e2, t8)) : D && (s2 = Ju(e2, t8, s2), i.push(s2.doc));
  }, "comments"), { leading: o2, trailing: i };
}
function Mr(e2, t8, r2) {
  let { leading: n2, trailing: u } = qu(e2, r2);
  return !n2 && !u ? t8 : Fe2(t8, (o2) => [n2, o2, u]);
}
function Gr2(e2) {
  let { [Symbol.for("comments")]: t8, [Symbol.for("printedComments")]: r2 } = e2;
  for (let n2 of t8) {
    if (!n2.printed && !r2.has(n2)) throw new Error('Comment "' + n2.value.trim() + '" was not printed. Please report this error!');
    delete n2.printed;
  }
}
function Xu(e2) {
  return () => {
  };
}
var Kr2 = Xu;
var ve2 = class extends Error {
  name = "ConfigError";
};
var Le2 = class extends Error {
  name = "UndefinedParserError";
};
var zr = { checkIgnorePragma: { category: "Special", type: "boolean", default: false, description: "Check whether the file's first docblock comment contains '@noprettier' or '@noformat' to determine if it should be formatted.", cliCategory: "Other" }, cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }, { value: "mjml", description: "MJML" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment in order for it to be formatted.", cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function Qe2({ plugins: e2 = [], showDeprecated: t8 = false } = {}) {
  let r2 = e2.flatMap((u) => u.languages ?? []), n2 = [];
  for (let u of Zu(Object.assign({}, ...e2.map(({ options: o2 }) => o2), zr))) !t8 && u.deprecated || (Array.isArray(u.choices) && (t8 || (u.choices = u.choices.filter((o2) => !o2.deprecated)), u.name === "parser" && (u.choices = [...u.choices, ...Qu(u.choices, r2, e2)])), u.pluginDefaults = Object.fromEntries(e2.filter((o2) => {
    var i;
    return ((i = o2.defaultOptions) == null ? void 0 : i[u.name]) !== void 0;
  }).map((o2) => [o2.name, o2.defaultOptions[u.name]])), n2.push(u));
  return { languages: r2, options: n2 };
}
function* Qu(e2, t8, r2) {
  let n2 = new Set(e2.map((u) => u.value));
  for (let u of t8) if (u.parsers) {
    for (let o2 of u.parsers) if (!n2.has(o2)) {
      n2.add(o2);
      let i = r2.find((a) => a.parsers && Object.prototype.hasOwnProperty.call(a.parsers, o2)), s2 = u.name;
      i != null && i.name && (s2 += ` (plugin: ${i.name})`), yield { value: o2, description: s2 };
    }
  }
}
function Zu(e2) {
  let t8 = [];
  for (let [r2, n2] of Object.entries(e2)) {
    let u = { name: r2, ...n2 };
    Array.isArray(u.default) && (u.default = y(false, u.default, -1).value), t8.push(u);
  }
  return t8;
}
var eo2 = (e2, t8) => {
  if (!(e2 && t8 == null)) return t8.toReversed || !Array.isArray(t8) ? t8.toReversed() : [...t8].reverse();
};
var Hr = eo2;
var Jr2;
var qr;
var Xr2;
var Qr2;
var Zr2;
var to2 = ((Jr2 = globalThis.Deno) == null ? void 0 : Jr2.build.os) === "windows" || ((Xr2 = (qr = globalThis.navigator) == null ? void 0 : qr.platform) == null ? void 0 : Xr2.startsWith("Win")) || ((Zr2 = (Qr2 = globalThis.process) == null ? void 0 : Qr2.platform) == null ? void 0 : Zr2.startsWith("win")) || false;
function en2(e2) {
  if (e2 = e2 instanceof URL ? e2 : new URL(e2), e2.protocol !== "file:") throw new TypeError(`URL must be a file URL: received "${e2.protocol}"`);
  return e2;
}
function ro2(e2) {
  return e2 = en2(e2), decodeURIComponent(e2.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function no2(e2) {
  e2 = en2(e2);
  let t8 = decodeURIComponent(e2.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return e2.hostname !== "" && (t8 = `\\\\${e2.hostname}${t8}`), t8;
}
function tn2(e2) {
  return to2 ? no2(e2) : ro2(e2);
}
var rn2 = tn2;
var uo2 = (e2) => String(e2).split(/[/\\]/u).pop();
function nn(e2, t8) {
  if (!t8) return;
  let r2 = uo2(t8).toLowerCase();
  return e2.find(({ filenames: n2 }) => n2 == null ? void 0 : n2.some((u) => u.toLowerCase() === r2)) ?? e2.find(({ extensions: n2 }) => n2 == null ? void 0 : n2.some((u) => r2.endsWith(u)));
}
function oo2(e2, t8) {
  if (t8) return e2.find(({ name: r2 }) => r2.toLowerCase() === t8) ?? e2.find(({ aliases: r2 }) => r2 == null ? void 0 : r2.includes(t8)) ?? e2.find(({ extensions: r2 }) => r2 == null ? void 0 : r2.includes(`.${t8}`));
}
function un2(e2, t8) {
  if (t8) {
    if (String(t8).startsWith("file:")) try {
      t8 = rn2(t8);
    } catch {
      return;
    }
    if (typeof t8 == "string") return e2.find(({ isSupported: r2 }) => r2 == null ? void 0 : r2({ filepath: t8 }));
  }
}
function io2(e2, t8) {
  let r2 = Hr(false, e2.plugins).flatMap((u) => u.languages ?? []), n2 = oo2(r2, t8.language) ?? nn(r2, t8.physicalFile) ?? nn(r2, t8.file) ?? un2(r2, t8.physicalFile) ?? un2(r2, t8.file) ?? (t8.physicalFile, void 0);
  return n2 == null ? void 0 : n2.parsers[0];
}
var on2 = io2;
var re2 = { key: (e2) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e2) ? e2 : JSON.stringify(e2), value(e2) {
  if (e2 === null || typeof e2 != "object") return JSON.stringify(e2);
  if (Array.isArray(e2)) return `[${e2.map((r2) => re2.value(r2)).join(", ")}]`;
  let t8 = Object.keys(e2);
  return t8.length === 0 ? "{}" : `{ ${t8.map((r2) => `${re2.key(r2)}: ${re2.value(e2[r2])}`).join(", ")} }`;
}, pair: ({ key: e2, value: t8 }) => re2.value({ [e2]: t8 }) };
var sn = new Proxy(String, { get: () => sn });
var V2 = sn;
var an = (e2, t8, { descriptor: r2 }) => {
  let n2 = [`${V2.yellow(typeof e2 == "string" ? r2.key(e2) : r2.pair(e2))} is deprecated`];
  return t8 && n2.push(`we now treat it as ${V2.blue(typeof t8 == "string" ? r2.key(t8) : r2.pair(t8))}`), n2.join("; ") + ".";
};
var Ze2 = Symbol.for("vnopts.VALUE_NOT_EXIST");
var ge2 = Symbol.for("vnopts.VALUE_UNCHANGED");
var Dn2 = " ".repeat(2);
var fn2 = (e2, t8, r2) => {
  let { text: n2, list: u } = r2.normalizeExpectedResult(r2.schemas[e2].expected(r2)), o2 = [];
  return n2 && o2.push(cn2(e2, t8, n2, r2.descriptor)), u && o2.push([cn2(e2, t8, u.title, r2.descriptor)].concat(u.values.map((i) => ln2(i, r2.loggerPrintWidth))).join(`
`)), Fn2(o2, r2.loggerPrintWidth);
};
function cn2(e2, t8, r2, n2) {
  return [`Invalid ${V2.red(n2.key(e2))} value.`, `Expected ${V2.blue(r2)},`, `but received ${t8 === Ze2 ? V2.gray("nothing") : V2.red(n2.value(t8))}.`].join(" ");
}
function ln2({ text: e2, list: t8 }, r2) {
  let n2 = [];
  return e2 && n2.push(`- ${V2.blue(e2)}`), t8 && n2.push([`- ${V2.blue(t8.title)}:`].concat(t8.values.map((u) => ln2(u, r2 - Dn2.length).replace(/^|\n/g, `$&${Dn2}`))).join(`
`)), Fn2(n2, r2);
}
function Fn2(e2, t8) {
  if (e2.length === 1) return e2[0];
  let [r2, n2] = e2, [u, o2] = e2.map((i) => i.split(`
`, 1)[0].length);
  return u > t8 && u > o2 ? n2 : r2;
}
var Pt2 = [];
var pn2 = [];
function vt2(e2, t8) {
  if (e2 === t8) return 0;
  let r2 = e2;
  e2.length > t8.length && (e2 = t8, t8 = r2);
  let n2 = e2.length, u = t8.length;
  for (; n2 > 0 && e2.charCodeAt(~-n2) === t8.charCodeAt(~-u); ) n2--, u--;
  let o2 = 0;
  for (; o2 < n2 && e2.charCodeAt(o2) === t8.charCodeAt(o2); ) o2++;
  if (n2 -= o2, u -= o2, n2 === 0) return u;
  let i, s2, a, c2, D = 0, p = 0;
  for (; D < n2; ) pn2[D] = e2.charCodeAt(o2 + D), Pt2[D] = ++D;
  for (; p < u; ) for (i = t8.charCodeAt(o2 + p), a = p++, s2 = p, D = 0; D < n2; D++) c2 = i === pn2[D] ? a : a + 1, a = Pt2[D], s2 = Pt2[D] = a > s2 ? c2 > s2 ? s2 + 1 : c2 : c2 > a ? a + 1 : c2;
  return s2;
}
var et2 = (e2, t8, { descriptor: r2, logger: n2, schemas: u }) => {
  let o2 = [`Ignored unknown option ${V2.yellow(r2.pair({ key: e2, value: t8 }))}.`], i = Object.keys(u).sort().find((s2) => vt2(e2, s2) < 3);
  i && o2.push(`Did you mean ${V2.blue(r2.key(i))}?`), n2.warn(o2.join(" "));
};
var so2 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function ao2(e2, t8) {
  let r2 = new e2(t8), n2 = Object.create(r2);
  for (let u of so2) u in t8 && (n2[u] = Do(t8[u], r2, b2.prototype[u].length));
  return n2;
}
var b2 = class {
  static create(t8) {
    return ao2(this, t8);
  }
  constructor(t8) {
    this.name = t8.name;
  }
  default(t8) {
  }
  expected(t8) {
    return "nothing";
  }
  validate(t8, r2) {
    return false;
  }
  deprecated(t8, r2) {
    return false;
  }
  forward(t8, r2) {
  }
  redirect(t8, r2) {
  }
  overlap(t8, r2, n2) {
    return t8;
  }
  preprocess(t8, r2) {
    return t8;
  }
  postprocess(t8, r2) {
    return ge2;
  }
};
function Do(e2, t8, r2) {
  return typeof e2 == "function" ? (...n2) => e2(...n2.slice(0, r2 - 1), t8, ...n2.slice(r2 - 1)) : () => e2;
}
var tt2 = class extends b2 {
  constructor(t8) {
    super(t8), this._sourceName = t8.sourceName;
  }
  expected(t8) {
    return t8.schemas[this._sourceName].expected(t8);
  }
  validate(t8, r2) {
    return r2.schemas[this._sourceName].validate(t8, r2);
  }
  redirect(t8, r2) {
    return this._sourceName;
  }
};
var rt2 = class extends b2 {
  expected() {
    return "anything";
  }
  validate() {
    return true;
  }
};
var nt2 = class extends b2 {
  constructor({ valueSchema: t8, name: r2 = t8.name, ...n2 }) {
    super({ ...n2, name: r2 }), this._valueSchema = t8;
  }
  expected(t8) {
    let { text: r2, list: n2 } = t8.normalizeExpectedResult(this._valueSchema.expected(t8));
    return { text: r2 && `an array of ${r2}`, list: n2 && { title: "an array of the following values", values: [{ list: n2 }] } };
  }
  validate(t8, r2) {
    if (!Array.isArray(t8)) return false;
    let n2 = [];
    for (let u of t8) {
      let o2 = r2.normalizeValidateResult(this._valueSchema.validate(u, r2), u);
      o2 !== true && n2.push(o2.value);
    }
    return n2.length === 0 ? true : { value: n2 };
  }
  deprecated(t8, r2) {
    let n2 = [];
    for (let u of t8) {
      let o2 = r2.normalizeDeprecatedResult(this._valueSchema.deprecated(u, r2), u);
      o2 !== false && n2.push(...o2.map(({ value: i }) => ({ value: [i] })));
    }
    return n2;
  }
  forward(t8, r2) {
    let n2 = [];
    for (let u of t8) {
      let o2 = r2.normalizeForwardResult(this._valueSchema.forward(u, r2), u);
      n2.push(...o2.map(dn2));
    }
    return n2;
  }
  redirect(t8, r2) {
    let n2 = [], u = [];
    for (let o2 of t8) {
      let i = r2.normalizeRedirectResult(this._valueSchema.redirect(o2, r2), o2);
      "remain" in i && n2.push(i.remain), u.push(...i.redirect.map(dn2));
    }
    return n2.length === 0 ? { redirect: u } : { redirect: u, remain: n2 };
  }
  overlap(t8, r2) {
    return t8.concat(r2);
  }
};
function dn2({ from: e2, to: t8 }) {
  return { from: [e2], to: t8 };
}
var ut2 = class extends b2 {
  expected() {
    return "true or false";
  }
  validate(t8) {
    return typeof t8 == "boolean";
  }
};
function En2(e2, t8) {
  let r2 = /* @__PURE__ */ Object.create(null);
  for (let n2 of e2) {
    let u = n2[t8];
    if (r2[u]) throw new Error(`Duplicate ${t8} ${JSON.stringify(u)}`);
    r2[u] = n2;
  }
  return r2;
}
function Cn2(e2, t8) {
  let r2 = /* @__PURE__ */ new Map();
  for (let n2 of e2) {
    let u = n2[t8];
    if (r2.has(u)) throw new Error(`Duplicate ${t8} ${JSON.stringify(u)}`);
    r2.set(u, n2);
  }
  return r2;
}
function hn2() {
  let e2 = /* @__PURE__ */ Object.create(null);
  return (t8) => {
    let r2 = JSON.stringify(t8);
    return e2[r2] ? true : (e2[r2] = true, false);
  };
}
function gn2(e2, t8) {
  let r2 = [], n2 = [];
  for (let u of e2) t8(u) ? r2.push(u) : n2.push(u);
  return [r2, n2];
}
function yn2(e2) {
  return e2 === Math.floor(e2);
}
function An2(e2, t8) {
  if (e2 === t8) return 0;
  let r2 = typeof e2, n2 = typeof t8, u = ["undefined", "object", "boolean", "number", "string"];
  return r2 !== n2 ? u.indexOf(r2) - u.indexOf(n2) : r2 !== "string" ? Number(e2) - Number(t8) : e2.localeCompare(t8);
}
function Bn2(e2) {
  return (...t8) => {
    let r2 = e2(...t8);
    return typeof r2 == "string" ? new Error(r2) : r2;
  };
}
function Lt2(e2) {
  return e2 === void 0 ? {} : e2;
}
function It2(e2) {
  if (typeof e2 == "string") return { text: e2 };
  let { text: t8, list: r2 } = e2;
  return co2((t8 || r2) !== void 0, "Unexpected `expected` result, there should be at least one field."), r2 ? { text: t8, list: { title: r2.title, values: r2.values.map(It2) } } : { text: t8 };
}
function Rt2(e2, t8) {
  return e2 === true ? true : e2 === false ? { value: t8 } : e2;
}
function Yt2(e2, t8, r2 = false) {
  return e2 === false ? false : e2 === true ? r2 ? true : [{ value: t8 }] : "value" in e2 ? [e2] : e2.length === 0 ? false : e2;
}
function mn2(e2, t8) {
  return typeof e2 == "string" || "key" in e2 ? { from: t8, to: e2 } : "from" in e2 ? { from: e2.from, to: e2.to } : { from: t8, to: e2.to };
}
function ot2(e2, t8) {
  return e2 === void 0 ? [] : Array.isArray(e2) ? e2.map((r2) => mn2(r2, t8)) : [mn2(e2, t8)];
}
function jt2(e2, t8) {
  let r2 = ot2(typeof e2 == "object" && "redirect" in e2 ? e2.redirect : e2, t8);
  return r2.length === 0 ? { remain: t8, redirect: r2 } : typeof e2 == "object" && "remain" in e2 ? { remain: e2.remain, redirect: r2 } : { redirect: r2 };
}
function co2(e2, t8) {
  if (!e2) throw new Error(t8);
}
var it2 = class extends b2 {
  constructor(t8) {
    super(t8), this._choices = Cn2(t8.choices.map((r2) => r2 && typeof r2 == "object" ? r2 : { value: r2 }), "value");
  }
  expected({ descriptor: t8 }) {
    let r2 = Array.from(this._choices.keys()).map((i) => this._choices.get(i)).filter(({ hidden: i }) => !i).map((i) => i.value).sort(An2).map(t8.value), n2 = r2.slice(0, -2), u = r2.slice(-2);
    return { text: n2.concat(u.join(" or ")).join(", "), list: { title: "one of the following values", values: r2 } };
  }
  validate(t8) {
    return this._choices.has(t8);
  }
  deprecated(t8) {
    let r2 = this._choices.get(t8);
    return r2 && r2.deprecated ? { value: t8 } : false;
  }
  forward(t8) {
    let r2 = this._choices.get(t8);
    return r2 ? r2.forward : void 0;
  }
  redirect(t8) {
    let r2 = this._choices.get(t8);
    return r2 ? r2.redirect : void 0;
  }
};
var st2 = class extends b2 {
  expected() {
    return "a number";
  }
  validate(t8, r2) {
    return typeof t8 == "number";
  }
};
var at2 = class extends st2 {
  expected() {
    return "an integer";
  }
  validate(t8, r2) {
    return r2.normalizeValidateResult(super.validate(t8, r2), t8) === true && yn2(t8);
  }
};
var Ie2 = class extends b2 {
  expected() {
    return "a string";
  }
  validate(t8) {
    return typeof t8 == "string";
  }
};
var _n2 = re2;
var xn2 = et2;
var wn2 = fn2;
var bn2 = an;
var Dt2 = class {
  constructor(t8, r2) {
    let { logger: n2 = console, loggerPrintWidth: u = 80, descriptor: o2 = _n2, unknown: i = xn2, invalid: s2 = wn2, deprecated: a = bn2, missing: c2 = () => false, required: D = () => false, preprocess: p = (F) => F, postprocess: l2 = () => ge2 } = r2 || {};
    this._utils = { descriptor: o2, logger: n2 || { warn: () => {
    } }, loggerPrintWidth: u, schemas: En2(t8, "name"), normalizeDefaultResult: Lt2, normalizeExpectedResult: It2, normalizeDeprecatedResult: Yt2, normalizeForwardResult: ot2, normalizeRedirectResult: jt2, normalizeValidateResult: Rt2 }, this._unknownHandler = i, this._invalidHandler = Bn2(s2), this._deprecatedHandler = a, this._identifyMissing = (F, f) => !(F in f) || c2(F, f), this._identifyRequired = D, this._preprocess = p, this._postprocess = l2, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = hn2();
  }
  normalize(t8) {
    let r2 = {}, u = [this._preprocess(t8, this._utils)], o2 = () => {
      for (; u.length !== 0; ) {
        let i = u.shift(), s2 = this._applyNormalization(i, r2);
        u.push(...s2);
      }
    };
    o2();
    for (let i of Object.keys(this._utils.schemas)) {
      let s2 = this._utils.schemas[i];
      if (!(i in r2)) {
        let a = Lt2(s2.default(this._utils));
        "value" in a && u.push({ [i]: a.value });
      }
    }
    o2();
    for (let i of Object.keys(this._utils.schemas)) {
      if (!(i in r2)) continue;
      let s2 = this._utils.schemas[i], a = r2[i], c2 = s2.postprocess(a, this._utils);
      c2 !== ge2 && (this._applyValidation(c2, i, s2), r2[i] = c2);
    }
    return this._applyPostprocess(r2), this._applyRequiredCheck(r2), r2;
  }
  _applyNormalization(t8, r2) {
    let n2 = [], { knownKeys: u, unknownKeys: o2 } = this._partitionOptionKeys(t8);
    for (let i of u) {
      let s2 = this._utils.schemas[i], a = s2.preprocess(t8[i], this._utils);
      this._applyValidation(a, i, s2);
      let c2 = ({ from: F, to: f }) => {
        n2.push(typeof f == "string" ? { [f]: F } : { [f.key]: f.value });
      }, D = ({ value: F, redirectTo: f }) => {
        let d2 = Yt2(s2.deprecated(F, this._utils), a, true);
        if (d2 !== false) if (d2 === true) this._hasDeprecationWarned(i) || this._utils.logger.warn(this._deprecatedHandler(i, f, this._utils));
        else for (let { value: m } of d2) {
          let C = { key: i, value: m };
          if (!this._hasDeprecationWarned(C)) {
            let E2 = typeof f == "string" ? { key: f, value: m } : f;
            this._utils.logger.warn(this._deprecatedHandler(C, E2, this._utils));
          }
        }
      };
      ot2(s2.forward(a, this._utils), a).forEach(c2);
      let l2 = jt2(s2.redirect(a, this._utils), a);
      if (l2.redirect.forEach(c2), "remain" in l2) {
        let F = l2.remain;
        r2[i] = i in r2 ? s2.overlap(r2[i], F, this._utils) : F, D({ value: F });
      }
      for (let { from: F, to: f } of l2.redirect) D({ value: F, redirectTo: f });
    }
    for (let i of o2) {
      let s2 = t8[i];
      this._applyUnknownHandler(i, s2, r2, (a, c2) => {
        n2.push({ [a]: c2 });
      });
    }
    return n2;
  }
  _applyRequiredCheck(t8) {
    for (let r2 of Object.keys(this._utils.schemas)) if (this._identifyMissing(r2, t8) && this._identifyRequired(r2)) throw this._invalidHandler(r2, Ze2, this._utils);
  }
  _partitionOptionKeys(t8) {
    let [r2, n2] = gn2(Object.keys(t8).filter((u) => !this._identifyMissing(u, t8)), (u) => u in this._utils.schemas);
    return { knownKeys: r2, unknownKeys: n2 };
  }
  _applyValidation(t8, r2, n2) {
    let u = Rt2(n2.validate(t8, this._utils), t8);
    if (u !== true) throw this._invalidHandler(r2, u.value, this._utils);
  }
  _applyUnknownHandler(t8, r2, n2, u) {
    let o2 = this._unknownHandler(t8, r2, this._utils);
    if (o2) for (let i of Object.keys(o2)) {
      if (this._identifyMissing(i, o2)) continue;
      let s2 = o2[i];
      i in this._utils.schemas ? u(i, s2) : n2[i] = s2;
    }
  }
  _applyPostprocess(t8) {
    let r2 = this._postprocess(t8, this._utils);
    if (r2 !== ge2) {
      if (r2.delete) for (let n2 of r2.delete) delete t8[n2];
      if (r2.override) {
        let { knownKeys: n2, unknownKeys: u } = this._partitionOptionKeys(r2.override);
        for (let o2 of n2) {
          let i = r2.override[o2];
          this._applyValidation(i, o2, this._utils.schemas[o2]), t8[o2] = i;
        }
        for (let o2 of u) {
          let i = r2.override[o2];
          this._applyUnknownHandler(o2, i, t8, (s2, a) => {
            let c2 = this._utils.schemas[s2];
            this._applyValidation(a, s2, c2), t8[s2] = a;
          });
        }
      }
    }
  }
};
var Ut2;
function lo2(e2, t8, { logger: r2 = false, isCLI: n2 = false, passThrough: u = false, FlagSchema: o2, descriptor: i } = {}) {
  if (n2) {
    if (!o2) throw new Error("'FlagSchema' option is required.");
    if (!i) throw new Error("'descriptor' option is required.");
  } else i = re2;
  let s2 = u ? Array.isArray(u) ? (l2, F) => u.includes(l2) ? { [l2]: F } : void 0 : (l2, F) => ({ [l2]: F }) : (l2, F, f) => {
    let { _: d2, ...m } = f.schemas;
    return et2(l2, F, { ...f, schemas: m });
  }, a = Fo(t8, { isCLI: n2, FlagSchema: o2 }), c2 = new Dt2(a, { logger: r2, unknown: s2, descriptor: i }), D = r2 !== false;
  D && Ut2 && (c2._hasDeprecationWarned = Ut2);
  let p = c2.normalize(e2);
  return D && (Ut2 = c2._hasDeprecationWarned), p;
}
function Fo(e2, { isCLI: t8, FlagSchema: r2 }) {
  let n2 = [];
  t8 && n2.push(rt2.create({ name: "_" }));
  for (let u of e2) n2.push(po2(u, { isCLI: t8, optionInfos: e2, FlagSchema: r2 })), u.alias && t8 && n2.push(tt2.create({ name: u.alias, sourceName: u.name }));
  return n2;
}
function po2(e2, { isCLI: t8, optionInfos: r2, FlagSchema: n2 }) {
  let { name: u } = e2, o2 = { name: u }, i, s2 = {};
  switch (e2.type) {
    case "int":
      i = at2, t8 && (o2.preprocess = Number);
      break;
    case "string":
      i = Ie2;
      break;
    case "choice":
      i = it2, o2.choices = e2.choices.map((a) => a != null && a.redirect ? { ...a, redirect: { to: { key: e2.name, value: a.redirect } } } : a);
      break;
    case "boolean":
      i = ut2;
      break;
    case "flag":
      i = n2, o2.flags = r2.flatMap((a) => [a.alias, a.description && a.name, a.oppositeDescription && `no-${a.name}`].filter(Boolean));
      break;
    case "path":
      i = Ie2;
      break;
    default:
      throw new Error(`Unexpected type ${e2.type}`);
  }
  if (e2.exception ? o2.validate = (a, c2, D) => e2.exception(a) || c2.validate(a, D) : o2.validate = (a, c2, D) => a === void 0 || c2.validate(a, D), e2.redirect && (s2.redirect = (a) => a ? { to: typeof e2.redirect == "string" ? e2.redirect : { key: e2.redirect.option, value: e2.redirect.value } } : void 0), e2.deprecated && (s2.deprecated = true), t8 && !e2.array) {
    let a = o2.preprocess || ((c2) => c2);
    o2.preprocess = (c2, D, p) => D.preprocess(a(Array.isArray(c2) ? y(false, c2, -1) : c2), p);
  }
  return e2.array ? nt2.create({ ...t8 ? { preprocess: (a) => Array.isArray(a) ? a : [a] } : {}, ...s2, valueSchema: i.create(o2) }) : i.create({ ...o2, ...s2 });
}
var kn2 = lo2;
var mo = (e2, t8, r2) => {
  if (!(e2 && t8 == null)) {
    if (t8.findLast) return t8.findLast(r2);
    for (let n2 = t8.length - 1; n2 >= 0; n2--) {
      let u = t8[n2];
      if (r2(u, n2, t8)) return u;
    }
  }
};
var Vt2 = mo;
function $t2(e2, t8) {
  if (!t8) throw new Error("parserName is required.");
  let r2 = Vt2(false, e2, (u) => u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, t8));
  if (r2) return r2;
  let n2 = `Couldn't resolve parser "${t8}".`;
  throw n2 += " Plugins must be explicitly added to the standalone bundle.", new ve2(n2);
}
function Sn2(e2, t8) {
  if (!t8) throw new Error("astFormat is required.");
  let r2 = Vt2(false, e2, (u) => u.printers && Object.prototype.hasOwnProperty.call(u.printers, t8));
  if (r2) return r2;
  let n2 = `Couldn't find plugin for AST format "${t8}".`;
  throw n2 += " Plugins must be explicitly added to the standalone bundle.", new ve2(n2);
}
function Re2({ plugins: e2, parser: t8 }) {
  let r2 = $t2(e2, t8);
  return Wt2(r2, t8);
}
function Wt2(e2, t8) {
  let r2 = e2.parsers[t8];
  return typeof r2 == "function" ? r2() : r2;
}
function Tn2(e2, t8) {
  let r2 = e2.printers[t8];
  return typeof r2 == "function" ? r2() : r2;
}
var Nn2 = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
async function Eo(e2, t8 = {}) {
  var p;
  let r2 = { ...e2 };
  if (!r2.parser) if (r2.filepath) {
    if (r2.parser = on2(r2, { physicalFile: r2.filepath }), !r2.parser) throw new Le2(`No parser could be inferred for file "${r2.filepath}".`);
  } else throw new Le2("No parser and no file path given, couldn't infer a parser.");
  let n2 = Qe2({ plugins: e2.plugins, showDeprecated: true }).options, u = { ...Nn2, ...Object.fromEntries(n2.filter((l2) => l2.default !== void 0).map((l2) => [l2.name, l2.default])) }, o2 = $t2(r2.plugins, r2.parser), i = await Wt2(o2, r2.parser);
  r2.astFormat = i.astFormat, r2.locEnd = i.locEnd, r2.locStart = i.locStart;
  let s2 = (p = o2.printers) != null && p[i.astFormat] ? o2 : Sn2(r2.plugins, i.astFormat), a = await Tn2(s2, i.astFormat);
  r2.printer = a;
  let c2 = s2.defaultOptions ? Object.fromEntries(Object.entries(s2.defaultOptions).filter(([, l2]) => l2 !== void 0)) : {}, D = { ...u, ...c2 };
  for (let [l2, F] of Object.entries(D)) (r2[l2] === null || r2[l2] === void 0) && (r2[l2] = F);
  return r2.parser === "json" && (r2.trailingComma = "none"), kn2(r2, n2, { passThrough: Object.keys(Nn2), ...t8 });
}
var ne2 = Eo;
var vn2 = gu(Pn2(), 1);
async function yo(e2, t8) {
  let r2 = await Re2(t8), n2 = r2.preprocess ? r2.preprocess(e2, t8) : e2;
  t8.originalText = n2;
  let u;
  try {
    u = await r2.parse(n2, t8, t8);
  } catch (o2) {
    Ao(o2, e2);
  }
  return { text: n2, ast: u };
}
function Ao(e2, t8) {
  let { loc: r2 } = e2;
  if (r2) {
    let n2 = (0, vn2.codeFrameColumns)(t8, r2, { highlightCode: true });
    throw e2.message += `
` + n2, e2.codeFrame = n2, e2;
  }
  throw e2;
}
var De2 = yo;
async function Ln2(e2, t8, r2, n2, u) {
  let { embeddedLanguageFormatting: o2, printer: { embed: i, hasPrettierIgnore: s2 = () => false, getVisitorKeys: a } } = r2;
  if (!i || o2 !== "auto") return;
  if (i.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
  let c2 = J2(i.getVisitorKeys ?? a), D = [];
  F();
  let p = e2.stack;
  for (let { print: f, node: d2, pathStack: m } of D) try {
    e2.stack = m;
    let C = await f(l2, t8, e2, r2);
    C && u.set(d2, C);
  } catch (C) {
    if (globalThis.PRETTIER_DEBUG) throw C;
  }
  e2.stack = p;
  function l2(f, d2) {
    return Bo(f, d2, r2, n2);
  }
  function F() {
    let { node: f } = e2;
    if (f === null || typeof f != "object" || s2(e2)) return;
    for (let m of c2(f)) Array.isArray(f[m]) ? e2.each(F, m) : e2.call(F, m);
    let d2 = i(e2, r2);
    if (d2) {
      if (typeof d2 == "function") {
        D.push({ print: d2, node: f, pathStack: [...e2.stack] });
        return;
      }
      u.set(f, d2);
    }
  }
}
async function Bo(e2, t8, r2, n2) {
  let u = await ne2({ ...r2, ...t8, parentParser: r2.parser, originalText: e2, cursorOffset: void 0, rangeStart: void 0, rangeEnd: void 0 }, { passThrough: true }), { ast: o2 } = await De2(e2, u), i = await n2(o2, u);
  return $e(i);
}
function _o(e2, t8) {
  let { originalText: r2, [Symbol.for("comments")]: n2, locStart: u, locEnd: o2, [Symbol.for("printedComments")]: i } = t8, { node: s2 } = e2, a = u(s2), c2 = o2(s2);
  for (let D of n2) u(D) >= a && o2(D) <= c2 && i.add(D);
  return r2.slice(a, c2);
}
var In2 = _o;
async function Ye2(e2, t8) {
  ({ ast: e2 } = await Gt2(e2, t8));
  let r2 = /* @__PURE__ */ new Map(), n2 = new Or2(e2), u = Kr2(t8), o2 = /* @__PURE__ */ new Map();
  await Ln2(n2, s2, t8, Ye2, o2);
  let i = await Rn2(n2, t8, s2, void 0, o2);
  if (Gr2(t8), t8.cursorOffset >= 0) {
    if (t8.nodeAfterCursor && !t8.nodeBeforeCursor) return [X2, i];
    if (t8.nodeBeforeCursor && !t8.nodeAfterCursor) return [i, X2];
  }
  return i;
  function s2(c2, D) {
    return c2 === void 0 || c2 === n2 ? a(D) : Array.isArray(c2) ? n2.call(() => a(D), ...c2) : n2.call(() => a(D), c2);
  }
  function a(c2) {
    u(n2);
    let D = n2.node;
    if (D == null) return "";
    let p = D && typeof D == "object" && c2 === void 0;
    if (p && r2.has(D)) return r2.get(D);
    let l2 = Rn2(n2, t8, s2, c2, o2);
    return p && r2.set(D, l2), l2;
  }
}
function Rn2(e2, t8, r2, n2, u) {
  var a;
  let { node: o2 } = e2, { printer: i } = t8, s2;
  switch ((a = i.hasPrettierIgnore) != null && a.call(i, e2) ? s2 = In2(e2, t8) : u.has(o2) ? s2 = u.get(o2) : s2 = i.print(e2, t8, r2, n2), o2) {
    case t8.cursorNode:
      s2 = Fe2(s2, (c2) => [X2, c2, X2]);
      break;
    case t8.nodeBeforeCursor:
      s2 = Fe2(s2, (c2) => [c2, X2]);
      break;
    case t8.nodeAfterCursor:
      s2 = Fe2(s2, (c2) => [X2, c2]);
      break;
  }
  return i.printComment && (!i.willPrintOwnComments || !i.willPrintOwnComments(e2, t8)) && (s2 = Mr(e2, s2, t8)), s2;
}
async function Gt2(e2, t8) {
  let r2 = e2.comments ?? [];
  t8[Symbol.for("comments")] = r2, t8[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), Vr(e2, t8);
  let { printer: { preprocess: n2 } } = t8;
  return e2 = n2 ? await n2(e2, t8) : e2, { ast: e2, comments: r2 };
}
function xo(e2, t8) {
  let { cursorOffset: r2, locStart: n2, locEnd: u } = t8, o2 = J2(t8.printer.getVisitorKeys), i = (F) => n2(F) <= r2 && u(F) >= r2, s2 = e2, a = [e2];
  for (let F of Lr2(e2, { getVisitorKeys: o2, filter: i })) a.push(F), s2 = F;
  if (Ir2(s2, { getVisitorKeys: o2 })) return { cursorNode: s2 };
  let c2, D, p = -1, l2 = Number.POSITIVE_INFINITY;
  for (; a.length > 0 && (c2 === void 0 || D === void 0); ) {
    s2 = a.pop();
    let F = c2 !== void 0, f = D !== void 0;
    for (let d2 of Ce2(s2, { getVisitorKeys: o2 })) {
      if (!F) {
        let m = u(d2);
        m <= r2 && m > p && (c2 = d2, p = m);
      }
      if (!f) {
        let m = n2(d2);
        m >= r2 && m < l2 && (D = d2, l2 = m);
      }
    }
  }
  return { nodeBeforeCursor: c2, nodeAfterCursor: D };
}
var Kt2 = xo;
function wo(e2, t8) {
  let { printer: { massageAstNode: r2, getVisitorKeys: n2 } } = t8;
  if (!r2) return e2;
  let u = J2(n2), o2 = r2.ignoredProperties ?? /* @__PURE__ */ new Set();
  return i(e2);
  function i(s2, a) {
    if (!(s2 !== null && typeof s2 == "object")) return s2;
    if (Array.isArray(s2)) return s2.map((l2) => i(l2, a)).filter(Boolean);
    let c2 = {}, D = new Set(u(s2));
    for (let l2 in s2) !Object.prototype.hasOwnProperty.call(s2, l2) || o2.has(l2) || (D.has(l2) ? c2[l2] = i(s2[l2], s2) : c2[l2] = s2[l2]);
    let p = r2(s2, c2, a);
    if (p !== null) return p ?? c2;
  }
}
var Yn2 = wo;
var bo = (e2, t8, r2) => {
  if (!(e2 && t8 == null)) {
    if (t8.findLastIndex) return t8.findLastIndex(r2);
    for (let n2 = t8.length - 1; n2 >= 0; n2--) {
      let u = t8[n2];
      if (r2(u, n2, t8)) return n2;
    }
    return -1;
  }
};
var jn2 = bo;
var ko = ({ parser: e2 }) => e2 === "json" || e2 === "json5" || e2 === "jsonc" || e2 === "json-stringify";
function So(e2, t8) {
  let r2 = [e2.node, ...e2.parentNodes], n2 = /* @__PURE__ */ new Set([t8.node, ...t8.parentNodes]);
  return r2.find((u) => $n2.has(u.type) && n2.has(u));
}
function Un2(e2) {
  let t8 = jn2(false, e2, (r2) => r2.type !== "Program" && r2.type !== "File");
  return t8 === -1 ? e2 : e2.slice(0, t8 + 1);
}
function To(e2, t8, { locStart: r2, locEnd: n2 }) {
  let u = e2.node, o2 = t8.node;
  if (u === o2) return { startNode: u, endNode: o2 };
  let i = r2(e2.node);
  for (let a of Un2(t8.parentNodes)) if (r2(a) >= i) o2 = a;
  else break;
  let s2 = n2(t8.node);
  for (let a of Un2(e2.parentNodes)) {
    if (n2(a) <= s2) u = a;
    else break;
    if (u === o2) break;
  }
  return { startNode: u, endNode: o2 };
}
function zt2(e2, t8, r2, n2, u = [], o2) {
  let { locStart: i, locEnd: s2 } = r2, a = i(e2), c2 = s2(e2);
  if (!(t8 > c2 || t8 < a || o2 === "rangeEnd" && t8 === a || o2 === "rangeStart" && t8 === c2)) {
    for (let D of Xe2(e2, r2)) {
      let p = zt2(D, t8, r2, n2, [e2, ...u], o2);
      if (p) return p;
    }
    if (!n2 || n2(e2, u[0])) return { node: e2, parentNodes: u };
  }
}
function No(e2, t8) {
  return t8 !== "DeclareExportDeclaration" && e2 !== "TypeParameterDeclaration" && (e2 === "Directive" || e2 === "TypeAlias" || e2 === "TSExportAssignment" || e2.startsWith("Declare") || e2.startsWith("TSDeclare") || e2.endsWith("Statement") || e2.endsWith("Declaration"));
}
var $n2 = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);
var Oo2 = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function Vn2(e2, t8, r2) {
  if (!t8) return false;
  switch (e2.parser) {
    case "flow":
    case "hermes":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "oxc":
    case "oxc-ts":
    case "__babel_estree":
      return No(t8.type, r2 == null ? void 0 : r2.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return $n2.has(t8.type);
    case "graphql":
      return Oo2.has(t8.kind);
    case "vue":
      return t8.tag !== "root";
  }
  return false;
}
function Wn2(e2, t8, r2) {
  let { rangeStart: n2, rangeEnd: u, locStart: o2, locEnd: i } = t8;
  Oe2.ok(u > n2);
  let s2 = e2.slice(n2, u).search(/\S/u), a = s2 === -1;
  if (!a) for (n2 += s2; u > n2 && !/\S/u.test(e2[u - 1]); --u) ;
  let c2 = zt2(r2, n2, t8, (F, f) => Vn2(t8, F, f), [], "rangeStart"), D = a ? c2 : zt2(r2, u, t8, (F) => Vn2(t8, F), [], "rangeEnd");
  if (!c2 || !D) return { rangeStart: 0, rangeEnd: 0 };
  let p, l2;
  if (ko(t8)) {
    let F = So(c2, D);
    p = F, l2 = F;
  } else ({ startNode: p, endNode: l2 } = To(c2, D, t8));
  return { rangeStart: Math.min(o2(p), o2(l2)), rangeEnd: Math.max(i(p), i(l2)) };
}
var zn2 = "\uFEFF";
var Mn2 = Symbol("cursor");
async function Hn2(e2, t8, r2 = 0) {
  if (!e2 || e2.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: n2, text: u } = await De2(e2, t8);
  t8.cursorOffset >= 0 && (t8 = { ...t8, ...Kt2(n2, t8) });
  let o2 = await Ye2(n2, t8, r2);
  r2 > 0 && (o2 = Ge3([z2, o2], r2, t8.tabWidth));
  let i = me2(o2, t8);
  if (r2 > 0) {
    let a = i.formatted.trim();
    i.cursorNodeStart !== void 0 && (i.cursorNodeStart -= i.formatted.indexOf(a), i.cursorNodeStart < 0 && (i.cursorNodeStart = 0, i.cursorNodeText = i.cursorNodeText.trimStart()), i.cursorNodeStart + i.cursorNodeText.length > a.length && (i.cursorNodeText = i.cursorNodeText.trimEnd())), i.formatted = a + xe2(t8.endOfLine);
  }
  let s2 = t8[Symbol.for("comments")];
  if (t8.cursorOffset >= 0) {
    let a, c2, D, p;
    if ((t8.cursorNode || t8.nodeBeforeCursor || t8.nodeAfterCursor) && i.cursorNodeText) if (D = i.cursorNodeStart, p = i.cursorNodeText, t8.cursorNode) a = t8.locStart(t8.cursorNode), c2 = u.slice(a, t8.locEnd(t8.cursorNode));
    else {
      if (!t8.nodeBeforeCursor && !t8.nodeAfterCursor) throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
      a = t8.nodeBeforeCursor ? t8.locEnd(t8.nodeBeforeCursor) : 0;
      let C = t8.nodeAfterCursor ? t8.locStart(t8.nodeAfterCursor) : u.length;
      c2 = u.slice(a, C);
    }
    else a = 0, c2 = u, D = 0, p = i.formatted;
    let l2 = t8.cursorOffset - a;
    if (c2 === p) return { formatted: i.formatted, cursorOffset: D + l2, comments: s2 };
    let F = c2.split("");
    F.splice(l2, 0, Mn2);
    let f = p.split(""), d2 = Et2(F, f), m = D;
    for (let C of d2) if (C.removed) {
      if (C.value.includes(Mn2)) break;
    } else m += C.count;
    return { formatted: i.formatted, cursorOffset: m, comments: s2 };
  }
  return { formatted: i.formatted, cursorOffset: -1, comments: s2 };
}
async function Po(e2, t8) {
  let { ast: r2, text: n2 } = await De2(e2, t8), { rangeStart: u, rangeEnd: o2 } = Wn2(n2, t8, r2), i = n2.slice(u, o2), s2 = Math.min(u, n2.lastIndexOf(`
`, u) + 1), a = n2.slice(s2, u).match(/^\s*/u)[0], c2 = Ee2(a, t8.tabWidth), D = await Hn2(i, { ...t8, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t8.cursorOffset > u && t8.cursorOffset <= o2 ? t8.cursorOffset - u : -1, endOfLine: "lf" }, c2), p = D.formatted.trimEnd(), { cursorOffset: l2 } = t8;
  l2 > o2 ? l2 += p.length - i.length : D.cursorOffset >= 0 && (l2 = D.cursorOffset + u);
  let F = n2.slice(0, u) + p + n2.slice(o2);
  if (t8.endOfLine !== "lf") {
    let f = xe2(t8.endOfLine);
    l2 >= 0 && f === `\r
` && (l2 += Ct2(F.slice(0, l2), `
`)), F = te(false, F, `
`, f);
  }
  return { formatted: F, cursorOffset: l2, comments: D.comments };
}
function Ht2(e2, t8, r2) {
  return typeof t8 != "number" || Number.isNaN(t8) || t8 < 0 || t8 > e2.length ? r2 : t8;
}
function Gn2(e2, t8) {
  let { cursorOffset: r2, rangeStart: n2, rangeEnd: u } = t8;
  return r2 = Ht2(e2, r2, -1), n2 = Ht2(e2, n2, 0), u = Ht2(e2, u, e2.length), { ...t8, cursorOffset: r2, rangeStart: n2, rangeEnd: u };
}
function Jn2(e2, t8) {
  let { cursorOffset: r2, rangeStart: n2, rangeEnd: u, endOfLine: o2 } = Gn2(e2, t8), i = e2.charAt(0) === zn2;
  if (i && (e2 = e2.slice(1), r2--, n2--, u--), o2 === "auto" && (o2 = nr2(e2)), e2.includes("\r")) {
    let s2 = (a) => Ct2(e2.slice(0, Math.max(a, 0)), `\r
`);
    r2 -= s2(r2), n2 -= s2(n2), u -= s2(u), e2 = ur2(e2);
  }
  return { hasBOM: i, text: e2, options: Gn2(e2, { ...t8, cursorOffset: r2, rangeStart: n2, rangeEnd: u, endOfLine: o2 }) };
}
async function Kn2(e2, t8) {
  let r2 = await Re2(t8);
  return !r2.hasPragma || r2.hasPragma(e2);
}
async function vo(e2, t8) {
  var n2;
  let r2 = await Re2(t8);
  return (n2 = r2.hasIgnorePragma) == null ? void 0 : n2.call(r2, e2);
}
async function Jt(e2, t8) {
  let { hasBOM: r2, text: n2, options: u } = Jn2(e2, await ne2(t8));
  if (u.rangeStart >= u.rangeEnd && n2 !== "" || u.requirePragma && !await Kn2(n2, u) || u.checkIgnorePragma && await vo(n2, u)) return { formatted: e2, cursorOffset: t8.cursorOffset, comments: [] };
  let o2;
  return u.rangeStart > 0 || u.rangeEnd < n2.length ? o2 = await Po(n2, u) : (!u.requirePragma && u.insertPragma && u.printer.insertPragma && !await Kn2(n2, u) && (n2 = u.printer.insertPragma(n2)), o2 = await Hn2(n2, u)), r2 && (o2.formatted = zn2 + o2.formatted, o2.cursorOffset >= 0 && o2.cursorOffset++), o2;
}
async function qn2(e2, t8, r2) {
  let { text: n2, options: u } = Jn2(e2, await ne2(t8)), o2 = await De2(n2, u);
  return r2 && (r2.preprocessForPrint && (o2.ast = await Gt2(o2.ast, u)), r2.massage && (o2.ast = Yn2(o2.ast, u))), o2;
}
async function Xn2(e2, t8) {
  t8 = await ne2(t8);
  let r2 = await Ye2(e2, t8);
  return me2(r2, t8);
}
async function Qn2(e2, t8) {
  let r2 = wr2(e2), { formatted: n2 } = await Jt(r2, { ...t8, parser: "__js_expression" });
  return n2;
}
async function Zn2(e2, t8) {
  t8 = await ne2(t8);
  let { ast: r2 } = await De2(e2, t8);
  return t8.cursorOffset >= 0 && (t8 = { ...t8, ...Kt2(r2, t8) }), Ye2(r2, t8);
}
async function eu2(e2, t8) {
  return me2(e2, await ne2(t8));
}
var qt2 = {};
dt(qt2, { builders: () => Io2, printer: () => Ro2, utils: () => Yo2 });
var Io2 = { join: ke2, line: Me2, softline: _r2, hardline: z2, literalline: We, group: At2, conditionalGroup: Cr2, fill: hr2, lineSuffix: Se2, lineSuffixBoundary: Ar2, cursor: X2, breakParent: pe2, ifBreak: gr2, trim: Br2, indent: ie2, indentIfBreak: yr2, align: oe, addAlignmentToDoc: Ge3, markAsRoot: mr2, dedentToRoot: dr2, dedent: Er2, hardlineWithoutBreakParent: Te2, literallineWithoutBreakParent: Bt2, label: xr2, concat: (e2) => e2 };
var Ro2 = { printDocToString: me2 };
var Yo2 = { willBreak: Dr2, traverseDoc: le2, findInDoc: Ve2, mapDoc: be2, removeLines: fr2, stripTrailingHardline: $e, replaceEndOfLine: lr2, canBreak: Fr2 };
var tu2 = "3.6.2";
var Qt2 = {};
dt(Qt2, { addDanglingComment: () => ee2, addLeadingComment: () => se2, addTrailingComment: () => ae2, getAlignmentSize: () => Ee2, getIndentSize: () => ru2, getMaxContinuousCount: () => nu2, getNextNonSpaceNonCommentCharacter: () => uu2, getNextNonSpaceNonCommentCharacterIndex: () => Xo2, getPreferredQuote: () => iu2, getStringWidth: () => Ne2, hasNewline: () => G2, hasNewlineInRange: () => su2, hasSpaces: () => au2, isNextLineEmpty: () => ti2, isNextLineEmptyAfterIndex: () => ct2, isPreviousLineEmpty: () => Zo2, makeString: () => Du, skip: () => he2, skipEverythingButNewLine: () => Je2, skipInlineComment: () => ye, skipNewline: () => U, skipSpaces: () => T2, skipToLineEnd: () => He2, skipTrailingComment: () => Ae2, skipWhitespace: () => Rr2 });
function jo2(e2, t8) {
  if (t8 === false) return false;
  if (e2.charAt(t8) === "/" && e2.charAt(t8 + 1) === "*") {
    for (let r2 = t8 + 2; r2 < e2.length; ++r2) if (e2.charAt(r2) === "*" && e2.charAt(r2 + 1) === "/") return r2 + 2;
  }
  return t8;
}
var ye = jo2;
function Uo2(e2, t8) {
  return t8 === false ? false : e2.charAt(t8) === "/" && e2.charAt(t8 + 1) === "/" ? Je2(e2, t8) : t8;
}
var Ae2 = Uo2;
function Vo2(e2, t8) {
  let r2 = null, n2 = t8;
  for (; n2 !== r2; ) r2 = n2, n2 = T2(e2, n2), n2 = ye(e2, n2), n2 = Ae2(e2, n2), n2 = U(e2, n2);
  return n2;
}
var je2 = Vo2;
function $o2(e2, t8) {
  let r2 = null, n2 = t8;
  for (; n2 !== r2; ) r2 = n2, n2 = He2(e2, n2), n2 = ye(e2, n2), n2 = T2(e2, n2);
  return n2 = Ae2(e2, n2), n2 = U(e2, n2), n2 !== false && G2(e2, n2);
}
var ct2 = $o2;
function Wo2(e2, t8) {
  let r2 = e2.lastIndexOf(`
`);
  return r2 === -1 ? 0 : Ee2(e2.slice(r2 + 1).match(/^[\t ]*/u)[0], t8);
}
var ru2 = Wo2;
function Xt2(e2) {
  if (typeof e2 != "string") throw new TypeError("Expected a string");
  return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Mo2(e2, t8) {
  let r2 = e2.match(new RegExp(`(${Xt2(t8)})+`, "gu"));
  return r2 === null ? 0 : r2.reduce((n2, u) => Math.max(n2, u.length / t8.length), 0);
}
var nu2 = Mo2;
function Go2(e2, t8) {
  let r2 = je2(e2, t8);
  return r2 === false ? "" : e2.charAt(r2);
}
var uu2 = Go2;
var ft2 = "'";
var ou2 = '"';
function Ko2(e2, t8) {
  let r2 = t8 === true || t8 === ft2 ? ft2 : ou2, n2 = r2 === ft2 ? ou2 : ft2, u = 0, o2 = 0;
  for (let i of e2) i === r2 ? u++ : i === n2 && o2++;
  return u > o2 ? n2 : r2;
}
var iu2 = Ko2;
function zo2(e2, t8, r2) {
  for (let n2 = t8; n2 < r2; ++n2) if (e2.charAt(n2) === `
`) return true;
  return false;
}
var su2 = zo2;
function Ho2(e2, t8, r2 = {}) {
  return T2(e2, r2.backwards ? t8 - 1 : t8, r2) !== t8;
}
var au2 = Ho2;
function Jo2(e2, t8, r2) {
  let n2 = t8 === '"' ? "'" : '"', o2 = te(false, e2, /\\(.)|(["'])/gsu, (i, s2, a) => s2 === n2 ? s2 : a === t8 ? "\\" + a : a || (r2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s2) ? s2 : "\\" + s2));
  return t8 + o2 + t8;
}
var Du = Jo2;
function qo2(e2, t8, r2) {
  return je2(e2, r2(t8));
}
function Xo2(e2, t8) {
  return arguments.length === 2 || typeof t8 == "number" ? je2(e2, t8) : qo2(...arguments);
}
function Qo2(e2, t8, r2) {
  return Pe2(e2, r2(t8));
}
function Zo2(e2, t8) {
  return arguments.length === 2 || typeof t8 == "number" ? Pe2(e2, t8) : Qo2(...arguments);
}
function ei(e2, t8, r2) {
  return ct2(e2, r2(t8));
}
function ti2(e2, t8) {
  return arguments.length === 2 || typeof t8 == "number" ? ct2(e2, t8) : ei(...arguments);
}
function ce2(e2, t8 = 1) {
  return async (...r2) => {
    let n2 = r2[t8] ?? {}, u = n2.plugins ?? [];
    return r2[t8] = { ...n2, plugins: Array.isArray(u) ? u : Object.values(u) }, e2(...r2);
  };
}
var cu = ce2(Jt);
async function fu(e2, t8) {
  let { formatted: r2 } = await cu(e2, { ...t8, cursorOffset: -1 });
  return r2;
}
async function ri2(e2, t8) {
  return await fu(e2, t8) === e2;
}
var ni2 = ce2(Qe2, 0);
var ui = { parse: ce2(qn2), formatAST: ce2(Xn2), formatDoc: ce2(Qn2), printToDoc: ce2(Zn2), printDocToString: ce2(eu2) };

// node_modules/domelementtype/lib/esm/index.js
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var Root = ElementType.Root;
var Text = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;

// node_modules/domhandler/lib/esm/node.js
var Node = class {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
};
var DataNode = class extends Node {
  /**
   * @param data The content of the data node
   */
  constructor(data) {
    super();
    this.data = data;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data) {
    this.data = data;
  }
};
var Text2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
};
var Comment2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
};
var ProcessingInstruction = class extends DataNode {
  constructor(name2, data) {
    super(data);
    this.name = name2;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
};
var NodeWithChildren = class extends Node {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children) {
    super();
    this.children = children;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a4;
    return (_a4 = this.children[0]) !== null && _a4 !== void 0 ? _a4 : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children) {
    this.children = children;
  }
};
var CDATA2 = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
};
var Document = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
};
var Element = class extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name2, attribs, children = [], type = name2 === "script" ? ElementType.Script : name2 === "style" ? ElementType.Style : ElementType.Tag) {
    super(children);
    this.name = name2;
    this.attribs = attribs;
    this.type = type;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name2) {
    this.name = name2;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name2) => {
      var _a4, _b;
      return {
        name: name2,
        value: this.attribs[name2],
        namespace: (_a4 = this["x-attribsNamespace"]) === null || _a4 === void 0 ? void 0 : _a4[name2],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
      };
    });
  }
};
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text2(node.data);
  } else if (isComment(node)) {
    result = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Element(node.name, { ...node.attribs }, children);
    children.forEach((child) => child.parent = clone);
    if (node.namespace != null) {
      clone.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new CDATA2(children);
    children.forEach((child) => child.parent = clone);
    result = clone;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone = new Document(children);
    children.forEach((child) => child.parent = clone);
    if (node["x-mode"]) {
      clone["x-mode"] = node["x-mode"];
    }
    result = clone;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}

// node_modules/domhandler/lib/esm/index.js
var defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var DomHandler = class {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = void 0;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error) {
    this.handleCallback(error);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name2, attribs) {
    const type = this.options.xmlMode ? ElementType.Tag : void 0;
    const element = new Element(name2, attribs, void 0, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new Text2(data);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node = new Comment2(data);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text = new Text2("");
    const node = new CDATA2([text]);
    this.addNode(node);
    text.parent = node;
    this.lastNode = text;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name2, data) {
    const node = new ProcessingInstruction(name2, data);
    this.addNode(node);
  }
  handleCallback(error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  }
  addNode(node) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent.children.push(node);
    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }
    node.parent = parent;
    this.lastNode = null;
  }
};

// node_modules/leac/lib/leac.mjs
var e = /\n/g;
function n(n2) {
  const o2 = [...n2.matchAll(e)].map(((e2) => e2.index || 0));
  o2.unshift(-1);
  const s2 = t7(o2, 0, o2.length);
  return (e2) => r(s2, e2);
}
function t7(e2, n2, r2) {
  if (r2 - n2 == 1) return { offset: e2[n2], index: n2 + 1 };
  const o2 = Math.ceil((n2 + r2) / 2), s2 = t7(e2, n2, o2), l2 = t7(e2, o2, r2);
  return { offset: s2.offset, low: s2, high: l2 };
}
function r(e2, n2) {
  return (function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "index");
  })(e2) ? { line: e2.index, column: n2 - e2.offset } : r(e2.high.offset < n2 ? e2.high : e2.low, n2);
}
function o(e2, t8 = "", r2 = {}) {
  const o2 = "string" != typeof t8 ? t8 : r2, l2 = "string" == typeof t8 ? t8 : "", c2 = e2.map(s), f = !!o2.lineNumbers;
  return function(e3, t9 = 0) {
    const r3 = f ? n(e3) : () => ({ line: 0, column: 0 });
    let o3 = t9;
    const s2 = [];
    e: for (; o3 < e3.length; ) {
      let n2 = false;
      for (const t10 of c2) {
        t10.regex.lastIndex = o3;
        const c3 = t10.regex.exec(e3);
        if (c3 && c3[0].length > 0) {
          if (!t10.discard) {
            const e4 = r3(o3), n3 = "string" == typeof t10.replace ? c3[0].replace(new RegExp(t10.regex.source, t10.regex.flags), t10.replace) : c3[0];
            s2.push({ state: l2, name: t10.name, text: n3, offset: o3, len: c3[0].length, line: e4.line, column: e4.column });
          }
          if (o3 = t10.regex.lastIndex, n2 = true, t10.push) {
            const n3 = t10.push(e3, o3);
            s2.push(...n3.tokens), o3 = n3.offset;
          }
          if (t10.pop) break e;
          break;
        }
      }
      if (!n2) break;
    }
    return { tokens: s2, offset: o3, complete: e3.length <= o3 };
  };
}
function s(e2, n2) {
  return { ...e2, regex: l(e2, n2) };
}
function l(e2, n2) {
  if (0 === e2.name.length) throw new Error(`Rule #${n2} has empty name, which is not allowed.`);
  if ((function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "regex");
  })(e2)) return (function(e3) {
    if (e3.global) throw new Error(`Regular expression /${e3.source}/${e3.flags} contains the global flag, which is not allowed.`);
    return e3.sticky ? e3 : new RegExp(e3.source, e3.flags + "y");
  })(e2.regex);
  if ((function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "str");
  })(e2)) {
    if (0 === e2.str.length) throw new Error(`Rule #${n2} ("${e2.name}") has empty "str" property, which is not allowed.`);
    return new RegExp(c(e2.str), "y");
  }
  return new RegExp(c(e2.name), "y");
}
function c(e2) {
  return e2.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g, "\\$&");
}

// node_modules/peberminta/lib/core.mjs
function token(onToken, onEnd) {
  return (data, i) => {
    let position = i;
    let value = void 0;
    if (i < data.tokens.length) {
      value = onToken(data.tokens[i], data, i);
      if (value !== void 0) {
        position++;
      }
    } else {
      onEnd?.(data, i);
    }
    return value === void 0 ? { matched: false } : {
      matched: true,
      position,
      value
    };
  };
}
function mapInner(r2, f) {
  return r2.matched ? {
    matched: true,
    position: r2.position,
    value: f(r2.value, r2.position)
  } : r2;
}
function mapOuter(r2, f) {
  return r2.matched ? f(r2) : r2;
}
function map(p, mapper) {
  return (data, i) => mapInner(p(data, i), (v3, j3) => mapper(v3, data, i, j3));
}
function option(p, def) {
  return (data, i) => {
    const r2 = p(data, i);
    return r2.matched ? r2 : {
      matched: true,
      position: i,
      value: def
    };
  };
}
function choice(...ps3) {
  return (data, i) => {
    for (const p of ps3) {
      const result = p(data, i);
      if (result.matched) {
        return result;
      }
    }
    return { matched: false };
  };
}
function otherwise(pa3, pb) {
  return (data, i) => {
    const r1 = pa3(data, i);
    return r1.matched ? r1 : pb(data, i);
  };
}
function takeWhile(p, test) {
  return (data, i) => {
    const values = [];
    let success = true;
    do {
      const r2 = p(data, i);
      if (r2.matched && test(r2.value, values.length + 1, data, i, r2.position)) {
        values.push(r2.value);
        i = r2.position;
      } else {
        success = false;
      }
    } while (success);
    return {
      matched: true,
      position: i,
      value: values
    };
  };
}
function many(p) {
  return takeWhile(p, () => true);
}
function many1(p) {
  return ab(p, many(p), (head, tail) => [head, ...tail]);
}
function ab(pa3, pb, join) {
  return (data, i) => mapOuter(pa3(data, i), (ma3) => mapInner(pb(data, ma3.position), (vb, j3) => join(ma3.value, vb, data, i, j3)));
}
function left(pa3, pb) {
  return ab(pa3, pb, (va3) => va3);
}
function right(pa3, pb) {
  return ab(pa3, pb, (va3, vb) => vb);
}
function abc(pa3, pb, pc2, join) {
  return (data, i) => mapOuter(pa3(data, i), (ma3) => mapOuter(pb(data, ma3.position), (mb) => mapInner(pc2(data, mb.position), (vc2, j3) => join(ma3.value, mb.value, vc2, data, i, j3))));
}
function middle(pa3, pb, pc2) {
  return abc(pa3, pb, pc2, (ra3, rb) => rb);
}
function all(...ps3) {
  return (data, i) => {
    const result = [];
    let position = i;
    for (const p of ps3) {
      const r1 = p(data, position);
      if (r1.matched) {
        result.push(r1.value);
        position = r1.position;
      } else {
        return { matched: false };
      }
    }
    return {
      matched: true,
      position,
      value: result
    };
  };
}
function flatten(...ps3) {
  return flatten1(all(...ps3));
}
function flatten1(p) {
  return map(p, (vs3) => vs3.flatMap((v3) => v3));
}
function chainReduce(acc, f) {
  return (data, i) => {
    let loop = true;
    let acc1 = acc;
    let pos = i;
    do {
      const r2 = f(acc1, data, pos)(data, pos);
      if (r2.matched) {
        acc1 = r2.value;
        pos = r2.position;
      } else {
        loop = false;
      }
    } while (loop);
    return {
      matched: true,
      position: pos,
      value: acc1
    };
  };
}
function reduceLeft(acc, p, reducer) {
  return chainReduce(acc, (acc2) => map(p, (v3, data, i, j3) => reducer(acc2, v3, data, i, j3)));
}
function leftAssoc2(pLeft, pOper, pRight) {
  return chain(pLeft, (v0) => reduceLeft(v0, ab(pOper, pRight, (f, y2) => [f, y2]), (acc, [f, y2]) => f(acc, y2)));
}
function chain(p, f) {
  return (data, i) => mapOuter(p(data, i), (m1) => f(m1.value, data, i, m1.position)(data, m1.position));
}

// node_modules/parseley/lib/parseley.mjs
var ws2 = `(?:[ \\t\\r\\n\\f]*)`;
var nl = `(?:\\n|\\r\\n|\\r|\\f)`;
var nonascii = `[^\\x00-\\x7F]`;
var unicode = `(?:\\\\[0-9a-f]{1,6}(?:\\r\\n|[ \\n\\r\\t\\f])?)`;
var escape = `(?:\\\\[^\\n\\r\\f0-9a-f])`;
var nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape})`;
var nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape})`;
var name = `(?:${nmchar}+)`;
var ident = `(?:[-]?${nmstart}${nmchar}*)`;
var string1 = `'([^\\n\\r\\f\\\\']|\\\\${nl}|${nonascii}|${unicode}|${escape})*'`;
var string2 = `"([^\\n\\r\\f\\\\"]|\\\\${nl}|${nonascii}|${unicode}|${escape})*"`;
var lexSelector = o([
  { name: "ws", regex: new RegExp(ws2) },
  { name: "hash", regex: new RegExp(`#${name}`, "i") },
  { name: "ident", regex: new RegExp(ident, "i") },
  { name: "str1", regex: new RegExp(string1, "i") },
  { name: "str2", regex: new RegExp(string2, "i") },
  { name: "*" },
  { name: "." },
  { name: "," },
  { name: "[" },
  { name: "]" },
  { name: "=" },
  { name: ">" },
  { name: "|" },
  { name: "+" },
  { name: "~" },
  { name: "^" },
  { name: "$" }
]);
var lexEscapedString = o([
  { name: "unicode", regex: new RegExp(unicode, "i") },
  { name: "escape", regex: new RegExp(escape, "i") },
  { name: "any", regex: new RegExp("[\\s\\S]", "i") }
]);
function sumSpec([a0, a1, a2], [b0, b1, b22]) {
  return [a0 + b0, a1 + b1, a2 + b22];
}
function sumAllSpec(ss3) {
  return ss3.reduce(sumSpec, [0, 0, 0]);
}
var unicodeEscapedSequence_ = token((t8) => t8.name === "unicode" ? String.fromCodePoint(parseInt(t8.text.slice(1), 16)) : void 0);
var escapedSequence_ = token((t8) => t8.name === "escape" ? t8.text.slice(1) : void 0);
var anyChar_ = token((t8) => t8.name === "any" ? t8.text : void 0);
var escapedString_ = map(many(choice(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs3) => cs3.join(""));
function unescape2(escapedString) {
  const lexerResult = lexEscapedString(escapedString);
  const result = escapedString_({ tokens: lexerResult.tokens, options: void 0 }, 0);
  return result.value;
}
function literal(name2) {
  return token((t8) => t8.name === name2 ? true : void 0);
}
var whitespace_ = token((t8) => t8.name === "ws" ? null : void 0);
var optionalWhitespace_ = option(whitespace_, null);
function optionallySpaced(parser) {
  return middle(optionalWhitespace_, parser, optionalWhitespace_);
}
var identifier_ = token((t8) => t8.name === "ident" ? unescape2(t8.text) : void 0);
var hashId_ = token((t8) => t8.name === "hash" ? unescape2(t8.text.slice(1)) : void 0);
var string_ = token((t8) => t8.name.startsWith("str") ? unescape2(t8.text.slice(1, -1)) : void 0);
var namespace_ = left(option(identifier_, ""), literal("|"));
var qualifiedName_ = otherwise(ab(namespace_, identifier_, (ns3, name2) => ({ name: name2, namespace: ns3 })), map(identifier_, (name2) => ({ name: name2, namespace: null })));
var uniSelector_ = otherwise(ab(namespace_, literal("*"), (ns3) => ({ type: "universal", namespace: ns3, specificity: [0, 0, 0] })), map(literal("*"), () => ({ type: "universal", namespace: null, specificity: [0, 0, 0] })));
var tagSelector_ = map(qualifiedName_, ({ name: name2, namespace }) => ({
  type: "tag",
  name: name2,
  namespace,
  specificity: [0, 0, 1]
}));
var classSelector_ = ab(literal("."), identifier_, (fullstop, name2) => ({
  type: "class",
  name: name2,
  specificity: [0, 1, 0]
}));
var idSelector_ = map(hashId_, (name2) => ({
  type: "id",
  name: name2,
  specificity: [1, 0, 0]
}));
var attrModifier_ = token((t8) => {
  if (t8.name === "ident") {
    if (t8.text === "i" || t8.text === "I") {
      return "i";
    }
    if (t8.text === "s" || t8.text === "S") {
      return "s";
    }
  }
  return void 0;
});
var attrValue_ = otherwise(ab(string_, option(right(optionalWhitespace_, attrModifier_), null), (v3, mod) => ({ value: v3, modifier: mod })), ab(identifier_, option(right(whitespace_, attrModifier_), null), (v3, mod) => ({ value: v3, modifier: mod })));
var attrMatcher_ = choice(map(literal("="), () => "="), ab(literal("~"), literal("="), () => "~="), ab(literal("|"), literal("="), () => "|="), ab(literal("^"), literal("="), () => "^="), ab(literal("$"), literal("="), () => "$="), ab(literal("*"), literal("="), () => "*="));
var attrPresenceSelector_ = abc(literal("["), optionallySpaced(qualifiedName_), literal("]"), (lbr, { name: name2, namespace }) => ({
  type: "attrPresence",
  name: name2,
  namespace,
  specificity: [0, 1, 0]
}));
var attrValueSelector_ = middle(literal("["), abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name: name2, namespace }, matcher, { value, modifier }) => ({
  type: "attrValue",
  name: name2,
  namespace,
  matcher,
  value,
  modifier,
  specificity: [0, 1, 0]
})), literal("]"));
var attrSelector_ = otherwise(attrPresenceSelector_, attrValueSelector_);
var typeSelector_ = otherwise(uniSelector_, tagSelector_);
var subclassSelector_ = choice(idSelector_, classSelector_, attrSelector_);
var compoundSelector_ = map(otherwise(flatten(typeSelector_, many(subclassSelector_)), many1(subclassSelector_)), (ss3) => {
  return {
    type: "compound",
    list: ss3,
    specificity: sumAllSpec(ss3.map((s2) => s2.specificity))
  };
});
var combinator_ = choice(map(literal(">"), () => ">"), map(literal("+"), () => "+"), map(literal("~"), () => "~"), ab(literal("|"), literal("|"), () => "||"));
var combinatorSeparator_ = otherwise(optionallySpaced(combinator_), map(whitespace_, () => " "));
var complexSelector_ = leftAssoc2(compoundSelector_, map(combinatorSeparator_, (c2) => (left2, right2) => ({
  type: "compound",
  list: [...right2.list, { type: "combinator", combinator: c2, left: left2, specificity: left2.specificity }],
  specificity: sumSpec(left2.specificity, right2.specificity)
})), compoundSelector_);
var listSelector_ = leftAssoc2(map(complexSelector_, (s2) => ({ type: "list", list: [s2] })), map(optionallySpaced(literal(",")), () => (acc, next) => ({ type: "list", list: [...acc.list, next] })), complexSelector_);
function parse_(parser, str) {
  if (!(typeof str === "string" || str instanceof String)) {
    throw new Error("Expected a selector string. Actual input is not a string!");
  }
  const lexerResult = lexSelector(str);
  if (!lexerResult.complete) {
    throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!
` + prettyPrintPosition(str, lexerResult.offset));
  }
  const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: void 0 }, 0);
  if (!result.matched) {
    throw new Error(`No match for "${str}" input!`);
  }
  if (result.position < lexerResult.tokens.length) {
    const token2 = lexerResult.tokens[result.position];
    throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token2.offset}!
` + prettyPrintPosition(str, token2.offset, token2.len));
  }
  return result.value;
}
function prettyPrintPosition(str, offset, len = 1) {
  return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t8, r2) => t8 ? "\u2409" : r2 ? "\u240D" : "\u240A")}
${"".padEnd(offset)}${"^".repeat(len)}`;
}
function parse1(str) {
  return parse_(complexSelector_, str);
}
function serialize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "universal":
      return _serNs(selector.namespace) + "*";
    case "tag":
      return _serNs(selector.namespace) + _serIdent(selector.name);
    case "class":
      return "." + _serIdent(selector.name);
    case "id":
      return "#" + _serIdent(selector.name);
    case "attrPresence":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;
    case "attrValue":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}"${_serStr(selector.value)}"${selector.modifier ? selector.modifier : ""}]`;
    case "combinator":
      return serialize(selector.left) + selector.combinator;
    case "compound":
      return selector.list.reduce((acc, node) => {
        if (node.type === "combinator") {
          return serialize(node) + acc;
        } else {
          return acc + serialize(node);
        }
      }, "");
    case "list":
      return selector.list.map(serialize).join(",");
  }
}
function _serNs(ns3) {
  return ns3 || ns3 === "" ? _serIdent(ns3) + "|" : "";
}
function _codePoint(char) {
  return `\\${char.codePointAt(0).toString(16)} `;
}
function _serIdent(str) {
  return str.replace(
    /(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\x00-\x7F])|(\x00)|([\x01-\x1f]|\x7f)|([\s\S])/g,
    (m, d1, d2, hy, safe, nl3, ctrl, other) => d1 ? _codePoint(d1) : d2 ? "-" + _codePoint(d2.slice(1)) : hy ? "\\-" : safe ? safe : nl3 ? "\uFFFD" : ctrl ? _codePoint(ctrl) : "\\" + other
  );
}
function _serStr(str) {
  return str.replace(
    /(")|(\\)|(\x00)|([\x01-\x1f]|\x7f)/g,
    (m, dq, bs3, nl3, ctrl) => dq ? '\\"' : bs3 ? "\\\\" : nl3 ? "\uFFFD" : _codePoint(ctrl)
  );
}
function normalize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "compound": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b3) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b3)));
      break;
    }
    case "combinator": {
      normalize(selector.left);
      break;
    }
    case "list": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b3) => serialize(a) < serialize(b3) ? -1 : 1);
      break;
    }
  }
  return selector;
}
function _getSelectorPriority(selector) {
  switch (selector.type) {
    case "universal":
      return [1];
    case "tag":
      return [1];
    case "id":
      return [2];
    case "class":
      return [3, selector.name];
    case "attrPresence":
      return [4, serialize(selector)];
    case "attrValue":
      return [5, serialize(selector)];
    case "combinator":
      return [15, serialize(selector)];
  }
}
function compareSpecificity(a, b3) {
  return _compareArrays(a, b3);
}
function _compareArrays(a, b3) {
  if (!Array.isArray(a) || !Array.isArray(b3)) {
    throw new Error("Arguments must be arrays.");
  }
  const shorter = a.length < b3.length ? a.length : b3.length;
  for (let i = 0; i < shorter; i++) {
    if (a[i] === b3[i]) {
      continue;
    }
    return a[i] < b3[i] ? -1 : 1;
  }
  return a.length - b3.length;
}

// node_modules/selderee/lib/selderee.mjs
var DecisionTree = class {
  constructor(input) {
    this.branches = weave(toAstTerminalPairs(input));
  }
  build(builder) {
    return builder(this.branches);
  }
};
function toAstTerminalPairs(array) {
  const len = array.length;
  const results = new Array(len);
  for (let i = 0; i < len; i++) {
    const [selectorString, val] = array[i];
    const ast = preprocess(parse1(selectorString));
    results[i] = {
      ast,
      terminal: {
        type: "terminal",
        valueContainer: { index: i, value: val, specificity: ast.specificity }
      }
    };
  }
  return results;
}
function preprocess(ast) {
  reduceSelectorVariants(ast);
  normalize(ast);
  return ast;
}
function reduceSelectorVariants(ast) {
  const newList = [];
  ast.list.forEach((sel) => {
    switch (sel.type) {
      case "class":
        newList.push({
          matcher: "~=",
          modifier: null,
          name: "class",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "id":
        newList.push({
          matcher: "=",
          modifier: null,
          name: "id",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "combinator":
        reduceSelectorVariants(sel.left);
        newList.push(sel);
        break;
      case "universal":
        break;
      default:
        newList.push(sel);
        break;
    }
  });
  ast.list = newList;
}
function weave(items) {
  const branches = [];
  while (items.length) {
    const topKind = findTopKey(items, (sel) => true, getSelectorKind);
    const { matches, nonmatches, empty } = breakByKind(items, topKind);
    items = nonmatches;
    if (matches.length) {
      branches.push(branchOfKind(topKind, matches));
    }
    if (empty.length) {
      branches.push(...terminate(empty));
    }
  }
  return branches;
}
function terminate(items) {
  const results = [];
  for (const item of items) {
    const terminal = item.terminal;
    if (terminal.type === "terminal") {
      results.push(terminal);
    } else {
      const { matches, rest } = partition(terminal.cont, (node) => node.type === "terminal");
      matches.forEach((node) => results.push(node));
      if (rest.length) {
        terminal.cont = rest;
        results.push(terminal);
      }
    }
  }
  return results;
}
function breakByKind(items, selectedKind) {
  const matches = [];
  const nonmatches = [];
  const empty = [];
  for (const item of items) {
    const simpsels = item.ast.list;
    if (simpsels.length) {
      const isMatch = simpsels.some((node) => getSelectorKind(node) === selectedKind);
      (isMatch ? matches : nonmatches).push(item);
    } else {
      empty.push(item);
    }
  }
  return { matches, nonmatches, empty };
}
function getSelectorKind(sel) {
  switch (sel.type) {
    case "attrPresence":
      return `attrPresence ${sel.name}`;
    case "attrValue":
      return `attrValue ${sel.name}`;
    case "combinator":
      return `combinator ${sel.combinator}`;
    default:
      return sel.type;
  }
}
function branchOfKind(kind, items) {
  if (kind === "tag") {
    return tagNameBranch(items);
  }
  if (kind.startsWith("attrValue ")) {
    return attrValueBranch(kind.substring(10), items);
  }
  if (kind.startsWith("attrPresence ")) {
    return attrPresenceBranch(kind.substring(13), items);
  }
  if (kind === "combinator >") {
    return combinatorBranch(">", items);
  }
  if (kind === "combinator +") {
    return combinatorBranch("+", items);
  }
  throw new Error(`Unsupported selector kind: ${kind}`);
}
function tagNameBranch(items) {
  const groups = spliceAndGroup(items, (x) => x.type === "tag", (x) => x.name);
  const variants = Object.entries(groups).map(([name2, group]) => ({
    type: "variant",
    value: name2,
    cont: weave(group.items)
  }));
  return {
    type: "tagName",
    variants
  };
}
function attrPresenceBranch(name2, items) {
  for (const item of items) {
    spliceSimpleSelector(item, (x) => x.type === "attrPresence" && x.name === name2);
  }
  return {
    type: "attrPresence",
    name: name2,
    cont: weave(items)
  };
}
function attrValueBranch(name2, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "attrValue" && x.name === name2, (x) => `${x.matcher} ${x.modifier || ""} ${x.value}`);
  const matchers = [];
  for (const group of Object.values(groups)) {
    const sel = group.oneSimpleSelector;
    const predicate = getAttrPredicate(sel);
    const continuation = weave(group.items);
    matchers.push({
      type: "matcher",
      matcher: sel.matcher,
      modifier: sel.modifier,
      value: sel.value,
      predicate,
      cont: continuation
    });
  }
  return {
    type: "attrValue",
    name: name2,
    matchers
  };
}
function getAttrPredicate(sel) {
  if (sel.modifier === "i") {
    const expected = sel.value.toLowerCase();
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual.toLowerCase();
      case "~=":
        return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.toLowerCase().startsWith(expected);
      case "$=":
        return (actual) => actual.toLowerCase().endsWith(expected);
      case "*=":
        return (actual) => actual.toLowerCase().includes(expected);
      case "|=":
        return (actual) => {
          const lower = actual.toLowerCase();
          return expected === lower || lower.startsWith(expected) && lower[expected.length] === "-";
        };
    }
  } else {
    const expected = sel.value;
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual;
      case "~=":
        return (actual) => actual.split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.startsWith(expected);
      case "$=":
        return (actual) => actual.endsWith(expected);
      case "*=":
        return (actual) => actual.includes(expected);
      case "|=":
        return (actual) => expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
    }
  }
}
function combinatorBranch(combinator, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "combinator" && x.combinator === combinator, (x) => serialize(x.left));
  const leftItems = [];
  for (const group of Object.values(groups)) {
    const rightCont = weave(group.items);
    const leftAst = group.oneSimpleSelector.left;
    leftItems.push({
      ast: leftAst,
      terminal: { type: "popElement", cont: rightCont }
    });
  }
  return {
    type: "pushElement",
    combinator,
    cont: weave(leftItems)
  };
}
function spliceAndGroup(items, predicate, keyCallback) {
  const groups = {};
  while (items.length) {
    const bestKey = findTopKey(items, predicate, keyCallback);
    const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
    const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
    const { matches, rest } = partition1(items, hasBestKeyPredicate);
    let oneSimpleSelector = null;
    for (const item of matches) {
      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
      if (!oneSimpleSelector) {
        oneSimpleSelector = splicedNode;
      }
    }
    if (oneSimpleSelector == null) {
      throw new Error("No simple selector is found.");
    }
    groups[bestKey] = { oneSimpleSelector, items: matches };
    items = rest;
  }
  return groups;
}
function spliceSimpleSelector(item, predicate) {
  const simpsels = item.ast.list;
  const matches = new Array(simpsels.length);
  let firstIndex = -1;
  for (let i = simpsels.length; i-- > 0; ) {
    if (predicate(simpsels[i])) {
      matches[i] = true;
      firstIndex = i;
    }
  }
  if (firstIndex == -1) {
    throw new Error(`Couldn't find the required simple selector.`);
  }
  const result = simpsels[firstIndex];
  item.ast.list = simpsels.filter((sel, i) => !matches[i]);
  return result;
}
function findTopKey(items, predicate, keyCallback) {
  const candidates = {};
  for (const item of items) {
    const candidates1 = {};
    for (const node of item.ast.list.filter(predicate)) {
      candidates1[keyCallback(node)] = true;
    }
    for (const key of Object.keys(candidates1)) {
      if (candidates[key]) {
        candidates[key]++;
      } else {
        candidates[key] = 1;
      }
    }
  }
  let topKind = "";
  let topCounter = 0;
  for (const entry of Object.entries(candidates)) {
    if (entry[1] > topCounter) {
      topKind = entry[0];
      topCounter = entry[1];
    }
  }
  return topKind;
}
function partition(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}
function partition1(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}
var Picker = class {
  constructor(f) {
    this.f = f;
  }
  pickAll(el2) {
    return this.f(el2);
  }
  pick1(el2, preferFirst = false) {
    const results = this.f(el2);
    const len = results.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return results[0].value;
    }
    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
    let result = results[0];
    for (let i = 1; i < len; i++) {
      const next = results[i];
      if (comparator(result, next)) {
        result = next;
      }
    }
    return result.value;
  }
};
function comparatorPreferFirst(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index < acc.index;
}
function comparatorPreferLast(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index > acc.index;
}

// node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.mjs
function hp2Builder(nodes) {
  return new Picker(handleArray(nodes));
}
function handleArray(nodes) {
  const matchers = nodes.map(handleNode);
  return (el2, ...tail) => matchers.flatMap((m) => m(el2, ...tail));
}
function handleNode(node) {
  switch (node.type) {
    case "terminal": {
      const result = [node.valueContainer];
      return (el2, ...tail) => result;
    }
    case "tagName":
      return handleTagName(node);
    case "attrValue":
      return handleAttrValueName(node);
    case "attrPresence":
      return handleAttrPresenceName(node);
    case "pushElement":
      return handlePushElementNode(node);
    case "popElement":
      return handlePopElementNode(node);
  }
}
function handleTagName(node) {
  const variants = {};
  for (const variant of node.variants) {
    variants[variant.value] = handleArray(variant.cont);
  }
  return (el2, ...tail) => {
    const continuation = variants[el2.name];
    return continuation ? continuation(el2, ...tail) : [];
  };
}
function handleAttrPresenceName(node) {
  const attrName = node.name;
  const continuation = handleArray(node.cont);
  return (el2, ...tail) => Object.prototype.hasOwnProperty.call(el2.attribs, attrName) ? continuation(el2, ...tail) : [];
}
function handleAttrValueName(node) {
  const callbacks = [];
  for (const matcher of node.matchers) {
    const predicate = matcher.predicate;
    const continuation = handleArray(matcher.cont);
    callbacks.push((attr, el2, ...tail) => predicate(attr) ? continuation(el2, ...tail) : []);
  }
  const attrName = node.name;
  return (el2, ...tail) => {
    const attr = el2.attribs[attrName];
    return attr || attr === "" ? callbacks.flatMap((cb) => cb(attr, el2, ...tail)) : [];
  };
}
function handlePushElementNode(node) {
  const continuation = handleArray(node.cont);
  const leftElementGetter = node.combinator === "+" ? getPrecedingElement : getParentElement;
  return (el2, ...tail) => {
    const next = leftElementGetter(el2);
    if (next === null) {
      return [];
    }
    return continuation(next, el2, ...tail);
  };
}
var getPrecedingElement = (el2) => {
  const prev = el2.prev;
  if (prev === null) {
    return null;
  }
  return isTag2(prev) ? prev : getPrecedingElement(prev);
};
var getParentElement = (el2) => {
  const parent = el2.parent;
  return parent && isTag2(parent) ? parent : null;
};
function handlePopElementNode(node) {
  const continuation = handleArray(node.cont);
  return (el2, next, ...tail) => continuation(next, ...tail);
}

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c2) => c2.charCodeAt(0))
);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c2) => c2.charCodeAt(0))
);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a2;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a2 = String.fromCodePoint) !== null && _a2 !== void 0 ? _a2 : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a4;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a4 = decodeMap.get(codePoint)) !== null && _a4 !== void 0 ? _a4 : codePoint;
}

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes3) {
  CharCodes3[CharCodes3["NUM"] = 35] = "NUM";
  CharCodes3[CharCodes3["SEMI"] = 59] = "SEMI";
  CharCodes3[CharCodes3["EQUALS"] = 61] = "EQUALS";
  CharCodes3[CharCodes3["ZERO"] = 48] = "ZERO";
  CharCodes3[CharCodes3["NINE"] = 57] = "NINE";
  CharCodes3[CharCodes3["LOWER_A"] = 97] = "LOWER_A";
  CharCodes3[CharCodes3["LOWER_F"] = 102] = "LOWER_F";
  CharCodes3[CharCodes3["LOWER_X"] = 120] = "LOWER_X";
  CharCodes3[CharCodes3["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes3[CharCodes3["UPPER_A"] = 65] = "UPPER_A";
  CharCodes3[CharCodes3["UPPER_F"] = 70] = "UPPER_F";
  CharCodes3[CharCodes3["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a4;
    if (this.consumed <= expectedLength) {
      (_a4 = this.errors) === null || _a4 === void 0 ? void 0 : _a4.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a4;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a4 = this.errors) === null || _a4 === void 0 ? void 0 : _a4.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a4;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a4 = this.errors) === null || _a4 === void 0 ? void 0 : _a4.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder2 = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder2.startEntity(decodeMode);
      const len = decoder2.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder2.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo4 = nodeIdx;
  let hi3 = lo4 + branchCount - 1;
  while (lo4 <= hi3) {
    const mid = lo4 + hi3 >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo4 = mid + 1;
    } else if (midVal > char) {
      hi3 = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);

// node_modules/htmlparser2/lib/esm/Tokenizer.js
var CharCodes2;
(function(CharCodes3) {
  CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
  CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
  CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
  CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes3[CharCodes3["Space"] = 32] = "Space";
  CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes3[CharCodes3["Number"] = 35] = "Number";
  CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
  CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
  CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
  CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
  CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
  CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
  CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
  CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
  CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
  CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
  CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
  CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
  CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
  CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
  CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
  CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
  CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
  CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
  CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes2 || (CharCodes2 = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
  State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
  State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
  State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
  State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
  State2[State2["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
function isWhitespace(c2) {
  return c2 === CharCodes2.Space || c2 === CharCodes2.NewLine || c2 === CharCodes2.Tab || c2 === CharCodes2.FormFeed || c2 === CharCodes2.CarriageReturn;
}
function isEndOfTagSection(c2) {
  return c2 === CharCodes2.Slash || c2 === CharCodes2.Gt || isWhitespace(c2);
}
function isNumber2(c2) {
  return c2 >= CharCodes2.Zero && c2 <= CharCodes2.Nine;
}
function isASCIIAlpha(c2) {
  return c2 >= CharCodes2.LowerA && c2 <= CharCodes2.LowerZ || c2 >= CharCodes2.UpperA && c2 <= CharCodes2.UpperZ;
}
function isHexDigit(c2) {
  return c2 >= CharCodes2.UpperA && c2 <= CharCodes2.UpperF || c2 >= CharCodes2.LowerA && c2 <= CharCodes2.LowerF;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  // `</title`
};
var Tokenizer = class {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = void 0;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  /**
   * The current index within all of the written data.
   */
  getIndex() {
    return this.index;
  }
  /**
   * The start of the current section.
   */
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c2) {
    if (c2 === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.state = State.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c2) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c2)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c2 | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c2);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c2) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c2 === CharCodes2.Gt || isWhitespace(c2)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c2);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c2 === CharCodes2.Amp) {
          this.state = State.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c2 === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c2) {
    if (c2 === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c2);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c2) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c2) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c2) {
    if (c2 === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c2) {
    return this.xmlMode ? !isEndOfTagSection(c2) : isASCIIAlpha(c2);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c2) {
    if (c2 === CharCodes2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c2)) {
      const lower = c2 | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
      }
    } else if (c2 === CharCodes2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c2);
    }
  }
  stateInTagName(c2) {
    if (isEndOfTagSection(c2)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateBeforeClosingTagName(c2) {
    if (isWhitespace(c2)) {
    } else if (c2 === CharCodes2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c2) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c2) {
    if (c2 === CharCodes2.Gt || isWhitespace(c2)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c2);
    }
  }
  stateAfterClosingTagName(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c2) {
    if (c2 === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c2)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c2) {
    if (c2 === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c2)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateInAttributeName(c2) {
    if (c2 === CharCodes2.Eq || isEndOfTagSection(c2)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c2);
    }
  }
  stateAfterAttributeName(c2) {
    if (c2 === CharCodes2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c2 === CharCodes2.Slash || c2 === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (!isWhitespace(c2)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c2) {
    if (c2 === CharCodes2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c2)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c2);
    }
  }
  handleInAttributeValue(c2, quote) {
    if (c2 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c2) {
    if (isWhitespace(c2) || c2 === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c2) {
    if (c2 === CharCodes2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c2 === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c2) {
    if (c2 === CharCodes2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c2) {
    const lower = c2 | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c2);
    }
  }
  stateBeforeEntity(c2) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c2 === CharCodes2.Number) {
      this.state = State.BeforeNumericEntity;
    } else if (c2 === CharCodes2.Amp) {
    } else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State.InNamedEntity;
      this.stateInNamedEntity(c2);
    }
  }
  stateInNamedEntity(c2) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c2);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c2 !== CharCodes2.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c2) {
    if ((c2 | 32) === CharCodes2.LowerX) {
      this.entityExcess++;
      this.state = State.InHexEntity;
    } else {
      this.state = State.InNumericEntity;
      this.stateInNumericEntity(c2);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c2) {
    if (c2 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c2)) {
      this.entityResult = this.entityResult * 10 + (c2 - CharCodes2.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c2) {
    if (c2 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c2)) {
      this.entityResult = this.entityResult * 16 + (c2 - CharCodes2.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c2)) {
      this.entityResult = this.entityResult * 16 + ((c2 | 32) - CharCodes2.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c2 = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c2);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c2);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c2);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c2);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c2);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c2);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c2);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c2);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c2);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c2);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c2);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c2);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c2);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c2);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c2);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c2);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c2);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c2);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c2);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c2);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c2);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c2);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c2);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c2);
          break;
        }
        case State.InNamedEntity: {
          this.stateInNamedEntity(c2);
          break;
        }
        case State.BeforeEntity: {
          this.stateBeforeEntity(c2);
          break;
        }
        case State.InHexEntity: {
          this.stateInHexEntity(c2);
          break;
        }
        case State.InNumericEntity: {
          this.stateInNumericEntity(c2);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c2);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
};

// node_modules/htmlparser2/lib/esm/Parser.js
var formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = /* @__PURE__ */ new Set(["p"]);
var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
var openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
var htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;
var Parser = class {
  constructor(cbs, options = {}) {
    var _a4, _b, _c, _d, _e3;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.lowerCaseTagNames = (_a4 = options.lowerCaseTags) !== null && _a4 !== void 0 ? _a4 : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer)(this.options, this);
    (_e3 = (_d = this.cbs).onparserinit) === null || _e3 === void 0 ? void 0 : _e3.call(_d, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start, endIndex) {
    var _a4, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a4 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a4, data);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp) {
    var _a4, _b;
    const index = this.tokenizer.getSectionStart();
    this.endIndex = index - 1;
    (_b = (_a4 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a4, fromCodePoint(cp));
    this.startIndex = index;
  }
  isVoidElement(name2) {
    return !this.options.xmlMode && voidElements.has(name2);
  }
  /** @internal */
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    this.emitOpenTag(name2);
  }
  emitOpenTag(name2) {
    var _a4, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name2;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b = (_a4 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a4, element, true);
      }
    }
    if (!this.isVoidElement(name2)) {
      this.stack.push(name2);
      if (foreignContextElements.has(name2)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name2)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name2);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a4, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a4 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a4, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start, endIndex) {
    var _a4, _b, _c, _d, _e3, _f2;
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name2)) {
      const pos = this.stack.lastIndexOf(name2);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count = this.stack.length - pos;
          while (count--) {
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name2 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name2 === "br") {
      (_b = (_a4 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a4, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
      (_f2 = (_e3 = this.cbs).onclosetag) === null || _f2 === void 0 ? void 0 : _f2.call(_e3, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a4, _b;
    const name2 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name2) {
      (_b = (_a4 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a4, name2, !isOpenImplied);
      this.stack.pop();
    }
  }
  /** @internal */
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name2 = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
  }
  /** @internal */
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a4, _b;
    this.endIndex = endIndex;
    (_b = (_a4 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a4, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index = value.search(reNameEnd);
    let name2 = index < 0 ? value : value.substr(0, index);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    return name2;
  }
  /** @internal */
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name2}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name2}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start, endIndex, offset) {
    var _a4, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a4 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a4, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start, endIndex, offset) {
    var _a4, _b, _c, _d, _e3, _f2, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a4 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a4);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f2 = (_e3 = this.cbs).oncdataend) === null || _f2 === void 0 ? void 0 : _f2.call(_e3);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a4, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index = this.stack.length; index > 0; this.cbs.onclosetag(this.stack[--index], true))
        ;
    }
    (_b = (_a4 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a4);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a4, _b, _c, _d;
    (_b = (_a4 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a4);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a4, _b;
    if (this.ended) {
      (_b = (_a4 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a4, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a4, _b;
    if (this.ended) {
      (_b = (_a4 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a4, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
};

// node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// node_modules/entities/lib/esm/escape.js
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c2, index) => (c2.charCodeAt(index) & 64512) === 55296 ? (c2.charCodeAt(index) - 55296) * 1024 + c2.charCodeAt(index + 1) - 56320 + 65536 : c2.charCodeAt(index)
  )
);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char = str.charCodeAt(i);
    const next = xmlCodeMap.get(char);
    if (next !== void 0) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map2) {
  return function escape3(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map2.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));

// node_modules/dom-serializer/lib/esm/index.js
var unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes, opts) {
  var _a4;
  if (!attributes)
    return;
  const encode = ((_a4 = opts.encodeEntities) !== null && _a4 !== void 0 ? _a4 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes).map((key) => {
    var _a5, _b;
    const value = (_a5 = attributes[key]) !== null && _a5 !== void 0 ? _a5 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode(value)}"`;
  }).join(" ");
}
var singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node, options = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
function renderNode(node, options) {
  switch (node.type) {
    case Root:
      return render(node.children, options);
    // @ts-expect-error We don't use `Doctype` yet
    case Doctype:
    case Directive:
      return renderDirective(node);
    case Comment:
      return renderComment(node);
    case CDATA:
      return renderCdata(node);
    case Script:
    case Style:
    case Tag:
      return renderTag(node, options);
    case Text:
      return renderText(node, options);
  }
}
var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a4;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a4 = elementNames.get(elem.name)) !== null && _a4 !== void 0 ? _a4 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a4;
  let data = elem.data || "";
  if (((_a4 = opts.encodeEntities) !== null && _a4 !== void 0 ? _a4 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}

// node_modules/domutils/lib/esm/helpers.js
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));

// node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data, options) {
  const handler = new DomHandler(void 0, options);
  new Parser(handler, options).end(data);
  return handler.root;
}

// node_modules/html-to-text/lib/html-to-text.mjs
var import_deepmerge = __toESM(require_cjs(), 1);
function limitedDepthRecursive(n2, f, g2 = () => void 0) {
  if (n2 === void 0) {
    const f1 = function(...args) {
      return f(f1, ...args);
    };
    return f1;
  }
  if (n2 >= 0) {
    return function(...args) {
      return f(limitedDepthRecursive(n2 - 1, f, g2), ...args);
    };
  }
  return g2;
}
function trimCharacter(str, char) {
  let start = 0;
  let end = str.length;
  while (start < end && str[start] === char) {
    ++start;
  }
  while (end > start && str[end - 1] === char) {
    --end;
  }
  return start > 0 || end < str.length ? str.substring(start, end) : str;
}
function trimCharacterEnd(str, char) {
  let end = str.length;
  while (end > 0 && str[end - 1] === char) {
    --end;
  }
  return end < str.length ? str.substring(0, end) : str;
}
function unicodeEscape(str) {
  return str.replace(/[\s\S]/g, (c2) => "\\u" + c2.charCodeAt().toString(16).padStart(4, "0"));
}
function mergeDuplicatesPreferLast(items, getKey) {
  const map2 = /* @__PURE__ */ new Map();
  for (let i = items.length; i-- > 0; ) {
    const item = items[i];
    const key = getKey(item);
    map2.set(
      key,
      map2.has(key) ? (0, import_deepmerge.default)(item, map2.get(key), { arrayMerge: overwriteMerge$1 }) : item
    );
  }
  return [...map2.values()].reverse();
}
var overwriteMerge$1 = (acc, src, options) => [...src];
function get(obj, path) {
  for (const key of path) {
    if (!obj) {
      return void 0;
    }
    obj = obj[key];
  }
  return obj;
}
function numberToLetterSequence(num, baseChar = "a", base = 26) {
  const digits = [];
  do {
    num -= 1;
    digits.push(num % base);
    num = num / base >> 0;
  } while (num > 0);
  const baseCode = baseChar.charCodeAt(0);
  return digits.reverse().map((n2) => String.fromCharCode(baseCode + n2)).join("");
}
var I2 = ["I", "X", "C", "M"];
var V3 = ["V", "L", "D"];
function numberToRoman(num) {
  return [...num + ""].map((n2) => +n2).reverse().map((v3, i) => v3 % 5 < 4 ? (v3 < 5 ? "" : V3[i]) + I2[i].repeat(v3 % 5) : I2[i] + (v3 < 5 ? V3[i] : I2[i + 1])).reverse().join("");
}
var InlineTextBuilder = class {
  /**
   * Creates an instance of InlineTextBuilder.
   *
   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.
   *
   * @param { Options } options           HtmlToText options.
   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.
   */
  constructor(options, maxLineLength = void 0) {
    this.lines = [];
    this.nextLineWords = [];
    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
    this.nextLineAvailableChars = this.maxLineLength;
    this.wrapCharacters = get(options, ["longWordSplit", "wrapCharacters"]) || [];
    this.forceWrapOnLimit = get(options, ["longWordSplit", "forceWrapOnLimit"]) || false;
    this.stashedSpace = false;
    this.wordBreakOpportunity = false;
  }
  /**
   * Add a new word.
   *
   * @param { string } word A word to add.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */
  pushWord(word, noWrap = false) {
    if (this.nextLineAvailableChars <= 0 && !noWrap) {
      this.startNewLine();
    }
    const isLineStart = this.nextLineWords.length === 0;
    const cost = word.length + (isLineStart ? 0 : 1);
    if (cost <= this.nextLineAvailableChars || noWrap) {
      this.nextLineWords.push(word);
      this.nextLineAvailableChars -= cost;
    } else {
      const [first, ...rest] = this.splitLongWord(word);
      if (!isLineStart) {
        this.startNewLine();
      }
      this.nextLineWords.push(first);
      this.nextLineAvailableChars -= first.length;
      for (const part of rest) {
        this.startNewLine();
        this.nextLineWords.push(part);
        this.nextLineAvailableChars -= part.length;
      }
    }
  }
  /**
   * Pop a word from the currently built line.
   * This doesn't affect completed lines.
   *
   * @returns { string }
   */
  popWord() {
    const lastWord = this.nextLineWords.pop();
    if (lastWord !== void 0) {
      const isLineStart = this.nextLineWords.length === 0;
      const cost = lastWord.length + (isLineStart ? 0 : 1);
      this.nextLineAvailableChars += cost;
    }
    return lastWord;
  }
  /**
   * Concat a word to the last word already in the builder.
   * Adds a new word in case there are no words yet in the last line.
   *
   * @param { string } word A word to be concatenated.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */
  concatWord(word, noWrap = false) {
    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
      this.pushWord(word, noWrap);
      this.wordBreakOpportunity = false;
    } else {
      const lastWord = this.popWord();
      this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);
    }
  }
  /**
   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.
   *
   * @param { number } n Number of line breaks that will be added to the resulting string.
   */
  startNewLine(n2 = 1) {
    this.lines.push(this.nextLineWords);
    if (n2 > 1) {
      this.lines.push(...Array.from({ length: n2 - 1 }, () => []));
    }
    this.nextLineWords = [];
    this.nextLineAvailableChars = this.maxLineLength;
  }
  /**
   * No words in this builder.
   *
   * @returns { boolean }
   */
  isEmpty() {
    return this.lines.length === 0 && this.nextLineWords.length === 0;
  }
  clear() {
    this.lines.length = 0;
    this.nextLineWords.length = 0;
    this.nextLineAvailableChars = this.maxLineLength;
  }
  /**
   * Join all lines of words inside the InlineTextBuilder into a complete string.
   *
   * @returns { string }
   */
  toString() {
    return [...this.lines, this.nextLineWords].map((words) => words.join(" ")).join("\n");
  }
  /**
   * Split a long word up to fit within the word wrap limit.
   * Use either a character to split looking back from the word wrap limit,
   * or truncate to the word wrap limit.
   *
   * @param   { string }   word Input word.
   * @returns { string[] }      Parts of the word.
   */
  splitLongWord(word) {
    const parts = [];
    let idx = 0;
    while (word.length > this.maxLineLength) {
      const firstLine = word.substring(0, this.maxLineLength);
      const remainingChars = word.substring(this.maxLineLength);
      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
      if (splitIndex > -1) {
        word = firstLine.substring(splitIndex + 1) + remainingChars;
        parts.push(firstLine.substring(0, splitIndex + 1));
      } else {
        idx++;
        if (idx < this.wrapCharacters.length) {
          word = firstLine + remainingChars;
        } else {
          if (this.forceWrapOnLimit) {
            parts.push(firstLine);
            word = remainingChars;
            if (word.length > this.maxLineLength) {
              continue;
            }
          } else {
            word = firstLine + remainingChars;
          }
          break;
        }
      }
    }
    parts.push(word);
    return parts;
  }
};
var StackItem = class {
  constructor(next = null) {
    this.next = next;
  }
  getRoot() {
    return this.next ? this.next : this;
  }
};
var BlockStackItem = class extends StackItem {
  constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = void 0) {
    super(next);
    this.leadingLineBreaks = leadingLineBreaks;
    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
};
var ListStackItem = class extends BlockStackItem {
  constructor(options, next = null, {
    interRowLineBreaks = 1,
    leadingLineBreaks = 2,
    maxLineLength = void 0,
    maxPrefixLength = 0,
    prefixAlign = "left"
  } = {}) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.maxPrefixLength = maxPrefixLength;
    this.prefixAlign = prefixAlign;
    this.interRowLineBreaks = interRowLineBreaks;
  }
};
var ListItemStackItem = class extends BlockStackItem {
  constructor(options, next = null, {
    leadingLineBreaks = 1,
    maxLineLength = void 0,
    prefix = ""
  } = {}) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.prefix = prefix;
  }
};
var TableStackItem = class extends StackItem {
  constructor(next = null) {
    super(next);
    this.rows = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
};
var TableRowStackItem = class extends StackItem {
  constructor(next = null) {
    super(next);
    this.cells = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
};
var TableCellStackItem = class extends StackItem {
  constructor(options, next = null, maxColumnWidth = void 0) {
    super(next);
    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
    this.rawText = "";
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
};
var TransformerStackItem = class extends StackItem {
  constructor(next = null, transform) {
    super(next);
    this.transform = transform;
  }
};
function charactersToCodes(str) {
  return [...str].map((c2) => "\\u" + c2.charCodeAt(0).toString(16).padStart(4, "0")).join("");
}
var WhitespaceProcessor = class {
  /**
   * Creates an instance of WhitespaceProcessor.
   *
   * @param { Options } options    HtmlToText options.
   * @memberof WhitespaceProcessor
   */
  constructor(options) {
    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\n/g, "") : options.whitespaceCharacters;
    const whitespaceCodes = charactersToCodes(this.whitespaceChars);
    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
    this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
    this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, "g");
    if (options.preserveNewlines) {
      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
      this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = ((str) => str), noWrap = false) {
        if (!text) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordOrNewlineRe.exec(text);
        if (m) {
          anyMatch = true;
          if (m[0] === "\n") {
            inlineTextBuilder.startNewLine();
          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordOrNewlineRe.exec(text)) !== null) {
            if (m[0] === "\n") {
              inlineTextBuilder.startNewLine();
            } else {
              inlineTextBuilder.pushWord(transform(m[0]), noWrap);
            }
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
      };
    } else {
      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
      this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = ((str) => str), noWrap = false) {
        if (!text) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordRe.exec(text);
        if (m) {
          anyMatch = true;
          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordRe.exec(text)) !== null) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
      };
    }
  }
  /**
   * Add text with only minimal processing.
   * Everything between newlines considered a single word.
   * No whitespace is trimmed.
   * Not affected by preserveNewlines option - `\n` always starts a new line.
   *
   * `noWrap` argument is `true` by default - this won't start a new line
   * even if there is not enough space left in the current line.
   *
   * @param { string }            text              Input text.
   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.
   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.
   */
  addLiteral(text, inlineTextBuilder, noWrap = true) {
    if (!text) {
      return;
    }
    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
    let anyMatch = false;
    let m = this.newlineOrNonNewlineStringRe.exec(text);
    if (m) {
      anyMatch = true;
      if (m[0] === "\n") {
        inlineTextBuilder.startNewLine();
      } else if (previouslyStashedSpace) {
        inlineTextBuilder.pushWord(m[0], noWrap);
      } else {
        inlineTextBuilder.concatWord(m[0], noWrap);
      }
      while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {
        if (m[0] === "\n") {
          inlineTextBuilder.startNewLine();
        } else {
          inlineTextBuilder.pushWord(m[0], noWrap);
        }
      }
    }
    inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;
  }
  /**
   * Test whether the given text starts with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testLeadingWhitespace(text) {
    return this.leadingWhitespaceRe.test(text);
  }
  /**
   * Test whether the given text ends with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testTrailingWhitespace(text) {
    return this.trailingWhitespaceRe.test(text);
  }
  /**
   * Test whether the given text contains any non-whitespace characters.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testContainsWords(text) {
    return !this.allWhitespaceOrEmptyRe.test(text);
  }
  /**
   * Return the number of newlines if there are no words.
   *
   * If any word is found then return zero regardless of the actual number of newlines.
   *
   * @param   { string }  text  Input string.
   * @returns { number }
   */
  countNewlinesNoWords(text) {
    this.newlineOrNonWhitespaceRe.lastIndex = 0;
    let counter = 0;
    let match;
    while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {
      if (match[0] === "\n") {
        counter++;
      } else {
        return 0;
      }
    }
    return counter;
  }
};
var BlockTextBuilder = class {
  /**
   * Creates an instance of BlockTextBuilder.
   *
   * @param { Options } options HtmlToText options.
   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.
   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.
   */
  constructor(options, picker, metadata = void 0) {
    this.options = options;
    this.picker = picker;
    this.metadata = metadata;
    this.whitespaceProcessor = new WhitespaceProcessor(options);
    this._stackItem = new BlockStackItem(options);
    this._wordTransformer = void 0;
  }
  /**
   * Put a word-by-word transform function onto the transformations stack.
   *
   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.
   *
   * Word transformations applied before wrapping.
   *
   * @param { (str: string) => string } wordTransform Word transformation function.
   */
  pushWordTransform(wordTransform) {
    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
  }
  /**
   * Remove a function from the word transformations stack.
   *
   * @returns { (str: string) => string } A function that was removed.
   */
  popWordTransform() {
    if (!this._wordTransformer) {
      return void 0;
    }
    const transform = this._wordTransformer.transform;
    this._wordTransformer = this._wordTransformer.next;
    return transform;
  }
  /**
   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.
   */
  startNoWrap() {
    this._stackItem.isNoWrap = true;
  }
  /**
   * Return automatic wrapping to behavior defined by options.
   */
  stopNoWrap() {
    this._stackItem.isNoWrap = false;
  }
  /** @returns { (str: string) => string } */
  _getCombinedWordTransformer() {
    const wt4 = this._wordTransformer ? ((str) => applyTransformer(str, this._wordTransformer)) : void 0;
    const ce3 = this.options.encodeCharacters;
    return wt4 ? ce3 ? (str) => ce3(wt4(str)) : wt4 : ce3;
  }
  _popStackItem() {
    const item = this._stackItem;
    this._stackItem = item.next;
    return item;
  }
  /**
   * Add a line break into currently built block.
   */
  addLineBreak() {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += "\n";
    } else {
      this._stackItem.inlineTextBuilder.startNewLine();
    }
  }
  /**
   * Allow to break line in case directly following text will not fit.
   */
  addWordBreakOpportunity() {
    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {
      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
    }
  }
  /**
   * Add a node inline into the currently built block.
   *
   * @param { string } str
   * Text content of a node to add.
   *
   * @param { object } [param1]
   * Object holding the parameters of the operation.
   *
   * @param { boolean } [param1.noWordTransform]
   * Ignore word transformers if there are any.
   * Don't encode characters as well.
   * (Use this for things like URL addresses).
   */
  addInline(str, { noWordTransform = false } = {}) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (str.length === 0 || // empty string
    this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant
    !this.whitespaceProcessor.testContainsWords(str)) {
      return;
    }
    if (this.options.preserveNewlines) {
      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
      if (newlinesNumber > 0) {
        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
        return;
      }
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.shrinkWrapAdd(
      str,
      this._stackItem.inlineTextBuilder,
      noWordTransform ? void 0 : this._getCombinedWordTransformer(),
      this._stackItem.isNoWrap
    );
    this._stackItem.stashedLineBreaks = 0;
  }
  /**
   * Add a string inline into the currently built block.
   *
   * Use this for markup elements that don't have to adhere
   * to text layout rules.
   *
   * @param { string } str Text to add.
   */
  addLiteral(str) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (str.length === 0) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.addLiteral(
      str,
      this._stackItem.inlineTextBuilder,
      this._stackItem.isNoWrap
    );
    this._stackItem.stashedLineBreaks = 0;
  }
  /**
   * Start building a new block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any preceding block.
   *
   * @param { number }  [param0.reservedLineLength]
   * Reserve this number of characters on each line for block markup.
   *
   * @param { boolean } [param0.isPre]
   * Should HTML whitespace be preserved inside this block.
   */
  openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
    this._stackItem = new BlockStackItem(
      this.options,
      this._stackItem,
      leadingLineBreaks,
      maxLineLength
    );
    if (isPre) {
      this._stackItem.isPre = true;
    }
  }
  /**
   * Finalize currently built block, add it's content to the parent block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any following block.
   *
   * @param { (str: string) => string } [param0.blockTransform]
   * A function to transform the block text before adding to the parent block.
   * This happens after word wrap and should be used in combination with reserved line length
   * in order to keep line lengths correct.
   * Used for whole block markup.
   */
  closeBlock({ trailingLineBreaks = 1, blockTransform = void 0 } = {}) {
    const block = this._popStackItem();
    const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);
    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
  }
  /**
   * Start building a new list.
   *
   * @param { object } [param0]
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.maxPrefixLength]
   * Length of the longest list item prefix.
   * If not supplied or too small then list items won't be aligned properly.
   *
   * @param { 'left' | 'right' } [param0.prefixAlign]
   * Specify how prefixes of different lengths have to be aligned
   * within a column.
   *
   * @param { number } [param0.interRowLineBreaks]
   * Minimum number of line breaks between list items.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any preceding block.
   */
  openList({ maxPrefixLength = 0, prefixAlign = "left", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
    this._stackItem = new ListStackItem(this.options, this._stackItem, {
      interRowLineBreaks,
      leadingLineBreaks,
      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
      maxPrefixLength,
      prefixAlign
    });
  }
  /**
   * Start building a new list item.
   *
   * @param {object} param0
   * Object holding the parameters of the list item.
   *
   * @param { string } [param0.prefix]
   * Prefix for this list item (item number, bullet point, etc).
   */
  openListItem({ prefix = "" } = {}) {
    if (!(this._stackItem instanceof ListStackItem)) {
      throw new Error("Can't add a list item to something that is not a list! Check the formatter.");
    }
    const list = this._stackItem;
    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
    this._stackItem = new ListItemStackItem(this.options, list, {
      prefix,
      maxLineLength,
      leadingLineBreaks: list.interRowLineBreaks
    });
  }
  /**
   * Finalize currently built list item, add it's content to the parent list.
   */
  closeListItem() {
    const listItem = this._popStackItem();
    const list = listItem.next;
    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
    const spacing = "\n" + " ".repeat(prefixLength);
    const prefix = list.prefixAlign === "right" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);
    const text = prefix + getText(listItem).replace(/\n/g, spacing);
    addText(
      list,
      text,
      listItem.leadingLineBreaks,
      Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks)
    );
  }
  /**
   * Finalize currently built list, add it's content to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any following block.
   */
  closeList({ trailingLineBreaks = 2 } = {}) {
    const list = this._popStackItem();
    const text = getText(list);
    if (text) {
      addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);
    }
  }
  /**
   * Start building a table.
   */
  openTable() {
    this._stackItem = new TableStackItem(this._stackItem);
  }
  /**
   * Start building a table row.
   */
  openTableRow() {
    if (!(this._stackItem instanceof TableStackItem)) {
      throw new Error("Can't add a table row to something that is not a table! Check the formatter.");
    }
    this._stackItem = new TableRowStackItem(this._stackItem);
  }
  /**
   * Start building a table cell.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.maxColumnWidth]
   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.
   */
  openTableCell({ maxColumnWidth = void 0 } = {}) {
    if (!(this._stackItem instanceof TableRowStackItem)) {
      throw new Error("Can't add a table cell to something that is not a table row! Check the formatter.");
    }
    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
  }
  /**
   * Finalize currently built table cell and add it to parent table row's cells.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.colspan] How many columns this cell should occupy.
   * @param { number } [param0.rowspan] How many rows this cell should occupy.
   */
  closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
    const cell = this._popStackItem();
    const text = trimCharacter(getText(cell), "\n");
    cell.next.cells.push({ colspan, rowspan, text });
  }
  /**
   * Finalize currently built table row and add it to parent table's rows.
   */
  closeTableRow() {
    const row = this._popStackItem();
    row.next.rows.push(row.cells);
  }
  /**
   * Finalize currently built table and add the rendered text to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the table.
   *
   * @param { TablePrinter } param0.tableToString
   * A function to convert a table of stringified cells into a complete table.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This table should have at least this number of line breaks to separate if from any preceding block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This table should have at least this number of line breaks to separate it from any following block.
   */
  closeTable({ tableToString: tableToString2, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
    const table = this._popStackItem();
    const output = tableToString2(table.rows);
    if (output) {
      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
    }
  }
  /**
   * Return the rendered text content of this builder.
   *
   * @returns { string }
   */
  toString() {
    return getText(this._stackItem.getRoot());
  }
};
function getText(stackItem) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can be requested for text contents.");
  }
  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();
}
function addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can contain text.");
  }
  const parentText = getText(stackItem);
  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
  stackItem.inlineTextBuilder.clear();
  if (parentText) {
    stackItem.rawText = parentText + "\n".repeat(lineBreaks) + text;
  } else {
    stackItem.rawText = text;
    stackItem.leadingLineBreaks = lineBreaks;
  }
  stackItem.stashedLineBreaks = trailingLineBreaks;
}
function applyTransformer(str, transformer) {
  return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
}
function compile$1(options = {}) {
  const selectorsWithoutFormat = options.selectors.filter((s2) => !s2.format);
  if (selectorsWithoutFormat.length) {
    throw new Error(
      "Following selectors have no specified format: " + selectorsWithoutFormat.map((s2) => `\`${s2.selector}\``).join(", ")
    );
  }
  const picker = new DecisionTree(
    options.selectors.map((s2) => [s2.selector, s2])
  ).build(hp2Builder);
  if (typeof options.encodeCharacters !== "function") {
    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
  }
  const baseSelectorsPicker = new DecisionTree(
    options.baseElements.selectors.map((s2, i) => [s2, i + 1])
  ).build(hp2Builder);
  function findBaseElements(dom) {
    return findBases(dom, options, baseSelectorsPicker);
  }
  const limitedWalk = limitedDepthRecursive(
    options.limits.maxDepth,
    recursiveWalk,
    function(dom, builder) {
      builder.addInline(options.limits.ellipsis || "");
    }
  );
  return function(html, metadata = void 0) {
    return process2(html, metadata, options, picker, findBaseElements, limitedWalk);
  };
}
function process2(html, metadata, options, picker, findBaseElements, walk) {
  const maxInputLength = options.limits.maxInputLength;
  if (maxInputLength && html && html.length > maxInputLength) {
    console.warn(
      `Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`
    );
    html = html.substring(0, maxInputLength);
  }
  const document = parseDocument(html, { decodeEntities: options.decodeEntities });
  const bases = findBaseElements(document.children);
  const builder = new BlockTextBuilder(options, picker, metadata);
  walk(bases, builder);
  return builder.toString();
}
function findBases(dom, options, baseSelectorsPicker) {
  const results = [];
  function recursiveWalk2(walk, dom2) {
    dom2 = dom2.slice(0, options.limits.maxChildNodes);
    for (const elem of dom2) {
      if (elem.type !== "tag") {
        continue;
      }
      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
      if (pickedSelectorIndex > 0) {
        results.push({ selectorIndex: pickedSelectorIndex, element: elem });
      } else if (elem.children) {
        walk(elem.children);
      }
      if (results.length >= options.limits.maxBaseElements) {
        return;
      }
    }
  }
  const limitedWalk = limitedDepthRecursive(
    options.limits.maxDepth,
    recursiveWalk2
  );
  limitedWalk(dom);
  if (options.baseElements.orderBy !== "occurrence") {
    results.sort((a, b3) => a.selectorIndex - b3.selectorIndex);
  }
  return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x) => x.element);
}
function recursiveWalk(walk, dom, builder) {
  if (!dom) {
    return;
  }
  const options = builder.options;
  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
  if (tooManyChildNodes) {
    dom = dom.slice(0, options.limits.maxChildNodes);
    dom.push({
      data: options.limits.ellipsis,
      type: "text"
    });
  }
  for (const elem of dom) {
    switch (elem.type) {
      case "text": {
        builder.addInline(elem.data);
        break;
      }
      case "tag": {
        const tagDefinition = builder.picker.pick1(elem);
        const format = options.formatters[tagDefinition.format];
        format(elem, walk, builder, tagDefinition.options || {});
        break;
      }
    }
  }
  return;
}
function makeReplacerFromDict(dict) {
  if (!dict || Object.keys(dict).length === 0) {
    return void 0;
  }
  const entries = Object.entries(dict).filter(([, v3]) => v3 !== false);
  const regex = new RegExp(
    entries.map(([c2]) => `(${unicodeEscape([...c2][0])})`).join("|"),
    "g"
  );
  const values = entries.map(([, v3]) => v3);
  const replacer = (m, ...cgs) => values[cgs.findIndex((cg) => cg)];
  return (str) => str.replace(regex, replacer);
}
function formatSkip(elem, walk, builder, formatOptions) {
}
function formatInlineString(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.string || "");
}
function formatBlockString(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addLiteral(formatOptions.string || "");
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInline(elem, walk, builder, formatOptions) {
  walk(elem.children, builder);
}
function formatBlock$1(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function renderOpenTag(elem) {
  const attrs = elem.attribs && elem.attribs.length ? " " + Object.entries(elem.attribs).map(([k3, v3]) => v3 === "" ? k3 : `${k3}=${v3.replace(/"/g, "&quot;")}`).join(" ") : "";
  return `<${elem.name}${attrs}>`;
}
function renderCloseTag(elem) {
  return `</${elem.name}>`;
}
function formatInlineTag(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
}
function formatBlockTag(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineHtml(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(
    render(elem, { decodeEntities: builder.options.decodeEntities })
  );
  builder.stopNoWrap();
}
function formatBlockHtml(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(
    render(elem, { decodeEntities: builder.options.decodeEntities })
  );
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineSurround(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.prefix || "");
  walk(elem.children, builder);
  builder.addLiteral(formatOptions.suffix || "");
}
var genericFormatters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  block: formatBlock$1,
  blockHtml: formatBlockHtml,
  blockString: formatBlockString,
  blockTag: formatBlockTag,
  inline: formatInline,
  inlineHtml: formatInlineHtml,
  inlineString: formatInlineString,
  inlineSurround: formatInlineSurround,
  inlineTag: formatInlineTag,
  skip: formatSkip
});
function getRow(matrix, j3) {
  if (!matrix[j3]) {
    matrix[j3] = [];
  }
  return matrix[j3];
}
function findFirstVacantIndex(row, x = 0) {
  while (row[x]) {
    x++;
  }
  return x;
}
function transposeInPlace(matrix, maxSize) {
  for (let i = 0; i < maxSize; i++) {
    const rowI = getRow(matrix, i);
    for (let j3 = 0; j3 < i; j3++) {
      const rowJ = getRow(matrix, j3);
      if (rowI[j3] || rowJ[i]) {
        const temp = rowI[j3];
        rowI[j3] = rowJ[i];
        rowJ[i] = temp;
      }
    }
  }
}
function putCellIntoLayout(cell, layout, baseRow, baseCol) {
  for (let r2 = 0; r2 < cell.rowspan; r2++) {
    const layoutRow = getRow(layout, baseRow + r2);
    for (let c2 = 0; c2 < cell.colspan; c2++) {
      layoutRow[baseCol + c2] = cell;
    }
  }
}
function getOrInitOffset(offsets, index) {
  if (offsets[index] === void 0) {
    offsets[index] = index === 0 ? 0 : 1 + getOrInitOffset(offsets, index - 1);
  }
  return offsets[index];
}
function updateOffset(offsets, base, span, value) {
  offsets[base + span] = Math.max(
    getOrInitOffset(offsets, base + span),
    getOrInitOffset(offsets, base) + value
  );
}
function tableToString(tableRows, rowSpacing, colSpacing) {
  const layout = [];
  let colNumber = 0;
  const rowNumber = tableRows.length;
  const rowOffsets = [0];
  for (let j3 = 0; j3 < rowNumber; j3++) {
    const layoutRow = getRow(layout, j3);
    const cells = tableRows[j3];
    let x = 0;
    for (let i = 0; i < cells.length; i++) {
      const cell = cells[i];
      x = findFirstVacantIndex(layoutRow, x);
      putCellIntoLayout(cell, layout, j3, x);
      x += cell.colspan;
      cell.lines = cell.text.split("\n");
      const cellHeight = cell.lines.length;
      updateOffset(rowOffsets, j3, cell.rowspan, cellHeight + rowSpacing);
    }
    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
  }
  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);
  const outputLines = [];
  const colOffsets = [0];
  for (let x = 0; x < colNumber; x++) {
    let y2 = 0;
    let cell;
    const rowsInThisColumn = Math.min(rowNumber, layout[x].length);
    while (y2 < rowsInThisColumn) {
      cell = layout[x][y2];
      if (cell) {
        if (!cell.rendered) {
          let cellWidth = 0;
          for (let j3 = 0; j3 < cell.lines.length; j3++) {
            const line = cell.lines[j3];
            const lineOffset = rowOffsets[y2] + j3;
            outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x]) + line;
            cellWidth = line.length > cellWidth ? line.length : cellWidth;
          }
          updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
          cell.rendered = true;
        }
        y2 += cell.rowspan;
      } else {
        const lineOffset = rowOffsets[y2];
        outputLines[lineOffset] = outputLines[lineOffset] || "";
        y2++;
      }
    }
  }
  return outputLines.join("\n");
}
function formatLineBreak(elem, walk, builder, formatOptions) {
  builder.addLineBreak();
}
function formatWbr(elem, walk, builder, formatOptions) {
  builder.addWordBreakOpportunity();
}
function formatHorizontalLine(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatParagraph(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatPre(elem, walk, builder, formatOptions) {
  builder.openBlock({
    isPre: true,
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2
  });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatHeading(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  if (formatOptions.uppercase !== false) {
    builder.pushWordTransform((str) => str.toUpperCase());
    walk(elem.children, builder);
    builder.popWordTransform();
  } else {
    walk(elem.children, builder);
  }
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatBlockquote(elem, walk, builder, formatOptions) {
  builder.openBlock({
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
    reservedLineLength: 2
  });
  walk(elem.children, builder);
  builder.closeBlock({
    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
    blockTransform: (str) => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, "\n") : str).split("\n").map((line) => "> " + line).join("\n")
  });
}
function withBrackets(str, brackets) {
  if (!brackets) {
    return str;
  }
  const lbr = typeof brackets[0] === "string" ? brackets[0] : "[";
  const rbr = typeof brackets[1] === "string" ? brackets[1] : "]";
  return lbr + str + rbr;
}
function pathRewrite(path, rewriter, baseUrl, metadata, elem) {
  const modifiedPath = typeof rewriter === "function" ? rewriter(path, metadata, elem) : path;
  return modifiedPath[0] === "/" && baseUrl ? trimCharacterEnd(baseUrl, "/") + modifiedPath : modifiedPath;
}
function formatImage(elem, walk, builder, formatOptions) {
  const attribs = elem.attribs || {};
  const alt = attribs.alt ? attribs.alt : "";
  const src = !attribs.src ? "" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
  const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
  builder.addInline(text, { noWordTransform: true });
}
function formatAnchor(elem, walk, builder, formatOptions) {
  function getHref() {
    if (formatOptions.ignoreHref) {
      return "";
    }
    if (!elem.attribs || !elem.attribs.href) {
      return "";
    }
    let href2 = elem.attribs.href.replace(/^mailto:/, "");
    if (formatOptions.noAnchorUrl && href2[0] === "#") {
      return "";
    }
    href2 = pathRewrite(href2, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    return href2;
  }
  const href = getHref();
  if (!href) {
    walk(elem.children, builder);
  } else {
    let text = "";
    builder.pushWordTransform(
      (str) => {
        if (str) {
          text += str;
        }
        return str;
      }
    );
    walk(elem.children, builder);
    builder.popWordTransform();
    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;
    if (!hideSameLink) {
      builder.addInline(
        !text ? href : " " + withBrackets(href, formatOptions.linkBrackets),
        { noWordTransform: true }
      );
    }
  }
}
function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {
  const isNestedList = get(elem, ["parent", "name"]) === "li";
  let maxPrefixLength = 0;
  const listItems = (elem.children || []).filter((child) => child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
    if (child.name !== "li") {
      return { node: child, prefix: "" };
    }
    const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
    if (prefix.length > maxPrefixLength) {
      maxPrefixLength = prefix.length;
    }
    return { node: child, prefix };
  });
  if (!listItems.length) {
    return;
  }
  builder.openList({
    interRowLineBreaks: 1,
    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,
    maxPrefixLength,
    prefixAlign: "left"
  });
  for (const { node, prefix } of listItems) {
    builder.openListItem({ prefix });
    walk([node], builder);
    builder.closeListItem();
  }
  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2 });
}
function formatUnorderedList(elem, walk, builder, formatOptions) {
  const prefix = formatOptions.itemPrefix || " * ";
  return formatList(elem, walk, builder, formatOptions, () => prefix);
}
function formatOrderedList(elem, walk, builder, formatOptions) {
  let nextIndex = Number(elem.attribs.start || "1");
  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
  const nextPrefixCallback = () => " " + indexFunction(nextIndex++) + ". ";
  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
}
function getOrderedListIndexFunction(olType = "1") {
  switch (olType) {
    case "a":
      return (i) => numberToLetterSequence(i, "a");
    case "A":
      return (i) => numberToLetterSequence(i, "A");
    case "i":
      return (i) => numberToRoman(i).toLowerCase();
    case "I":
      return (i) => numberToRoman(i);
    case "1":
    default:
      return (i) => i.toString();
  }
}
function splitClassesAndIds(selectors) {
  const classes = [];
  const ids = [];
  for (const selector of selectors) {
    if (selector.startsWith(".")) {
      classes.push(selector.substring(1));
    } else if (selector.startsWith("#")) {
      ids.push(selector.substring(1));
    }
  }
  return { classes, ids };
}
function isDataTable(attr, tables) {
  if (tables === true) {
    return true;
  }
  if (!attr) {
    return false;
  }
  const { classes, ids } = splitClassesAndIds(tables);
  const attrClasses = (attr["class"] || "").split(" ");
  const attrIds = (attr["id"] || "").split(" ");
  return attrClasses.some((x) => classes.includes(x)) || attrIds.some((x) => ids.includes(x));
}
function formatTable(elem, walk, builder, formatOptions) {
  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
}
function formatBlock(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
}
function formatDataTable(elem, walk, builder, formatOptions) {
  builder.openTable();
  elem.children.forEach(walkTable);
  builder.closeTable({
    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
    leadingLineBreaks: formatOptions.leadingLineBreaks,
    trailingLineBreaks: formatOptions.trailingLineBreaks
  });
  function formatCell(cellNode) {
    const colspan = +get(cellNode, ["attribs", "colspan"]) || 1;
    const rowspan = +get(cellNode, ["attribs", "rowspan"]) || 1;
    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
    walk(cellNode.children, builder);
    builder.closeTableCell({ colspan, rowspan });
  }
  function walkTable(elem2) {
    if (elem2.type !== "tag") {
      return;
    }
    const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode) => {
      builder.pushWordTransform((str) => str.toUpperCase());
      formatCell(cellNode);
      builder.popWordTransform();
    } : formatCell;
    switch (elem2.name) {
      case "thead":
      case "tbody":
      case "tfoot":
      case "center":
        elem2.children.forEach(walkTable);
        return;
      case "tr": {
        builder.openTableRow();
        for (const childOfTr of elem2.children) {
          if (childOfTr.type !== "tag") {
            continue;
          }
          switch (childOfTr.name) {
            case "th": {
              formatHeaderCell(childOfTr);
              break;
            }
            case "td": {
              formatCell(childOfTr);
              break;
            }
          }
        }
        builder.closeTableRow();
        break;
      }
    }
  }
}
var textFormatters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  anchor: formatAnchor,
  blockquote: formatBlockquote,
  dataTable: formatDataTable,
  heading: formatHeading,
  horizontalLine: formatHorizontalLine,
  image: formatImage,
  lineBreak: formatLineBreak,
  orderedList: formatOrderedList,
  paragraph: formatParagraph,
  pre: formatPre,
  table: formatTable,
  unorderedList: formatUnorderedList,
  wbr: formatWbr
});
var DEFAULT_OPTIONS = {
  baseElements: {
    selectors: ["body"],
    orderBy: "selectors",
    // 'selectors' | 'occurrence'
    returnDomByDefault: true
  },
  decodeEntities: true,
  encodeCharacters: {},
  formatters: {},
  limits: {
    ellipsis: "...",
    maxBaseElements: void 0,
    maxChildNodes: void 0,
    maxDepth: void 0,
    maxInputLength: 1 << 24
    // 16_777_216
  },
  longWordSplit: {
    forceWrapOnLimit: false,
    wrapCharacters: []
  },
  preserveNewlines: false,
  selectors: [
    { selector: "*", format: "inline" },
    {
      selector: "a",
      format: "anchor",
      options: {
        baseUrl: null,
        hideLinkHrefIfSameAsText: false,
        ignoreHref: false,
        linkBrackets: ["[", "]"],
        noAnchorUrl: true
      }
    },
    { selector: "article", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "aside", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "blockquote",
      format: "blockquote",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
    },
    { selector: "br", format: "lineBreak" },
    { selector: "div", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "footer", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "form", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "h1", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h2", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h3", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h4", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h5", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "h6", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: "header", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "hr",
      format: "horizontalLine",
      options: { leadingLineBreaks: 2, length: void 0, trailingLineBreaks: 2 }
    },
    {
      selector: "img",
      format: "image",
      options: { baseUrl: null, linkBrackets: ["[", "]"] }
    },
    { selector: "main", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: "nav", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "ol",
      format: "orderedList",
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "p", format: "paragraph", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "pre", format: "pre", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: "section", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: "table",
      format: "table",
      options: {
        colSpacing: 3,
        leadingLineBreaks: 2,
        maxColumnWidth: 60,
        rowSpacing: 0,
        trailingLineBreaks: 2,
        uppercaseHeaderCells: true
      }
    },
    {
      selector: "ul",
      format: "unorderedList",
      options: { itemPrefix: " * ", leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: "wbr", format: "wbr" }
  ],
  tables: [],
  // deprecated
  whitespaceCharacters: " 	\r\n\f\u200B",
  wordwrap: 80
};
var concatMerge = (acc, src, options) => [...acc, ...src];
var overwriteMerge = (acc, src, options) => [...src];
var selectorsMerge = (acc, src, options) => acc.some((s2) => typeof s2 === "object") ? concatMerge(acc, src) : overwriteMerge(acc, src);
function compile(options = {}) {
  options = (0, import_deepmerge.default)(
    DEFAULT_OPTIONS,
    options,
    {
      arrayMerge: overwriteMerge,
      customMerge: (key) => key === "selectors" ? selectorsMerge : void 0
    }
  );
  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
  options.selectors = mergeDuplicatesPreferLast(options.selectors, ((s2) => s2.selector));
  handleDeprecatedOptions(options);
  return compile$1(options);
}
function convert(html, options = {}, metadata = void 0) {
  return compile(options)(html, metadata);
}
function handleDeprecatedOptions(options) {
  if (options.tags) {
    const tagDefinitions = Object.entries(options.tags).map(
      ([selector, definition]) => ({ ...definition, selector: selector || "*" })
    );
    options.selectors.push(...tagDefinitions);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, ((s2) => s2.selector));
  }
  function set(obj, path, value) {
    const valueKey = path.pop();
    for (const key of path) {
      let nested = obj[key];
      if (!nested) {
        nested = {};
        obj[key] = nested;
      }
      obj = nested;
    }
    obj[valueKey] = value;
  }
  if (options["baseElement"]) {
    const baseElement = options["baseElement"];
    set(
      options,
      ["baseElements", "selectors"],
      Array.isArray(baseElement) ? baseElement : [baseElement]
    );
  }
  if (options["returnDomByDefault"] !== void 0) {
    set(options, ["baseElements", "returnDomByDefault"], options["returnDomByDefault"]);
  }
  for (const definition of options.selectors) {
    if (definition.format === "anchor" && get(definition, ["options", "noLinkBrackets"])) {
      set(definition, ["options", "linkBrackets"], false);
    }
  }
}

// node_modules/@react-email/render/dist/node/index.mjs
var import_node_stream = require("node:stream");
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var __defProp9 = Object.defineProperty;
var __defProps8 = Object.defineProperties;
var __getOwnPropDescs8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols8 = Object.getOwnPropertySymbols;
var __hasOwnProp9 = Object.prototype.hasOwnProperty;
var __propIsEnum8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues8 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp9.call(b3, prop))
      __defNormalProp8(a, prop, b3[prop]);
  if (__getOwnPropSymbols8)
    for (var prop of __getOwnPropSymbols8(b3)) {
      if (__propIsEnum8.call(b3, prop))
        __defNormalProp8(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps8 = (a, b3) => __defProps8(a, __getOwnPropDescs8(b3));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function recursivelyMapDoc(doc, callback) {
  if (Array.isArray(doc)) {
    return doc.map((innerDoc) => recursivelyMapDoc(innerDoc, callback));
  }
  if (typeof doc === "object") {
    if (doc.type === "group") {
      return __spreadProps8(__spreadValues8({}, doc), {
        contents: recursivelyMapDoc(doc.contents, callback),
        expandedStates: recursivelyMapDoc(
          doc.expandedStates,
          callback
        )
      });
    }
    if ("contents" in doc) {
      return __spreadProps8(__spreadValues8({}, doc), {
        contents: recursivelyMapDoc(doc.contents, callback)
      });
    }
    if ("parts" in doc) {
      return __spreadProps8(__spreadValues8({}, doc), {
        parts: recursivelyMapDoc(doc.parts, callback)
      });
    }
    if (doc.type === "if-break") {
      return __spreadProps8(__spreadValues8({}, doc), {
        breakContents: recursivelyMapDoc(doc.breakContents, callback),
        flatContents: recursivelyMapDoc(doc.flatContents, callback)
      });
    }
  }
  return callback(doc);
}
var modifiedHtml = __spreadValues8({}, html_exports);
if (modifiedHtml.printers) {
  const previousPrint = modifiedHtml.printers.html.print;
  modifiedHtml.printers.html.print = (path, options, print, args) => {
    const node = path.getNode();
    const rawPrintingResult = previousPrint(path, options, print, args);
    if (node.type === "ieConditionalComment") {
      const printingResult = recursivelyMapDoc(rawPrintingResult, (doc) => {
        if (typeof doc === "object" && doc.type === "line") {
          return doc.soft ? "" : " ";
        }
        return doc;
      });
      return printingResult;
    }
    return rawPrintingResult;
  };
}
var defaults = {
  endOfLine: "lf",
  tabWidth: 2,
  plugins: [modifiedHtml],
  bracketSameLine: true,
  parser: "html"
};
var pretty = (str, options = {}) => {
  return fu(str.replaceAll("\0", ""), __spreadValues8(__spreadValues8({}, defaults), options));
};
var plainTextSelectors = [
  { selector: "img", format: "skip" },
  { selector: "[data-skip-in-text=true]", format: "skip" },
  {
    selector: "a",
    options: { linkBrackets: false }
  }
];
function toPlainText(html2, options) {
  return convert(html2, __spreadValues8({
    selectors: plainTextSelectors
  }, options));
}
var decoder = new TextDecoder("utf-8");
var readStream = (stream) => __async(void 0, null, function* () {
  let result = "";
  if ("pipeTo" in stream) {
    const writableStream = new WritableStream({
      write(chunk) {
        result += decoder.decode(chunk);
      }
    });
    yield stream.pipeTo(writableStream);
  } else {
    const writable = new import_node_stream.Writable({
      write(chunk, _encoding, callback) {
        result += decoder.decode(chunk);
        callback();
      }
    });
    stream.pipe(writable);
    yield new Promise((resolve, reject) => {
      writable.on("error", reject);
      writable.on("close", () => {
        resolve();
      });
    });
  }
  return result;
});
var render2 = (node, options) => __async(void 0, null, function* () {
  const suspendedElement = /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(import_react.Suspense, { children: node });
  const reactDOMServer = yield Promise.resolve().then(() => __toESM(require_server_node(), 1)).then(
    // This is beacuse react-dom/server is CJS
    (m) => m.default
  );
  let html2;
  if (Object.hasOwn(reactDOMServer, "renderToReadableStream")) {
    html2 = yield readStream(
      yield reactDOMServer.renderToReadableStream(suspendedElement, {
        progressiveChunkSize: Number.POSITIVE_INFINITY
      })
    );
  } else {
    yield new Promise((resolve, reject) => {
      const stream = reactDOMServer.renderToPipeableStream(suspendedElement, {
        onAllReady() {
          return __async(this, null, function* () {
            html2 = yield readStream(stream);
            resolve();
          });
        },
        onError(error) {
          reject(error);
        },
        progressiveChunkSize: Number.POSITIVE_INFINITY
      });
    });
  }
  if (options == null ? void 0 : options.plainText) {
    return toPlainText(html2, options.htmlToTextOptions);
  }
  const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
  const document = `${doctype}${html2.replace(/<!DOCTYPE.*?>/, "")}`;
  if (options == null ? void 0 : options.pretty) {
    return pretty(document);
  }
  return document;
});

// node_modules/@react-email/row/dist/index.mjs
var React8 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var __defProp10 = Object.defineProperty;
var __defProps9 = Object.defineProperties;
var __getOwnPropDescs9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols9 = Object.getOwnPropertySymbols;
var __hasOwnProp10 = Object.prototype.hasOwnProperty;
var __propIsEnum9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp9 = (obj, key, value) => key in obj ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues9 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp10.call(b3, prop))
      __defNormalProp9(a, prop, b3[prop]);
  if (__getOwnPropSymbols9)
    for (var prop of __getOwnPropSymbols9(b3)) {
      if (__propIsEnum9.call(b3, prop))
        __defNormalProp9(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps9 = (a, b3) => __defProps9(a, __getOwnPropDescs9(b3));
var __objRest8 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp10.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols9)
    for (var prop of __getOwnPropSymbols9(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum9.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Row = React8.forwardRef(
  (_a4, ref) => {
    var _b = _a4, { children, style } = _b, props = __objRest8(_b, ["children", "style"]);
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      "table",
      __spreadProps9(__spreadValues9({
        align: "center",
        width: "100%",
        border: 0,
        cellPadding: "0",
        cellSpacing: "0",
        role: "presentation"
      }, props), {
        ref,
        style,
        children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("tbody", { style: { width: "100%" }, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("tr", { style: { width: "100%" }, children }) })
      })
    );
  }
);
Row.displayName = "Row";

// node_modules/@react-email/section/dist/index.mjs
var React9 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var __defProp11 = Object.defineProperty;
var __defProps10 = Object.defineProperties;
var __getOwnPropDescs10 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols10 = Object.getOwnPropertySymbols;
var __hasOwnProp11 = Object.prototype.hasOwnProperty;
var __propIsEnum10 = Object.prototype.propertyIsEnumerable;
var __defNormalProp10 = (obj, key, value) => key in obj ? __defProp11(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues10 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp11.call(b3, prop))
      __defNormalProp10(a, prop, b3[prop]);
  if (__getOwnPropSymbols10)
    for (var prop of __getOwnPropSymbols10(b3)) {
      if (__propIsEnum10.call(b3, prop))
        __defNormalProp10(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps10 = (a, b3) => __defProps10(a, __getOwnPropDescs10(b3));
var __objRest9 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp11.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols10)
    for (var prop of __getOwnPropSymbols10(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum10.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Section = React9.forwardRef(
  (_a4, ref) => {
    var _b = _a4, { children, style } = _b, props = __objRest9(_b, ["children", "style"]);
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
      "table",
      __spreadProps10(__spreadValues10({
        align: "center",
        width: "100%",
        border: 0,
        cellPadding: "0",
        cellSpacing: "0",
        role: "presentation"
      }, props), {
        ref,
        style,
        children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("tbody", { children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("tr", { children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("td", { children }) }) })
      })
    );
  }
);
Section.displayName = "Section";

// node_modules/@react-email/tailwind/dist/index.mjs
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var Or3 = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var ta2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function He3(u) {
  return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
}
function cu2(u) {
  if (Object.prototype.hasOwnProperty.call(u, "__esModule")) return u;
  var a = u.default;
  if (typeof a == "function") {
    var h2 = function p() {
      return this instanceof p ? Reflect.construct(a, arguments, this.constructor) : a.apply(this, arguments);
    };
    h2.prototype = a.prototype;
  } else h2 = {};
  return Object.defineProperty(h2, "__esModule", { value: true }), Object.keys(u).forEach(function(p) {
    var l2 = Object.getOwnPropertyDescriptor(u, p);
    Object.defineProperty(h2, p, l2.get ? l2 : {
      enumerable: true,
      get: function() {
        return u[p];
      }
    });
  }), h2;
}
var pt3 = { exports: {} };
var ra2;
function Ti() {
  if (ra2) return pt3.exports;
  ra2 = 1;
  var u = String, a = function() {
    return { isColorSupported: false, reset: u, bold: u, dim: u, italic: u, underline: u, inverse: u, hidden: u, strikethrough: u, black: u, red: u, green: u, yellow: u, blue: u, magenta: u, cyan: u, white: u, gray: u, bgBlack: u, bgRed: u, bgGreen: u, bgYellow: u, bgBlue: u, bgMagenta: u, bgCyan: u, bgWhite: u, blackBright: u, redBright: u, greenBright: u, yellowBright: u, blueBright: u, magentaBright: u, cyanBright: u, whiteBright: u, bgBlackBright: u, bgRedBright: u, bgGreenBright: u, bgYellowBright: u, bgBlueBright: u, bgMagentaBright: u, bgCyanBright: u, bgWhiteBright: u };
  };
  return pt3.exports = a(), pt3.exports.createColors = a, pt3.exports;
}
var du2 = {};
var pu2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: du2
}, Symbol.toStringTag, { value: "Module" }));
var Ne3 = /* @__PURE__ */ cu2(pu2);
var kr3;
var na2;
function Ai2() {
  if (na2) return kr3;
  na2 = 1;
  let u = /* @__PURE__ */ Ti(), a = Ne3;
  class h2 extends Error {
    constructor(l2, f, s2, c2, t8, e2) {
      super(l2), this.name = "CssSyntaxError", this.reason = l2, t8 && (this.file = t8), c2 && (this.source = c2), e2 && (this.plugin = e2), typeof f < "u" && typeof s2 < "u" && (typeof f == "number" ? (this.line = f, this.column = s2) : (this.line = f.line, this.column = f.column, this.endLine = s2.line, this.endColumn = s2.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, h2);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(l2) {
      if (!this.source) return "";
      let f = this.source;
      l2 == null && (l2 = u.isColorSupported);
      let s2 = (v3) => v3, c2 = (v3) => v3, t8 = (v3) => v3;
      if (l2) {
        let { bold: v3, gray: m, red: n2 } = u.createColors(true);
        c2 = (d2) => v3(n2(d2)), s2 = (d2) => m(d2), a && (t8 = (d2) => a(d2));
      }
      let e2 = f.split(/\r?\n/), r2 = Math.max(this.line - 3, 0), i = Math.min(this.line + 2, e2.length), o2 = String(i).length;
      return e2.slice(r2, i).map((v3, m) => {
        let n2 = r2 + 1 + m, d2 = " " + (" " + n2).slice(-o2) + " | ";
        if (n2 === this.line) {
          if (v3.length > 160) {
            let w3 = 20, y2 = Math.max(0, this.column - w3), x = Math.max(
              this.column + w3,
              this.endColumn + w3
            ), g2 = v3.slice(y2, x), O3 = s2(d2.replace(/\d/g, " ")) + v3.slice(0, Math.min(this.column - 1, w3 - 1)).replace(/[^\t]/g, " ");
            return c2(">") + s2(d2) + t8(g2) + `
 ` + O3 + c2("^");
          }
          let _3 = s2(d2.replace(/\d/g, " ")) + v3.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return c2(">") + s2(d2) + t8(v3) + `
 ` + _3 + c2("^");
        }
        return " " + s2(d2) + t8(v3);
      }).join(`
`);
    }
    toString() {
      let l2 = this.showSourceCode();
      return l2 && (l2 = `

` + l2 + `
`), this.name + ": " + this.message + l2;
    }
  }
  return kr3 = h2, h2.default = h2, kr3;
}
var Pr3;
var ia2;
function dl() {
  if (ia2) return Pr3;
  ia2 = 1;
  const u = {
    after: `
`,
    beforeClose: `
`,
    beforeComment: `
`,
    beforeDecl: `
`,
    beforeOpen: " ",
    beforeRule: `
`,
    colon: ": ",
    commentLeft: " ",
    commentRight: " ",
    emptyBody: "",
    indent: "    ",
    semicolon: false
  };
  function a(p) {
    return p[0].toUpperCase() + p.slice(1);
  }
  class h2 {
    constructor(l2) {
      this.builder = l2;
    }
    atrule(l2, f) {
      let s2 = "@" + l2.name, c2 = l2.params ? this.rawValue(l2, "params") : "";
      if (typeof l2.raws.afterName < "u" ? s2 += l2.raws.afterName : c2 && (s2 += " "), l2.nodes)
        this.block(l2, s2 + c2);
      else {
        let t8 = (l2.raws.between || "") + (f ? ";" : "");
        this.builder(s2 + c2 + t8, l2);
      }
    }
    beforeAfter(l2, f) {
      let s2;
      l2.type === "decl" ? s2 = this.raw(l2, null, "beforeDecl") : l2.type === "comment" ? s2 = this.raw(l2, null, "beforeComment") : f === "before" ? s2 = this.raw(l2, null, "beforeRule") : s2 = this.raw(l2, null, "beforeClose");
      let c2 = l2.parent, t8 = 0;
      for (; c2 && c2.type !== "root"; )
        t8 += 1, c2 = c2.parent;
      if (s2.includes(`
`)) {
        let e2 = this.raw(l2, null, "indent");
        if (e2.length)
          for (let r2 = 0; r2 < t8; r2++) s2 += e2;
      }
      return s2;
    }
    block(l2, f) {
      let s2 = this.raw(l2, "between", "beforeOpen");
      this.builder(f + s2 + "{", l2, "start");
      let c2;
      l2.nodes && l2.nodes.length ? (this.body(l2), c2 = this.raw(l2, "after")) : c2 = this.raw(l2, "after", "emptyBody"), c2 && this.builder(c2), this.builder("}", l2, "end");
    }
    body(l2) {
      let f = l2.nodes.length - 1;
      for (; f > 0 && l2.nodes[f].type === "comment"; )
        f -= 1;
      let s2 = this.raw(l2, "semicolon");
      for (let c2 = 0; c2 < l2.nodes.length; c2++) {
        let t8 = l2.nodes[c2], e2 = this.raw(t8, "before");
        e2 && this.builder(e2), this.stringify(t8, f !== c2 || s2);
      }
    }
    comment(l2) {
      let f = this.raw(l2, "left", "commentLeft"), s2 = this.raw(l2, "right", "commentRight");
      this.builder("/*" + f + l2.text + s2 + "*/", l2);
    }
    decl(l2, f) {
      let s2 = this.raw(l2, "between", "colon"), c2 = l2.prop + s2 + this.rawValue(l2, "value");
      l2.important && (c2 += l2.raws.important || " !important"), f && (c2 += ";"), this.builder(c2, l2);
    }
    document(l2) {
      this.body(l2);
    }
    raw(l2, f, s2) {
      let c2;
      if (s2 || (s2 = f), f && (c2 = l2.raws[f], typeof c2 < "u"))
        return c2;
      let t8 = l2.parent;
      if (s2 === "before" && (!t8 || t8.type === "root" && t8.first === l2 || t8 && t8.type === "document"))
        return "";
      if (!t8) return u[s2];
      let e2 = l2.root();
      if (e2.rawCache || (e2.rawCache = {}), typeof e2.rawCache[s2] < "u")
        return e2.rawCache[s2];
      if (s2 === "before" || s2 === "after")
        return this.beforeAfter(l2, s2);
      {
        let r2 = "raw" + a(s2);
        this[r2] ? c2 = this[r2](e2, l2) : e2.walk((i) => {
          if (c2 = i.raws[f], typeof c2 < "u") return false;
        });
      }
      return typeof c2 > "u" && (c2 = u[s2]), e2.rawCache[s2] = c2, c2;
    }
    rawBeforeClose(l2) {
      let f;
      return l2.walk((s2) => {
        if (s2.nodes && s2.nodes.length > 0 && typeof s2.raws.after < "u")
          return f = s2.raws.after, f.includes(`
`) && (f = f.replace(/[^\n]+$/, "")), false;
      }), f && (f = f.replace(/\S/g, "")), f;
    }
    rawBeforeComment(l2, f) {
      let s2;
      return l2.walkComments((c2) => {
        if (typeof c2.raws.before < "u")
          return s2 = c2.raws.before, s2.includes(`
`) && (s2 = s2.replace(/[^\n]+$/, "")), false;
      }), typeof s2 > "u" ? s2 = this.raw(f, null, "beforeDecl") : s2 && (s2 = s2.replace(/\S/g, "")), s2;
    }
    rawBeforeDecl(l2, f) {
      let s2;
      return l2.walkDecls((c2) => {
        if (typeof c2.raws.before < "u")
          return s2 = c2.raws.before, s2.includes(`
`) && (s2 = s2.replace(/[^\n]+$/, "")), false;
      }), typeof s2 > "u" ? s2 = this.raw(f, null, "beforeRule") : s2 && (s2 = s2.replace(/\S/g, "")), s2;
    }
    rawBeforeOpen(l2) {
      let f;
      return l2.walk((s2) => {
        if (s2.type !== "decl" && (f = s2.raws.between, typeof f < "u"))
          return false;
      }), f;
    }
    rawBeforeRule(l2) {
      let f;
      return l2.walk((s2) => {
        if (s2.nodes && (s2.parent !== l2 || l2.first !== s2) && typeof s2.raws.before < "u")
          return f = s2.raws.before, f.includes(`
`) && (f = f.replace(/[^\n]+$/, "")), false;
      }), f && (f = f.replace(/\S/g, "")), f;
    }
    rawColon(l2) {
      let f;
      return l2.walkDecls((s2) => {
        if (typeof s2.raws.between < "u")
          return f = s2.raws.between.replace(/[^\s:]/g, ""), false;
      }), f;
    }
    rawEmptyBody(l2) {
      let f;
      return l2.walk((s2) => {
        if (s2.nodes && s2.nodes.length === 0 && (f = s2.raws.after, typeof f < "u"))
          return false;
      }), f;
    }
    rawIndent(l2) {
      if (l2.raws.indent) return l2.raws.indent;
      let f;
      return l2.walk((s2) => {
        let c2 = s2.parent;
        if (c2 && c2 !== l2 && c2.parent && c2.parent === l2 && typeof s2.raws.before < "u") {
          let t8 = s2.raws.before.split(`
`);
          return f = t8[t8.length - 1], f = f.replace(/\S/g, ""), false;
        }
      }), f;
    }
    rawSemicolon(l2) {
      let f;
      return l2.walk((s2) => {
        if (s2.nodes && s2.nodes.length && s2.last.type === "decl" && (f = s2.raws.semicolon, typeof f < "u"))
          return false;
      }), f;
    }
    rawValue(l2, f) {
      let s2 = l2[f], c2 = l2.raws[f];
      return c2 && c2.value === s2 ? c2.raw : s2;
    }
    root(l2) {
      this.body(l2), l2.raws.after && this.builder(l2.raws.after);
    }
    rule(l2) {
      this.block(l2, this.rawValue(l2, "selector")), l2.raws.ownSemicolon && this.builder(l2.raws.ownSemicolon, l2, "end");
    }
    stringify(l2, f) {
      if (!this[l2.type])
        throw new Error(
          "Unknown AST node type " + l2.type + ". Maybe you need to change PostCSS stringifier."
        );
      this[l2.type](l2, f);
    }
  }
  return Pr3 = h2, h2.default = h2, Pr3;
}
var Er3;
var aa2;
function or3() {
  if (aa2) return Er3;
  aa2 = 1;
  let u = dl();
  function a(h2, p) {
    new u(p).stringify(h2);
  }
  return Er3 = a, a.default = a, Er3;
}
var ht3 = {};
var sa2;
function Ci2() {
  return sa2 || (sa2 = 1, ht3.isClean = Symbol("isClean"), ht3.my = Symbol("my")), ht3;
}
var Tr3;
var oa2;
function lr3() {
  if (oa2) return Tr3;
  oa2 = 1;
  let u = Ai2(), a = dl(), h2 = or3(), { isClean: p, my: l2 } = Ci2();
  function f(t8, e2) {
    let r2 = new t8.constructor();
    for (let i in t8) {
      if (!Object.prototype.hasOwnProperty.call(t8, i) || i === "proxyCache") continue;
      let o2 = t8[i], v3 = typeof o2;
      i === "parent" && v3 === "object" ? e2 && (r2[i] = e2) : i === "source" ? r2[i] = o2 : Array.isArray(o2) ? r2[i] = o2.map((m) => f(m, r2)) : (v3 === "object" && o2 !== null && (o2 = f(o2)), r2[i] = o2);
    }
    return r2;
  }
  function s2(t8, e2) {
    if (e2 && typeof e2.offset < "u")
      return e2.offset;
    let r2 = 1, i = 1, o2 = 0;
    for (let v3 = 0; v3 < t8.length; v3++) {
      if (i === e2.line && r2 === e2.column) {
        o2 = v3;
        break;
      }
      t8[v3] === `
` ? (r2 = 1, i += 1) : r2 += 1;
    }
    return o2;
  }
  class c2 {
    get proxyOf() {
      return this;
    }
    constructor(e2 = {}) {
      this.raws = {}, this[p] = false, this[l2] = true;
      for (let r2 in e2)
        if (r2 === "nodes") {
          this.nodes = [];
          for (let i of e2[r2])
            typeof i.clone == "function" ? this.append(i.clone()) : this.append(i);
        } else
          this[r2] = e2[r2];
    }
    addToError(e2) {
      if (e2.postcssNode = this, e2.stack && this.source && /\n\s{4}at /.test(e2.stack)) {
        let r2 = this.source;
        e2.stack = e2.stack.replace(
          /\n\s{4}at /,
          `$&${r2.input.from}:${r2.start.line}:${r2.start.column}$&`
        );
      }
      return e2;
    }
    after(e2) {
      return this.parent.insertAfter(this, e2), this;
    }
    assign(e2 = {}) {
      for (let r2 in e2)
        this[r2] = e2[r2];
      return this;
    }
    before(e2) {
      return this.parent.insertBefore(this, e2), this;
    }
    cleanRaws(e2) {
      delete this.raws.before, delete this.raws.after, e2 || delete this.raws.between;
    }
    clone(e2 = {}) {
      let r2 = f(this);
      for (let i in e2)
        r2[i] = e2[i];
      return r2;
    }
    cloneAfter(e2 = {}) {
      let r2 = this.clone(e2);
      return this.parent.insertAfter(this, r2), r2;
    }
    cloneBefore(e2 = {}) {
      let r2 = this.clone(e2);
      return this.parent.insertBefore(this, r2), r2;
    }
    error(e2, r2 = {}) {
      if (this.source) {
        let { end: i, start: o2 } = this.rangeBy(r2);
        return this.source.input.error(
          e2,
          { column: o2.column, line: o2.line },
          { column: i.column, line: i.line },
          r2
        );
      }
      return new u(e2);
    }
    getProxyProcessor() {
      return {
        get(e2, r2) {
          return r2 === "proxyOf" ? e2 : r2 === "root" ? () => e2.root().toProxy() : e2[r2];
        },
        set(e2, r2, i) {
          return e2[r2] === i || (e2[r2] = i, (r2 === "prop" || r2 === "value" || r2 === "name" || r2 === "params" || r2 === "important" || /* c8 ignore next */
          r2 === "text") && e2.markDirty()), true;
        }
      };
    }
    /* c8 ignore next 3 */
    markClean() {
      this[p] = true;
    }
    markDirty() {
      if (this[p]) {
        this[p] = false;
        let e2 = this;
        for (; e2 = e2.parent; )
          e2[p] = false;
      }
    }
    next() {
      if (!this.parent) return;
      let e2 = this.parent.index(this);
      return this.parent.nodes[e2 + 1];
    }
    positionBy(e2) {
      let r2 = this.source.start;
      if (e2.index)
        r2 = this.positionInside(e2.index);
      else if (e2.word) {
        let i = "document" in this.source.input ? this.source.input.document : this.source.input.css, v3 = i.slice(
          s2(i, this.source.start),
          s2(i, this.source.end)
        ).indexOf(e2.word);
        v3 !== -1 && (r2 = this.positionInside(v3));
      }
      return r2;
    }
    positionInside(e2) {
      let r2 = this.source.start.column, i = this.source.start.line, o2 = "document" in this.source.input ? this.source.input.document : this.source.input.css, v3 = s2(o2, this.source.start), m = v3 + e2;
      for (let n2 = v3; n2 < m; n2++)
        o2[n2] === `
` ? (r2 = 1, i += 1) : r2 += 1;
      return { column: r2, line: i };
    }
    prev() {
      if (!this.parent) return;
      let e2 = this.parent.index(this);
      return this.parent.nodes[e2 - 1];
    }
    rangeBy(e2) {
      let r2 = {
        column: this.source.start.column,
        line: this.source.start.line
      }, i = this.source.end ? {
        column: this.source.end.column + 1,
        line: this.source.end.line
      } : {
        column: r2.column + 1,
        line: r2.line
      };
      if (e2.word) {
        let o2 = "document" in this.source.input ? this.source.input.document : this.source.input.css, m = o2.slice(
          s2(o2, this.source.start),
          s2(o2, this.source.end)
        ).indexOf(e2.word);
        m !== -1 && (r2 = this.positionInside(m), i = this.positionInside(
          m + e2.word.length
        ));
      } else
        e2.start ? r2 = {
          column: e2.start.column,
          line: e2.start.line
        } : e2.index && (r2 = this.positionInside(e2.index)), e2.end ? i = {
          column: e2.end.column,
          line: e2.end.line
        } : typeof e2.endIndex == "number" ? i = this.positionInside(e2.endIndex) : e2.index && (i = this.positionInside(e2.index + 1));
      return (i.line < r2.line || i.line === r2.line && i.column <= r2.column) && (i = { column: r2.column + 1, line: r2.line }), { end: i, start: r2 };
    }
    raw(e2, r2) {
      return new a().raw(this, e2, r2);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...e2) {
      if (this.parent) {
        let r2 = this, i = false;
        for (let o2 of e2)
          o2 === this ? i = true : i ? (this.parent.insertAfter(r2, o2), r2 = o2) : this.parent.insertBefore(r2, o2);
        i || this.remove();
      }
      return this;
    }
    root() {
      let e2 = this;
      for (; e2.parent && e2.parent.type !== "document"; )
        e2 = e2.parent;
      return e2;
    }
    toJSON(e2, r2) {
      let i = {}, o2 = r2 == null;
      r2 = r2 || /* @__PURE__ */ new Map();
      let v3 = 0;
      for (let m in this) {
        if (!Object.prototype.hasOwnProperty.call(this, m) || m === "parent" || m === "proxyCache") continue;
        let n2 = this[m];
        if (Array.isArray(n2))
          i[m] = n2.map((d2) => typeof d2 == "object" && d2.toJSON ? d2.toJSON(null, r2) : d2);
        else if (typeof n2 == "object" && n2.toJSON)
          i[m] = n2.toJSON(null, r2);
        else if (m === "source") {
          let d2 = r2.get(n2.input);
          d2 == null && (d2 = v3, r2.set(n2.input, v3), v3++), i[m] = {
            end: n2.end,
            inputId: d2,
            start: n2.start
          };
        } else
          i[m] = n2;
      }
      return o2 && (i.inputs = [...r2.keys()].map((m) => m.toJSON())), i;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(e2 = h2) {
      e2.stringify && (e2 = e2.stringify);
      let r2 = "";
      return e2(this, (i) => {
        r2 += i;
      }), r2;
    }
    warn(e2, r2, i) {
      let o2 = { node: this };
      for (let v3 in i) o2[v3] = i[v3];
      return e2.warn(r2, o2);
    }
  }
  return Tr3 = c2, c2.default = c2, Tr3;
}
var Ar3;
var la2;
function ur3() {
  if (la2) return Ar3;
  la2 = 1;
  let u = lr3();
  class a extends u {
    constructor(p) {
      super(p), this.type = "comment";
    }
  }
  return Ar3 = a, a.default = a, Ar3;
}
var Cr3;
var ua2;
function fr3() {
  if (ua2) return Cr3;
  ua2 = 1;
  let u = lr3();
  class a extends u {
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
    constructor(p) {
      p && typeof p.value < "u" && typeof p.value != "string" && (p = { ...p, value: String(p.value) }), super(p), this.type = "decl";
    }
  }
  return Cr3 = a, a.default = a, Cr3;
}
var Rr3;
var fa2;
function nt3() {
  if (fa2) return Rr3;
  fa2 = 1;
  let u = ur3(), a = fr3(), h2 = lr3(), { isClean: p, my: l2 } = Ci2(), f, s2, c2, t8;
  function e2(o2) {
    return o2.map((v3) => (v3.nodes && (v3.nodes = e2(v3.nodes)), delete v3.source, v3));
  }
  function r2(o2) {
    if (o2[p] = false, o2.proxyOf.nodes)
      for (let v3 of o2.proxyOf.nodes)
        r2(v3);
  }
  class i extends h2 {
    get first() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
    append(...v3) {
      for (let m of v3) {
        let n2 = this.normalize(m, this.last);
        for (let d2 of n2) this.proxyOf.nodes.push(d2);
      }
      return this.markDirty(), this;
    }
    cleanRaws(v3) {
      if (super.cleanRaws(v3), this.nodes)
        for (let m of this.nodes) m.cleanRaws(v3);
    }
    each(v3) {
      if (!this.proxyOf.nodes) return;
      let m = this.getIterator(), n2, d2;
      for (; this.indexes[m] < this.proxyOf.nodes.length && (n2 = this.indexes[m], d2 = v3(this.proxyOf.nodes[n2], n2), d2 !== false); )
        this.indexes[m] += 1;
      return delete this.indexes[m], d2;
    }
    every(v3) {
      return this.nodes.every(v3);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let v3 = this.lastEach;
      return this.indexes[v3] = 0, v3;
    }
    getProxyProcessor() {
      return {
        get(v3, m) {
          return m === "proxyOf" ? v3 : v3[m] ? m === "each" || typeof m == "string" && m.startsWith("walk") ? (...n2) => v3[m](
            ...n2.map((d2) => typeof d2 == "function" ? (_3, w3) => d2(_3.toProxy(), w3) : d2)
          ) : m === "every" || m === "some" ? (n2) => v3[m](
            (d2, ..._3) => n2(d2.toProxy(), ..._3)
          ) : m === "root" ? () => v3.root().toProxy() : m === "nodes" ? v3.nodes.map((n2) => n2.toProxy()) : m === "first" || m === "last" ? v3[m].toProxy() : v3[m] : v3[m];
        },
        set(v3, m, n2) {
          return v3[m] === n2 || (v3[m] = n2, (m === "name" || m === "params" || m === "selector") && v3.markDirty()), true;
        }
      };
    }
    index(v3) {
      return typeof v3 == "number" ? v3 : (v3.proxyOf && (v3 = v3.proxyOf), this.proxyOf.nodes.indexOf(v3));
    }
    insertAfter(v3, m) {
      let n2 = this.index(v3), d2 = this.normalize(m, this.proxyOf.nodes[n2]).reverse();
      n2 = this.index(v3);
      for (let w3 of d2) this.proxyOf.nodes.splice(n2 + 1, 0, w3);
      let _3;
      for (let w3 in this.indexes)
        _3 = this.indexes[w3], n2 < _3 && (this.indexes[w3] = _3 + d2.length);
      return this.markDirty(), this;
    }
    insertBefore(v3, m) {
      let n2 = this.index(v3), d2 = n2 === 0 ? "prepend" : false, _3 = this.normalize(
        m,
        this.proxyOf.nodes[n2],
        d2
      ).reverse();
      n2 = this.index(v3);
      for (let y2 of _3) this.proxyOf.nodes.splice(n2, 0, y2);
      let w3;
      for (let y2 in this.indexes)
        w3 = this.indexes[y2], n2 <= w3 && (this.indexes[y2] = w3 + _3.length);
      return this.markDirty(), this;
    }
    normalize(v3, m) {
      if (typeof v3 == "string")
        v3 = e2(s2(v3).nodes);
      else if (typeof v3 > "u")
        v3 = [];
      else if (Array.isArray(v3)) {
        v3 = v3.slice(0);
        for (let d2 of v3)
          d2.parent && d2.parent.removeChild(d2, "ignore");
      } else if (v3.type === "root" && this.type !== "document") {
        v3 = v3.nodes.slice(0);
        for (let d2 of v3)
          d2.parent && d2.parent.removeChild(d2, "ignore");
      } else if (v3.type)
        v3 = [v3];
      else if (v3.prop) {
        if (typeof v3.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof v3.value != "string" && (v3.value = String(v3.value)), v3 = [new a(v3)];
      } else if (v3.selector || v3.selectors)
        v3 = [new t8(v3)];
      else if (v3.name)
        v3 = [new f(v3)];
      else if (v3.text)
        v3 = [new u(v3)];
      else
        throw new Error("Unknown node type in node creation");
      return v3.map((d2) => (d2[l2] || i.rebuild(d2), d2 = d2.proxyOf, d2.parent && d2.parent.removeChild(d2), d2[p] && r2(d2), d2.raws || (d2.raws = {}), typeof d2.raws.before > "u" && m && typeof m.raws.before < "u" && (d2.raws.before = m.raws.before.replace(/\S/g, "")), d2.parent = this.proxyOf, d2));
    }
    prepend(...v3) {
      v3 = v3.reverse();
      for (let m of v3) {
        let n2 = this.normalize(m, this.first, "prepend").reverse();
        for (let d2 of n2) this.proxyOf.nodes.unshift(d2);
        for (let d2 in this.indexes)
          this.indexes[d2] = this.indexes[d2] + n2.length;
      }
      return this.markDirty(), this;
    }
    push(v3) {
      return v3.parent = this, this.proxyOf.nodes.push(v3), this;
    }
    removeAll() {
      for (let v3 of this.proxyOf.nodes) v3.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(v3) {
      v3 = this.index(v3), this.proxyOf.nodes[v3].parent = void 0, this.proxyOf.nodes.splice(v3, 1);
      let m;
      for (let n2 in this.indexes)
        m = this.indexes[n2], m >= v3 && (this.indexes[n2] = m - 1);
      return this.markDirty(), this;
    }
    replaceValues(v3, m, n2) {
      return n2 || (n2 = m, m = {}), this.walkDecls((d2) => {
        m.props && !m.props.includes(d2.prop) || m.fast && !d2.value.includes(m.fast) || (d2.value = d2.value.replace(v3, n2));
      }), this.markDirty(), this;
    }
    some(v3) {
      return this.nodes.some(v3);
    }
    walk(v3) {
      return this.each((m, n2) => {
        let d2;
        try {
          d2 = v3(m, n2);
        } catch (_3) {
          throw m.addToError(_3);
        }
        return d2 !== false && m.walk && (d2 = m.walk(v3)), d2;
      });
    }
    walkAtRules(v3, m) {
      return m ? v3 instanceof RegExp ? this.walk((n2, d2) => {
        if (n2.type === "atrule" && v3.test(n2.name))
          return m(n2, d2);
      }) : this.walk((n2, d2) => {
        if (n2.type === "atrule" && n2.name === v3)
          return m(n2, d2);
      }) : (m = v3, this.walk((n2, d2) => {
        if (n2.type === "atrule")
          return m(n2, d2);
      }));
    }
    walkComments(v3) {
      return this.walk((m, n2) => {
        if (m.type === "comment")
          return v3(m, n2);
      });
    }
    walkDecls(v3, m) {
      return m ? v3 instanceof RegExp ? this.walk((n2, d2) => {
        if (n2.type === "decl" && v3.test(n2.prop))
          return m(n2, d2);
      }) : this.walk((n2, d2) => {
        if (n2.type === "decl" && n2.prop === v3)
          return m(n2, d2);
      }) : (m = v3, this.walk((n2, d2) => {
        if (n2.type === "decl")
          return m(n2, d2);
      }));
    }
    walkRules(v3, m) {
      return m ? v3 instanceof RegExp ? this.walk((n2, d2) => {
        if (n2.type === "rule" && v3.test(n2.selector))
          return m(n2, d2);
      }) : this.walk((n2, d2) => {
        if (n2.type === "rule" && n2.selector === v3)
          return m(n2, d2);
      }) : (m = v3, this.walk((n2, d2) => {
        if (n2.type === "rule")
          return m(n2, d2);
      }));
    }
  }
  return i.registerParse = (o2) => {
    s2 = o2;
  }, i.registerRule = (o2) => {
    t8 = o2;
  }, i.registerAtRule = (o2) => {
    f = o2;
  }, i.registerRoot = (o2) => {
    c2 = o2;
  }, Rr3 = i, i.default = i, i.rebuild = (o2) => {
    o2.type === "atrule" ? Object.setPrototypeOf(o2, f.prototype) : o2.type === "rule" ? Object.setPrototypeOf(o2, t8.prototype) : o2.type === "decl" ? Object.setPrototypeOf(o2, a.prototype) : o2.type === "comment" ? Object.setPrototypeOf(o2, u.prototype) : o2.type === "root" && Object.setPrototypeOf(o2, c2.prototype), o2[l2] = true, o2.nodes && o2.nodes.forEach((v3) => {
      i.rebuild(v3);
    });
  }, Rr3;
}
var Ir3;
var ca2;
function Ri2() {
  if (ca2) return Ir3;
  ca2 = 1;
  let u = nt3();
  class a extends u {
    constructor(p) {
      super(p), this.type = "atrule";
    }
    append(...p) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...p);
    }
    prepend(...p) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...p);
    }
  }
  return Ir3 = a, a.default = a, u.registerAtRule(a), Ir3;
}
var Mr2;
var da2;
function Ii2() {
  if (da2) return Mr2;
  da2 = 1;
  let u = nt3(), a, h2;
  class p extends u {
    constructor(f) {
      super({ type: "document", ...f }), this.nodes || (this.nodes = []);
    }
    toResult(f = {}) {
      return new a(new h2(), this, f).stringify();
    }
  }
  return p.registerLazyResult = (l2) => {
    a = l2;
  }, p.registerProcessor = (l2) => {
    h2 = l2;
  }, Mr2 = p, p.default = p, Mr2;
}
var Dr3;
var pa2;
function hu2() {
  if (pa2) return Dr3;
  pa2 = 1;
  let u = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  return Dr3 = { nanoid: (p = 21) => {
    let l2 = "", f = p | 0;
    for (; f--; )
      l2 += u[Math.random() * 64 | 0];
    return l2;
  }, customAlphabet: (p, l2 = 21) => (f = l2) => {
    let s2 = "", c2 = f | 0;
    for (; c2--; )
      s2 += p[Math.random() * p.length | 0];
    return s2;
  } }, Dr3;
}
var qr2;
var ha2;
function pl() {
  if (ha2) return qr2;
  ha2 = 1;
  let { existsSync: u, readFileSync: a } = Ne3, { dirname: h2, join: p } = Ne3, { SourceMapConsumer: l2, SourceMapGenerator: f } = Ne3;
  function s2(t8) {
    return Buffer ? Buffer.from(t8, "base64").toString() : window.atob(t8);
  }
  class c2 {
    constructor(e2, r2) {
      if (r2.map === false) return;
      this.loadAnnotation(e2), this.inline = this.startWith(this.annotation, "data:");
      let i = r2.map ? r2.map.prev : void 0, o2 = this.loadMap(r2.from, i);
      !this.mapFile && r2.from && (this.mapFile = r2.from), this.mapFile && (this.root = h2(this.mapFile)), o2 && (this.text = o2);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new l2(this.text)), this.consumerCache;
    }
    decodeInline(e2) {
      let r2 = /^data:application\/json;charset=utf-?8;base64,/, i = /^data:application\/json;base64,/, o2 = /^data:application\/json;charset=utf-?8,/, v3 = /^data:application\/json,/, m = e2.match(o2) || e2.match(v3);
      if (m)
        return decodeURIComponent(e2.substr(m[0].length));
      let n2 = e2.match(r2) || e2.match(i);
      if (n2)
        return s2(e2.substr(n2[0].length));
      let d2 = e2.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + d2);
    }
    getAnnotationURL(e2) {
      return e2.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(e2) {
      return typeof e2 != "object" ? false : typeof e2.mappings == "string" || typeof e2._mappings == "string" || Array.isArray(e2.sections);
    }
    loadAnnotation(e2) {
      let r2 = e2.match(/\/\*\s*# sourceMappingURL=/g);
      if (!r2) return;
      let i = e2.lastIndexOf(r2.pop()), o2 = e2.indexOf("*/", i);
      i > -1 && o2 > -1 && (this.annotation = this.getAnnotationURL(e2.substring(i, o2)));
    }
    loadFile(e2) {
      if (this.root = h2(e2), u(e2))
        return this.mapFile = e2, a(e2, "utf-8").toString().trim();
    }
    loadMap(e2, r2) {
      if (r2 === false) return false;
      if (r2) {
        if (typeof r2 == "string")
          return r2;
        if (typeof r2 == "function") {
          let i = r2(e2);
          if (i) {
            let o2 = this.loadFile(i);
            if (!o2)
              throw new Error(
                "Unable to load previous source map: " + i.toString()
              );
            return o2;
          }
        } else {
          if (r2 instanceof l2)
            return f.fromSourceMap(r2).toString();
          if (r2 instanceof f)
            return r2.toString();
          if (this.isMap(r2))
            return JSON.stringify(r2);
          throw new Error(
            "Unsupported previous source map format: " + r2.toString()
          );
        }
      } else {
        if (this.inline)
          return this.decodeInline(this.annotation);
        if (this.annotation) {
          let i = this.annotation;
          return e2 && (i = p(h2(e2), i)), this.loadFile(i);
        }
      }
    }
    startWith(e2, r2) {
      return e2 ? e2.substr(0, r2.length) === r2 : false;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  }
  return qr2 = c2, c2.default = c2, qr2;
}
var Lr3;
var va2;
function cr3() {
  if (va2) return Lr3;
  va2 = 1;
  let { nanoid: u } = /* @__PURE__ */ hu2(), { isAbsolute: a, resolve: h2 } = Ne3, { SourceMapConsumer: p, SourceMapGenerator: l2 } = Ne3, { fileURLToPath: f, pathToFileURL: s2 } = Ne3, c2 = Ai2(), t8 = pl(), e2 = Ne3, r2 = Symbol("fromOffsetCache"), i = !!(p && l2), o2 = !!(h2 && a);
  class v3 {
    get from() {
      return this.file || this.id;
    }
    constructor(n2, d2 = {}) {
      if (n2 === null || typeof n2 > "u" || typeof n2 == "object" && !n2.toString)
        throw new Error(`PostCSS received ${n2} instead of CSS string`);
      if (this.css = n2.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, this.document = this.css, d2.document && (this.document = d2.document.toString()), d2.from && (!o2 || /^\w+:\/\//.test(d2.from) || a(d2.from) ? this.file = d2.from : this.file = h2(d2.from)), o2 && i) {
        let _3 = new t8(this.css, d2);
        if (_3.text) {
          this.map = _3;
          let w3 = _3.consumer().file;
          !this.file && w3 && (this.file = this.mapResolve(w3));
        }
      }
      this.file || (this.id = "<input css " + u(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(n2, d2, _3, w3 = {}) {
      let y2, x, g2;
      if (d2 && typeof d2 == "object") {
        let A = d2, E2 = _3;
        if (typeof A.offset == "number") {
          let b3 = this.fromOffset(A.offset);
          d2 = b3.line, _3 = b3.col;
        } else
          d2 = A.line, _3 = A.column;
        if (typeof E2.offset == "number") {
          let b3 = this.fromOffset(E2.offset);
          x = b3.line, y2 = b3.col;
        } else
          x = E2.line, y2 = E2.column;
      } else if (!_3) {
        let A = this.fromOffset(d2);
        d2 = A.line, _3 = A.col;
      }
      let O3 = this.origin(d2, _3, x, y2);
      return O3 ? g2 = new c2(
        n2,
        O3.endLine === void 0 ? O3.line : { column: O3.column, line: O3.line },
        O3.endLine === void 0 ? O3.column : { column: O3.endColumn, line: O3.endLine },
        O3.source,
        O3.file,
        w3.plugin
      ) : g2 = new c2(
        n2,
        x === void 0 ? d2 : { column: _3, line: d2 },
        x === void 0 ? _3 : { column: y2, line: x },
        this.css,
        this.file,
        w3.plugin
      ), g2.input = { column: _3, endColumn: y2, endLine: x, line: d2, source: this.css }, this.file && (s2 && (g2.input.url = s2(this.file).toString()), g2.input.file = this.file), g2;
    }
    fromOffset(n2) {
      let d2, _3;
      if (this[r2])
        _3 = this[r2];
      else {
        let y2 = this.css.split(`
`);
        _3 = new Array(y2.length);
        let x = 0;
        for (let g2 = 0, O3 = y2.length; g2 < O3; g2++)
          _3[g2] = x, x += y2[g2].length + 1;
        this[r2] = _3;
      }
      d2 = _3[_3.length - 1];
      let w3 = 0;
      if (n2 >= d2)
        w3 = _3.length - 1;
      else {
        let y2 = _3.length - 2, x;
        for (; w3 < y2; )
          if (x = w3 + (y2 - w3 >> 1), n2 < _3[x])
            y2 = x - 1;
          else if (n2 >= _3[x + 1])
            w3 = x + 1;
          else {
            w3 = x;
            break;
          }
      }
      return {
        col: n2 - _3[w3] + 1,
        line: w3 + 1
      };
    }
    mapResolve(n2) {
      return /^\w+:\/\//.test(n2) ? n2 : h2(this.map.consumer().sourceRoot || this.map.root || ".", n2);
    }
    origin(n2, d2, _3, w3) {
      if (!this.map) return false;
      let y2 = this.map.consumer(), x = y2.originalPositionFor({ column: d2, line: n2 });
      if (!x.source) return false;
      let g2;
      typeof _3 == "number" && (g2 = y2.originalPositionFor({ column: w3, line: _3 }));
      let O3;
      a(x.source) ? O3 = s2(x.source) : O3 = new URL(
        x.source,
        this.map.consumer().sourceRoot || s2(this.map.mapFile)
      );
      let A = {
        column: x.column,
        endColumn: g2 && g2.column,
        endLine: g2 && g2.line,
        line: x.line,
        url: O3.toString()
      };
      if (O3.protocol === "file:")
        if (f)
          A.file = f(O3);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let E2 = y2.sourceContentFor(x.source);
      return E2 && (A.source = E2), A;
    }
    toJSON() {
      let n2 = {};
      for (let d2 of ["hasBOM", "css", "file", "id"])
        this[d2] != null && (n2[d2] = this[d2]);
      return this.map && (n2.map = { ...this.map }, n2.map.consumerCache && (n2.map.consumerCache = void 0)), n2;
    }
  }
  return Lr3 = v3, v3.default = v3, e2 && e2.registerInput && e2.registerInput(v3), Lr3;
}
var Nr3;
var ga2;
function lt2() {
  if (ga2) return Nr3;
  ga2 = 1;
  let u = nt3(), a, h2;
  class p extends u {
    constructor(f) {
      super(f), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(f, s2, c2) {
      let t8 = super.normalize(f);
      if (s2) {
        if (c2 === "prepend")
          this.nodes.length > 1 ? s2.raws.before = this.nodes[1].raws.before : delete s2.raws.before;
        else if (this.first !== s2)
          for (let e2 of t8)
            e2.raws.before = s2.raws.before;
      }
      return t8;
    }
    removeChild(f, s2) {
      let c2 = this.index(f);
      return !s2 && c2 === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[c2].raws.before), super.removeChild(f);
    }
    toResult(f = {}) {
      return new a(new h2(), this, f).stringify();
    }
  }
  return p.registerLazyResult = (l2) => {
    a = l2;
  }, p.registerProcessor = (l2) => {
    h2 = l2;
  }, Nr3 = p, p.default = p, u.registerRoot(p), Nr3;
}
var Fr3;
var ma2;
function hl() {
  if (ma2) return Fr3;
  ma2 = 1;
  let u = {
    comma(a) {
      return u.split(a, [","], true);
    },
    space(a) {
      let h2 = [" ", `
`, "	"];
      return u.split(a, h2);
    },
    split(a, h2, p) {
      let l2 = [], f = "", s2 = false, c2 = 0, t8 = false, e2 = "", r2 = false;
      for (let i of a)
        r2 ? r2 = false : i === "\\" ? r2 = true : t8 ? i === e2 && (t8 = false) : i === '"' || i === "'" ? (t8 = true, e2 = i) : i === "(" ? c2 += 1 : i === ")" ? c2 > 0 && (c2 -= 1) : c2 === 0 && h2.includes(i) && (s2 = true), s2 ? (f !== "" && l2.push(f.trim()), f = "", s2 = false) : f += i;
      return (p || f !== "") && l2.push(f.trim()), l2;
    }
  };
  return Fr3 = u, u.default = u, Fr3;
}
var $r3;
var ya2;
function Mi2() {
  if (ya2) return $r3;
  ya2 = 1;
  let u = nt3(), a = hl();
  class h2 extends u {
    get selectors() {
      return a.comma(this.selector);
    }
    set selectors(l2) {
      let f = this.selector ? this.selector.match(/,\s*/) : null, s2 = f ? f[0] : "," + this.raw("between", "beforeOpen");
      this.selector = l2.join(s2);
    }
    constructor(l2) {
      super(l2), this.type = "rule", this.nodes || (this.nodes = []);
    }
  }
  return $r3 = h2, h2.default = h2, u.registerRule(h2), $r3;
}
var Ur3;
var wa2;
function vu2() {
  if (wa2) return Ur3;
  wa2 = 1;
  let u = Ri2(), a = ur3(), h2 = fr3(), p = cr3(), l2 = pl(), f = lt2(), s2 = Mi2();
  function c2(t8, e2) {
    if (Array.isArray(t8)) return t8.map((o2) => c2(o2));
    let { inputs: r2, ...i } = t8;
    if (r2) {
      e2 = [];
      for (let o2 of r2) {
        let v3 = { ...o2, __proto__: p.prototype };
        v3.map && (v3.map = {
          ...v3.map,
          __proto__: l2.prototype
        }), e2.push(v3);
      }
    }
    if (i.nodes && (i.nodes = t8.nodes.map((o2) => c2(o2, e2))), i.source) {
      let { inputId: o2, ...v3 } = i.source;
      i.source = v3, o2 != null && (i.source.input = e2[o2]);
    }
    if (i.type === "root")
      return new f(i);
    if (i.type === "decl")
      return new h2(i);
    if (i.type === "rule")
      return new s2(i);
    if (i.type === "comment")
      return new a(i);
    if (i.type === "atrule")
      return new u(i);
    throw new Error("Unknown node type: " + t8.type);
  }
  return Ur3 = c2, c2.default = c2, Ur3;
}
var zr2;
var ba2;
function vl() {
  if (ba2) return zr2;
  ba2 = 1;
  let { dirname: u, relative: a, resolve: h2, sep: p } = Ne3, { SourceMapConsumer: l2, SourceMapGenerator: f } = Ne3, { pathToFileURL: s2 } = Ne3, c2 = cr3(), t8 = !!(l2 && f), e2 = !!(u && h2 && a && p);
  class r2 {
    constructor(o2, v3, m, n2) {
      this.stringify = o2, this.mapOpts = m.map || {}, this.root = v3, this.opts = m, this.css = n2, this.originalCSS = n2, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
    }
    addAnnotation() {
      let o2;
      this.isInline() ? o2 = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? o2 = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? o2 = this.mapOpts.annotation(this.opts.to, this.root) : o2 = this.outputFile() + ".map";
      let v3 = `
`;
      this.css.includes(`\r
`) && (v3 = `\r
`), this.css += v3 + "/*# sourceMappingURL=" + o2 + " */";
    }
    applyPrevMaps() {
      for (let o2 of this.previous()) {
        let v3 = this.toUrl(this.path(o2.file)), m = o2.root || u(o2.file), n2;
        this.mapOpts.sourcesContent === false ? (n2 = new l2(o2.text), n2.sourcesContent && (n2.sourcesContent = null)) : n2 = o2.consumer(), this.map.applySourceMap(n2, v3, this.toUrl(this.path(m)));
      }
    }
    clearAnnotation() {
      if (this.mapOpts.annotation !== false)
        if (this.root) {
          let o2;
          for (let v3 = this.root.nodes.length - 1; v3 >= 0; v3--)
            o2 = this.root.nodes[v3], o2.type === "comment" && o2.text.startsWith("# sourceMappingURL=") && this.root.removeChild(v3);
        } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), e2 && t8 && this.isMap())
        return this.generateMap();
      {
        let o2 = "";
        return this.stringify(this.root, (v3) => {
          o2 += v3;
        }), [o2];
      }
    }
    generateMap() {
      if (this.root)
        this.generateString();
      else if (this.previous().length === 1) {
        let o2 = this.previous()[0].consumer();
        o2.file = this.outputFile(), this.map = f.fromSourceMap(o2, {
          ignoreInvalidMapping: true
        });
      } else
        this.map = new f({
          file: this.outputFile(),
          ignoreInvalidMapping: true
        }), this.map.addMapping({
          generated: { column: 0, line: 1 },
          original: { column: 0, line: 1 },
          source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
        });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new f({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      });
      let o2 = 1, v3 = 1, m = "<no source>", n2 = {
        generated: { column: 0, line: 0 },
        original: { column: 0, line: 0 },
        source: ""
      }, d2, _3;
      this.stringify(this.root, (w3, y2, x) => {
        if (this.css += w3, y2 && x !== "end" && (n2.generated.line = o2, n2.generated.column = v3 - 1, y2.source && y2.source.start ? (n2.source = this.sourcePath(y2), n2.original.line = y2.source.start.line, n2.original.column = y2.source.start.column - 1, this.map.addMapping(n2)) : (n2.source = m, n2.original.line = 1, n2.original.column = 0, this.map.addMapping(n2))), _3 = w3.match(/\n/g), _3 ? (o2 += _3.length, d2 = w3.lastIndexOf(`
`), v3 = w3.length - d2) : v3 += w3.length, y2 && x !== "start") {
          let g2 = y2.parent || { raws: {} };
          (!(y2.type === "decl" || y2.type === "atrule" && !y2.nodes) || y2 !== g2.last || g2.raws.semicolon) && (y2.source && y2.source.end ? (n2.source = this.sourcePath(y2), n2.original.line = y2.source.end.line, n2.original.column = y2.source.end.column - 1, n2.generated.line = o2, n2.generated.column = v3 - 2, this.map.addMapping(n2)) : (n2.source = m, n2.original.line = 1, n2.original.column = 0, n2.generated.line = o2, n2.generated.column = v3 - 1, this.map.addMapping(n2)));
        }
      });
    }
    isAnnotation() {
      return this.isInline() ? true : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((o2) => o2.annotation) : true;
    }
    isInline() {
      if (typeof this.mapOpts.inline < "u")
        return this.mapOpts.inline;
      let o2 = this.mapOpts.annotation;
      return typeof o2 < "u" && o2 !== true ? false : this.previous().length ? this.previous().some((v3) => v3.inline) : true;
    }
    isMap() {
      return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((o2) => o2.withContent()) : true;
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(o2) {
      if (this.mapOpts.absolute || o2.charCodeAt(0) === 60 || /^\w+:\/\//.test(o2)) return o2;
      let v3 = this.memoizedPaths.get(o2);
      if (v3) return v3;
      let m = this.opts.to ? u(this.opts.to) : ".";
      typeof this.mapOpts.annotation == "string" && (m = u(h2(m, this.mapOpts.annotation)));
      let n2 = a(m, o2);
      return this.memoizedPaths.set(o2, n2), n2;
    }
    previous() {
      if (!this.previousMaps)
        if (this.previousMaps = [], this.root)
          this.root.walk((o2) => {
            if (o2.source && o2.source.input.map) {
              let v3 = o2.source.input.map;
              this.previousMaps.includes(v3) || this.previousMaps.push(v3);
            }
          });
        else {
          let o2 = new c2(this.originalCSS, this.opts);
          o2.map && this.previousMaps.push(o2.map);
        }
      return this.previousMaps;
    }
    setSourcesContent() {
      let o2 = {};
      if (this.root)
        this.root.walk((v3) => {
          if (v3.source) {
            let m = v3.source.input.from;
            if (m && !o2[m]) {
              o2[m] = true;
              let n2 = this.usesFileUrls ? this.toFileUrl(m) : this.toUrl(this.path(m));
              this.map.setSourceContent(n2, v3.source.input.css);
            }
          }
        });
      else if (this.css) {
        let v3 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(v3, this.css);
      }
    }
    sourcePath(o2) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(o2.source.input.from) : this.toUrl(this.path(o2.source.input.from));
    }
    toBase64(o2) {
      return Buffer ? Buffer.from(o2).toString("base64") : window.btoa(unescape(encodeURIComponent(o2)));
    }
    toFileUrl(o2) {
      let v3 = this.memoizedFileURLs.get(o2);
      if (v3) return v3;
      if (s2) {
        let m = s2(o2).toString();
        return this.memoizedFileURLs.set(o2, m), m;
      } else
        throw new Error(
          "`map.absolute` option is not available in this PostCSS build"
        );
    }
    toUrl(o2) {
      let v3 = this.memoizedURLs.get(o2);
      if (v3) return v3;
      p === "\\" && (o2 = o2.replace(/\\/g, "/"));
      let m = encodeURI(o2).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(o2, m), m;
    }
  }
  return zr2 = r2, zr2;
}
var Wr3;
var _a3;
function gu2() {
  if (_a3) return Wr3;
  _a3 = 1;
  const u = 39, a = 34, h2 = 92, p = 47, l2 = 10, f = 32, s2 = 12, c2 = 9, t8 = 13, e2 = 91, r2 = 93, i = 40, o2 = 41, v3 = 123, m = 125, n2 = 59, d2 = 42, _3 = 58, w3 = 64, y2 = /[\t\n\f\r "#'()/;[\\\]{}]/g, x = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, g2 = /.[\r\n"'(/\\]/, O3 = /[\da-f]/i;
  return Wr3 = function(E2, b3 = {}) {
    let k3 = E2.css.valueOf(), q2 = b3.ignoreErrors, M2, W3, S3, P3, C, R3, $2, B3, z3, L3, F = k3.length, D = 0, I3 = [], N3 = [];
    function J3() {
      return D;
    }
    function T3(V4) {
      throw E2.error("Unclosed " + V4, D);
    }
    function U2() {
      return N3.length === 0 && D >= F;
    }
    function j3(V4) {
      if (N3.length) return N3.pop();
      if (D >= F) return;
      let K3 = V4 ? V4.ignoreUnclosed : false;
      switch (M2 = k3.charCodeAt(D), M2) {
        case l2:
        case f:
        case c2:
        case t8:
        case s2: {
          P3 = D;
          do
            P3 += 1, M2 = k3.charCodeAt(P3);
          while (M2 === f || M2 === l2 || M2 === c2 || M2 === t8 || M2 === s2);
          R3 = ["space", k3.slice(D, P3)], D = P3 - 1;
          break;
        }
        case e2:
        case r2:
        case v3:
        case m:
        case _3:
        case n2:
        case o2: {
          let X3 = String.fromCharCode(M2);
          R3 = [X3, X3, D];
          break;
        }
        case i: {
          if (L3 = I3.length ? I3.pop()[1] : "", z3 = k3.charCodeAt(D + 1), L3 === "url" && z3 !== u && z3 !== a && z3 !== f && z3 !== l2 && z3 !== c2 && z3 !== s2 && z3 !== t8) {
            P3 = D;
            do {
              if ($2 = false, P3 = k3.indexOf(")", P3 + 1), P3 === -1)
                if (q2 || K3) {
                  P3 = D;
                  break;
                } else
                  T3("bracket");
              for (B3 = P3; k3.charCodeAt(B3 - 1) === h2; )
                B3 -= 1, $2 = !$2;
            } while ($2);
            R3 = ["brackets", k3.slice(D, P3 + 1), D, P3], D = P3;
          } else
            P3 = k3.indexOf(")", D + 1), W3 = k3.slice(D, P3 + 1), P3 === -1 || g2.test(W3) ? R3 = ["(", "(", D] : (R3 = ["brackets", W3, D, P3], D = P3);
          break;
        }
        case u:
        case a: {
          C = M2 === u ? "'" : '"', P3 = D;
          do {
            if ($2 = false, P3 = k3.indexOf(C, P3 + 1), P3 === -1)
              if (q2 || K3) {
                P3 = D + 1;
                break;
              } else
                T3("string");
            for (B3 = P3; k3.charCodeAt(B3 - 1) === h2; )
              B3 -= 1, $2 = !$2;
          } while ($2);
          R3 = ["string", k3.slice(D, P3 + 1), D, P3], D = P3;
          break;
        }
        case w3: {
          y2.lastIndex = D + 1, y2.test(k3), y2.lastIndex === 0 ? P3 = k3.length - 1 : P3 = y2.lastIndex - 2, R3 = ["at-word", k3.slice(D, P3 + 1), D, P3], D = P3;
          break;
        }
        case h2: {
          for (P3 = D, S3 = true; k3.charCodeAt(P3 + 1) === h2; )
            P3 += 1, S3 = !S3;
          if (M2 = k3.charCodeAt(P3 + 1), S3 && M2 !== p && M2 !== f && M2 !== l2 && M2 !== c2 && M2 !== t8 && M2 !== s2 && (P3 += 1, O3.test(k3.charAt(P3)))) {
            for (; O3.test(k3.charAt(P3 + 1)); )
              P3 += 1;
            k3.charCodeAt(P3 + 1) === f && (P3 += 1);
          }
          R3 = ["word", k3.slice(D, P3 + 1), D, P3], D = P3;
          break;
        }
        default: {
          M2 === p && k3.charCodeAt(D + 1) === d2 ? (P3 = k3.indexOf("*/", D + 2) + 1, P3 === 0 && (q2 || K3 ? P3 = k3.length : T3("comment")), R3 = ["comment", k3.slice(D, P3 + 1), D, P3], D = P3) : (x.lastIndex = D + 1, x.test(k3), x.lastIndex === 0 ? P3 = k3.length - 1 : P3 = x.lastIndex - 2, R3 = ["word", k3.slice(D, P3 + 1), D, P3], I3.push(R3), D = P3);
          break;
        }
      }
      return D++, R3;
    }
    function H3(V4) {
      N3.push(V4);
    }
    return {
      back: H3,
      endOfFile: U2,
      nextToken: j3,
      position: J3
    };
  }, Wr3;
}
var Vr2;
var Sa2;
function mu2() {
  if (Sa2) return Vr2;
  Sa2 = 1;
  let u = Ri2(), a = ur3(), h2 = fr3(), p = lt2(), l2 = Mi2(), f = gu2();
  const s2 = {
    empty: true,
    space: true
  };
  function c2(e2) {
    for (let r2 = e2.length - 1; r2 >= 0; r2--) {
      let i = e2[r2], o2 = i[3] || i[2];
      if (o2) return o2;
    }
  }
  class t8 {
    constructor(r2) {
      this.input = r2, this.root = new p(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: r2, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(r2) {
      let i = new u();
      i.name = r2[1].slice(1), i.name === "" && this.unnamedAtrule(i, r2), this.init(i, r2[2]);
      let o2, v3, m, n2 = false, d2 = false, _3 = [], w3 = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (r2 = this.tokenizer.nextToken(), o2 = r2[0], o2 === "(" || o2 === "[" ? w3.push(o2 === "(" ? ")" : "]") : o2 === "{" && w3.length > 0 ? w3.push("}") : o2 === w3[w3.length - 1] && w3.pop(), w3.length === 0)
          if (o2 === ";") {
            i.source.end = this.getPosition(r2[2]), i.source.end.offset++, this.semicolon = true;
            break;
          } else if (o2 === "{") {
            d2 = true;
            break;
          } else if (o2 === "}") {
            if (_3.length > 0) {
              for (m = _3.length - 1, v3 = _3[m]; v3 && v3[0] === "space"; )
                v3 = _3[--m];
              v3 && (i.source.end = this.getPosition(v3[3] || v3[2]), i.source.end.offset++);
            }
            this.end(r2);
            break;
          } else
            _3.push(r2);
        else
          _3.push(r2);
        if (this.tokenizer.endOfFile()) {
          n2 = true;
          break;
        }
      }
      i.raws.between = this.spacesAndCommentsFromEnd(_3), _3.length ? (i.raws.afterName = this.spacesAndCommentsFromStart(_3), this.raw(i, "params", _3), n2 && (r2 = _3[_3.length - 1], i.source.end = this.getPosition(r2[3] || r2[2]), i.source.end.offset++, this.spaces = i.raws.between, i.raws.between = "")) : (i.raws.afterName = "", i.params = ""), d2 && (i.nodes = [], this.current = i);
    }
    checkMissedSemicolon(r2) {
      let i = this.colon(r2);
      if (i === false) return;
      let o2 = 0, v3;
      for (let m = i - 1; m >= 0 && (v3 = r2[m], !(v3[0] !== "space" && (o2 += 1, o2 === 2))); m--)
        ;
      throw this.input.error(
        "Missed semicolon",
        v3[0] === "word" ? v3[3] + 1 : v3[2]
      );
    }
    colon(r2) {
      let i = 0, o2, v3, m;
      for (let [n2, d2] of r2.entries()) {
        if (v3 = d2, m = v3[0], m === "(" && (i += 1), m === ")" && (i -= 1), i === 0 && m === ":")
          if (!o2)
            this.doubleColon(v3);
          else {
            if (o2[0] === "word" && o2[1] === "progid")
              continue;
            return n2;
          }
        o2 = v3;
      }
      return false;
    }
    comment(r2) {
      let i = new a();
      this.init(i, r2[2]), i.source.end = this.getPosition(r2[3] || r2[2]), i.source.end.offset++;
      let o2 = r2[1].slice(2, -2);
      if (/^\s*$/.test(o2))
        i.text = "", i.raws.left = o2, i.raws.right = "";
      else {
        let v3 = o2.match(/^(\s*)([^]*\S)(\s*)$/);
        i.text = v3[2], i.raws.left = v3[1], i.raws.right = v3[3];
      }
    }
    createTokenizer() {
      this.tokenizer = f(this.input);
    }
    decl(r2, i) {
      let o2 = new h2();
      this.init(o2, r2[0][2]);
      let v3 = r2[r2.length - 1];
      for (v3[0] === ";" && (this.semicolon = true, r2.pop()), o2.source.end = this.getPosition(
        v3[3] || v3[2] || c2(r2)
      ), o2.source.end.offset++; r2[0][0] !== "word"; )
        r2.length === 1 && this.unknownWord(r2), o2.raws.before += r2.shift()[1];
      for (o2.source.start = this.getPosition(r2[0][2]), o2.prop = ""; r2.length; ) {
        let w3 = r2[0][0];
        if (w3 === ":" || w3 === "space" || w3 === "comment")
          break;
        o2.prop += r2.shift()[1];
      }
      o2.raws.between = "";
      let m;
      for (; r2.length; )
        if (m = r2.shift(), m[0] === ":") {
          o2.raws.between += m[1];
          break;
        } else
          m[0] === "word" && /\w/.test(m[1]) && this.unknownWord([m]), o2.raws.between += m[1];
      (o2.prop[0] === "_" || o2.prop[0] === "*") && (o2.raws.before += o2.prop[0], o2.prop = o2.prop.slice(1));
      let n2 = [], d2;
      for (; r2.length && (d2 = r2[0][0], !(d2 !== "space" && d2 !== "comment")); )
        n2.push(r2.shift());
      this.precheckMissedSemicolon(r2);
      for (let w3 = r2.length - 1; w3 >= 0; w3--) {
        if (m = r2[w3], m[1].toLowerCase() === "!important") {
          o2.important = true;
          let y2 = this.stringFrom(r2, w3);
          y2 = this.spacesFromEnd(r2) + y2, y2 !== " !important" && (o2.raws.important = y2);
          break;
        } else if (m[1].toLowerCase() === "important") {
          let y2 = r2.slice(0), x = "";
          for (let g2 = w3; g2 > 0; g2--) {
            let O3 = y2[g2][0];
            if (x.trim().startsWith("!") && O3 !== "space")
              break;
            x = y2.pop()[1] + x;
          }
          x.trim().startsWith("!") && (o2.important = true, o2.raws.important = x, r2 = y2);
        }
        if (m[0] !== "space" && m[0] !== "comment")
          break;
      }
      r2.some((w3) => w3[0] !== "space" && w3[0] !== "comment") && (o2.raws.between += n2.map((w3) => w3[1]).join(""), n2 = []), this.raw(o2, "value", n2.concat(r2), i), o2.value.includes(":") && !i && this.checkMissedSemicolon(r2);
    }
    doubleColon(r2) {
      throw this.input.error(
        "Double colon",
        { offset: r2[2] },
        { offset: r2[2] + r2[1].length }
      );
    }
    emptyRule(r2) {
      let i = new l2();
      this.init(i, r2[2]), i.selector = "", i.raws.between = "", this.current = i;
    }
    end(r2) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(r2[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(r2);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(r2) {
      if (this.spaces += r2[1], this.current.nodes) {
        let i = this.current.nodes[this.current.nodes.length - 1];
        i && i.type === "rule" && !i.raws.ownSemicolon && (i.raws.ownSemicolon = this.spaces, this.spaces = "", i.source.end = this.getPosition(r2[2]), i.source.end.offset += i.raws.ownSemicolon.length);
      }
    }
    // Helpers
    getPosition(r2) {
      let i = this.input.fromOffset(r2);
      return {
        column: i.col,
        line: i.line,
        offset: r2
      };
    }
    init(r2, i) {
      this.current.push(r2), r2.source = {
        input: this.input,
        start: this.getPosition(i)
      }, r2.raws.before = this.spaces, this.spaces = "", r2.type !== "comment" && (this.semicolon = false);
    }
    other(r2) {
      let i = false, o2 = null, v3 = false, m = null, n2 = [], d2 = r2[1].startsWith("--"), _3 = [], w3 = r2;
      for (; w3; ) {
        if (o2 = w3[0], _3.push(w3), o2 === "(" || o2 === "[")
          m || (m = w3), n2.push(o2 === "(" ? ")" : "]");
        else if (d2 && v3 && o2 === "{")
          m || (m = w3), n2.push("}");
        else if (n2.length === 0)
          if (o2 === ";")
            if (v3) {
              this.decl(_3, d2);
              return;
            } else
              break;
          else if (o2 === "{") {
            this.rule(_3);
            return;
          } else if (o2 === "}") {
            this.tokenizer.back(_3.pop()), i = true;
            break;
          } else o2 === ":" && (v3 = true);
        else o2 === n2[n2.length - 1] && (n2.pop(), n2.length === 0 && (m = null));
        w3 = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (i = true), n2.length > 0 && this.unclosedBracket(m), i && v3) {
        if (!d2)
          for (; _3.length && (w3 = _3[_3.length - 1][0], !(w3 !== "space" && w3 !== "comment")); )
            this.tokenizer.back(_3.pop());
        this.decl(_3, d2);
      } else
        this.unknownWord(_3);
    }
    parse() {
      let r2;
      for (; !this.tokenizer.endOfFile(); )
        switch (r2 = this.tokenizer.nextToken(), r2[0]) {
          case "space":
            this.spaces += r2[1];
            break;
          case ";":
            this.freeSemicolon(r2);
            break;
          case "}":
            this.end(r2);
            break;
          case "comment":
            this.comment(r2);
            break;
          case "at-word":
            this.atrule(r2);
            break;
          case "{":
            this.emptyRule(r2);
            break;
          default:
            this.other(r2);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(r2, i, o2, v3) {
      let m, n2, d2 = o2.length, _3 = "", w3 = true, y2, x;
      for (let g2 = 0; g2 < d2; g2 += 1)
        m = o2[g2], n2 = m[0], n2 === "space" && g2 === d2 - 1 && !v3 ? w3 = false : n2 === "comment" ? (x = o2[g2 - 1] ? o2[g2 - 1][0] : "empty", y2 = o2[g2 + 1] ? o2[g2 + 1][0] : "empty", !s2[x] && !s2[y2] ? _3.slice(-1) === "," ? w3 = false : _3 += m[1] : w3 = false) : _3 += m[1];
      if (!w3) {
        let g2 = o2.reduce((O3, A) => O3 + A[1], "");
        r2.raws[i] = { raw: g2, value: _3 };
      }
      r2[i] = _3;
    }
    rule(r2) {
      r2.pop();
      let i = new l2();
      this.init(i, r2[0][2]), i.raws.between = this.spacesAndCommentsFromEnd(r2), this.raw(i, "selector", r2), this.current = i;
    }
    spacesAndCommentsFromEnd(r2) {
      let i, o2 = "";
      for (; r2.length && (i = r2[r2.length - 1][0], !(i !== "space" && i !== "comment")); )
        o2 = r2.pop()[1] + o2;
      return o2;
    }
    // Errors
    spacesAndCommentsFromStart(r2) {
      let i, o2 = "";
      for (; r2.length && (i = r2[0][0], !(i !== "space" && i !== "comment")); )
        o2 += r2.shift()[1];
      return o2;
    }
    spacesFromEnd(r2) {
      let i, o2 = "";
      for (; r2.length && (i = r2[r2.length - 1][0], i === "space"); )
        o2 = r2.pop()[1] + o2;
      return o2;
    }
    stringFrom(r2, i) {
      let o2 = "";
      for (let v3 = i; v3 < r2.length; v3++)
        o2 += r2[v3][1];
      return r2.splice(i, r2.length - i), o2;
    }
    unclosedBlock() {
      let r2 = this.current.source.start;
      throw this.input.error("Unclosed block", r2.line, r2.column);
    }
    unclosedBracket(r2) {
      throw this.input.error(
        "Unclosed bracket",
        { offset: r2[2] },
        { offset: r2[2] + 1 }
      );
    }
    unexpectedClose(r2) {
      throw this.input.error(
        "Unexpected }",
        { offset: r2[2] },
        { offset: r2[2] + 1 }
      );
    }
    unknownWord(r2) {
      throw this.input.error(
        "Unknown word " + r2[0][1],
        { offset: r2[0][2] },
        { offset: r2[0][2] + r2[0][1].length }
      );
    }
    unnamedAtrule(r2, i) {
      throw this.input.error(
        "At-rule without name",
        { offset: i[2] },
        { offset: i[2] + i[1].length }
      );
    }
  }
  return Vr2 = t8, Vr2;
}
var jr3;
var xa2;
function Di2() {
  if (xa2) return jr3;
  xa2 = 1;
  let u = nt3(), a = cr3(), h2 = mu2();
  function p(l2, f) {
    let s2 = new a(l2, f), c2 = new h2(s2);
    try {
      c2.parse();
    } catch (t8) {
      throw process.env.NODE_ENV !== "production" && t8.name === "CssSyntaxError" && f && f.from && (/\.scss$/i.test(f.from) ? t8.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(f.from) ? t8.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(f.from) && (t8.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), t8;
    }
    return c2.root;
  }
  return jr3 = p, p.default = p, u.registerParse(p), jr3;
}
var Br3;
var Oa2;
function gl() {
  if (Oa2) return Br3;
  Oa2 = 1;
  class u {
    constructor(h2, p = {}) {
      if (this.type = "warning", this.text = h2, p.node && p.node.source) {
        let l2 = p.node.rangeBy(p);
        this.line = l2.start.line, this.column = l2.start.column, this.endLine = l2.end.line, this.endColumn = l2.end.column;
      }
      for (let l2 in p) this[l2] = p[l2];
    }
    toString() {
      return this.node ? this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  }
  return Br3 = u, u.default = u, Br3;
}
var Gr3;
var ka2;
function qi2() {
  if (ka2) return Gr3;
  ka2 = 1;
  let u = gl();
  class a {
    get content() {
      return this.css;
    }
    constructor(p, l2, f) {
      this.processor = p, this.messages = [], this.root = l2, this.opts = f, this.css = void 0, this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(p, l2 = {}) {
      l2.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (l2.plugin = this.lastPlugin.postcssPlugin);
      let f = new u(p, l2);
      return this.messages.push(f), f;
    }
    warnings() {
      return this.messages.filter((p) => p.type === "warning");
    }
  }
  return Gr3 = a, a.default = a, Gr3;
}
var Yr2;
var Pa2;
function ml() {
  if (Pa2) return Yr2;
  Pa2 = 1;
  let u = {};
  return Yr2 = function(h2) {
    u[h2] || (u[h2] = true, typeof console < "u" && console.warn && console.warn(h2));
  }, Yr2;
}
var Qr3;
var Ea2;
function yl() {
  if (Ea2) return Qr3;
  Ea2 = 1;
  let u = nt3(), a = Ii2(), h2 = vl(), p = Di2(), l2 = qi2(), f = lt2(), s2 = or3(), { isClean: c2, my: t8 } = Ci2(), e2 = ml();
  const r2 = {
    atrule: "AtRule",
    comment: "Comment",
    decl: "Declaration",
    document: "Document",
    root: "Root",
    rule: "Rule"
  }, i = {
    AtRule: true,
    AtRuleExit: true,
    Comment: true,
    CommentExit: true,
    Declaration: true,
    DeclarationExit: true,
    Document: true,
    DocumentExit: true,
    Once: true,
    OnceExit: true,
    postcssPlugin: true,
    prepare: true,
    Root: true,
    RootExit: true,
    Rule: true,
    RuleExit: true
  }, o2 = {
    Once: true,
    postcssPlugin: true,
    prepare: true
  }, v3 = 0;
  function m(x) {
    return typeof x == "object" && typeof x.then == "function";
  }
  function n2(x) {
    let g2 = false, O3 = r2[x.type];
    return x.type === "decl" ? g2 = x.prop.toLowerCase() : x.type === "atrule" && (g2 = x.name.toLowerCase()), g2 && x.append ? [
      O3,
      O3 + "-" + g2,
      v3,
      O3 + "Exit",
      O3 + "Exit-" + g2
    ] : g2 ? [O3, O3 + "-" + g2, O3 + "Exit", O3 + "Exit-" + g2] : x.append ? [O3, v3, O3 + "Exit"] : [O3, O3 + "Exit"];
  }
  function d2(x) {
    let g2;
    return x.type === "document" ? g2 = ["Document", v3, "DocumentExit"] : x.type === "root" ? g2 = ["Root", v3, "RootExit"] : g2 = n2(x), {
      eventIndex: 0,
      events: g2,
      iterator: 0,
      node: x,
      visitorIndex: 0,
      visitors: []
    };
  }
  function _3(x) {
    return x[c2] = false, x.nodes && x.nodes.forEach((g2) => _3(g2)), x;
  }
  let w3 = {};
  class y2 {
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
    constructor(g2, O3, A) {
      this.stringified = false, this.processed = false;
      let E2;
      if (typeof O3 == "object" && O3 !== null && (O3.type === "root" || O3.type === "document"))
        E2 = _3(O3);
      else if (O3 instanceof y2 || O3 instanceof l2)
        E2 = _3(O3.root), O3.map && (typeof A.map > "u" && (A.map = {}), A.map.inline || (A.map.inline = false), A.map.prev = O3.map);
      else {
        let b3 = p;
        A.syntax && (b3 = A.syntax.parse), A.parser && (b3 = A.parser), b3.parse && (b3 = b3.parse);
        try {
          E2 = b3(O3, A);
        } catch (k3) {
          this.processed = true, this.error = k3;
        }
        E2 && !E2[t8] && u.rebuild(E2);
      }
      this.result = new l2(g2, E2, A), this.helpers = { ...w3, postcss: w3, result: this.result }, this.plugins = this.processor.plugins.map((b3) => typeof b3 == "object" && b3.prepare ? { ...b3, ...b3.prepare(this.result) } : b3);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(g2) {
      return this.async().catch(g2);
    }
    finally(g2) {
      return this.async().then(g2, g2);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(g2, O3) {
      let A = this.result.lastPlugin;
      try {
        if (O3 && O3.addToError(g2), this.error = g2, g2.name === "CssSyntaxError" && !g2.plugin)
          g2.plugin = A.postcssPlugin, g2.setMessage();
        else if (A.postcssVersion && process.env.NODE_ENV !== "production") {
          let E2 = A.postcssPlugin, b3 = A.postcssVersion, k3 = this.result.processor.version, q2 = b3.split("."), M2 = k3.split(".");
          (q2[0] !== M2[0] || parseInt(q2[1]) > parseInt(M2[1])) && console.error(
            "Unknown error from PostCSS plugin. Your current PostCSS version is " + k3 + ", but " + E2 + " uses " + b3 + ". Perhaps this is the source of the error below."
          );
        }
      } catch (E2) {
        console && console.error && console.error(E2);
      }
      return g2;
    }
    prepareVisitors() {
      this.listeners = {};
      let g2 = (O3, A, E2) => {
        this.listeners[A] || (this.listeners[A] = []), this.listeners[A].push([O3, E2]);
      };
      for (let O3 of this.plugins)
        if (typeof O3 == "object")
          for (let A in O3) {
            if (!i[A] && /^[A-Z]/.test(A))
              throw new Error(
                `Unknown event ${A} in ${O3.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
              );
            if (!o2[A])
              if (typeof O3[A] == "object")
                for (let E2 in O3[A])
                  E2 === "*" ? g2(O3, A, O3[A][E2]) : g2(
                    O3,
                    A + "-" + E2.toLowerCase(),
                    O3[A][E2]
                  );
              else typeof O3[A] == "function" && g2(O3, A, O3[A]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let g2 = 0; g2 < this.plugins.length; g2++) {
        let O3 = this.plugins[g2], A = this.runOnRoot(O3);
        if (m(A))
          try {
            await A;
          } catch (E2) {
            throw this.handleError(E2);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let g2 = this.result.root;
        for (; !g2[c2]; ) {
          g2[c2] = true;
          let O3 = [d2(g2)];
          for (; O3.length > 0; ) {
            let A = this.visitTick(O3);
            if (m(A))
              try {
                await A;
              } catch (E2) {
                let b3 = O3[O3.length - 1].node;
                throw this.handleError(E2, b3);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [O3, A] of this.listeners.OnceExit) {
            this.result.lastPlugin = O3;
            try {
              if (g2.type === "document") {
                let E2 = g2.nodes.map(
                  (b3) => A(b3, this.helpers)
                );
                await Promise.all(E2);
              } else
                await A(g2, this.helpers);
            } catch (E2) {
              throw this.handleError(E2);
            }
          }
      }
      return this.processed = true, this.stringify();
    }
    runOnRoot(g2) {
      this.result.lastPlugin = g2;
      try {
        if (typeof g2 == "object" && g2.Once) {
          if (this.result.root.type === "document") {
            let O3 = this.result.root.nodes.map(
              (A) => g2.Once(A, this.helpers)
            );
            return m(O3[0]) ? Promise.all(O3) : O3;
          }
          return g2.Once(this.result.root, this.helpers);
        } else if (typeof g2 == "function")
          return g2(this.result.root, this.result);
      } catch (O3) {
        throw this.handleError(O3);
      }
    }
    stringify() {
      if (this.error) throw this.error;
      if (this.stringified) return this.result;
      this.stringified = true, this.sync();
      let g2 = this.result.opts, O3 = s2;
      g2.syntax && (O3 = g2.syntax.stringify), g2.stringifier && (O3 = g2.stringifier), O3.stringify && (O3 = O3.stringify);
      let E2 = new h2(O3, this.result.root, this.result.opts).generate();
      return this.result.css = E2[0], this.result.map = E2[1], this.result;
    }
    sync() {
      if (this.error) throw this.error;
      if (this.processed) return this.result;
      if (this.processed = true, this.processing)
        throw this.getAsyncError();
      for (let g2 of this.plugins) {
        let O3 = this.runOnRoot(g2);
        if (m(O3))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let g2 = this.result.root;
        for (; !g2[c2]; )
          g2[c2] = true, this.walkSync(g2);
        if (this.listeners.OnceExit)
          if (g2.type === "document")
            for (let O3 of g2.nodes)
              this.visitSync(this.listeners.OnceExit, O3);
          else
            this.visitSync(this.listeners.OnceExit, g2);
      }
      return this.result;
    }
    then(g2, O3) {
      return process.env.NODE_ENV !== "production" && ("from" in this.opts || e2(
        "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
      )), this.async().then(g2, O3);
    }
    toString() {
      return this.css;
    }
    visitSync(g2, O3) {
      for (let [A, E2] of g2) {
        this.result.lastPlugin = A;
        let b3;
        try {
          b3 = E2(O3, this.helpers);
        } catch (k3) {
          throw this.handleError(k3, O3.proxyOf);
        }
        if (O3.type !== "root" && O3.type !== "document" && !O3.parent)
          return true;
        if (m(b3))
          throw this.getAsyncError();
      }
    }
    visitTick(g2) {
      let O3 = g2[g2.length - 1], { node: A, visitors: E2 } = O3;
      if (A.type !== "root" && A.type !== "document" && !A.parent) {
        g2.pop();
        return;
      }
      if (E2.length > 0 && O3.visitorIndex < E2.length) {
        let [k3, q2] = E2[O3.visitorIndex];
        O3.visitorIndex += 1, O3.visitorIndex === E2.length && (O3.visitors = [], O3.visitorIndex = 0), this.result.lastPlugin = k3;
        try {
          return q2(A.toProxy(), this.helpers);
        } catch (M2) {
          throw this.handleError(M2, A);
        }
      }
      if (O3.iterator !== 0) {
        let k3 = O3.iterator, q2;
        for (; q2 = A.nodes[A.indexes[k3]]; )
          if (A.indexes[k3] += 1, !q2[c2]) {
            q2[c2] = true, g2.push(d2(q2));
            return;
          }
        O3.iterator = 0, delete A.indexes[k3];
      }
      let b3 = O3.events;
      for (; O3.eventIndex < b3.length; ) {
        let k3 = b3[O3.eventIndex];
        if (O3.eventIndex += 1, k3 === v3) {
          A.nodes && A.nodes.length && (A[c2] = true, O3.iterator = A.getIterator());
          return;
        } else if (this.listeners[k3]) {
          O3.visitors = this.listeners[k3];
          return;
        }
      }
      g2.pop();
    }
    walkSync(g2) {
      g2[c2] = true;
      let O3 = n2(g2);
      for (let A of O3)
        if (A === v3)
          g2.nodes && g2.each((E2) => {
            E2[c2] || this.walkSync(E2);
          });
        else {
          let E2 = this.listeners[A];
          if (E2 && this.visitSync(E2, g2.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
  }
  return y2.registerPostcss = (x) => {
    w3 = x;
  }, Qr3 = y2, y2.default = y2, f.registerLazyResult(y2), a.registerLazyResult(y2), Qr3;
}
var Hr2;
var Ta2;
function yu2() {
  if (Ta2) return Hr2;
  Ta2 = 1;
  let u = vl(), a = Di2();
  const h2 = qi2();
  let p = or3(), l2 = ml();
  class f {
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let c2, t8 = a;
      try {
        c2 = t8(this._css, this._opts);
      } catch (e2) {
        this.error = e2;
      }
      if (this.error)
        throw this.error;
      return this._root = c2, c2;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
    constructor(c2, t8, e2) {
      t8 = t8.toString(), this.stringified = false, this._processor = c2, this._css = t8, this._opts = e2, this._map = void 0;
      let r2, i = p;
      this.result = new h2(this._processor, r2, this._opts), this.result.css = t8;
      let o2 = this;
      Object.defineProperty(this.result, "root", {
        get() {
          return o2.root;
        }
      });
      let v3 = new u(i, r2, this._opts, t8);
      if (v3.isMap()) {
        let [m, n2] = v3.generate();
        m && (this.result.css = m), n2 && (this.result.map = n2);
      } else
        v3.clearAnnotation(), this.result.css = v3.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(c2) {
      return this.async().catch(c2);
    }
    finally(c2) {
      return this.async().then(c2, c2);
    }
    sync() {
      if (this.error) throw this.error;
      return this.result;
    }
    then(c2, t8) {
      return process.env.NODE_ENV !== "production" && ("from" in this._opts || l2(
        "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
      )), this.async().then(c2, t8);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
  }
  return Hr2 = f, f.default = f, Hr2;
}
var Jr3;
var Aa2;
function wu2() {
  if (Aa2) return Jr3;
  Aa2 = 1;
  let u = Ii2(), a = yl(), h2 = yu2(), p = lt2();
  class l2 {
    constructor(s2 = []) {
      this.version = "8.5.3", this.plugins = this.normalize(s2);
    }
    normalize(s2) {
      let c2 = [];
      for (let t8 of s2)
        if (t8.postcss === true ? t8 = t8() : t8.postcss && (t8 = t8.postcss), typeof t8 == "object" && Array.isArray(t8.plugins))
          c2 = c2.concat(t8.plugins);
        else if (typeof t8 == "object" && t8.postcssPlugin)
          c2.push(t8);
        else if (typeof t8 == "function")
          c2.push(t8);
        else if (typeof t8 == "object" && (t8.parse || t8.stringify)) {
          if (process.env.NODE_ENV !== "production")
            throw new Error(
              "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
            );
        } else
          throw new Error(t8 + " is not a PostCSS plugin");
      return c2;
    }
    process(s2, c2 = {}) {
      return !this.plugins.length && !c2.parser && !c2.stringifier && !c2.syntax ? new h2(this, s2, c2) : new a(this, s2, c2);
    }
    use(s2) {
      return this.plugins = this.plugins.concat(this.normalize([s2])), this;
    }
  }
  return Jr3 = l2, l2.default = l2, p.registerProcessor(l2), u.registerProcessor(l2), Jr3;
}
var Kr3;
var Ca2;
function Be2() {
  if (Ca2) return Kr3;
  Ca2 = 1;
  let u = Ri2(), a = ur3(), h2 = nt3(), p = Ai2(), l2 = fr3(), f = Ii2(), s2 = vu2(), c2 = cr3(), t8 = yl(), e2 = hl(), r2 = lr3(), i = Di2(), o2 = wu2(), v3 = qi2(), m = lt2(), n2 = Mi2(), d2 = or3(), _3 = gl();
  function w3(...y2) {
    return y2.length === 1 && Array.isArray(y2[0]) && (y2 = y2[0]), new o2(y2);
  }
  return w3.plugin = function(x, g2) {
    let O3 = false;
    function A(...b3) {
      console && console.warn && !O3 && (O3 = true, console.warn(
        x + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
      ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
        x + `: \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:
https://www.w3ctech.com/topic/2226`
      ));
      let k3 = g2(...b3);
      return k3.postcssPlugin = x, k3.postcssVersion = new o2().version, k3;
    }
    let E2;
    return Object.defineProperty(A, "postcss", {
      get() {
        return E2 || (E2 = A()), E2;
      }
    }), A.process = function(b3, k3, q2) {
      return w3([A(q2)]).process(b3, k3);
    }, A;
  }, w3.stringify = d2, w3.parse = i, w3.fromJSON = s2, w3.list = e2, w3.comment = (y2) => new a(y2), w3.atRule = (y2) => new u(y2), w3.decl = (y2) => new l2(y2), w3.rule = (y2) => new n2(y2), w3.root = (y2) => new m(y2), w3.document = (y2) => new f(y2), w3.CssSyntaxError = p, w3.Declaration = l2, w3.Container = h2, w3.Processor = o2, w3.Document = f, w3.Comment = a, w3.Warning = _3, w3.AtRule = u, w3.Result = v3, w3.Input = c2, w3.Rule = n2, w3.Root = m, w3.Node = r2, t8.registerPostcss(w3), Kr3 = w3, w3.default = w3, Kr3;
}
var bu2 = Be2();
var Le3 = /* @__PURE__ */ He3(bu2);
Le3.stringify;
Le3.fromJSON;
Le3.plugin;
var _u2 = Le3.parse;
Le3.list;
Le3.document;
Le3.comment;
Le3.atRule;
var Su2 = Le3.rule;
var xu2 = Le3.decl;
Le3.root;
Le3.CssSyntaxError;
Le3.Declaration;
Le3.Container;
Le3.Processor;
Le3.Document;
Le3.Comment;
Le3.Warning;
var wl = Le3.AtRule;
Le3.Result;
Le3.Input;
var Ra2 = Le3.Rule;
var Ou2 = Le3.Root;
Le3.Node;
var ku2 = (u) => u.replace(/\/\*[\s\S]*?\*\//gm, "").replace(/;\s+/gm, ";").replace(/:\s+/gm, ":").replace(/\)\s*{/gm, "){").replace(/\s+\(/gm, "(").replace(/{\s+/gm, "{").replace(/}\s+/gm, "}").replace(/\s*{/gm, "{").replace(/;?\s*}/gm, "}");
var Li2 = (u) => {
  if (u.first === void 0) {
    const a = u.parent;
    a && (u.remove(), Li2(a));
  }
};
var Pu2 = (u) => {
  u.walkRules((a) => {
    u.walkRules(a.selector, (h2) => {
      if (h2 === a) return;
      const p = h2.parent;
      h2.remove(), p && Li2(p);
    });
  });
};
var bl = (u) => typeof u.type == "function" || // @ts-expect-error - we know this is a component that may have a render function
u.type.render !== void 0;
function sr3(u, a) {
  const h2 = import_react2.default.Children.map(u, (p) => {
    if (import_react2.default.isValidElement(p)) {
      const l2 = { ...p.props };
      p.props.children && !bl(p) && (l2.children = sr3(p.props.children, a));
      const f = a(
        import_react2.default.cloneElement(p, l2, l2.children)
      );
      if (import_react2.default.isValidElement(f) && (typeof f.type == "function" || // @ts-expect-error - we know this is a component that may have a render function
      f.type.render)) {
        const c2 = (typeof f.type == "object" ? (
          // @ts-expect-error - we know this is a component with a render function
          f.type.render
        ) : f.type)(f.props);
        return sr3(c2, a);
      }
      return f;
    }
    return a(p);
  });
  return h2 && h2.length === 1 ? h2[0] : h2;
}
var Eu2 = {
  0: "zero",
  1: "one",
  2: "two",
  3: "three",
  4: "four",
  5: "five",
  6: "six",
  7: "seven",
  8: "eight",
  9: "nine"
};
var _l = (u) => u.replaceAll("+", "plus").replaceAll("[", "").replaceAll("%", "pc").replaceAll("]", "").replaceAll("(", "").replaceAll(")", "").replaceAll("!", "imprtnt").replaceAll(">", "gt").replaceAll("<", "lt").replaceAll("=", "eq").replace(/^[0-9]/, (a) => Eu2[a]).replace(/[^a-zA-Z0-9\-_]/g, "_");
var vt3 = { exports: {} };
var gt3 = { exports: {} };
var mt3 = { exports: {} };
var yt3 = { exports: {} };
var wt3 = { exports: {} };
var bt3 = { exports: {} };
var Ye3 = {};
var _t3 = { exports: {} };
var Ia2;
function Sl() {
  return Ia2 || (Ia2 = 1, (function(u, a) {
    a.__esModule = true, a.default = l2;
    function h2(f) {
      for (var s2 = f.toLowerCase(), c2 = "", t8 = false, e2 = 0; e2 < 6 && s2[e2] !== void 0; e2++) {
        var r2 = s2.charCodeAt(e2), i = r2 >= 97 && r2 <= 102 || r2 >= 48 && r2 <= 57;
        if (t8 = r2 === 32, !i)
          break;
        c2 += s2[e2];
      }
      if (c2.length !== 0) {
        var o2 = parseInt(c2, 16), v3 = o2 >= 55296 && o2 <= 57343;
        return v3 || o2 === 0 || o2 > 1114111 ? ["\uFFFD", c2.length + (t8 ? 1 : 0)] : [String.fromCodePoint(o2), c2.length + (t8 ? 1 : 0)];
      }
    }
    var p = /\\/;
    function l2(f) {
      var s2 = p.test(f);
      if (!s2)
        return f;
      for (var c2 = "", t8 = 0; t8 < f.length; t8++) {
        if (f[t8] === "\\") {
          var e2 = h2(f.slice(t8 + 1, t8 + 7));
          if (e2 !== void 0) {
            c2 += e2[0], t8 += e2[1];
            continue;
          }
          if (f[t8 + 1] === "\\") {
            c2 += "\\", t8++;
            continue;
          }
          f.length === t8 + 1 && (c2 += f[t8]);
          continue;
        }
        c2 += f[t8];
      }
      return c2;
    }
    u.exports = a.default;
  })(_t3, _t3.exports)), _t3.exports;
}
var St3 = { exports: {} };
var Ma2;
function Tu2() {
  return Ma2 || (Ma2 = 1, (function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      for (var l2 = arguments.length, f = new Array(l2 > 1 ? l2 - 1 : 0), s2 = 1; s2 < l2; s2++)
        f[s2 - 1] = arguments[s2];
      for (; f.length > 0; ) {
        var c2 = f.shift();
        if (!p[c2])
          return;
        p = p[c2];
      }
      return p;
    }
    u.exports = a.default;
  })(St3, St3.exports)), St3.exports;
}
var xt3 = { exports: {} };
var Da2;
function Au2() {
  return Da2 || (Da2 = 1, (function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      for (var l2 = arguments.length, f = new Array(l2 > 1 ? l2 - 1 : 0), s2 = 1; s2 < l2; s2++)
        f[s2 - 1] = arguments[s2];
      for (; f.length > 0; ) {
        var c2 = f.shift();
        p[c2] || (p[c2] = {}), p = p[c2];
      }
    }
    u.exports = a.default;
  })(xt3, xt3.exports)), xt3.exports;
}
var Ot3 = { exports: {} };
var qa2;
function Cu2() {
  return qa2 || (qa2 = 1, (function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      for (var l2 = "", f = p.indexOf("/*"), s2 = 0; f >= 0; ) {
        l2 = l2 + p.slice(s2, f);
        var c2 = p.indexOf("*/", f + 2);
        if (c2 < 0)
          return l2;
        s2 = c2 + 2, f = p.indexOf("/*", s2);
      }
      return l2 = l2 + p.slice(s2), l2;
    }
    u.exports = a.default;
  })(Ot3, Ot3.exports)), Ot3.exports;
}
var La2;
function dr3() {
  if (La2) return Ye3;
  La2 = 1, Ye3.__esModule = true, Ye3.unesc = Ye3.stripComments = Ye3.getProp = Ye3.ensureObject = void 0;
  var u = l2(Sl());
  Ye3.unesc = u.default;
  var a = l2(Tu2());
  Ye3.getProp = a.default;
  var h2 = l2(Au2());
  Ye3.ensureObject = h2.default;
  var p = l2(Cu2());
  Ye3.stripComments = p.default;
  function l2(f) {
    return f && f.__esModule ? f : { default: f };
  }
  return Ye3;
}
var Na2;
function et3() {
  return Na2 || (Na2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = dr3();
    function p(c2, t8) {
      for (var e2 = 0; e2 < t8.length; e2++) {
        var r2 = t8[e2];
        r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(c2, r2.key, r2);
      }
    }
    function l2(c2, t8, e2) {
      return t8 && p(c2.prototype, t8), Object.defineProperty(c2, "prototype", { writable: false }), c2;
    }
    var f = function c2(t8, e2) {
      if (typeof t8 != "object" || t8 === null)
        return t8;
      var r2 = new t8.constructor();
      for (var i in t8)
        if (t8.hasOwnProperty(i)) {
          var o2 = t8[i], v3 = typeof o2;
          i === "parent" && v3 === "object" ? e2 && (r2[i] = e2) : o2 instanceof Array ? r2[i] = o2.map(function(m) {
            return c2(m, r2);
          }) : r2[i] = c2(o2, r2);
        }
      return r2;
    }, s2 = /* @__PURE__ */ (function() {
      function c2(e2) {
        e2 === void 0 && (e2 = {}), Object.assign(this, e2), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
      }
      var t8 = c2.prototype;
      return t8.remove = function() {
        return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
      }, t8.replaceWith = function() {
        if (this.parent) {
          for (var r2 in arguments)
            this.parent.insertBefore(this, arguments[r2]);
          this.remove();
        }
        return this;
      }, t8.next = function() {
        return this.parent.at(this.parent.index(this) + 1);
      }, t8.prev = function() {
        return this.parent.at(this.parent.index(this) - 1);
      }, t8.clone = function(r2) {
        r2 === void 0 && (r2 = {});
        var i = f(this);
        for (var o2 in r2)
          i[o2] = r2[o2];
        return i;
      }, t8.appendToPropertyAndEscape = function(r2, i, o2) {
        this.raws || (this.raws = {});
        var v3 = this[r2], m = this.raws[r2];
        this[r2] = v3 + i, m || o2 !== i ? this.raws[r2] = (m || v3) + o2 : delete this.raws[r2];
      }, t8.setPropertyAndEscape = function(r2, i, o2) {
        this.raws || (this.raws = {}), this[r2] = i, this.raws[r2] = o2;
      }, t8.setPropertyWithoutEscape = function(r2, i) {
        this[r2] = i, this.raws && delete this.raws[r2];
      }, t8.isAtPosition = function(r2, i) {
        if (this.source && this.source.start && this.source.end)
          return !(this.source.start.line > r2 || this.source.end.line < r2 || this.source.start.line === r2 && this.source.start.column > i || this.source.end.line === r2 && this.source.end.column < i);
      }, t8.stringifyProperty = function(r2) {
        return this.raws && this.raws[r2] || this[r2];
      }, t8.valueToString = function() {
        return String(this.stringifyProperty("value"));
      }, t8.toString = function() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      }, l2(c2, [{
        key: "rawSpaceBefore",
        get: function() {
          var r2 = this.raws && this.raws.spaces && this.raws.spaces.before;
          return r2 === void 0 && (r2 = this.spaces && this.spaces.before), r2 || "";
        },
        set: function(r2) {
          (0, h2.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = r2;
        }
      }, {
        key: "rawSpaceAfter",
        get: function() {
          var r2 = this.raws && this.raws.spaces && this.raws.spaces.after;
          return r2 === void 0 && (r2 = this.spaces.after), r2 || "";
        },
        set: function(r2) {
          (0, h2.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = r2;
        }
      }]), c2;
    })();
    a.default = s2, u.exports = a.default;
  })(bt3, bt3.exports)), bt3.exports;
}
var Re3 = {};
var Fa2;
function Fe3() {
  if (Fa2) return Re3;
  Fa2 = 1, Re3.__esModule = true, Re3.UNIVERSAL = Re3.TAG = Re3.STRING = Re3.SELECTOR = Re3.ROOT = Re3.PSEUDO = Re3.NESTING = Re3.ID = Re3.COMMENT = Re3.COMBINATOR = Re3.CLASS = Re3.ATTRIBUTE = void 0;
  var u = "tag";
  Re3.TAG = u;
  var a = "string";
  Re3.STRING = a;
  var h2 = "selector";
  Re3.SELECTOR = h2;
  var p = "root";
  Re3.ROOT = p;
  var l2 = "pseudo";
  Re3.PSEUDO = l2;
  var f = "nesting";
  Re3.NESTING = f;
  var s2 = "id";
  Re3.ID = s2;
  var c2 = "comment";
  Re3.COMMENT = c2;
  var t8 = "combinator";
  Re3.COMBINATOR = t8;
  var e2 = "class";
  Re3.CLASS = e2;
  var r2 = "attribute";
  Re3.ATTRIBUTE = r2;
  var i = "universal";
  return Re3.UNIVERSAL = i, Re3;
}
var $a2;
function Ni2() {
  return $a2 || ($a2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = s2(et3()), p = f(Fe3());
    function l2(n2) {
      if (typeof WeakMap != "function") return null;
      var d2 = /* @__PURE__ */ new WeakMap(), _3 = /* @__PURE__ */ new WeakMap();
      return (l2 = function(y2) {
        return y2 ? _3 : d2;
      })(n2);
    }
    function f(n2, d2) {
      if (n2 && n2.__esModule)
        return n2;
      if (n2 === null || typeof n2 != "object" && typeof n2 != "function")
        return { default: n2 };
      var _3 = l2(d2);
      if (_3 && _3.has(n2))
        return _3.get(n2);
      var w3 = {}, y2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var x in n2)
        if (x !== "default" && Object.prototype.hasOwnProperty.call(n2, x)) {
          var g2 = y2 ? Object.getOwnPropertyDescriptor(n2, x) : null;
          g2 && (g2.get || g2.set) ? Object.defineProperty(w3, x, g2) : w3[x] = n2[x];
        }
      return w3.default = n2, _3 && _3.set(n2, w3), w3;
    }
    function s2(n2) {
      return n2 && n2.__esModule ? n2 : { default: n2 };
    }
    function c2(n2, d2) {
      var _3 = typeof Symbol < "u" && n2[Symbol.iterator] || n2["@@iterator"];
      if (_3) return (_3 = _3.call(n2)).next.bind(_3);
      if (Array.isArray(n2) || (_3 = t8(n2)) || d2) {
        _3 && (n2 = _3);
        var w3 = 0;
        return function() {
          return w3 >= n2.length ? { done: true } : { done: false, value: n2[w3++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function t8(n2, d2) {
      if (n2) {
        if (typeof n2 == "string") return e2(n2, d2);
        var _3 = Object.prototype.toString.call(n2).slice(8, -1);
        if (_3 === "Object" && n2.constructor && (_3 = n2.constructor.name), _3 === "Map" || _3 === "Set") return Array.from(n2);
        if (_3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_3)) return e2(n2, d2);
      }
    }
    function e2(n2, d2) {
      (d2 == null || d2 > n2.length) && (d2 = n2.length);
      for (var _3 = 0, w3 = new Array(d2); _3 < d2; _3++)
        w3[_3] = n2[_3];
      return w3;
    }
    function r2(n2, d2) {
      for (var _3 = 0; _3 < d2.length; _3++) {
        var w3 = d2[_3];
        w3.enumerable = w3.enumerable || false, w3.configurable = true, "value" in w3 && (w3.writable = true), Object.defineProperty(n2, w3.key, w3);
      }
    }
    function i(n2, d2, _3) {
      return d2 && r2(n2.prototype, d2), Object.defineProperty(n2, "prototype", { writable: false }), n2;
    }
    function o2(n2, d2) {
      n2.prototype = Object.create(d2.prototype), n2.prototype.constructor = n2, v3(n2, d2);
    }
    function v3(n2, d2) {
      return v3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(w3, y2) {
        return w3.__proto__ = y2, w3;
      }, v3(n2, d2);
    }
    var m = /* @__PURE__ */ (function(n2) {
      o2(d2, n2);
      function d2(w3) {
        var y2;
        return y2 = n2.call(this, w3) || this, y2.nodes || (y2.nodes = []), y2;
      }
      var _3 = d2.prototype;
      return _3.append = function(y2) {
        return y2.parent = this, this.nodes.push(y2), this;
      }, _3.prepend = function(y2) {
        y2.parent = this, this.nodes.unshift(y2);
        for (var x in this.indexes)
          this.indexes[x]++;
        return this;
      }, _3.at = function(y2) {
        return this.nodes[y2];
      }, _3.index = function(y2) {
        return typeof y2 == "number" ? y2 : this.nodes.indexOf(y2);
      }, _3.removeChild = function(y2) {
        y2 = this.index(y2), this.at(y2).parent = void 0, this.nodes.splice(y2, 1);
        var x;
        for (var g2 in this.indexes)
          x = this.indexes[g2], x >= y2 && (this.indexes[g2] = x - 1);
        return this;
      }, _3.removeAll = function() {
        for (var y2 = c2(this.nodes), x; !(x = y2()).done; ) {
          var g2 = x.value;
          g2.parent = void 0;
        }
        return this.nodes = [], this;
      }, _3.empty = function() {
        return this.removeAll();
      }, _3.insertAfter = function(y2, x) {
        var g2;
        x.parent = this;
        for (var O3 = this.index(y2), A = [], E2 = 2; E2 < arguments.length; E2++)
          A.push(arguments[E2]);
        (g2 = this.nodes).splice.apply(g2, [O3 + 1, 0, x].concat(A)), x.parent = this;
        var b3;
        for (var k3 in this.indexes)
          b3 = this.indexes[k3], O3 < b3 && (this.indexes[k3] = b3 + arguments.length - 1);
        return this;
      }, _3.insertBefore = function(y2, x) {
        var g2;
        x.parent = this;
        for (var O3 = this.index(y2), A = [], E2 = 2; E2 < arguments.length; E2++)
          A.push(arguments[E2]);
        (g2 = this.nodes).splice.apply(g2, [O3, 0, x].concat(A)), x.parent = this;
        var b3;
        for (var k3 in this.indexes)
          b3 = this.indexes[k3], b3 >= O3 && (this.indexes[k3] = b3 + arguments.length - 1);
        return this;
      }, _3._findChildAtPosition = function(y2, x) {
        var g2 = void 0;
        return this.each(function(O3) {
          if (O3.atPosition) {
            var A = O3.atPosition(y2, x);
            if (A)
              return g2 = A, false;
          } else if (O3.isAtPosition(y2, x))
            return g2 = O3, false;
        }), g2;
      }, _3.atPosition = function(y2, x) {
        if (this.isAtPosition(y2, x))
          return this._findChildAtPosition(y2, x) || this;
      }, _3._inferEndPosition = function() {
        this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
      }, _3.each = function(y2) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var x = this.lastEach;
        if (this.indexes[x] = 0, !!this.length) {
          for (var g2, O3; this.indexes[x] < this.length && (g2 = this.indexes[x], O3 = y2(this.at(g2), g2), O3 !== false); )
            this.indexes[x] += 1;
          if (delete this.indexes[x], O3 === false)
            return false;
        }
      }, _3.walk = function(y2) {
        return this.each(function(x, g2) {
          var O3 = y2(x, g2);
          if (O3 !== false && x.length && (O3 = x.walk(y2)), O3 === false)
            return false;
        });
      }, _3.walkAttributes = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.ATTRIBUTE)
            return y2.call(x, g2);
        });
      }, _3.walkClasses = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.CLASS)
            return y2.call(x, g2);
        });
      }, _3.walkCombinators = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.COMBINATOR)
            return y2.call(x, g2);
        });
      }, _3.walkComments = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.COMMENT)
            return y2.call(x, g2);
        });
      }, _3.walkIds = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.ID)
            return y2.call(x, g2);
        });
      }, _3.walkNesting = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.NESTING)
            return y2.call(x, g2);
        });
      }, _3.walkPseudos = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.PSEUDO)
            return y2.call(x, g2);
        });
      }, _3.walkTags = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.TAG)
            return y2.call(x, g2);
        });
      }, _3.walkUniversals = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.UNIVERSAL)
            return y2.call(x, g2);
        });
      }, _3.split = function(y2) {
        var x = this, g2 = [];
        return this.reduce(function(O3, A, E2) {
          var b3 = y2.call(x, A);
          return g2.push(A), b3 ? (O3.push(g2), g2 = []) : E2 === x.length - 1 && O3.push(g2), O3;
        }, []);
      }, _3.map = function(y2) {
        return this.nodes.map(y2);
      }, _3.reduce = function(y2, x) {
        return this.nodes.reduce(y2, x);
      }, _3.every = function(y2) {
        return this.nodes.every(y2);
      }, _3.some = function(y2) {
        return this.nodes.some(y2);
      }, _3.filter = function(y2) {
        return this.nodes.filter(y2);
      }, _3.sort = function(y2) {
        return this.nodes.sort(y2);
      }, _3.toString = function() {
        return this.map(String).join("");
      }, i(d2, [{
        key: "first",
        get: function() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function() {
          return this.nodes.length;
        }
      }]), d2;
    })(h2.default);
    a.default = m, u.exports = a.default;
  })(wt3, wt3.exports)), wt3.exports;
}
var Ua2;
function xl() {
  return Ua2 || (Ua2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(Ni2()), p = Fe3();
    function l2(r2) {
      return r2 && r2.__esModule ? r2 : { default: r2 };
    }
    function f(r2, i) {
      for (var o2 = 0; o2 < i.length; o2++) {
        var v3 = i[o2];
        v3.enumerable = v3.enumerable || false, v3.configurable = true, "value" in v3 && (v3.writable = true), Object.defineProperty(r2, v3.key, v3);
      }
    }
    function s2(r2, i, o2) {
      return i && f(r2.prototype, i), Object.defineProperty(r2, "prototype", { writable: false }), r2;
    }
    function c2(r2, i) {
      r2.prototype = Object.create(i.prototype), r2.prototype.constructor = r2, t8(r2, i);
    }
    function t8(r2, i) {
      return t8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v3, m) {
        return v3.__proto__ = m, v3;
      }, t8(r2, i);
    }
    var e2 = /* @__PURE__ */ (function(r2) {
      c2(i, r2);
      function i(v3) {
        var m;
        return m = r2.call(this, v3) || this, m.type = p.ROOT, m;
      }
      var o2 = i.prototype;
      return o2.toString = function() {
        var m = this.reduce(function(n2, d2) {
          return n2.push(String(d2)), n2;
        }, []).join(",");
        return this.trailingComma ? m + "," : m;
      }, o2.error = function(m, n2) {
        return this._error ? this._error(m, n2) : new Error(m);
      }, s2(i, [{
        key: "errorGenerator",
        set: function(m) {
          this._error = m;
        }
      }]), i;
    })(h2.default);
    a.default = e2, u.exports = a.default;
  })(yt3, yt3.exports)), yt3.exports;
}
var kt3 = { exports: {} };
var za2;
function Ol() {
  return za2 || (za2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(Ni2()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.SELECTOR, i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(kt3, kt3.exports)), kt3.exports;
}
var Pt3 = { exports: {} };
var Xr3;
var Wa2;
function at3() {
  if (Wa2) return Xr3;
  Wa2 = 1;
  var u = {}, a = u.hasOwnProperty, h2 = function(t8, e2) {
    if (!t8)
      return e2;
    var r2 = {};
    for (var i in e2)
      r2[i] = a.call(t8, i) ? t8[i] : e2[i];
    return r2;
  }, p = /[ -,\.\/:-@\[-\^`\{-~]/, l2 = /[ -,\.\/:-@\[\]\^`\{-~]/, f = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, s2 = function c2(t8, e2) {
    e2 = h2(e2, c2.options), e2.quotes != "single" && e2.quotes != "double" && (e2.quotes = "single");
    for (var r2 = e2.quotes == "double" ? '"' : "'", i = e2.isIdentifier, o2 = t8.charAt(0), v3 = "", m = 0, n2 = t8.length; m < n2; ) {
      var d2 = t8.charAt(m++), _3 = d2.charCodeAt(), w3 = void 0;
      if (_3 < 32 || _3 > 126) {
        if (_3 >= 55296 && _3 <= 56319 && m < n2) {
          var y2 = t8.charCodeAt(m++);
          (y2 & 64512) == 56320 ? _3 = ((_3 & 1023) << 10) + (y2 & 1023) + 65536 : m--;
        }
        w3 = "\\" + _3.toString(16).toUpperCase() + " ";
      } else
        e2.escapeEverything ? p.test(d2) ? w3 = "\\" + d2 : w3 = "\\" + _3.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(d2) ? w3 = "\\" + _3.toString(16).toUpperCase() + " " : d2 == "\\" || !i && (d2 == '"' && r2 == d2 || d2 == "'" && r2 == d2) || i && l2.test(d2) ? w3 = "\\" + d2 : w3 = d2;
      v3 += w3;
    }
    return i && (/^-[-\d]/.test(v3) ? v3 = "\\-" + v3.slice(1) : /\d/.test(o2) && (v3 = "\\3" + o2 + " " + v3.slice(1))), v3 = v3.replace(f, function(x, g2, O3) {
      return g2 && g2.length % 2 ? x : (g2 || "") + O3;
    }), !i && e2.wrap ? r2 + v3 + r2 : v3;
  };
  return s2.options = {
    escapeEverything: false,
    isIdentifier: false,
    quotes: "single",
    wrap: false
  }, s2.version = "3.0.0", Xr3 = s2, Xr3;
}
var Va2;
function kl() {
  return Va2 || (Va2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = s2(at3()), p = dr3(), l2 = s2(et3()), f = Fe3();
    function s2(o2) {
      return o2 && o2.__esModule ? o2 : { default: o2 };
    }
    function c2(o2, v3) {
      for (var m = 0; m < v3.length; m++) {
        var n2 = v3[m];
        n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(o2, n2.key, n2);
      }
    }
    function t8(o2, v3, m) {
      return v3 && c2(o2.prototype, v3), Object.defineProperty(o2, "prototype", { writable: false }), o2;
    }
    function e2(o2, v3) {
      o2.prototype = Object.create(v3.prototype), o2.prototype.constructor = o2, r2(o2, v3);
    }
    function r2(o2, v3) {
      return r2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, d2) {
        return n2.__proto__ = d2, n2;
      }, r2(o2, v3);
    }
    var i = /* @__PURE__ */ (function(o2) {
      e2(v3, o2);
      function v3(n2) {
        var d2;
        return d2 = o2.call(this, n2) || this, d2.type = f.CLASS, d2._constructed = true, d2;
      }
      var m = v3.prototype;
      return m.valueToString = function() {
        return "." + o2.prototype.valueToString.call(this);
      }, t8(v3, [{
        key: "value",
        get: function() {
          return this._value;
        },
        set: function(d2) {
          if (this._constructed) {
            var _3 = (0, h2.default)(d2, {
              isIdentifier: true
            });
            _3 !== d2 ? ((0, p.ensureObject)(this, "raws"), this.raws.value = _3) : this.raws && delete this.raws.value;
          }
          this._value = d2;
        }
      }]), v3;
    })(l2.default);
    a.default = i, u.exports = a.default;
  })(Pt3, Pt3.exports)), Pt3.exports;
}
var Et3 = { exports: {} };
var ja2;
function Pl() {
  return ja2 || (ja2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(et3()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.COMMENT, i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(Et3, Et3.exports)), Et3.exports;
}
var Tt3 = { exports: {} };
var Ba2;
function El() {
  return Ba2 || (Ba2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(et3()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(i) {
        var o2;
        return o2 = t8.call(this, i) || this, o2.type = p.ID, o2;
      }
      var r2 = e2.prototype;
      return r2.valueToString = function() {
        return "#" + t8.prototype.valueToString.call(this);
      }, e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(Tt3, Tt3.exports)), Tt3.exports;
}
var At3 = { exports: {} };
var Ct3 = { exports: {} };
var Ga2;
function Fi2() {
  return Ga2 || (Ga2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = f(at3()), p = dr3(), l2 = f(et3());
    function f(i) {
      return i && i.__esModule ? i : { default: i };
    }
    function s2(i, o2) {
      for (var v3 = 0; v3 < o2.length; v3++) {
        var m = o2[v3];
        m.enumerable = m.enumerable || false, m.configurable = true, "value" in m && (m.writable = true), Object.defineProperty(i, m.key, m);
      }
    }
    function c2(i, o2, v3) {
      return o2 && s2(i.prototype, o2), Object.defineProperty(i, "prototype", { writable: false }), i;
    }
    function t8(i, o2) {
      i.prototype = Object.create(o2.prototype), i.prototype.constructor = i, e2(i, o2);
    }
    function e2(i, o2) {
      return e2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, n2) {
        return m.__proto__ = n2, m;
      }, e2(i, o2);
    }
    var r2 = /* @__PURE__ */ (function(i) {
      t8(o2, i);
      function o2() {
        return i.apply(this, arguments) || this;
      }
      var v3 = o2.prototype;
      return v3.qualifiedName = function(n2) {
        return this.namespace ? this.namespaceString + "|" + n2 : n2;
      }, v3.valueToString = function() {
        return this.qualifiedName(i.prototype.valueToString.call(this));
      }, c2(o2, [{
        key: "namespace",
        get: function() {
          return this._namespace;
        },
        set: function(n2) {
          if (n2 === true || n2 === "*" || n2 === "&") {
            this._namespace = n2, this.raws && delete this.raws.namespace;
            return;
          }
          var d2 = (0, h2.default)(n2, {
            isIdentifier: true
          });
          this._namespace = n2, d2 !== n2 ? ((0, p.ensureObject)(this, "raws"), this.raws.namespace = d2) : this.raws && delete this.raws.namespace;
        }
      }, {
        key: "ns",
        get: function() {
          return this._namespace;
        },
        set: function(n2) {
          this.namespace = n2;
        }
      }, {
        key: "namespaceString",
        get: function() {
          if (this.namespace) {
            var n2 = this.stringifyProperty("namespace");
            return n2 === true ? "" : n2;
          } else
            return "";
        }
      }]), o2;
    })(l2.default);
    a.default = r2, u.exports = a.default;
  })(Ct3, Ct3.exports)), Ct3.exports;
}
var Ya2;
function Tl() {
  return Ya2 || (Ya2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(Fi2()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.TAG, i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(At3, At3.exports)), At3.exports;
}
var Rt3 = { exports: {} };
var Qa2;
function Al() {
  return Qa2 || (Qa2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(et3()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.STRING, i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(Rt3, Rt3.exports)), Rt3.exports;
}
var It3 = { exports: {} };
var Ha2;
function Cl() {
  return Ha2 || (Ha2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(Ni2()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(i) {
        var o2;
        return o2 = t8.call(this, i) || this, o2.type = p.PSEUDO, o2;
      }
      var r2 = e2.prototype;
      return r2.toString = function() {
        var o2 = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), o2, this.rawSpaceAfter].join("");
      }, e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(It3, It3.exports)), It3.exports;
}
var Zr3 = {};
var en3;
var Ja2;
function Rl() {
  if (Ja2) return en3;
  Ja2 = 1, en3 = u;
  function u(h2, p) {
    if (a("noDeprecation"))
      return h2;
    var l2 = false;
    function f() {
      if (!l2) {
        if (a("throwDeprecation"))
          throw new Error(p);
        a("traceDeprecation") ? console.trace(p) : console.warn(p), l2 = true;
      }
      return h2.apply(this, arguments);
    }
    return f;
  }
  function a(h2) {
    try {
      if (!ta2.localStorage) return false;
    } catch {
      return false;
    }
    var p = ta2.localStorage[h2];
    return p == null ? false : String(p).toLowerCase() === "true";
  }
  return en3;
}
var Ka2;
function Il() {
  return Ka2 || (Ka2 = 1, (function(u) {
    u.__esModule = true, u.default = void 0, u.unescapeValue = d2;
    var a = s2(at3()), h2 = s2(Sl()), p = s2(Fi2()), l2 = Fe3(), f;
    function s2(g2) {
      return g2 && g2.__esModule ? g2 : { default: g2 };
    }
    function c2(g2, O3) {
      for (var A = 0; A < O3.length; A++) {
        var E2 = O3[A];
        E2.enumerable = E2.enumerable || false, E2.configurable = true, "value" in E2 && (E2.writable = true), Object.defineProperty(g2, E2.key, E2);
      }
    }
    function t8(g2, O3, A) {
      return O3 && c2(g2.prototype, O3), Object.defineProperty(g2, "prototype", { writable: false }), g2;
    }
    function e2(g2, O3) {
      g2.prototype = Object.create(O3.prototype), g2.prototype.constructor = g2, r2(g2, O3);
    }
    function r2(g2, O3) {
      return r2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(E2, b3) {
        return E2.__proto__ = b3, E2;
      }, r2(g2, O3);
    }
    var i = Rl(), o2 = /^('|")([^]*)\1$/, v3 = i(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), m = i(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), n2 = i(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function d2(g2) {
      var O3 = false, A = null, E2 = g2, b3 = E2.match(o2);
      return b3 && (A = b3[1], E2 = b3[2]), E2 = (0, h2.default)(E2), E2 !== g2 && (O3 = true), {
        deprecatedUsage: O3,
        unescaped: E2,
        quoteMark: A
      };
    }
    function _3(g2) {
      if (g2.quoteMark !== void 0 || g2.value === void 0)
        return g2;
      n2();
      var O3 = d2(g2.value), A = O3.quoteMark, E2 = O3.unescaped;
      return g2.raws || (g2.raws = {}), g2.raws.value === void 0 && (g2.raws.value = g2.value), g2.value = E2, g2.quoteMark = A, g2;
    }
    var w3 = /* @__PURE__ */ (function(g2) {
      e2(O3, g2);
      function O3(E2) {
        var b3;
        return E2 === void 0 && (E2 = {}), b3 = g2.call(this, _3(E2)) || this, b3.type = l2.ATTRIBUTE, b3.raws = b3.raws || {}, Object.defineProperty(b3.raws, "unquoted", {
          get: i(function() {
            return b3.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: i(function() {
            return b3.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        }), b3._constructed = true, b3;
      }
      var A = O3.prototype;
      return A.getQuotedValue = function(b3) {
        b3 === void 0 && (b3 = {});
        var k3 = this._determineQuoteMark(b3), q2 = y2[k3], M2 = (0, a.default)(this._value, q2);
        return M2;
      }, A._determineQuoteMark = function(b3) {
        return b3.smart ? this.smartQuoteMark(b3) : this.preferredQuoteMark(b3);
      }, A.setValue = function(b3, k3) {
        k3 === void 0 && (k3 = {}), this._value = b3, this._quoteMark = this._determineQuoteMark(k3), this._syncRawValue();
      }, A.smartQuoteMark = function(b3) {
        var k3 = this.value, q2 = k3.replace(/[^']/g, "").length, M2 = k3.replace(/[^"]/g, "").length;
        if (q2 + M2 === 0) {
          var W3 = (0, a.default)(k3, {
            isIdentifier: true
          });
          if (W3 === k3)
            return O3.NO_QUOTE;
          var S3 = this.preferredQuoteMark(b3);
          if (S3 === O3.NO_QUOTE) {
            var P3 = this.quoteMark || b3.quoteMark || O3.DOUBLE_QUOTE, C = y2[P3], R3 = (0, a.default)(k3, C);
            if (R3.length < W3.length)
              return P3;
          }
          return S3;
        } else return M2 === q2 ? this.preferredQuoteMark(b3) : M2 < q2 ? O3.DOUBLE_QUOTE : O3.SINGLE_QUOTE;
      }, A.preferredQuoteMark = function(b3) {
        var k3 = b3.preferCurrentQuoteMark ? this.quoteMark : b3.quoteMark;
        return k3 === void 0 && (k3 = b3.preferCurrentQuoteMark ? b3.quoteMark : this.quoteMark), k3 === void 0 && (k3 = O3.DOUBLE_QUOTE), k3;
      }, A._syncRawValue = function() {
        var b3 = (0, a.default)(this._value, y2[this.quoteMark]);
        b3 === this._value ? this.raws && delete this.raws.value : this.raws.value = b3;
      }, A._handleEscapes = function(b3, k3) {
        if (this._constructed) {
          var q2 = (0, a.default)(k3, {
            isIdentifier: true
          });
          q2 !== k3 ? this.raws[b3] = q2 : delete this.raws[b3];
        }
      }, A._spacesFor = function(b3) {
        var k3 = {
          before: "",
          after: ""
        }, q2 = this.spaces[b3] || {}, M2 = this.raws.spaces && this.raws.spaces[b3] || {};
        return Object.assign(k3, q2, M2);
      }, A._stringFor = function(b3, k3, q2) {
        k3 === void 0 && (k3 = b3), q2 === void 0 && (q2 = x);
        var M2 = this._spacesFor(k3);
        return q2(this.stringifyProperty(b3), M2);
      }, A.offsetOf = function(b3) {
        var k3 = 1, q2 = this._spacesFor("attribute");
        if (k3 += q2.before.length, b3 === "namespace" || b3 === "ns")
          return this.namespace ? k3 : -1;
        if (b3 === "attributeNS" || (k3 += this.namespaceString.length, this.namespace && (k3 += 1), b3 === "attribute"))
          return k3;
        k3 += this.stringifyProperty("attribute").length, k3 += q2.after.length;
        var M2 = this._spacesFor("operator");
        k3 += M2.before.length;
        var W3 = this.stringifyProperty("operator");
        if (b3 === "operator")
          return W3 ? k3 : -1;
        k3 += W3.length, k3 += M2.after.length;
        var S3 = this._spacesFor("value");
        k3 += S3.before.length;
        var P3 = this.stringifyProperty("value");
        if (b3 === "value")
          return P3 ? k3 : -1;
        k3 += P3.length, k3 += S3.after.length;
        var C = this._spacesFor("insensitive");
        return k3 += C.before.length, b3 === "insensitive" && this.insensitive ? k3 : -1;
      }, A.toString = function() {
        var b3 = this, k3 = [this.rawSpaceBefore, "["];
        return k3.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (k3.push(this._stringFor("operator")), k3.push(this._stringFor("value")), k3.push(this._stringFor("insensitiveFlag", "insensitive", function(q2, M2) {
          return q2.length > 0 && !b3.quoted && M2.before.length === 0 && !(b3.spaces.value && b3.spaces.value.after) && (M2.before = " "), x(q2, M2);
        }))), k3.push("]"), k3.push(this.rawSpaceAfter), k3.join("");
      }, t8(O3, [{
        key: "quoted",
        get: function() {
          var b3 = this.quoteMark;
          return b3 === "'" || b3 === '"';
        },
        set: function(b3) {
          m();
        }
        /**
         * returns a single (`'`) or double (`"`) quote character if the value is quoted.
         * returns `null` if the value is not quoted.
         * returns `undefined` if the quotation state is unknown (this can happen when
         * the attribute is constructed without specifying a quote mark.)
         */
      }, {
        key: "quoteMark",
        get: function() {
          return this._quoteMark;
        },
        set: function(b3) {
          if (!this._constructed) {
            this._quoteMark = b3;
            return;
          }
          this._quoteMark !== b3 && (this._quoteMark = b3, this._syncRawValue());
        }
      }, {
        key: "qualifiedAttribute",
        get: function() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function() {
          return this._value;
        },
        set: (
          /**
           * Before 3.0, the value had to be set to an escaped value including any wrapped
           * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
           * is unescaped during parsing and any quote marks are removed.
           *
           * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
           * a deprecation warning is raised when the new value contains any characters that would
           * require escaping (including if it contains wrapped quotes).
           *
           * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
           * how the new value is quoted.
           */
          (function(b3) {
            if (this._constructed) {
              var k3 = d2(b3), q2 = k3.deprecatedUsage, M2 = k3.unescaped, W3 = k3.quoteMark;
              if (q2 && v3(), M2 === this._value && W3 === this._quoteMark)
                return;
              this._value = M2, this._quoteMark = W3, this._syncRawValue();
            } else
              this._value = b3;
          })
        )
      }, {
        key: "insensitive",
        get: function() {
          return this._insensitive;
        },
        set: function(b3) {
          b3 || (this._insensitive = false, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = b3;
        }
      }, {
        key: "attribute",
        get: function() {
          return this._attribute;
        },
        set: function(b3) {
          this._handleEscapes("attribute", b3), this._attribute = b3;
        }
      }]), O3;
    })(p.default);
    u.default = w3, w3.NO_QUOTE = null, w3.SINGLE_QUOTE = "'", w3.DOUBLE_QUOTE = '"';
    var y2 = (f = {
      "'": {
        quotes: "single",
        wrap: true
      },
      '"': {
        quotes: "double",
        wrap: true
      }
    }, f[null] = {
      isIdentifier: true
    }, f);
    function x(g2, O3) {
      return "" + O3.before + g2 + O3.after;
    }
  })(Zr3)), Zr3;
}
var Mt2 = { exports: {} };
var Xa2;
function Ml() {
  return Xa2 || (Xa2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(Fi2()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.UNIVERSAL, i.value = "*", i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(Mt2, Mt2.exports)), Mt2.exports;
}
var Dt3 = { exports: {} };
var Za2;
function Dl() {
  return Za2 || (Za2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(et3()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.COMBINATOR, i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(Dt3, Dt3.exports)), Dt3.exports;
}
var qt3 = { exports: {} };
var es2;
function ql() {
  return es2 || (es2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(et3()), p = Fe3();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.NESTING, i.value = "&", i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(qt3, qt3.exports)), qt3.exports;
}
var Lt3 = { exports: {} };
var ts2;
function Ru2() {
  return ts2 || (ts2 = 1, (function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      return p.sort(function(l2, f) {
        return l2 - f;
      });
    }
    u.exports = a.default;
  })(Lt3, Lt3.exports)), Lt3.exports;
}
var tn3 = {};
var oe2 = {};
var rs2;
function Ll() {
  if (rs2) return oe2;
  rs2 = 1, oe2.__esModule = true, oe2.word = oe2.tilde = oe2.tab = oe2.str = oe2.space = oe2.slash = oe2.singleQuote = oe2.semicolon = oe2.plus = oe2.pipe = oe2.openSquare = oe2.openParenthesis = oe2.newline = oe2.greaterThan = oe2.feed = oe2.equals = oe2.doubleQuote = oe2.dollar = oe2.cr = oe2.comment = oe2.comma = oe2.combinator = oe2.colon = oe2.closeSquare = oe2.closeParenthesis = oe2.caret = oe2.bang = oe2.backslash = oe2.at = oe2.asterisk = oe2.ampersand = void 0;
  var u = 38;
  oe2.ampersand = u;
  var a = 42;
  oe2.asterisk = a;
  var h2 = 64;
  oe2.at = h2;
  var p = 44;
  oe2.comma = p;
  var l2 = 58;
  oe2.colon = l2;
  var f = 59;
  oe2.semicolon = f;
  var s2 = 40;
  oe2.openParenthesis = s2;
  var c2 = 41;
  oe2.closeParenthesis = c2;
  var t8 = 91;
  oe2.openSquare = t8;
  var e2 = 93;
  oe2.closeSquare = e2;
  var r2 = 36;
  oe2.dollar = r2;
  var i = 126;
  oe2.tilde = i;
  var o2 = 94;
  oe2.caret = o2;
  var v3 = 43;
  oe2.plus = v3;
  var m = 61;
  oe2.equals = m;
  var n2 = 124;
  oe2.pipe = n2;
  var d2 = 62;
  oe2.greaterThan = d2;
  var _3 = 32;
  oe2.space = _3;
  var w3 = 39;
  oe2.singleQuote = w3;
  var y2 = 34;
  oe2.doubleQuote = y2;
  var x = 47;
  oe2.slash = x;
  var g2 = 33;
  oe2.bang = g2;
  var O3 = 92;
  oe2.backslash = O3;
  var A = 13;
  oe2.cr = A;
  var E2 = 12;
  oe2.feed = E2;
  var b3 = 10;
  oe2.newline = b3;
  var k3 = 9;
  oe2.tab = k3;
  var q2 = w3;
  oe2.str = q2;
  var M2 = -1;
  oe2.comment = M2;
  var W3 = -2;
  oe2.word = W3;
  var S3 = -3;
  return oe2.combinator = S3, oe2;
}
var ns2;
function Iu2() {
  return ns2 || (ns2 = 1, (function(u) {
    u.__esModule = true, u.FIELDS = void 0, u.default = m;
    var a = f(Ll()), h2, p;
    function l2(n2) {
      if (typeof WeakMap != "function") return null;
      var d2 = /* @__PURE__ */ new WeakMap(), _3 = /* @__PURE__ */ new WeakMap();
      return (l2 = function(y2) {
        return y2 ? _3 : d2;
      })(n2);
    }
    function f(n2, d2) {
      if (n2 && n2.__esModule)
        return n2;
      if (n2 === null || typeof n2 != "object" && typeof n2 != "function")
        return { default: n2 };
      var _3 = l2(d2);
      if (_3 && _3.has(n2))
        return _3.get(n2);
      var w3 = {}, y2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var x in n2)
        if (x !== "default" && Object.prototype.hasOwnProperty.call(n2, x)) {
          var g2 = y2 ? Object.getOwnPropertyDescriptor(n2, x) : null;
          g2 && (g2.get || g2.set) ? Object.defineProperty(w3, x, g2) : w3[x] = n2[x];
        }
      return w3.default = n2, _3 && _3.set(n2, w3), w3;
    }
    for (var s2 = (h2 = {}, h2[a.tab] = true, h2[a.newline] = true, h2[a.cr] = true, h2[a.feed] = true, h2), c2 = (p = {}, p[a.space] = true, p[a.tab] = true, p[a.newline] = true, p[a.cr] = true, p[a.feed] = true, p[a.ampersand] = true, p[a.asterisk] = true, p[a.bang] = true, p[a.comma] = true, p[a.colon] = true, p[a.semicolon] = true, p[a.openParenthesis] = true, p[a.closeParenthesis] = true, p[a.openSquare] = true, p[a.closeSquare] = true, p[a.singleQuote] = true, p[a.doubleQuote] = true, p[a.plus] = true, p[a.pipe] = true, p[a.tilde] = true, p[a.greaterThan] = true, p[a.equals] = true, p[a.dollar] = true, p[a.caret] = true, p[a.slash] = true, p), t8 = {}, e2 = "0123456789abcdefABCDEF", r2 = 0; r2 < e2.length; r2++)
      t8[e2.charCodeAt(r2)] = true;
    function i(n2, d2) {
      var _3 = d2, w3;
      do {
        if (w3 = n2.charCodeAt(_3), c2[w3])
          return _3 - 1;
        w3 === a.backslash ? _3 = o2(n2, _3) + 1 : _3++;
      } while (_3 < n2.length);
      return _3 - 1;
    }
    function o2(n2, d2) {
      var _3 = d2, w3 = n2.charCodeAt(_3 + 1);
      if (!s2[w3]) if (t8[w3]) {
        var y2 = 0;
        do
          _3++, y2++, w3 = n2.charCodeAt(_3 + 1);
        while (t8[w3] && y2 < 6);
        y2 < 6 && w3 === a.space && _3++;
      } else
        _3++;
      return _3;
    }
    var v3 = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    u.FIELDS = v3;
    function m(n2) {
      var d2 = [], _3 = n2.css.valueOf(), w3 = _3, y2 = w3.length, x = -1, g2 = 1, O3 = 0, A = 0, E2, b3, k3, q2, M2, W3, S3, P3, C, R3, $2, B3, z3;
      function L3(F, D) {
        if (n2.safe)
          _3 += D, C = _3.length - 1;
        else
          throw n2.error("Unclosed " + F, g2, O3 - x, O3);
      }
      for (; O3 < y2; ) {
        switch (E2 = _3.charCodeAt(O3), E2 === a.newline && (x = O3, g2 += 1), E2) {
          case a.space:
          case a.tab:
          case a.newline:
          case a.cr:
          case a.feed:
            C = O3;
            do
              C += 1, E2 = _3.charCodeAt(C), E2 === a.newline && (x = C, g2 += 1);
            while (E2 === a.space || E2 === a.newline || E2 === a.tab || E2 === a.cr || E2 === a.feed);
            z3 = a.space, q2 = g2, k3 = C - x - 1, A = C;
            break;
          case a.plus:
          case a.greaterThan:
          case a.tilde:
          case a.pipe:
            C = O3;
            do
              C += 1, E2 = _3.charCodeAt(C);
            while (E2 === a.plus || E2 === a.greaterThan || E2 === a.tilde || E2 === a.pipe);
            z3 = a.combinator, q2 = g2, k3 = O3 - x, A = C;
            break;
          // Consume these characters as single tokens.
          case a.asterisk:
          case a.ampersand:
          case a.bang:
          case a.comma:
          case a.equals:
          case a.dollar:
          case a.caret:
          case a.openSquare:
          case a.closeSquare:
          case a.colon:
          case a.semicolon:
          case a.openParenthesis:
          case a.closeParenthesis:
            C = O3, z3 = E2, q2 = g2, k3 = O3 - x, A = C + 1;
            break;
          case a.singleQuote:
          case a.doubleQuote:
            B3 = E2 === a.singleQuote ? "'" : '"', C = O3;
            do
              for (M2 = false, C = _3.indexOf(B3, C + 1), C === -1 && L3("quote", B3), W3 = C; _3.charCodeAt(W3 - 1) === a.backslash; )
                W3 -= 1, M2 = !M2;
            while (M2);
            z3 = a.str, q2 = g2, k3 = O3 - x, A = C + 1;
            break;
          default:
            E2 === a.slash && _3.charCodeAt(O3 + 1) === a.asterisk ? (C = _3.indexOf("*/", O3 + 2) + 1, C === 0 && L3("comment", "*/"), b3 = _3.slice(O3, C + 1), P3 = b3.split(`
`), S3 = P3.length - 1, S3 > 0 ? (R3 = g2 + S3, $2 = C - P3[S3].length) : (R3 = g2, $2 = x), z3 = a.comment, g2 = R3, q2 = R3, k3 = C - $2) : E2 === a.slash ? (C = O3, z3 = E2, q2 = g2, k3 = O3 - x, A = C + 1) : (C = i(_3, O3), z3 = a.word, q2 = g2, k3 = C - x), A = C + 1;
            break;
        }
        d2.push([
          z3,
          // [0] Token type
          g2,
          // [1] Starting line
          O3 - x,
          // [2] Starting column
          q2,
          // [3] Ending line
          k3,
          // [4] Ending column
          O3,
          // [5] Start position / Source index
          A
          // [6] End position
        ]), $2 && (x = $2, $2 = null), O3 = A;
      }
      return d2;
    }
  })(tn3)), tn3;
}
var is2;
function Mu2() {
  return is2 || (is2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = A(xl()), p = A(Ol()), l2 = A(kl()), f = A(Pl()), s2 = A(El()), c2 = A(Tl()), t8 = A(Al()), e2 = A(Cl()), r2 = O3(Il()), i = A(Ml()), o2 = A(Dl()), v3 = A(ql()), m = A(Ru2()), n2 = O3(Iu2()), d2 = O3(Ll()), _3 = O3(Fe3()), w3 = dr3(), y2, x;
    function g2(L3) {
      if (typeof WeakMap != "function") return null;
      var F = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap();
      return (g2 = function(N3) {
        return N3 ? D : F;
      })(L3);
    }
    function O3(L3, F) {
      if (L3 && L3.__esModule)
        return L3;
      if (L3 === null || typeof L3 != "object" && typeof L3 != "function")
        return { default: L3 };
      var D = g2(F);
      if (D && D.has(L3))
        return D.get(L3);
      var I3 = {}, N3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var J3 in L3)
        if (J3 !== "default" && Object.prototype.hasOwnProperty.call(L3, J3)) {
          var T3 = N3 ? Object.getOwnPropertyDescriptor(L3, J3) : null;
          T3 && (T3.get || T3.set) ? Object.defineProperty(I3, J3, T3) : I3[J3] = L3[J3];
        }
      return I3.default = L3, D && D.set(L3, I3), I3;
    }
    function A(L3) {
      return L3 && L3.__esModule ? L3 : { default: L3 };
    }
    function E2(L3, F) {
      for (var D = 0; D < F.length; D++) {
        var I3 = F[D];
        I3.enumerable = I3.enumerable || false, I3.configurable = true, "value" in I3 && (I3.writable = true), Object.defineProperty(L3, I3.key, I3);
      }
    }
    function b3(L3, F, D) {
      return F && E2(L3.prototype, F), Object.defineProperty(L3, "prototype", { writable: false }), L3;
    }
    var k3 = (y2 = {}, y2[d2.space] = true, y2[d2.cr] = true, y2[d2.feed] = true, y2[d2.newline] = true, y2[d2.tab] = true, y2), q2 = Object.assign({}, k3, (x = {}, x[d2.comment] = true, x));
    function M2(L3) {
      return {
        line: L3[n2.FIELDS.START_LINE],
        column: L3[n2.FIELDS.START_COL]
      };
    }
    function W3(L3) {
      return {
        line: L3[n2.FIELDS.END_LINE],
        column: L3[n2.FIELDS.END_COL]
      };
    }
    function S3(L3, F, D, I3) {
      return {
        start: {
          line: L3,
          column: F
        },
        end: {
          line: D,
          column: I3
        }
      };
    }
    function P3(L3) {
      return S3(L3[n2.FIELDS.START_LINE], L3[n2.FIELDS.START_COL], L3[n2.FIELDS.END_LINE], L3[n2.FIELDS.END_COL]);
    }
    function C(L3, F) {
      if (L3)
        return S3(L3[n2.FIELDS.START_LINE], L3[n2.FIELDS.START_COL], F[n2.FIELDS.END_LINE], F[n2.FIELDS.END_COL]);
    }
    function R3(L3, F) {
      var D = L3[F];
      if (typeof D == "string")
        return D.indexOf("\\") !== -1 && ((0, w3.ensureObject)(L3, "raws"), L3[F] = (0, w3.unesc)(D), L3.raws[F] === void 0 && (L3.raws[F] = D)), L3;
    }
    function $2(L3, F) {
      for (var D = -1, I3 = []; (D = L3.indexOf(F, D + 1)) !== -1; )
        I3.push(D);
      return I3;
    }
    function B3() {
      var L3 = Array.prototype.concat.apply([], arguments);
      return L3.filter(function(F, D) {
        return D === L3.indexOf(F);
      });
    }
    var z3 = /* @__PURE__ */ (function() {
      function L3(D, I3) {
        I3 === void 0 && (I3 = {}), this.rule = D, this.options = Object.assign({
          lossy: false,
          safe: false
        }, I3), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, n2.default)({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var N3 = C(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new h2.default({
          source: N3
        }), this.root.errorGenerator = this._errorGenerator();
        var J3 = new p.default({
          source: {
            start: {
              line: 1,
              column: 1
            }
          },
          sourceIndex: 0
        });
        this.root.append(J3), this.current = J3, this.loop();
      }
      var F = L3.prototype;
      return F._errorGenerator = function() {
        var I3 = this;
        return function(N3, J3) {
          return typeof I3.rule == "string" ? new Error(N3) : I3.rule.error(N3, J3);
        };
      }, F.attribute = function() {
        var I3 = [], N3 = this.currToken;
        for (this.position++; this.position < this.tokens.length && this.currToken[n2.FIELDS.TYPE] !== d2.closeSquare; )
          I3.push(this.currToken), this.position++;
        if (this.currToken[n2.FIELDS.TYPE] !== d2.closeSquare)
          return this.expected("closing square bracket", this.currToken[n2.FIELDS.START_POS]);
        var J3 = I3.length, T3 = {
          source: S3(N3[1], N3[2], this.currToken[3], this.currToken[4]),
          sourceIndex: N3[n2.FIELDS.START_POS]
        };
        if (J3 === 1 && !~[d2.word].indexOf(I3[0][n2.FIELDS.TYPE]))
          return this.expected("attribute", I3[0][n2.FIELDS.START_POS]);
        for (var U2 = 0, j3 = "", H3 = "", V4 = null, K3 = false; U2 < J3; ) {
          var X3 = I3[U2], Q3 = this.content(X3), ne3 = I3[U2 + 1];
          switch (X3[n2.FIELDS.TYPE]) {
            case d2.space:
              if (K3 = true, this.options.lossy)
                break;
              if (V4) {
                (0, w3.ensureObject)(T3, "spaces", V4);
                var de3 = T3.spaces[V4].after || "";
                T3.spaces[V4].after = de3 + Q3;
                var _e3 = (0, w3.getProp)(T3, "raws", "spaces", V4, "after") || null;
                _e3 && (T3.raws.spaces[V4].after = _e3 + Q3);
              } else
                j3 = j3 + Q3, H3 = H3 + Q3;
              break;
            case d2.asterisk:
              if (ne3[n2.FIELDS.TYPE] === d2.equals)
                T3.operator = Q3, V4 = "operator";
              else if ((!T3.namespace || V4 === "namespace" && !K3) && ne3) {
                j3 && ((0, w3.ensureObject)(T3, "spaces", "attribute"), T3.spaces.attribute.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T3, "raws", "spaces", "attribute"), T3.raws.spaces.attribute.before = j3, H3 = ""), T3.namespace = (T3.namespace || "") + Q3;
                var be3 = (0, w3.getProp)(T3, "raws", "namespace") || null;
                be3 && (T3.raws.namespace += Q3), V4 = "namespace";
              }
              K3 = false;
              break;
            case d2.dollar:
              if (V4 === "value") {
                var ie3 = (0, w3.getProp)(T3, "raws", "value");
                T3.value += "$", ie3 && (T3.raws.value = ie3 + "$");
                break;
              }
            // Falls through
            case d2.caret:
              ne3[n2.FIELDS.TYPE] === d2.equals && (T3.operator = Q3, V4 = "operator"), K3 = false;
              break;
            case d2.combinator:
              if (Q3 === "~" && ne3[n2.FIELDS.TYPE] === d2.equals && (T3.operator = Q3, V4 = "operator"), Q3 !== "|") {
                K3 = false;
                break;
              }
              ne3[n2.FIELDS.TYPE] === d2.equals ? (T3.operator = Q3, V4 = "operator") : !T3.namespace && !T3.attribute && (T3.namespace = true), K3 = false;
              break;
            case d2.word:
              if (ne3 && this.content(ne3) === "|" && I3[U2 + 2] && I3[U2 + 2][n2.FIELDS.TYPE] !== d2.equals && // this look-ahead probably fails with comment nodes involved.
              !T3.operator && !T3.namespace)
                T3.namespace = Q3, V4 = "namespace";
              else if (!T3.attribute || V4 === "attribute" && !K3) {
                j3 && ((0, w3.ensureObject)(T3, "spaces", "attribute"), T3.spaces.attribute.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T3, "raws", "spaces", "attribute"), T3.raws.spaces.attribute.before = H3, H3 = ""), T3.attribute = (T3.attribute || "") + Q3;
                var ke3 = (0, w3.getProp)(T3, "raws", "attribute") || null;
                ke3 && (T3.raws.attribute += Q3), V4 = "attribute";
              } else if (!T3.value && T3.value !== "" || V4 === "value" && !(K3 || T3.quoteMark)) {
                var Y3 = (0, w3.unesc)(Q3), G3 = (0, w3.getProp)(T3, "raws", "value") || "", te2 = T3.value || "";
                T3.value = te2 + Y3, T3.quoteMark = null, (Y3 !== Q3 || G3) && ((0, w3.ensureObject)(T3, "raws"), T3.raws.value = (G3 || te2) + Q3), V4 = "value";
              } else {
                var Z3 = Q3 === "i" || Q3 === "I";
                (T3.value || T3.value === "") && (T3.quoteMark || K3) ? (T3.insensitive = Z3, (!Z3 || Q3 === "I") && ((0, w3.ensureObject)(T3, "raws"), T3.raws.insensitiveFlag = Q3), V4 = "insensitive", j3 && ((0, w3.ensureObject)(T3, "spaces", "insensitive"), T3.spaces.insensitive.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T3, "raws", "spaces", "insensitive"), T3.raws.spaces.insensitive.before = H3, H3 = "")) : (T3.value || T3.value === "") && (V4 = "value", T3.value += Q3, T3.raws.value && (T3.raws.value += Q3));
              }
              K3 = false;
              break;
            case d2.str:
              if (!T3.attribute || !T3.operator)
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: X3[n2.FIELDS.START_POS]
                });
              var ee3 = (0, r2.unescapeValue)(Q3), se3 = ee3.unescaped, ue = ee3.quoteMark;
              T3.value = se3, T3.quoteMark = ue, V4 = "value", (0, w3.ensureObject)(T3, "raws"), T3.raws.value = Q3, K3 = false;
              break;
            case d2.equals:
              if (!T3.attribute)
                return this.expected("attribute", X3[n2.FIELDS.START_POS], Q3);
              if (T3.value)
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: X3[n2.FIELDS.START_POS]
                });
              T3.operator = T3.operator ? T3.operator + Q3 : Q3, V4 = "operator", K3 = false;
              break;
            case d2.comment:
              if (V4)
                if (K3 || ne3 && ne3[n2.FIELDS.TYPE] === d2.space || V4 === "insensitive") {
                  var xe3 = (0, w3.getProp)(T3, "spaces", V4, "after") || "", ce3 = (0, w3.getProp)(T3, "raws", "spaces", V4, "after") || xe3;
                  (0, w3.ensureObject)(T3, "raws", "spaces", V4), T3.raws.spaces[V4].after = ce3 + Q3;
                } else {
                  var Te3 = T3[V4] || "", ve3 = (0, w3.getProp)(T3, "raws", V4) || Te3;
                  (0, w3.ensureObject)(T3, "raws"), T3.raws[V4] = ve3 + Q3;
                }
              else
                H3 = H3 + Q3;
              break;
            default:
              return this.error('Unexpected "' + Q3 + '" found.', {
                index: X3[n2.FIELDS.START_POS]
              });
          }
          U2++;
        }
        R3(T3, "attribute"), R3(T3, "namespace"), this.newNode(new r2.default(T3)), this.position++;
      }, F.parseWhitespaceEquivalentTokens = function(I3) {
        I3 < 0 && (I3 = this.tokens.length);
        var N3 = this.position, J3 = [], T3 = "", U2 = void 0;
        do
          if (k3[this.currToken[n2.FIELDS.TYPE]])
            this.options.lossy || (T3 += this.content());
          else if (this.currToken[n2.FIELDS.TYPE] === d2.comment) {
            var j3 = {};
            T3 && (j3.before = T3, T3 = ""), U2 = new f.default({
              value: this.content(),
              source: P3(this.currToken),
              sourceIndex: this.currToken[n2.FIELDS.START_POS],
              spaces: j3
            }), J3.push(U2);
          }
        while (++this.position < I3);
        if (T3) {
          if (U2)
            U2.spaces.after = T3;
          else if (!this.options.lossy) {
            var H3 = this.tokens[N3], V4 = this.tokens[this.position - 1];
            J3.push(new t8.default({
              value: "",
              source: S3(H3[n2.FIELDS.START_LINE], H3[n2.FIELDS.START_COL], V4[n2.FIELDS.END_LINE], V4[n2.FIELDS.END_COL]),
              sourceIndex: H3[n2.FIELDS.START_POS],
              spaces: {
                before: T3,
                after: ""
              }
            }));
          }
        }
        return J3;
      }, F.convertWhitespaceNodesToSpace = function(I3, N3) {
        var J3 = this;
        N3 === void 0 && (N3 = false);
        var T3 = "", U2 = "";
        I3.forEach(function(H3) {
          var V4 = J3.lossySpace(H3.spaces.before, N3), K3 = J3.lossySpace(H3.rawSpaceBefore, N3);
          T3 += V4 + J3.lossySpace(H3.spaces.after, N3 && V4.length === 0), U2 += V4 + H3.value + J3.lossySpace(H3.rawSpaceAfter, N3 && K3.length === 0);
        }), U2 === T3 && (U2 = void 0);
        var j3 = {
          space: T3,
          rawSpace: U2
        };
        return j3;
      }, F.isNamedCombinator = function(I3) {
        return I3 === void 0 && (I3 = this.position), this.tokens[I3 + 0] && this.tokens[I3 + 0][n2.FIELDS.TYPE] === d2.slash && this.tokens[I3 + 1] && this.tokens[I3 + 1][n2.FIELDS.TYPE] === d2.word && this.tokens[I3 + 2] && this.tokens[I3 + 2][n2.FIELDS.TYPE] === d2.slash;
      }, F.namedCombinator = function() {
        if (this.isNamedCombinator()) {
          var I3 = this.content(this.tokens[this.position + 1]), N3 = (0, w3.unesc)(I3).toLowerCase(), J3 = {};
          N3 !== I3 && (J3.value = "/" + I3 + "/");
          var T3 = new o2.default({
            value: "/" + N3 + "/",
            source: S3(this.currToken[n2.FIELDS.START_LINE], this.currToken[n2.FIELDS.START_COL], this.tokens[this.position + 2][n2.FIELDS.END_LINE], this.tokens[this.position + 2][n2.FIELDS.END_COL]),
            sourceIndex: this.currToken[n2.FIELDS.START_POS],
            raws: J3
          });
          return this.position = this.position + 3, T3;
        } else
          this.unexpected();
      }, F.combinator = function() {
        var I3 = this;
        if (this.content() === "|")
          return this.namespace();
        var N3 = this.locateNextMeaningfulToken(this.position);
        if (N3 < 0 || this.tokens[N3][n2.FIELDS.TYPE] === d2.comma || this.tokens[N3][n2.FIELDS.TYPE] === d2.closeParenthesis) {
          var J3 = this.parseWhitespaceEquivalentTokens(N3);
          if (J3.length > 0) {
            var T3 = this.current.last;
            if (T3) {
              var U2 = this.convertWhitespaceNodesToSpace(J3), j3 = U2.space, H3 = U2.rawSpace;
              H3 !== void 0 && (T3.rawSpaceAfter += H3), T3.spaces.after += j3;
            } else
              J3.forEach(function(G3) {
                return I3.newNode(G3);
              });
          }
          return;
        }
        var V4 = this.currToken, K3 = void 0;
        N3 > this.position && (K3 = this.parseWhitespaceEquivalentTokens(N3));
        var X3;
        if (this.isNamedCombinator() ? X3 = this.namedCombinator() : this.currToken[n2.FIELDS.TYPE] === d2.combinator ? (X3 = new o2.default({
          value: this.content(),
          source: P3(this.currToken),
          sourceIndex: this.currToken[n2.FIELDS.START_POS]
        }), this.position++) : k3[this.currToken[n2.FIELDS.TYPE]] || K3 || this.unexpected(), X3) {
          if (K3) {
            var Q3 = this.convertWhitespaceNodesToSpace(K3), ne3 = Q3.space, de3 = Q3.rawSpace;
            X3.spaces.before = ne3, X3.rawSpaceBefore = de3;
          }
        } else {
          var _e3 = this.convertWhitespaceNodesToSpace(K3, true), be3 = _e3.space, ie3 = _e3.rawSpace;
          ie3 || (ie3 = be3);
          var ke3 = {}, Y3 = {
            spaces: {}
          };
          be3.endsWith(" ") && ie3.endsWith(" ") ? (ke3.before = be3.slice(0, be3.length - 1), Y3.spaces.before = ie3.slice(0, ie3.length - 1)) : be3.startsWith(" ") && ie3.startsWith(" ") ? (ke3.after = be3.slice(1), Y3.spaces.after = ie3.slice(1)) : Y3.value = ie3, X3 = new o2.default({
            value: " ",
            source: C(V4, this.tokens[this.position - 1]),
            sourceIndex: V4[n2.FIELDS.START_POS],
            spaces: ke3,
            raws: Y3
          });
        }
        return this.currToken && this.currToken[n2.FIELDS.TYPE] === d2.space && (X3.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(X3);
      }, F.comma = function() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = true, this.position++;
          return;
        }
        this.current._inferEndPosition();
        var I3 = new p.default({
          source: {
            start: M2(this.tokens[this.position + 1])
          },
          sourceIndex: this.tokens[this.position + 1][n2.FIELDS.START_POS]
        });
        this.current.parent.append(I3), this.current = I3, this.position++;
      }, F.comment = function() {
        var I3 = this.currToken;
        this.newNode(new f.default({
          value: this.content(),
          source: P3(I3),
          sourceIndex: I3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.error = function(I3, N3) {
        throw this.root.error(I3, N3);
      }, F.missingBackslash = function() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[n2.FIELDS.START_POS]
        });
      }, F.missingParenthesis = function() {
        return this.expected("opening parenthesis", this.currToken[n2.FIELDS.START_POS]);
      }, F.missingSquareBracket = function() {
        return this.expected("opening square bracket", this.currToken[n2.FIELDS.START_POS]);
      }, F.unexpected = function() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[n2.FIELDS.START_POS]);
      }, F.unexpectedPipe = function() {
        return this.error("Unexpected '|'.", this.currToken[n2.FIELDS.START_POS]);
      }, F.namespace = function() {
        var I3 = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[n2.FIELDS.TYPE] === d2.word)
          return this.position++, this.word(I3);
        if (this.nextToken[n2.FIELDS.TYPE] === d2.asterisk)
          return this.position++, this.universal(I3);
        this.unexpectedPipe();
      }, F.nesting = function() {
        if (this.nextToken) {
          var I3 = this.content(this.nextToken);
          if (I3 === "|") {
            this.position++;
            return;
          }
        }
        var N3 = this.currToken;
        this.newNode(new v3.default({
          value: this.content(),
          source: P3(N3),
          sourceIndex: N3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.parentheses = function() {
        var I3 = this.current.last, N3 = 1;
        if (this.position++, I3 && I3.type === _3.PSEUDO) {
          var J3 = new p.default({
            source: {
              start: M2(this.tokens[this.position])
            },
            sourceIndex: this.tokens[this.position][n2.FIELDS.START_POS]
          }), T3 = this.current;
          for (I3.append(J3), this.current = J3; this.position < this.tokens.length && N3; )
            this.currToken[n2.FIELDS.TYPE] === d2.openParenthesis && N3++, this.currToken[n2.FIELDS.TYPE] === d2.closeParenthesis && N3--, N3 ? this.parse() : (this.current.source.end = W3(this.currToken), this.current.parent.source.end = W3(this.currToken), this.position++);
          this.current = T3;
        } else {
          for (var U2 = this.currToken, j3 = "(", H3; this.position < this.tokens.length && N3; )
            this.currToken[n2.FIELDS.TYPE] === d2.openParenthesis && N3++, this.currToken[n2.FIELDS.TYPE] === d2.closeParenthesis && N3--, H3 = this.currToken, j3 += this.parseParenthesisToken(this.currToken), this.position++;
          I3 ? I3.appendToPropertyAndEscape("value", j3, j3) : this.newNode(new t8.default({
            value: j3,
            source: S3(U2[n2.FIELDS.START_LINE], U2[n2.FIELDS.START_COL], H3[n2.FIELDS.END_LINE], H3[n2.FIELDS.END_COL]),
            sourceIndex: U2[n2.FIELDS.START_POS]
          }));
        }
        if (N3)
          return this.expected("closing parenthesis", this.currToken[n2.FIELDS.START_POS]);
      }, F.pseudo = function() {
        for (var I3 = this, N3 = "", J3 = this.currToken; this.currToken && this.currToken[n2.FIELDS.TYPE] === d2.colon; )
          N3 += this.content(), this.position++;
        if (!this.currToken)
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        if (this.currToken[n2.FIELDS.TYPE] === d2.word)
          this.splitWord(false, function(T3, U2) {
            N3 += T3, I3.newNode(new e2.default({
              value: N3,
              source: C(J3, I3.currToken),
              sourceIndex: J3[n2.FIELDS.START_POS]
            })), U2 > 1 && I3.nextToken && I3.nextToken[n2.FIELDS.TYPE] === d2.openParenthesis && I3.error("Misplaced parenthesis.", {
              index: I3.nextToken[n2.FIELDS.START_POS]
            });
          });
        else
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[n2.FIELDS.START_POS]);
      }, F.space = function() {
        var I3 = this.content();
        this.position === 0 || this.prevToken[n2.FIELDS.TYPE] === d2.comma || this.prevToken[n2.FIELDS.TYPE] === d2.openParenthesis || this.current.nodes.every(function(N3) {
          return N3.type === "comment";
        }) ? (this.spaces = this.optionalSpace(I3), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[n2.FIELDS.TYPE] === d2.comma || this.nextToken[n2.FIELDS.TYPE] === d2.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(I3), this.position++) : this.combinator();
      }, F.string = function() {
        var I3 = this.currToken;
        this.newNode(new t8.default({
          value: this.content(),
          source: P3(I3),
          sourceIndex: I3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.universal = function(I3) {
        var N3 = this.nextToken;
        if (N3 && this.content(N3) === "|")
          return this.position++, this.namespace();
        var J3 = this.currToken;
        this.newNode(new i.default({
          value: this.content(),
          source: P3(J3),
          sourceIndex: J3[n2.FIELDS.START_POS]
        }), I3), this.position++;
      }, F.splitWord = function(I3, N3) {
        for (var J3 = this, T3 = this.nextToken, U2 = this.content(); T3 && ~[d2.dollar, d2.caret, d2.equals, d2.word].indexOf(T3[n2.FIELDS.TYPE]); ) {
          this.position++;
          var j3 = this.content();
          if (U2 += j3, j3.lastIndexOf("\\") === j3.length - 1) {
            var H3 = this.nextToken;
            H3 && H3[n2.FIELDS.TYPE] === d2.space && (U2 += this.requiredSpace(this.content(H3)), this.position++);
          }
          T3 = this.nextToken;
        }
        var V4 = $2(U2, ".").filter(function(ne3) {
          var de3 = U2[ne3 - 1] === "\\", _e3 = /^\d+\.\d+%$/.test(U2);
          return !de3 && !_e3;
        }), K3 = $2(U2, "#").filter(function(ne3) {
          return U2[ne3 - 1] !== "\\";
        }), X3 = $2(U2, "#{");
        X3.length && (K3 = K3.filter(function(ne3) {
          return !~X3.indexOf(ne3);
        }));
        var Q3 = (0, m.default)(B3([0].concat(V4, K3)));
        Q3.forEach(function(ne3, de3) {
          var _e3 = Q3[de3 + 1] || U2.length, be3 = U2.slice(ne3, _e3);
          if (de3 === 0 && N3)
            return N3.call(J3, be3, Q3.length);
          var ie3, ke3 = J3.currToken, Y3 = ke3[n2.FIELDS.START_POS] + Q3[de3], G3 = S3(ke3[1], ke3[2] + ne3, ke3[3], ke3[2] + (_e3 - 1));
          if (~V4.indexOf(ne3)) {
            var te2 = {
              value: be3.slice(1),
              source: G3,
              sourceIndex: Y3
            };
            ie3 = new l2.default(R3(te2, "value"));
          } else if (~K3.indexOf(ne3)) {
            var Z3 = {
              value: be3.slice(1),
              source: G3,
              sourceIndex: Y3
            };
            ie3 = new s2.default(R3(Z3, "value"));
          } else {
            var ee3 = {
              value: be3,
              source: G3,
              sourceIndex: Y3
            };
            R3(ee3, "value"), ie3 = new c2.default(ee3);
          }
          J3.newNode(ie3, I3), I3 = null;
        }), this.position++;
      }, F.word = function(I3) {
        var N3 = this.nextToken;
        return N3 && this.content(N3) === "|" ? (this.position++, this.namespace()) : this.splitWord(I3);
      }, F.loop = function() {
        for (; this.position < this.tokens.length; )
          this.parse(true);
        return this.current._inferEndPosition(), this.root;
      }, F.parse = function(I3) {
        switch (this.currToken[n2.FIELDS.TYPE]) {
          case d2.space:
            this.space();
            break;
          case d2.comment:
            this.comment();
            break;
          case d2.openParenthesis:
            this.parentheses();
            break;
          case d2.closeParenthesis:
            I3 && this.missingParenthesis();
            break;
          case d2.openSquare:
            this.attribute();
            break;
          case d2.dollar:
          case d2.caret:
          case d2.equals:
          case d2.word:
            this.word();
            break;
          case d2.colon:
            this.pseudo();
            break;
          case d2.comma:
            this.comma();
            break;
          case d2.asterisk:
            this.universal();
            break;
          case d2.ampersand:
            this.nesting();
            break;
          case d2.slash:
          case d2.combinator:
            this.combinator();
            break;
          case d2.str:
            this.string();
            break;
          // These cases throw; no break needed.
          case d2.closeSquare:
            this.missingSquareBracket();
          case d2.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      }, F.expected = function(I3, N3, J3) {
        if (Array.isArray(I3)) {
          var T3 = I3.pop();
          I3 = I3.join(", ") + " or " + T3;
        }
        var U2 = /^[aeiou]/.test(I3[0]) ? "an" : "a";
        return J3 ? this.error("Expected " + U2 + " " + I3 + ', found "' + J3 + '" instead.', {
          index: N3
        }) : this.error("Expected " + U2 + " " + I3 + ".", {
          index: N3
        });
      }, F.requiredSpace = function(I3) {
        return this.options.lossy ? " " : I3;
      }, F.optionalSpace = function(I3) {
        return this.options.lossy ? "" : I3;
      }, F.lossySpace = function(I3, N3) {
        return this.options.lossy ? N3 ? " " : "" : I3;
      }, F.parseParenthesisToken = function(I3) {
        var N3 = this.content(I3);
        return I3[n2.FIELDS.TYPE] === d2.space ? this.requiredSpace(N3) : N3;
      }, F.newNode = function(I3, N3) {
        return N3 && (/^ +$/.test(N3) && (this.options.lossy || (this.spaces = (this.spaces || "") + N3), N3 = true), I3.namespace = N3, R3(I3, "namespace")), this.spaces && (I3.spaces.before = this.spaces, this.spaces = ""), this.current.append(I3);
      }, F.content = function(I3) {
        return I3 === void 0 && (I3 = this.currToken), this.css.slice(I3[n2.FIELDS.START_POS], I3[n2.FIELDS.END_POS]);
      }, F.locateNextMeaningfulToken = function(I3) {
        I3 === void 0 && (I3 = this.position + 1);
        for (var N3 = I3; N3 < this.tokens.length; )
          if (q2[this.tokens[N3][n2.FIELDS.TYPE]]) {
            N3++;
            continue;
          } else
            return N3;
        return -1;
      }, b3(L3, [{
        key: "currToken",
        get: function() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function() {
          return this.tokens[this.position - 1];
        }
      }]), L3;
    })();
    a.default = z3, u.exports = a.default;
  })(mt3, mt3.exports)), mt3.exports;
}
var as2;
function Du2() {
  return as2 || (as2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = p(Mu2());
    function p(f) {
      return f && f.__esModule ? f : { default: f };
    }
    var l2 = /* @__PURE__ */ (function() {
      function f(c2, t8) {
        this.func = c2 || function() {
        }, this.funcRes = null, this.options = t8;
      }
      var s2 = f.prototype;
      return s2._shouldUpdateSelector = function(t8, e2) {
        e2 === void 0 && (e2 = {});
        var r2 = Object.assign({}, this.options, e2);
        return r2.updateSelector === false ? false : typeof t8 != "string";
      }, s2._isLossy = function(t8) {
        t8 === void 0 && (t8 = {});
        var e2 = Object.assign({}, this.options, t8);
        return e2.lossless === false;
      }, s2._root = function(t8, e2) {
        e2 === void 0 && (e2 = {});
        var r2 = new h2.default(t8, this._parseOptions(e2));
        return r2.root;
      }, s2._parseOptions = function(t8) {
        return {
          lossy: this._isLossy(t8)
        };
      }, s2._run = function(t8, e2) {
        var r2 = this;
        return e2 === void 0 && (e2 = {}), new Promise(function(i, o2) {
          try {
            var v3 = r2._root(t8, e2);
            Promise.resolve(r2.func(v3)).then(function(m) {
              var n2 = void 0;
              return r2._shouldUpdateSelector(t8, e2) && (n2 = v3.toString(), t8.selector = n2), {
                transform: m,
                root: v3,
                string: n2
              };
            }).then(i, o2);
          } catch (m) {
            o2(m);
            return;
          }
        });
      }, s2._runSync = function(t8, e2) {
        e2 === void 0 && (e2 = {});
        var r2 = this._root(t8, e2), i = this.func(r2);
        if (i && typeof i.then == "function")
          throw new Error("Selector processor returned a promise to a synchronous call.");
        var o2 = void 0;
        return e2.updateSelector && typeof t8 != "string" && (o2 = r2.toString(), t8.selector = o2), {
          transform: i,
          root: r2,
          string: o2
        };
      }, s2.ast = function(t8, e2) {
        return this._run(t8, e2).then(function(r2) {
          return r2.root;
        });
      }, s2.astSync = function(t8, e2) {
        return this._runSync(t8, e2).root;
      }, s2.transform = function(t8, e2) {
        return this._run(t8, e2).then(function(r2) {
          return r2.transform;
        });
      }, s2.transformSync = function(t8, e2) {
        return this._runSync(t8, e2).transform;
      }, s2.process = function(t8, e2) {
        return this._run(t8, e2).then(function(r2) {
          return r2.string || r2.root.toString();
        });
      }, s2.processSync = function(t8, e2) {
        var r2 = this._runSync(t8, e2);
        return r2.string || r2.root.toString();
      }, f;
    })();
    a.default = l2, u.exports = a.default;
  })(gt3, gt3.exports)), gt3.exports;
}
var rn3 = {};
var Ie3 = {};
var ss2;
function qu2() {
  if (ss2) return Ie3;
  ss2 = 1, Ie3.__esModule = true, Ie3.universal = Ie3.tag = Ie3.string = Ie3.selector = Ie3.root = Ie3.pseudo = Ie3.nesting = Ie3.id = Ie3.comment = Ie3.combinator = Ie3.className = Ie3.attribute = void 0;
  var u = o2(Il()), a = o2(kl()), h2 = o2(Dl()), p = o2(Pl()), l2 = o2(El()), f = o2(ql()), s2 = o2(Cl()), c2 = o2(xl()), t8 = o2(Ol()), e2 = o2(Al()), r2 = o2(Tl()), i = o2(Ml());
  function o2(b3) {
    return b3 && b3.__esModule ? b3 : { default: b3 };
  }
  var v3 = function(k3) {
    return new u.default(k3);
  };
  Ie3.attribute = v3;
  var m = function(k3) {
    return new a.default(k3);
  };
  Ie3.className = m;
  var n2 = function(k3) {
    return new h2.default(k3);
  };
  Ie3.combinator = n2;
  var d2 = function(k3) {
    return new p.default(k3);
  };
  Ie3.comment = d2;
  var _3 = function(k3) {
    return new l2.default(k3);
  };
  Ie3.id = _3;
  var w3 = function(k3) {
    return new f.default(k3);
  };
  Ie3.nesting = w3;
  var y2 = function(k3) {
    return new s2.default(k3);
  };
  Ie3.pseudo = y2;
  var x = function(k3) {
    return new c2.default(k3);
  };
  Ie3.root = x;
  var g2 = function(k3) {
    return new t8.default(k3);
  };
  Ie3.selector = g2;
  var O3 = function(k3) {
    return new e2.default(k3);
  };
  Ie3.string = O3;
  var A = function(k3) {
    return new r2.default(k3);
  };
  Ie3.tag = A;
  var E2 = function(k3) {
    return new i.default(k3);
  };
  return Ie3.universal = E2, Ie3;
}
var Pe3 = {};
var os2;
function Lu2() {
  if (os2) return Pe3;
  os2 = 1, Pe3.__esModule = true, Pe3.isComment = Pe3.isCombinator = Pe3.isClassName = Pe3.isAttribute = void 0, Pe3.isContainer = y2, Pe3.isIdentifier = void 0, Pe3.isNamespace = x, Pe3.isNesting = void 0, Pe3.isNode = p, Pe3.isPseudo = void 0, Pe3.isPseudoClass = w3, Pe3.isPseudoElement = _3, Pe3.isUniversal = Pe3.isTag = Pe3.isString = Pe3.isSelector = Pe3.isRoot = void 0;
  var u = Fe3(), a, h2 = (a = {}, a[u.ATTRIBUTE] = true, a[u.CLASS] = true, a[u.COMBINATOR] = true, a[u.COMMENT] = true, a[u.ID] = true, a[u.NESTING] = true, a[u.PSEUDO] = true, a[u.ROOT] = true, a[u.SELECTOR] = true, a[u.STRING] = true, a[u.TAG] = true, a[u.UNIVERSAL] = true, a);
  function p(g2) {
    return typeof g2 == "object" && h2[g2.type];
  }
  function l2(g2, O3) {
    return p(O3) && O3.type === g2;
  }
  var f = l2.bind(null, u.ATTRIBUTE);
  Pe3.isAttribute = f;
  var s2 = l2.bind(null, u.CLASS);
  Pe3.isClassName = s2;
  var c2 = l2.bind(null, u.COMBINATOR);
  Pe3.isCombinator = c2;
  var t8 = l2.bind(null, u.COMMENT);
  Pe3.isComment = t8;
  var e2 = l2.bind(null, u.ID);
  Pe3.isIdentifier = e2;
  var r2 = l2.bind(null, u.NESTING);
  Pe3.isNesting = r2;
  var i = l2.bind(null, u.PSEUDO);
  Pe3.isPseudo = i;
  var o2 = l2.bind(null, u.ROOT);
  Pe3.isRoot = o2;
  var v3 = l2.bind(null, u.SELECTOR);
  Pe3.isSelector = v3;
  var m = l2.bind(null, u.STRING);
  Pe3.isString = m;
  var n2 = l2.bind(null, u.TAG);
  Pe3.isTag = n2;
  var d2 = l2.bind(null, u.UNIVERSAL);
  Pe3.isUniversal = d2;
  function _3(g2) {
    return i(g2) && g2.value && (g2.value.startsWith("::") || g2.value.toLowerCase() === ":before" || g2.value.toLowerCase() === ":after" || g2.value.toLowerCase() === ":first-letter" || g2.value.toLowerCase() === ":first-line");
  }
  function w3(g2) {
    return i(g2) && !_3(g2);
  }
  function y2(g2) {
    return !!(p(g2) && g2.walk);
  }
  function x(g2) {
    return f(g2) || n2(g2);
  }
  return Pe3;
}
var ls2;
function Nu2() {
  return ls2 || (ls2 = 1, (function(u) {
    u.__esModule = true;
    var a = Fe3();
    Object.keys(a).forEach(function(l2) {
      l2 === "default" || l2 === "__esModule" || l2 in u && u[l2] === a[l2] || (u[l2] = a[l2]);
    });
    var h2 = qu2();
    Object.keys(h2).forEach(function(l2) {
      l2 === "default" || l2 === "__esModule" || l2 in u && u[l2] === h2[l2] || (u[l2] = h2[l2]);
    });
    var p = Lu2();
    Object.keys(p).forEach(function(l2) {
      l2 === "default" || l2 === "__esModule" || l2 in u && u[l2] === p[l2] || (u[l2] = p[l2]);
    });
  })(rn3)), rn3;
}
var us2;
function Fu2() {
  return us2 || (us2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = s2(Du2()), p = f(Nu2());
    function l2(e2) {
      if (typeof WeakMap != "function") return null;
      var r2 = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap();
      return (l2 = function(v3) {
        return v3 ? i : r2;
      })(e2);
    }
    function f(e2, r2) {
      if (e2 && e2.__esModule)
        return e2;
      if (e2 === null || typeof e2 != "object" && typeof e2 != "function")
        return { default: e2 };
      var i = l2(r2);
      if (i && i.has(e2))
        return i.get(e2);
      var o2 = {}, v3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var m in e2)
        if (m !== "default" && Object.prototype.hasOwnProperty.call(e2, m)) {
          var n2 = v3 ? Object.getOwnPropertyDescriptor(e2, m) : null;
          n2 && (n2.get || n2.set) ? Object.defineProperty(o2, m, n2) : o2[m] = e2[m];
        }
      return o2.default = e2, i && i.set(e2, o2), o2;
    }
    function s2(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var c2 = function(r2) {
      return new h2.default(r2);
    };
    Object.assign(c2, p), delete c2.__esModule;
    var t8 = c2;
    a.default = t8, u.exports = a.default;
  })(vt3, vt3.exports)), vt3.exports;
}
var $u2 = Fu2();
var $i2 = /* @__PURE__ */ He3($u2);
var fs2 = (u) => u.replace(/-(\w|$)/g, (a, h2) => h2.toUpperCase());
var Uu2 = (u) => {
  const a = u.toLowerCase();
  return a.startsWith("--") ? a : a.startsWith("-ms-") ? fs2(a.slice(1)) : fs2(a);
};
function zu2(u) {
  return u.replaceAll(/\\[0-9]|\\/g, "");
}
var Wu2 = (u, a) => {
  u.walkRules((h2) => {
    var p;
    ((p = h2.parent) == null ? void 0 : p.type) !== "atrule" && $i2((l2) => {
      let f = false;
      l2.walkPseudos(() => {
        f = true;
      }), f || a(h2);
    }).processSync(h2.selector);
  });
};
function Vu2(u, a) {
  let p = [...u.split(" ")];
  const l2 = {};
  return Wu2(a, (f) => {
    const s2 = [];
    $i2((c2) => {
      c2.walkClasses((t8) => {
        s2.push(zu2(t8.value));
      });
    }).processSync(f.selector), p = p.filter((c2) => !s2.includes(c2)), f.walkDecls((c2) => {
      l2[Uu2(c2.prop)] = c2.value + (c2.important ? "!important" : "");
    });
  }), {
    styles: l2,
    residualClassName: p.join(" ")
  };
}
var ju2 = (u) => {
  u.walkDecls((a) => {
    const h2 = /rgb\(\s*(\d+)\s*(\d+)\s*(\d+)(?:\s*\/\s*([\d%.]+))?\s*\)/g;
    a.value = a.value.replaceAll(
      h2,
      (p, l2, f, s2, c2) => {
        const t8 = c2 === "1" || typeof c2 > "u" ? "" : `,${c2}`;
        return `rgb(${l2},${f},${s2}${t8})`;
      }
    );
  });
};
var Bu2 = (u) => {
  const a = [], h2 = [], p = $i2();
  return u.walkAtRules((l2) => {
    const f = l2.clone();
    f.walkRules((c2) => {
      const t8 = p.astSync(c2.selector);
      t8.walkClasses((r2) => {
        h2.push(r2.value), cs2(r2);
      });
      const e2 = c2.clone({ selector: t8.toString() });
      e2.walkDecls((r2) => {
        r2.important = true;
      }), c2.replaceWith(e2);
    });
    const s2 = a.find(
      (c2) => c2 instanceof wl && c2.params === f.params
    );
    s2 ? s2.append(f.nodes) : a.push(f);
  }), u.walkRules((l2) => {
    if (l2.parent && l2.parent.type !== "root") return;
    const f = p.astSync(l2.selector);
    let s2 = false;
    if (f.walkPseudos(() => {
      s2 = true;
    }), !!s2 && (f.walkClasses((c2) => {
      h2.push(c2.value), cs2(c2);
    }), s2)) {
      const c2 = l2.clone({ selector: f.toString() });
      c2.walkDecls((t8) => {
        t8.important = true;
      }), a.push(c2);
    }
  }), {
    nonInlinableClasses: h2,
    sanitizedRules: a
  };
};
var cs2 = (u) => {
  u.replaceWith(
    u.clone({
      value: _l(u.value)
    })
  );
};
var Gu2 = (u, a) => {
  const h2 = {};
  let p = [], l2 = [];
  if (u.props.className) {
    const s2 = a.generateRootForClasses(
      u.props.className.split(" ")
    );
    ju2(s2), {
      sanitizedRules: l2,
      nonInlinableClasses: p
    } = Bu2(s2);
    const { styles: c2, residualClassName: t8 } = Vu2(
      u.props.className,
      s2
    );
    if (h2.style = {
      ...c2,
      ...u.props.style
    }, !bl(u))
      if (t8.trim().length > 0) {
        h2.className = t8;
        for (const e2 of p)
          h2.className = h2.className.replace(
            e2,
            _l(e2)
          );
      } else
        h2.className = void 0;
  }
  const f = {
    ...u.props,
    ...h2
  };
  return {
    elementWithInlinedStyles: import_react2.default.cloneElement(
      u,
      f,
      f.children
    ),
    nonInlinableClasses: p,
    nonInlineStyleNodes: l2
  };
};
var nn2 = {};
var ds2;
function Yu2() {
  return ds2 || (ds2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return p;
      }
    });
    let a = {
      atrule: [
        "name",
        "params"
      ],
      rule: [
        "selector"
      ]
    }, h2 = new Set(Object.keys(a));
    function p() {
      function l2(f) {
        let s2 = null;
        f.each((c2) => {
          if (!h2.has(c2.type)) {
            s2 = null;
            return;
          }
          if (s2 === null) {
            s2 = c2;
            return;
          }
          let t8 = a[c2.type];
          var e2, r2;
          c2.type === "atrule" && c2.name === "font-face" ? s2 = c2 : t8.every((i) => ((e2 = c2[i]) !== null && e2 !== void 0 ? e2 : "").replace(/\s+/g, " ") === ((r2 = s2[i]) !== null && r2 !== void 0 ? r2 : "").replace(/\s+/g, " ")) ? (c2.nodes && s2.append(c2.nodes), c2.remove()) : s2 = c2;
        }), f.each((c2) => {
          c2.type === "atrule" && l2(c2);
        });
      }
      return (f) => {
        l2(f);
      };
    }
  })(nn2)), nn2;
}
var Qu2 = Yu2();
var Hu2 = /* @__PURE__ */ He3(Qu2);
var an2 = {};
var ps2;
function Ju2() {
  return ps2 || (ps2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a() {
      return (l2) => {
        l2.walkRules((f) => {
          let s2 = /* @__PURE__ */ new Map(), c2 = /* @__PURE__ */ new Set([]), t8 = /* @__PURE__ */ new Map();
          f.walkDecls((e2) => {
            if (e2.parent === f) {
              if (s2.has(e2.prop)) {
                if (s2.get(e2.prop).value === e2.value) {
                  c2.add(s2.get(e2.prop)), s2.set(e2.prop, e2);
                  return;
                }
                t8.has(e2.prop) || t8.set(e2.prop, /* @__PURE__ */ new Set()), t8.get(e2.prop).add(s2.get(e2.prop)), t8.get(e2.prop).add(e2);
              }
              s2.set(e2.prop, e2);
            }
          });
          for (let e2 of c2)
            e2.remove();
          for (let e2 of t8.values()) {
            let r2 = /* @__PURE__ */ new Map();
            for (let i of e2) {
              let o2 = p(i.value);
              o2 !== null && (r2.has(o2) || r2.set(o2, /* @__PURE__ */ new Set()), r2.get(o2).add(i));
            }
            for (let i of r2.values()) {
              let o2 = Array.from(i).slice(0, -1);
              for (let v3 of o2)
                v3.remove();
            }
          }
        });
      };
    }
    let h2 = Symbol("unitless-number");
    function p(l2) {
      let f = /^-?\d*.?\d+([\w%]+)?$/g.exec(l2);
      if (f) {
        var s2;
        return (s2 = f[1]) !== null && s2 !== void 0 ? s2 : h2;
      }
      return null;
    }
  })(an2)), an2;
}
var Ku2 = Ju2();
var Xu2 = /* @__PURE__ */ He3(Ku2);
var sn2 = {};
var on3 = { exports: {} };
var hs2;
function Nl() {
  return hs2 || (hs2 = 1, (function(u, a) {
    (function(h2, p) {
      u.exports = function(l2, f, s2, c2, t8) {
        for (f = f.split ? f.split(".") : f, c2 = 0; c2 < f.length; c2++) l2 = l2 ? l2[f[c2]] : t8;
        return l2 === t8 ? s2 : l2;
      };
    })();
  })(on3)), on3.exports;
}
var ln3 = { exports: {} };
var vs2;
function Zu2() {
  return vs2 || (vs2 = 1, (function(u) {
    (function() {
      function a(l2, f, s2) {
        if (!l2) return null;
        a.caseSensitive || (l2 = l2.toLowerCase());
        var c2 = a.threshold === null ? null : a.threshold * l2.length, t8 = a.thresholdAbsolute, e2;
        c2 !== null && t8 !== null ? e2 = Math.min(c2, t8) : c2 !== null ? e2 = c2 : t8 !== null ? e2 = t8 : e2 = null;
        var r2, i, o2, v3, m, n2 = f.length;
        for (m = 0; m < n2; m++)
          if (i = f[m], s2 && (i = i[s2]), !!i && (a.caseSensitive ? o2 = i : o2 = i.toLowerCase(), v3 = p(l2, o2, e2), (e2 === null || v3 < e2) && (e2 = v3, s2 && a.returnWinningObject ? r2 = f[m] : r2 = i, a.returnFirstMatch)))
            return r2;
        return r2 || a.nullResultValue;
      }
      a.threshold = 0.4, a.thresholdAbsolute = 20, a.caseSensitive = false, a.nullResultValue = null, a.returnWinningObject = null, a.returnFirstMatch = false, u.exports ? u.exports = a : window.didYouMean = a;
      var h2 = Math.pow(2, 32) - 1;
      function p(l2, f, s2) {
        s2 = s2 || s2 === 0 ? s2 : h2;
        var c2 = l2.length, t8 = f.length;
        if (c2 === 0) return Math.min(s2 + 1, t8);
        if (t8 === 0) return Math.min(s2 + 1, c2);
        if (Math.abs(c2 - t8) > s2) return s2 + 1;
        var e2 = [], r2, i, o2, v3, m;
        for (r2 = 0; r2 <= t8; r2++)
          e2[r2] = [r2];
        for (i = 0; i <= c2; i++)
          e2[0][i] = i;
        for (r2 = 1; r2 <= t8; r2++) {
          for (o2 = h2, v3 = 1, r2 > s2 && (v3 = r2 - s2), m = t8 + 1, m > s2 + r2 && (m = s2 + r2), i = 1; i <= c2; i++)
            i < v3 || i > m ? e2[r2][i] = s2 + 1 : f.charAt(r2 - 1) === l2.charAt(i - 1) ? e2[r2][i] = e2[r2 - 1][i - 1] : e2[r2][i] = Math.min(
              e2[r2 - 1][i - 1] + 1,
              // Substitute
              Math.min(
                e2[r2][i - 1] + 1,
                // Insert
                e2[r2 - 1][i] + 1
              )
            ), e2[r2][i] < o2 && (o2 = e2[r2][i]);
          if (o2 > s2) return s2 + 1;
        }
        return e2[t8][c2];
      }
    })();
  })(ln3)), ln3.exports;
}
var un3 = {};
var fn3 = {};
var gs2;
function ut3() {
  return gs2 || (gs2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      if (Object.prototype.toString.call(h2) !== "[object Object]")
        return false;
      const p = Object.getPrototypeOf(h2);
      return p === null || Object.getPrototypeOf(p) === null;
    }
  })(fn3)), fn3;
}
var ms2;
function pr3() {
  return ms2 || (ms2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = /* @__PURE__ */ p(Be2()), h2 = /* @__PURE__ */ p(ut3());
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l2(f) {
      return [
        "fontSize",
        "outline"
      ].includes(f) ? (s2) => (typeof s2 == "function" && (s2 = s2({})), Array.isArray(s2) && (s2 = s2[0]), s2) : f === "fontFamily" ? (s2) => {
        typeof s2 == "function" && (s2 = s2({}));
        let c2 = Array.isArray(s2) && (0, h2.default)(s2[1]) ? s2[0] : s2;
        return Array.isArray(c2) ? c2.join(", ") : c2;
      } : [
        "boxShadow",
        "transitionProperty",
        "transitionDuration",
        "transitionDelay",
        "transitionTimingFunction",
        "backgroundImage",
        "backgroundSize",
        "backgroundColor",
        "cursor",
        "animation"
      ].includes(f) ? (s2) => (typeof s2 == "function" && (s2 = s2({})), Array.isArray(s2) && (s2 = s2.join(", ")), s2) : [
        "gridTemplateColumns",
        "gridTemplateRows",
        "objectPosition"
      ].includes(f) ? (s2) => (typeof s2 == "function" && (s2 = s2({})), typeof s2 == "string" && (s2 = a.default.list.comma(s2).join(" ")), s2) : (s2, c2 = {}) => (typeof s2 == "function" && (s2 = s2(c2)), s2);
    }
  })(un3)), un3;
}
var cn3;
var ys2;
function ef() {
  if (ys2) return cn3;
  ys2 = 1;
  var u = 40, a = 41, h2 = 39, p = 34, l2 = 92, f = 47, s2 = 44, c2 = 58, t8 = 42, e2 = 117, r2 = 85, i = 43, o2 = /^[a-f0-9?-]+$/i;
  return cn3 = function(v3) {
    for (var m = [], n2 = v3, d2, _3, w3, y2, x, g2, O3, A, E2 = 0, b3 = n2.charCodeAt(E2), k3 = n2.length, q2 = [
      {
        nodes: m
      }
    ], M2 = 0, W3, S3 = "", P3 = "", C = ""; E2 < k3; )
      if (b3 <= 32) {
        d2 = E2;
        do
          d2 += 1, b3 = n2.charCodeAt(d2);
        while (b3 <= 32);
        y2 = n2.slice(E2, d2), w3 = m[m.length - 1], b3 === a && M2 ? C = y2 : w3 && w3.type === "div" ? (w3.after = y2, w3.sourceEndIndex += y2.length) : b3 === s2 || b3 === c2 || b3 === f && n2.charCodeAt(d2 + 1) !== t8 && (!W3 || W3 && W3.type === "function" && false) ? P3 = y2 : m.push({
          type: "space",
          sourceIndex: E2,
          sourceEndIndex: d2,
          value: y2
        }), E2 = d2;
      } else if (b3 === h2 || b3 === p) {
        d2 = E2, _3 = b3 === h2 ? "'" : '"', y2 = {
          type: "string",
          sourceIndex: E2,
          quote: _3
        };
        do
          if (x = false, d2 = n2.indexOf(_3, d2 + 1), ~d2)
            for (g2 = d2; n2.charCodeAt(g2 - 1) === l2; )
              g2 -= 1, x = !x;
          else
            n2 += _3, d2 = n2.length - 1, y2.unclosed = true;
        while (x);
        y2.value = n2.slice(E2 + 1, d2), y2.sourceEndIndex = y2.unclosed ? d2 : d2 + 1, m.push(y2), E2 = d2 + 1, b3 = n2.charCodeAt(E2);
      } else if (b3 === f && n2.charCodeAt(E2 + 1) === t8)
        d2 = n2.indexOf("*/", E2), y2 = {
          type: "comment",
          sourceIndex: E2,
          sourceEndIndex: d2 + 2
        }, d2 === -1 && (y2.unclosed = true, d2 = n2.length, y2.sourceEndIndex = d2), y2.value = n2.slice(E2 + 2, d2), m.push(y2), E2 = d2 + 2, b3 = n2.charCodeAt(E2);
      else if ((b3 === f || b3 === t8) && W3 && W3.type === "function")
        y2 = n2[E2], m.push({
          type: "word",
          sourceIndex: E2 - P3.length,
          sourceEndIndex: E2 + y2.length,
          value: y2
        }), E2 += 1, b3 = n2.charCodeAt(E2);
      else if (b3 === f || b3 === s2 || b3 === c2)
        y2 = n2[E2], m.push({
          type: "div",
          sourceIndex: E2 - P3.length,
          sourceEndIndex: E2 + y2.length,
          value: y2,
          before: P3,
          after: ""
        }), P3 = "", E2 += 1, b3 = n2.charCodeAt(E2);
      else if (u === b3) {
        d2 = E2;
        do
          d2 += 1, b3 = n2.charCodeAt(d2);
        while (b3 <= 32);
        if (A = E2, y2 = {
          type: "function",
          sourceIndex: E2 - S3.length,
          value: S3,
          before: n2.slice(A + 1, d2)
        }, E2 = d2, S3 === "url" && b3 !== h2 && b3 !== p) {
          d2 -= 1;
          do
            if (x = false, d2 = n2.indexOf(")", d2 + 1), ~d2)
              for (g2 = d2; n2.charCodeAt(g2 - 1) === l2; )
                g2 -= 1, x = !x;
            else
              n2 += ")", d2 = n2.length - 1, y2.unclosed = true;
          while (x);
          O3 = d2;
          do
            O3 -= 1, b3 = n2.charCodeAt(O3);
          while (b3 <= 32);
          A < O3 ? (E2 !== O3 + 1 ? y2.nodes = [
            {
              type: "word",
              sourceIndex: E2,
              sourceEndIndex: O3 + 1,
              value: n2.slice(E2, O3 + 1)
            }
          ] : y2.nodes = [], y2.unclosed && O3 + 1 !== d2 ? (y2.after = "", y2.nodes.push({
            type: "space",
            sourceIndex: O3 + 1,
            sourceEndIndex: d2,
            value: n2.slice(O3 + 1, d2)
          })) : (y2.after = n2.slice(O3 + 1, d2), y2.sourceEndIndex = d2)) : (y2.after = "", y2.nodes = []), E2 = d2 + 1, y2.sourceEndIndex = y2.unclosed ? d2 : E2, b3 = n2.charCodeAt(E2), m.push(y2);
        } else
          M2 += 1, y2.after = "", y2.sourceEndIndex = E2 + 1, m.push(y2), q2.push(y2), m = y2.nodes = [], W3 = y2;
        S3 = "";
      } else if (a === b3 && M2)
        E2 += 1, b3 = n2.charCodeAt(E2), W3.after = C, W3.sourceEndIndex += C.length, C = "", M2 -= 1, q2[q2.length - 1].sourceEndIndex = E2, q2.pop(), W3 = q2[M2], m = W3.nodes;
      else {
        d2 = E2;
        do
          b3 === l2 && (d2 += 1), d2 += 1, b3 = n2.charCodeAt(d2);
        while (d2 < k3 && !(b3 <= 32 || b3 === h2 || b3 === p || b3 === s2 || b3 === c2 || b3 === f || b3 === u || b3 === t8 && W3 && W3.type === "function" || b3 === f && W3.type === "function" || b3 === a && M2));
        y2 = n2.slice(E2, d2), u === b3 ? S3 = y2 : (e2 === y2.charCodeAt(0) || r2 === y2.charCodeAt(0)) && i === y2.charCodeAt(1) && o2.test(y2.slice(2)) ? m.push({
          type: "unicode-range",
          sourceIndex: E2,
          sourceEndIndex: d2,
          value: y2
        }) : m.push({
          type: "word",
          sourceIndex: E2,
          sourceEndIndex: d2,
          value: y2
        }), E2 = d2;
      }
    for (E2 = q2.length - 1; E2; E2 -= 1)
      q2[E2].unclosed = true, q2[E2].sourceEndIndex = n2.length;
    return q2[0].nodes;
  }, cn3;
}
var dn3;
var ws3;
function tf() {
  return ws3 || (ws3 = 1, dn3 = function u(a, h2, p) {
    var l2, f, s2, c2;
    for (l2 = 0, f = a.length; l2 < f; l2 += 1)
      s2 = a[l2], p || (c2 = h2(s2, l2, a)), c2 !== false && s2.type === "function" && Array.isArray(s2.nodes) && u(s2.nodes, h2, p), p && h2(s2, l2, a);
  }), dn3;
}
var pn3;
var bs2;
function rf() {
  if (bs2) return pn3;
  bs2 = 1;
  function u(h2, p) {
    var l2 = h2.type, f = h2.value, s2, c2;
    return p && (c2 = p(h2)) !== void 0 ? c2 : l2 === "word" || l2 === "space" ? f : l2 === "string" ? (s2 = h2.quote || "", s2 + f + (h2.unclosed ? "" : s2)) : l2 === "comment" ? "/*" + f + (h2.unclosed ? "" : "*/") : l2 === "div" ? (h2.before || "") + f + (h2.after || "") : Array.isArray(h2.nodes) ? (s2 = a(h2.nodes, p), l2 !== "function" ? s2 : f + "(" + (h2.before || "") + s2 + (h2.after || "") + (h2.unclosed ? "" : ")")) : f;
  }
  function a(h2, p) {
    var l2, f;
    if (Array.isArray(h2)) {
      for (l2 = "", f = h2.length - 1; ~f; f -= 1)
        l2 = u(h2[f], p) + l2;
      return l2;
    }
    return u(h2, p);
  }
  return pn3 = a, pn3;
}
var hn3;
var _s2;
function nf() {
  if (_s2) return hn3;
  _s2 = 1;
  var u = 45, a = 43, h2 = 46, p = 101, l2 = 69;
  function f(s2) {
    var c2 = s2.charCodeAt(0), t8;
    if (c2 === a || c2 === u) {
      if (t8 = s2.charCodeAt(1), t8 >= 48 && t8 <= 57)
        return true;
      var e2 = s2.charCodeAt(2);
      return t8 === h2 && e2 >= 48 && e2 <= 57;
    }
    return c2 === h2 ? (t8 = s2.charCodeAt(1), t8 >= 48 && t8 <= 57) : c2 >= 48 && c2 <= 57;
  }
  return hn3 = function(s2) {
    var c2 = 0, t8 = s2.length, e2, r2, i;
    if (t8 === 0 || !f(s2))
      return false;
    for (e2 = s2.charCodeAt(c2), (e2 === a || e2 === u) && c2++; c2 < t8 && (e2 = s2.charCodeAt(c2), !(e2 < 48 || e2 > 57)); )
      c2 += 1;
    if (e2 = s2.charCodeAt(c2), r2 = s2.charCodeAt(c2 + 1), e2 === h2 && r2 >= 48 && r2 <= 57)
      for (c2 += 2; c2 < t8 && (e2 = s2.charCodeAt(c2), !(e2 < 48 || e2 > 57)); )
        c2 += 1;
    if (e2 = s2.charCodeAt(c2), r2 = s2.charCodeAt(c2 + 1), i = s2.charCodeAt(c2 + 2), (e2 === p || e2 === l2) && (r2 >= 48 && r2 <= 57 || (r2 === a || r2 === u) && i >= 48 && i <= 57))
      for (c2 += r2 === a || r2 === u ? 3 : 2; c2 < t8 && (e2 = s2.charCodeAt(c2), !(e2 < 48 || e2 > 57)); )
        c2 += 1;
    return {
      number: s2.slice(0, c2),
      unit: s2.slice(c2)
    };
  }, hn3;
}
var vn3;
var Ss2;
function af() {
  if (Ss2) return vn3;
  Ss2 = 1;
  var u = ef(), a = tf(), h2 = rf();
  function p(l2) {
    return this instanceof p ? (this.nodes = u(l2), this) : new p(l2);
  }
  return p.prototype.toString = function() {
    return Array.isArray(this.nodes) ? h2(this.nodes) : "";
  }, p.prototype.walk = function(l2, f) {
    return a(this.nodes, l2, f), this;
  }, p.unit = nf(), p.walk = a, p.stringify = h2, vn3 = p, vn3;
}
var gn3 = {};
var xs2;
function Ui2() {
  return xs2 || (xs2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(c2, t8) {
      for (var e2 in t8) Object.defineProperty(c2, e2, {
        enumerable: true,
        get: t8[e2]
      });
    }
    a(u, {
      normalizeScreens: function() {
        return h2;
      },
      isScreenSortable: function() {
        return p;
      },
      compareScreens: function() {
        return l2;
      },
      toScreen: function() {
        return f;
      }
    });
    function h2(c2, t8 = true) {
      return Array.isArray(c2) ? c2.map((e2) => {
        if (t8 && Array.isArray(e2))
          throw new Error("The tuple syntax is not supported for `screens`.");
        if (typeof e2 == "string")
          return {
            name: e2.toString(),
            not: false,
            values: [
              {
                min: e2,
                max: void 0
              }
            ]
          };
        let [r2, i] = e2;
        return r2 = r2.toString(), typeof i == "string" ? {
          name: r2,
          not: false,
          values: [
            {
              min: i,
              max: void 0
            }
          ]
        } : Array.isArray(i) ? {
          name: r2,
          not: false,
          values: i.map((o2) => s2(o2))
        } : {
          name: r2,
          not: false,
          values: [
            s2(i)
          ]
        };
      }) : h2(Object.entries(c2 ?? {}), false);
    }
    function p(c2) {
      return c2.values.length !== 1 ? {
        result: false,
        reason: "multiple-values"
      } : c2.values[0].raw !== void 0 ? {
        result: false,
        reason: "raw-values"
      } : c2.values[0].min !== void 0 && c2.values[0].max !== void 0 ? {
        result: false,
        reason: "min-and-max"
      } : {
        result: true,
        reason: null
      };
    }
    function l2(c2, t8, e2) {
      let r2 = f(t8, c2), i = f(e2, c2), o2 = p(r2), v3 = p(i);
      if (o2.reason === "multiple-values" || v3.reason === "multiple-values")
        throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
      if (o2.reason === "raw-values" || v3.reason === "raw-values")
        throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
      if (o2.reason === "min-and-max" || v3.reason === "min-and-max")
        throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
      let { min: m, max: n2 } = r2.values[0], { min: d2, max: _3 } = i.values[0];
      t8.not && ([m, n2] = [
        n2,
        m
      ]), e2.not && ([d2, _3] = [
        _3,
        d2
      ]), m = m === void 0 ? m : parseFloat(m), n2 = n2 === void 0 ? n2 : parseFloat(n2), d2 = d2 === void 0 ? d2 : parseFloat(d2), _3 = _3 === void 0 ? _3 : parseFloat(_3);
      let [w3, y2] = c2 === "min" ? [
        m,
        d2
      ] : [
        _3,
        n2
      ];
      return w3 - y2;
    }
    function f(c2, t8) {
      return typeof c2 == "object" ? c2 : {
        name: "arbitrary-screen",
        values: [
          {
            [t8]: c2
          }
        ]
      };
    }
    function s2({ "min-width": c2, min: t8 = c2, max: e2, raw: r2 } = {}) {
      return {
        min: t8,
        max: e2,
        raw: r2
      };
    }
  })(gn3)), gn3;
}
var mn3 = {};
var Os2;
function zi2() {
  return Os2 || (Os2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      return h2 = Array.isArray(h2) ? h2 : [
        h2
      ], h2.map((p) => {
        let l2 = p.values.map((f) => f.raw !== void 0 ? f.raw : [
          f.min && `(min-width: ${f.min})`,
          f.max && `(max-width: ${f.max})`
        ].filter(Boolean).join(" and "));
        return p.not ? `not all and ${l2}` : l2;
      }).join(", ");
    }
  })(mn3)), mn3;
}
var yn3 = {};
var ks2;
function Wi2() {
  return ks2 || (ks2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "toPath", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      if (Array.isArray(h2)) return h2;
      let p = h2.split("[").length - 1, l2 = h2.split("]").length - 1;
      if (p !== l2)
        throw new Error(`Path is invalid. Has unbalanced brackets: ${h2}`);
      return h2.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
    }
  })(yn3)), yn3;
}
var wn3 = {};
var bn3 = {};
var _n3 = {};
var Ps2;
function sf() {
  return Ps2 || (Ps2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    const a = {
      aliceblue: [
        240,
        248,
        255
      ],
      antiquewhite: [
        250,
        235,
        215
      ],
      aqua: [
        0,
        255,
        255
      ],
      aquamarine: [
        127,
        255,
        212
      ],
      azure: [
        240,
        255,
        255
      ],
      beige: [
        245,
        245,
        220
      ],
      bisque: [
        255,
        228,
        196
      ],
      black: [
        0,
        0,
        0
      ],
      blanchedalmond: [
        255,
        235,
        205
      ],
      blue: [
        0,
        0,
        255
      ],
      blueviolet: [
        138,
        43,
        226
      ],
      brown: [
        165,
        42,
        42
      ],
      burlywood: [
        222,
        184,
        135
      ],
      cadetblue: [
        95,
        158,
        160
      ],
      chartreuse: [
        127,
        255,
        0
      ],
      chocolate: [
        210,
        105,
        30
      ],
      coral: [
        255,
        127,
        80
      ],
      cornflowerblue: [
        100,
        149,
        237
      ],
      cornsilk: [
        255,
        248,
        220
      ],
      crimson: [
        220,
        20,
        60
      ],
      cyan: [
        0,
        255,
        255
      ],
      darkblue: [
        0,
        0,
        139
      ],
      darkcyan: [
        0,
        139,
        139
      ],
      darkgoldenrod: [
        184,
        134,
        11
      ],
      darkgray: [
        169,
        169,
        169
      ],
      darkgreen: [
        0,
        100,
        0
      ],
      darkgrey: [
        169,
        169,
        169
      ],
      darkkhaki: [
        189,
        183,
        107
      ],
      darkmagenta: [
        139,
        0,
        139
      ],
      darkolivegreen: [
        85,
        107,
        47
      ],
      darkorange: [
        255,
        140,
        0
      ],
      darkorchid: [
        153,
        50,
        204
      ],
      darkred: [
        139,
        0,
        0
      ],
      darksalmon: [
        233,
        150,
        122
      ],
      darkseagreen: [
        143,
        188,
        143
      ],
      darkslateblue: [
        72,
        61,
        139
      ],
      darkslategray: [
        47,
        79,
        79
      ],
      darkslategrey: [
        47,
        79,
        79
      ],
      darkturquoise: [
        0,
        206,
        209
      ],
      darkviolet: [
        148,
        0,
        211
      ],
      deeppink: [
        255,
        20,
        147
      ],
      deepskyblue: [
        0,
        191,
        255
      ],
      dimgray: [
        105,
        105,
        105
      ],
      dimgrey: [
        105,
        105,
        105
      ],
      dodgerblue: [
        30,
        144,
        255
      ],
      firebrick: [
        178,
        34,
        34
      ],
      floralwhite: [
        255,
        250,
        240
      ],
      forestgreen: [
        34,
        139,
        34
      ],
      fuchsia: [
        255,
        0,
        255
      ],
      gainsboro: [
        220,
        220,
        220
      ],
      ghostwhite: [
        248,
        248,
        255
      ],
      gold: [
        255,
        215,
        0
      ],
      goldenrod: [
        218,
        165,
        32
      ],
      gray: [
        128,
        128,
        128
      ],
      green: [
        0,
        128,
        0
      ],
      greenyellow: [
        173,
        255,
        47
      ],
      grey: [
        128,
        128,
        128
      ],
      honeydew: [
        240,
        255,
        240
      ],
      hotpink: [
        255,
        105,
        180
      ],
      indianred: [
        205,
        92,
        92
      ],
      indigo: [
        75,
        0,
        130
      ],
      ivory: [
        255,
        255,
        240
      ],
      khaki: [
        240,
        230,
        140
      ],
      lavender: [
        230,
        230,
        250
      ],
      lavenderblush: [
        255,
        240,
        245
      ],
      lawngreen: [
        124,
        252,
        0
      ],
      lemonchiffon: [
        255,
        250,
        205
      ],
      lightblue: [
        173,
        216,
        230
      ],
      lightcoral: [
        240,
        128,
        128
      ],
      lightcyan: [
        224,
        255,
        255
      ],
      lightgoldenrodyellow: [
        250,
        250,
        210
      ],
      lightgray: [
        211,
        211,
        211
      ],
      lightgreen: [
        144,
        238,
        144
      ],
      lightgrey: [
        211,
        211,
        211
      ],
      lightpink: [
        255,
        182,
        193
      ],
      lightsalmon: [
        255,
        160,
        122
      ],
      lightseagreen: [
        32,
        178,
        170
      ],
      lightskyblue: [
        135,
        206,
        250
      ],
      lightslategray: [
        119,
        136,
        153
      ],
      lightslategrey: [
        119,
        136,
        153
      ],
      lightsteelblue: [
        176,
        196,
        222
      ],
      lightyellow: [
        255,
        255,
        224
      ],
      lime: [
        0,
        255,
        0
      ],
      limegreen: [
        50,
        205,
        50
      ],
      linen: [
        250,
        240,
        230
      ],
      magenta: [
        255,
        0,
        255
      ],
      maroon: [
        128,
        0,
        0
      ],
      mediumaquamarine: [
        102,
        205,
        170
      ],
      mediumblue: [
        0,
        0,
        205
      ],
      mediumorchid: [
        186,
        85,
        211
      ],
      mediumpurple: [
        147,
        112,
        219
      ],
      mediumseagreen: [
        60,
        179,
        113
      ],
      mediumslateblue: [
        123,
        104,
        238
      ],
      mediumspringgreen: [
        0,
        250,
        154
      ],
      mediumturquoise: [
        72,
        209,
        204
      ],
      mediumvioletred: [
        199,
        21,
        133
      ],
      midnightblue: [
        25,
        25,
        112
      ],
      mintcream: [
        245,
        255,
        250
      ],
      mistyrose: [
        255,
        228,
        225
      ],
      moccasin: [
        255,
        228,
        181
      ],
      navajowhite: [
        255,
        222,
        173
      ],
      navy: [
        0,
        0,
        128
      ],
      oldlace: [
        253,
        245,
        230
      ],
      olive: [
        128,
        128,
        0
      ],
      olivedrab: [
        107,
        142,
        35
      ],
      orange: [
        255,
        165,
        0
      ],
      orangered: [
        255,
        69,
        0
      ],
      orchid: [
        218,
        112,
        214
      ],
      palegoldenrod: [
        238,
        232,
        170
      ],
      palegreen: [
        152,
        251,
        152
      ],
      paleturquoise: [
        175,
        238,
        238
      ],
      palevioletred: [
        219,
        112,
        147
      ],
      papayawhip: [
        255,
        239,
        213
      ],
      peachpuff: [
        255,
        218,
        185
      ],
      peru: [
        205,
        133,
        63
      ],
      pink: [
        255,
        192,
        203
      ],
      plum: [
        221,
        160,
        221
      ],
      powderblue: [
        176,
        224,
        230
      ],
      purple: [
        128,
        0,
        128
      ],
      rebeccapurple: [
        102,
        51,
        153
      ],
      red: [
        255,
        0,
        0
      ],
      rosybrown: [
        188,
        143,
        143
      ],
      royalblue: [
        65,
        105,
        225
      ],
      saddlebrown: [
        139,
        69,
        19
      ],
      salmon: [
        250,
        128,
        114
      ],
      sandybrown: [
        244,
        164,
        96
      ],
      seagreen: [
        46,
        139,
        87
      ],
      seashell: [
        255,
        245,
        238
      ],
      sienna: [
        160,
        82,
        45
      ],
      silver: [
        192,
        192,
        192
      ],
      skyblue: [
        135,
        206,
        235
      ],
      slateblue: [
        106,
        90,
        205
      ],
      slategray: [
        112,
        128,
        144
      ],
      slategrey: [
        112,
        128,
        144
      ],
      snow: [
        255,
        250,
        250
      ],
      springgreen: [
        0,
        255,
        127
      ],
      steelblue: [
        70,
        130,
        180
      ],
      tan: [
        210,
        180,
        140
      ],
      teal: [
        0,
        128,
        128
      ],
      thistle: [
        216,
        191,
        216
      ],
      tomato: [
        255,
        99,
        71
      ],
      turquoise: [
        64,
        224,
        208
      ],
      violet: [
        238,
        130,
        238
      ],
      wheat: [
        245,
        222,
        179
      ],
      white: [
        255,
        255,
        255
      ],
      whitesmoke: [
        245,
        245,
        245
      ],
      yellow: [
        255,
        255,
        0
      ],
      yellowgreen: [
        154,
        205,
        50
      ]
    };
  })(_n3)), _n3;
}
var Es2;
function Fl() {
  return Es2 || (Es2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(m, n2) {
      for (var d2 in n2) Object.defineProperty(m, d2, {
        enumerable: true,
        get: n2[d2]
      });
    }
    a(u, {
      parseColor: function() {
        return o2;
      },
      formatColor: function() {
        return v3;
      }
    });
    const h2 = /* @__PURE__ */ p(sf());
    function p(m) {
      return m && m.__esModule ? m : {
        default: m
      };
    }
    let l2 = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, f = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, s2 = /(?:\d+|\d*\.\d+)%?/, c2 = /(?:\s*,\s*|\s+)/, t8 = /\s*[,/]\s*/, e2 = /var\(--(?:[^ )]*?)(?:,(?:[^ )]*?|var\(--[^ )]*?\)))?\)/, r2 = new RegExp(`^(rgba?)\\(\\s*(${s2.source}|${e2.source})(?:${c2.source}(${s2.source}|${e2.source}))?(?:${c2.source}(${s2.source}|${e2.source}))?(?:${t8.source}(${s2.source}|${e2.source}))?\\s*\\)$`), i = new RegExp(`^(hsla?)\\(\\s*((?:${s2.source})(?:deg|rad|grad|turn)?|${e2.source})(?:${c2.source}(${s2.source}|${e2.source}))?(?:${c2.source}(${s2.source}|${e2.source}))?(?:${t8.source}(${s2.source}|${e2.source}))?\\s*\\)$`);
    function o2(m, { loose: n2 = false } = {}) {
      var d2, _3;
      if (typeof m != "string")
        return null;
      if (m = m.trim(), m === "transparent")
        return {
          mode: "rgb",
          color: [
            "0",
            "0",
            "0"
          ],
          alpha: "0"
        };
      if (m in h2.default)
        return {
          mode: "rgb",
          color: h2.default[m].map((O3) => O3.toString())
        };
      let w3 = m.replace(f, (O3, A, E2, b3, k3) => [
        "#",
        A,
        A,
        E2,
        E2,
        b3,
        b3,
        k3 ? k3 + k3 : ""
      ].join("")).match(l2);
      if (w3 !== null)
        return {
          mode: "rgb",
          color: [
            parseInt(w3[1], 16),
            parseInt(w3[2], 16),
            parseInt(w3[3], 16)
          ].map((O3) => O3.toString()),
          alpha: w3[4] ? (parseInt(w3[4], 16) / 255).toString() : void 0
        };
      var y2;
      let x = (y2 = m.match(r2)) !== null && y2 !== void 0 ? y2 : m.match(i);
      if (x === null)
        return null;
      let g2 = [
        x[2],
        x[3],
        x[4]
      ].filter(Boolean).map((O3) => O3.toString());
      return g2.length === 2 && g2[0].startsWith("var(") ? {
        mode: x[1],
        color: [
          g2[0]
        ],
        alpha: g2[1]
      } : !n2 && g2.length !== 3 || g2.length < 3 && !g2.some((O3) => /^var\(.*?\)$/.test(O3)) ? null : {
        mode: x[1],
        color: g2,
        alpha: (d2 = x[5]) === null || d2 === void 0 || (_3 = d2.toString) === null || _3 === void 0 ? void 0 : _3.call(d2)
      };
    }
    function v3({ mode: m, color: n2, alpha: d2 }) {
      let _3 = d2 !== void 0;
      return m === "rgba" || m === "hsla" ? `${m}(${n2.join(", ")}${_3 ? `, ${d2}` : ""})` : `${m}(${n2.join(" ")}${_3 ? ` / ${d2}` : ""})`;
    }
  })(bn3)), bn3;
}
var Ts2;
function hr3() {
  return Ts2 || (Ts2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(f, s2) {
      for (var c2 in s2) Object.defineProperty(f, c2, {
        enumerable: true,
        get: s2[c2]
      });
    }
    a(u, {
      withAlphaValue: function() {
        return p;
      },
      default: function() {
        return l2;
      }
    });
    const h2 = Fl();
    function p(f, s2, c2) {
      if (typeof f == "function")
        return f({
          opacityValue: s2
        });
      let t8 = (0, h2.parseColor)(f, {
        loose: true
      });
      return t8 === null ? c2 : (0, h2.formatColor)({
        ...t8,
        alpha: s2
      });
    }
    function l2({ color: f, property: s2, variable: c2 }) {
      let t8 = [].concat(s2);
      if (typeof f == "function")
        return {
          [c2]: "1",
          ...Object.fromEntries(t8.map((r2) => [
            r2,
            f({
              opacityVariable: c2,
              opacityValue: `var(${c2})`
            })
          ]))
        };
      const e2 = (0, h2.parseColor)(f);
      return e2 === null ? Object.fromEntries(t8.map((r2) => [
        r2,
        f
      ])) : e2.alpha !== void 0 ? Object.fromEntries(t8.map((r2) => [
        r2,
        f
      ])) : {
        [c2]: "1",
        ...Object.fromEntries(t8.map((r2) => [
          r2,
          (0, h2.formatColor)({
            ...e2,
            alpha: `var(${c2})`
          })
        ]))
      };
    }
  })(wn3)), wn3;
}
var Sn3 = {};
var xn3 = {};
var As2;
function Vi2() {
  return As2 || (As2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      return h2.replace(/\\,/g, "\\2c ");
    }
  })(xn3)), xn3;
}
var On2 = {};
var kn3 = {};
var Pn3 = {};
var Cs2;
function st3() {
  return Cs2 || (Cs2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "splitAtTopLevelOnly", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2, p) {
      let l2 = [], f = [], s2 = 0, c2 = false;
      for (let t8 = 0; t8 < h2.length; t8++) {
        let e2 = h2[t8];
        l2.length === 0 && e2 === p[0] && !c2 && (p.length === 1 || h2.slice(t8, t8 + p.length) === p) && (f.push(h2.slice(s2, t8)), s2 = t8 + p.length), c2 = c2 ? false : e2 === "\\", e2 === "(" || e2 === "[" || e2 === "{" ? l2.push(e2) : (e2 === ")" && l2[l2.length - 1] === "(" || e2 === "]" && l2[l2.length - 1] === "[" || e2 === "}" && l2[l2.length - 1] === "{") && l2.pop();
      }
      return f.push(h2.slice(s2)), f;
    }
  })(Pn3)), Pn3;
}
var Rs2;
function $l() {
  return Rs2 || (Rs2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(t8, e2) {
      for (var r2 in e2) Object.defineProperty(t8, r2, {
        enumerable: true,
        get: e2[r2]
      });
    }
    a(u, {
      parseBoxShadowValue: function() {
        return s2;
      },
      formatBoxShadowValue: function() {
        return c2;
      }
    });
    const h2 = st3();
    let p = /* @__PURE__ */ new Set([
      "inset",
      "inherit",
      "initial",
      "revert",
      "unset"
    ]), l2 = /\ +(?![^(]*\))/g, f = /^-?(\d+|\.\d+)(.*?)$/g;
    function s2(t8) {
      return (0, h2.splitAtTopLevelOnly)(t8, ",").map((r2) => {
        let i = r2.trim(), o2 = {
          raw: i
        }, v3 = i.split(l2), m = /* @__PURE__ */ new Set();
        for (let n2 of v3)
          f.lastIndex = 0, !m.has("KEYWORD") && p.has(n2) ? (o2.keyword = n2, m.add("KEYWORD")) : f.test(n2) ? m.has("X") ? m.has("Y") ? m.has("BLUR") ? m.has("SPREAD") || (o2.spread = n2, m.add("SPREAD")) : (o2.blur = n2, m.add("BLUR")) : (o2.y = n2, m.add("Y")) : (o2.x = n2, m.add("X")) : o2.color ? (o2.unknown || (o2.unknown = []), o2.unknown.push(n2)) : o2.color = n2;
        return o2.valid = o2.x !== void 0 && o2.y !== void 0, o2;
      });
    }
    function c2(t8) {
      return t8.map((e2) => e2.valid ? [
        e2.keyword,
        e2.x,
        e2.y,
        e2.blur,
        e2.spread,
        e2.color
      ].filter(Boolean).join(" ") : e2.raw).join(", ");
    }
  })(kn3)), kn3;
}
var Is2;
function vr3() {
  return Is2 || (Is2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(R3, $2) {
      for (var B3 in $2) Object.defineProperty(R3, B3, {
        enumerable: true,
        get: $2[B3]
      });
    }
    a(u, {
      normalize: function() {
        return t8;
      },
      normalizeAttributeSelectors: function() {
        return e2;
      },
      url: function() {
        return i;
      },
      number: function() {
        return o2;
      },
      percentage: function() {
        return v3;
      },
      length: function() {
        return d2;
      },
      lineWidth: function() {
        return w3;
      },
      shadow: function() {
        return y2;
      },
      color: function() {
        return x;
      },
      image: function() {
        return g2;
      },
      gradient: function() {
        return A;
      },
      position: function() {
        return b3;
      },
      familyName: function() {
        return k3;
      },
      genericName: function() {
        return M2;
      },
      absoluteSize: function() {
        return S3;
      },
      relativeSize: function() {
        return C;
      }
    });
    const h2 = Fl(), p = $l(), l2 = st3();
    let f = [
      "min",
      "max",
      "clamp",
      "calc"
    ];
    function s2(R3) {
      return f.some(($2) => new RegExp(`^${$2}\\(.*\\)`).test(R3));
    }
    const c2 = /* @__PURE__ */ new Set([
      // Concrete properties
      "scroll-timeline-name",
      "timeline-scope",
      "view-timeline-name",
      "font-palette",
      "anchor-name",
      "anchor-scope",
      "position-anchor",
      "position-try-options",
      // Shorthand properties
      "scroll-timeline",
      "animation-timeline",
      "view-timeline",
      "position-try"
    ]);
    function t8(R3, $2 = null, B3 = true) {
      let z3 = $2 && c2.has($2.property);
      return R3.startsWith("--") && !z3 ? `var(${R3})` : R3.includes("url(") ? R3.split(/(url\(.*?\))/g).filter(Boolean).map((L3) => /^url\(.*?\)$/.test(L3) ? L3 : t8(L3, $2, false)).join("") : (R3 = R3.replace(/([^\\])_+/g, (L3, F) => F + " ".repeat(L3.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), B3 && (R3 = R3.trim()), R3 = r2(R3), R3);
    }
    function e2(R3) {
      return R3.includes("=") && (R3 = R3.replace(/(=.*)/g, ($2, B3) => {
        if (B3[1] === "'" || B3[1] === '"')
          return B3;
        if (B3.length > 2) {
          let z3 = B3[B3.length - 1];
          if (B3[B3.length - 2] === " " && (z3 === "i" || z3 === "I" || z3 === "s" || z3 === "S"))
            return `="${B3.slice(1, -2)}" ${B3[B3.length - 1]}`;
        }
        return `="${B3.slice(1)}"`;
      })), R3;
    }
    function r2(R3) {
      let $2 = [
        "theme"
      ], B3 = [
        "min-content",
        "max-content",
        "fit-content",
        // Env
        "safe-area-inset-top",
        "safe-area-inset-right",
        "safe-area-inset-bottom",
        "safe-area-inset-left",
        "titlebar-area-x",
        "titlebar-area-y",
        "titlebar-area-width",
        "titlebar-area-height",
        "keyboard-inset-top",
        "keyboard-inset-right",
        "keyboard-inset-bottom",
        "keyboard-inset-left",
        "keyboard-inset-width",
        "keyboard-inset-height",
        "radial-gradient",
        "linear-gradient",
        "conic-gradient",
        "repeating-radial-gradient",
        "repeating-linear-gradient",
        "repeating-conic-gradient"
      ];
      return R3.replace(/(calc|min|max|clamp)\(.+\)/g, (z3) => {
        let L3 = "";
        function F() {
          let D = L3.trimEnd();
          return D[D.length - 1];
        }
        for (let D = 0; D < z3.length; D++) {
          let I3 = function(T3) {
            return T3.split("").every((U2, j3) => z3[D + j3] === U2);
          }, N3 = function(T3) {
            let U2 = 1 / 0;
            for (let H3 of T3) {
              let V4 = z3.indexOf(H3, D);
              V4 !== -1 && V4 < U2 && (U2 = V4);
            }
            let j3 = z3.slice(D, U2);
            return D += j3.length - 1, j3;
          }, J3 = z3[D];
          if (I3("var"))
            L3 += N3([
              ")",
              ","
            ]);
          else if (B3.some((T3) => I3(T3))) {
            let T3 = B3.find((U2) => I3(U2));
            L3 += T3, D += T3.length - 1;
          } else $2.some((T3) => I3(T3)) ? L3 += N3([
            ")"
          ]) : I3("[") ? L3 += N3([
            "]"
          ]) : [
            "+",
            "-",
            "*",
            "/"
          ].includes(J3) && ![
            "(",
            "+",
            "-",
            "*",
            "/",
            ","
          ].includes(F()) ? L3 += ` ${J3} ` : L3 += J3;
        }
        return L3.replace(/\s+/g, " ");
      });
    }
    function i(R3) {
      return R3.startsWith("url(");
    }
    function o2(R3) {
      return !isNaN(Number(R3)) || s2(R3);
    }
    function v3(R3) {
      return R3.endsWith("%") && o2(R3.slice(0, -1)) || s2(R3);
    }
    let n2 = `(?:${[
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px",
      "em",
      "ex",
      "ch",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vmin",
      "vmax",
      "vb",
      "vi",
      "svw",
      "svh",
      "lvw",
      "lvh",
      "dvw",
      "dvh",
      "cqw",
      "cqh",
      "cqi",
      "cqb",
      "cqmin",
      "cqmax"
    ].join("|")})`;
    function d2(R3) {
      return R3 === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${n2}$`).test(R3) || s2(R3);
    }
    let _3 = /* @__PURE__ */ new Set([
      "thin",
      "medium",
      "thick"
    ]);
    function w3(R3) {
      return _3.has(R3);
    }
    function y2(R3) {
      let $2 = (0, p.parseBoxShadowValue)(t8(R3));
      for (let B3 of $2)
        if (!B3.valid)
          return false;
      return true;
    }
    function x(R3) {
      let $2 = 0;
      return (0, l2.splitAtTopLevelOnly)(R3, "_").every((z3) => (z3 = t8(z3), z3.startsWith("var(") ? true : (0, h2.parseColor)(z3, {
        loose: true
      }) !== null ? ($2++, true) : false)) ? $2 > 0 : false;
    }
    function g2(R3) {
      let $2 = 0;
      return (0, l2.splitAtTopLevelOnly)(R3, ",").every((z3) => (z3 = t8(z3), z3.startsWith("var(") ? true : i(z3) || A(z3) || [
        "element(",
        "image(",
        "cross-fade(",
        "image-set("
      ].some((L3) => z3.startsWith(L3)) ? ($2++, true) : false)) ? $2 > 0 : false;
    }
    let O3 = /* @__PURE__ */ new Set([
      "conic-gradient",
      "linear-gradient",
      "radial-gradient",
      "repeating-conic-gradient",
      "repeating-linear-gradient",
      "repeating-radial-gradient"
    ]);
    function A(R3) {
      R3 = t8(R3);
      for (let $2 of O3)
        if (R3.startsWith(`${$2}(`))
          return true;
      return false;
    }
    let E2 = /* @__PURE__ */ new Set([
      "center",
      "top",
      "right",
      "bottom",
      "left"
    ]);
    function b3(R3) {
      let $2 = 0;
      return (0, l2.splitAtTopLevelOnly)(R3, "_").every((z3) => (z3 = t8(z3), z3.startsWith("var(") ? true : E2.has(z3) || d2(z3) || v3(z3) ? ($2++, true) : false)) ? $2 > 0 : false;
    }
    function k3(R3) {
      let $2 = 0;
      return (0, l2.splitAtTopLevelOnly)(R3, ",").every((z3) => (z3 = t8(z3), z3.startsWith("var(") ? true : z3.includes(" ") && !/(['"])([^"']+)\1/g.test(z3) || /^\d/g.test(z3) ? false : ($2++, true))) ? $2 > 0 : false;
    }
    let q2 = /* @__PURE__ */ new Set([
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui",
      "ui-serif",
      "ui-sans-serif",
      "ui-monospace",
      "ui-rounded",
      "math",
      "emoji",
      "fangsong"
    ]);
    function M2(R3) {
      return q2.has(R3);
    }
    let W3 = /* @__PURE__ */ new Set([
      "xx-small",
      "x-small",
      "small",
      "medium",
      "large",
      "x-large",
      "xx-large",
      "xxx-large"
    ]);
    function S3(R3) {
      return W3.has(R3);
    }
    let P3 = /* @__PURE__ */ new Set([
      "larger",
      "smaller"
    ]);
    function C(R3) {
      return P3.has(R3);
    }
  })(On2)), On2;
}
var En3 = {};
var Ms2;
function ji2() {
  return Ms2 || (Ms2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      if (h2 = `${h2}`, h2 === "0")
        return "0";
      if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(h2))
        return h2.replace(/^[+-]?/, (l2) => l2 === "-" ? "" : "-");
      let p = [
        "var",
        "calc",
        "min",
        "max",
        "clamp"
      ];
      for (const l2 of p)
        if (h2.includes(`${l2}(`))
          return `calc(${h2} * -1)`;
    }
  })(En3)), En3;
}
var Tn3 = {};
var Ds2;
function of() {
  return Ds2 || (Ds2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "backgroundSize", {
      enumerable: true,
      get: function() {
        return p;
      }
    });
    const a = vr3(), h2 = st3();
    function p(l2) {
      let f = [
        "cover",
        "contain"
      ];
      return (0, h2.splitAtTopLevelOnly)(l2, ",").every((s2) => {
        let c2 = (0, h2.splitAtTopLevelOnly)(s2, "_").filter(Boolean);
        return c2.length === 1 && f.includes(c2[0]) ? true : c2.length !== 1 && c2.length !== 2 ? false : c2.every((t8) => (0, a.length)(t8) || (0, a.percentage)(t8) || t8 === "auto");
      });
    }
  })(Tn3)), Tn3;
}
var An3 = {};
var Cn3 = {};
var qs2;
function tt3() {
  return qs2 || (qs2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(t8, e2) {
      for (var r2 in e2) Object.defineProperty(t8, r2, {
        enumerable: true,
        get: e2[r2]
      });
    }
    a(u, {
      dim: function() {
        return s2;
      },
      default: function() {
        return c2;
      }
    });
    const h2 = /* @__PURE__ */ p(/* @__PURE__ */ Ti());
    function p(t8) {
      return t8 && t8.__esModule ? t8 : {
        default: t8
      };
    }
    let l2 = /* @__PURE__ */ new Set();
    function f(t8, e2, r2) {
      typeof process < "u" && process.env.JEST_WORKER_ID || r2 && l2.has(r2) || (r2 && l2.add(r2), console.warn(""), e2.forEach((i) => console.warn(t8, "-", i)));
    }
    function s2(t8) {
      return h2.default.dim(t8);
    }
    const c2 = {
      info(t8, e2) {
        f(h2.default.bold(h2.default.cyan("info")), ...Array.isArray(t8) ? [
          t8
        ] : [
          e2,
          t8
        ]);
      },
      warn(t8, e2) {
        f(h2.default.bold(h2.default.yellow("warn")), ...Array.isArray(t8) ? [
          t8
        ] : [
          e2,
          t8
        ]);
      },
      risk(t8, e2) {
        f(h2.default.bold(h2.default.magenta("risk")), ...Array.isArray(t8) ? [
          t8
        ] : [
          e2,
          t8
        ]);
      }
    };
  })(Cn3)), Cn3;
}
var Ls2;
function it3() {
  return Ls2 || (Ls2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(i, o2) {
      for (var v3 in o2) Object.defineProperty(i, v3, {
        enumerable: true,
        get: o2[v3]
      });
    }
    a(u, {
      flagEnabled: function() {
        return c2;
      },
      issueFlagNotices: function() {
        return e2;
      },
      default: function() {
        return r2;
      }
    });
    const h2 = /* @__PURE__ */ l2(/* @__PURE__ */ Ti()), p = /* @__PURE__ */ l2(tt3());
    function l2(i) {
      return i && i.__esModule ? i : {
        default: i
      };
    }
    let f = {
      optimizeUniversalDefaults: false,
      generalizedModifiers: true,
      disableColorOpacityUtilitiesByDefault: false,
      relativeContentPathsByDefault: false
    }, s2 = {
      future: [
        "hoverOnlyWhenSupported",
        "respectDefaultRingColorOpacity",
        "disableColorOpacityUtilitiesByDefault",
        "relativeContentPathsByDefault"
      ],
      experimental: [
        "optimizeUniversalDefaults",
        "generalizedModifiers"
      ]
    };
    function c2(i, o2) {
      if (s2.future.includes(o2)) {
        var v3, m, n2;
        return i.future === "all" || ((n2 = (m = i == null || (v3 = i.future) === null || v3 === void 0 ? void 0 : v3[o2]) !== null && m !== void 0 ? m : f[o2]) !== null && n2 !== void 0 ? n2 : false);
      }
      if (s2.experimental.includes(o2)) {
        var d2, _3, w3;
        return i.experimental === "all" || ((w3 = (_3 = i == null || (d2 = i.experimental) === null || d2 === void 0 ? void 0 : d2[o2]) !== null && _3 !== void 0 ? _3 : f[o2]) !== null && w3 !== void 0 ? w3 : false);
      }
      return false;
    }
    function t8(i) {
      if (i.experimental === "all")
        return s2.experimental;
      var o2;
      return Object.keys((o2 = i == null ? void 0 : i.experimental) !== null && o2 !== void 0 ? o2 : {}).filter((v3) => s2.experimental.includes(v3) && i.experimental[v3]);
    }
    function e2(i) {
      if (process.env.JEST_WORKER_ID === void 0 && t8(i).length > 0) {
        let o2 = t8(i).map((v3) => h2.default.yellow(v3)).join(", ");
        p.default.warn("experimental-flags-enabled", [
          `You have enabled experimental features: ${o2}`,
          "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
        ]);
      }
    }
    const r2 = s2;
  })(An3)), An3;
}
var Ns2;
function gr3() {
  return Ns2 || (Ns2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(b3, k3) {
      for (var q2 in k3) Object.defineProperty(b3, q2, {
        enumerable: true,
        get: k3[q2]
      });
    }
    a(u, {
      updateAllClasses: function() {
        return e2;
      },
      asValue: function() {
        return o2;
      },
      parseColorFormat: function() {
        return n2;
      },
      asColor: function() {
        return _3;
      },
      asLookupValue: function() {
        return w3;
      },
      typeMap: function() {
        return x;
      },
      coerceValue: function() {
        return A;
      },
      getMatchingTypes: function() {
        return E2;
      }
    });
    const h2 = /* @__PURE__ */ t8(Vi2()), p = hr3(), l2 = vr3(), f = /* @__PURE__ */ t8(ji2()), s2 = of(), c2 = it3();
    function t8(b3) {
      return b3 && b3.__esModule ? b3 : {
        default: b3
      };
    }
    function e2(b3, k3) {
      b3.walkClasses((q2) => {
        q2.value = k3(q2.value), q2.raws && q2.raws.value && (q2.raws.value = (0, h2.default)(q2.raws.value));
      });
    }
    function r2(b3, k3) {
      if (!v3(b3))
        return;
      let q2 = b3.slice(1, -1);
      if (k3(q2))
        return (0, l2.normalize)(q2);
    }
    function i(b3, k3 = {}, q2) {
      let M2 = k3[b3];
      if (M2 !== void 0)
        return (0, f.default)(M2);
      if (v3(b3)) {
        let W3 = r2(b3, q2);
        return W3 === void 0 ? void 0 : (0, f.default)(W3);
      }
    }
    function o2(b3, k3 = {}, { validate: q2 = () => true } = {}) {
      var M2;
      let W3 = (M2 = k3.values) === null || M2 === void 0 ? void 0 : M2[b3];
      return W3 !== void 0 ? W3 : k3.supportsNegativeValues && b3.startsWith("-") ? i(b3.slice(1), k3.values, q2) : r2(b3, q2);
    }
    function v3(b3) {
      return b3.startsWith("[") && b3.endsWith("]");
    }
    function m(b3) {
      let k3 = b3.lastIndexOf("/"), q2 = b3.lastIndexOf("[", k3), M2 = b3.indexOf("]", k3);
      return b3[k3 - 1] === "]" || b3[k3 + 1] === "[" || q2 !== -1 && M2 !== -1 && q2 < k3 && k3 < M2 && (k3 = b3.lastIndexOf("/", q2)), k3 === -1 || k3 === b3.length - 1 ? [
        b3,
        void 0
      ] : v3(b3) && !b3.includes("]/[") ? [
        b3,
        void 0
      ] : [
        b3.slice(0, k3),
        b3.slice(k3 + 1)
      ];
    }
    function n2(b3) {
      if (typeof b3 == "string" && b3.includes("<alpha-value>")) {
        let k3 = b3;
        return ({ opacityValue: q2 = 1 }) => k3.replace(/<alpha-value>/g, q2);
      }
      return b3;
    }
    function d2(b3) {
      return (0, l2.normalize)(b3.slice(1, -1));
    }
    function _3(b3, k3 = {}, { tailwindConfig: q2 = {} } = {}) {
      var M2;
      if (((M2 = k3.values) === null || M2 === void 0 ? void 0 : M2[b3]) !== void 0) {
        var W3;
        return n2((W3 = k3.values) === null || W3 === void 0 ? void 0 : W3[b3]);
      }
      let [S3, P3] = m(b3);
      if (P3 !== void 0) {
        var C, R3, $2, B3;
        let z3 = (B3 = (C = k3.values) === null || C === void 0 ? void 0 : C[S3]) !== null && B3 !== void 0 ? B3 : v3(S3) ? S3.slice(1, -1) : void 0;
        return z3 === void 0 ? void 0 : (z3 = n2(z3), v3(P3) ? (0, p.withAlphaValue)(z3, d2(P3)) : ((R3 = q2.theme) === null || R3 === void 0 || ($2 = R3.opacity) === null || $2 === void 0 ? void 0 : $2[P3]) === void 0 ? void 0 : (0, p.withAlphaValue)(z3, q2.theme.opacity[P3]));
      }
      return o2(b3, k3, {
        validate: l2.color
      });
    }
    function w3(b3, k3 = {}) {
      var q2;
      return (q2 = k3.values) === null || q2 === void 0 ? void 0 : q2[b3];
    }
    function y2(b3) {
      return (k3, q2) => o2(k3, q2, {
        validate: b3
      });
    }
    let x = {
      any: o2,
      color: _3,
      url: y2(l2.url),
      image: y2(l2.image),
      length: y2(l2.length),
      percentage: y2(l2.percentage),
      position: y2(l2.position),
      lookup: w3,
      "generic-name": y2(l2.genericName),
      "family-name": y2(l2.familyName),
      number: y2(l2.number),
      "line-width": y2(l2.lineWidth),
      "absolute-size": y2(l2.absoluteSize),
      "relative-size": y2(l2.relativeSize),
      shadow: y2(l2.shadow),
      size: y2(s2.backgroundSize)
    }, g2 = Object.keys(x);
    function O3(b3, k3) {
      let q2 = b3.indexOf(k3);
      return q2 === -1 ? [
        void 0,
        b3
      ] : [
        b3.slice(0, q2),
        b3.slice(q2 + 1)
      ];
    }
    function A(b3, k3, q2, M2) {
      if (q2.values && k3 in q2.values)
        for (let { type: S3 } of b3 ?? []) {
          let P3 = x[S3](k3, q2, {
            tailwindConfig: M2
          });
          if (P3 !== void 0)
            return [
              P3,
              S3,
              null
            ];
        }
      if (v3(k3)) {
        let S3 = k3.slice(1, -1), [P3, C] = O3(S3, ":");
        if (!/^[\w-_]+$/g.test(P3))
          C = S3;
        else if (P3 !== void 0 && !g2.includes(P3))
          return [];
        if (C.length > 0 && g2.includes(P3))
          return [
            o2(`[${C}]`, q2),
            P3,
            null
          ];
      }
      let W3 = E2(b3, k3, q2, M2);
      for (let S3 of W3)
        return S3;
      return [];
    }
    function* E2(b3, k3, q2, M2) {
      let W3 = (0, c2.flagEnabled)(M2, "generalizedModifiers"), [S3, P3] = m(k3);
      if (W3 && q2.modifiers != null && (q2.modifiers === "any" || typeof q2.modifiers == "object" && (P3 && v3(P3) || P3 in q2.modifiers)) || (S3 = k3, P3 = void 0), P3 !== void 0 && S3 === "" && (S3 = "DEFAULT"), P3 !== void 0 && typeof q2.modifiers == "object") {
        var R3, $2;
        let B3 = ($2 = (R3 = q2.modifiers) === null || R3 === void 0 ? void 0 : R3[P3]) !== null && $2 !== void 0 ? $2 : null;
        B3 !== null ? P3 = B3 : v3(P3) && (P3 = d2(P3));
      }
      for (let { type: B3 } of b3 ?? []) {
        let z3 = x[B3](S3, q2, {
          tailwindConfig: M2
        });
        z3 !== void 0 && (yield [
          z3,
          B3,
          P3 ?? null
        ]);
      }
    }
  })(Sn3)), Sn3;
}
var Fs2;
function lf() {
  return Fs2 || (Fs2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return E2;
      }
    });
    const a = /* @__PURE__ */ i(Nl()), h2 = /* @__PURE__ */ i(Zu2()), p = /* @__PURE__ */ i(pr3()), l2 = /* @__PURE__ */ i(af()), f = Ui2(), s2 = /* @__PURE__ */ i(zi2()), c2 = Wi2(), t8 = hr3(), e2 = gr3(), r2 = /* @__PURE__ */ i(tt3());
    function i(b3) {
      return b3 && b3.__esModule ? b3 : {
        default: b3
      };
    }
    function o2(b3) {
      return typeof b3 == "object" && b3 !== null;
    }
    function v3(b3, k3) {
      let q2 = (0, c2.toPath)(k3);
      do
        if (q2.pop(), (0, a.default)(b3, q2) !== void 0) break;
      while (q2.length);
      return q2.length ? q2 : void 0;
    }
    function m(b3) {
      return typeof b3 == "string" ? b3 : b3.reduce((k3, q2, M2) => q2.includes(".") ? `${k3}[${q2}]` : M2 === 0 ? q2 : `${k3}.${q2}`, "");
    }
    function n2(b3) {
      return b3.map((k3) => `'${k3}'`).join(", ");
    }
    function d2(b3) {
      return n2(Object.keys(b3));
    }
    function _3(b3, k3, q2, M2 = {}) {
      const W3 = Array.isArray(k3) ? m(k3) : k3.replace(/^['"]+|['"]+$/g, ""), S3 = Array.isArray(k3) ? k3 : (0, c2.toPath)(W3), P3 = (0, a.default)(b3.theme, S3, q2);
      if (P3 === void 0) {
        let R3 = `'${W3}' does not exist in your theme config.`;
        const $2 = S3.slice(0, -1), B3 = (0, a.default)(b3.theme, $2);
        if (o2(B3)) {
          const z3 = Object.keys(B3).filter((F) => _3(b3, [
            ...$2,
            F
          ]).isValid), L3 = (0, h2.default)(S3[S3.length - 1], z3);
          L3 ? R3 += ` Did you mean '${m([
            ...$2,
            L3
          ])}'?` : z3.length > 0 && (R3 += ` '${m($2)}' has the following valid keys: ${n2(z3)}`);
        } else {
          const z3 = v3(b3.theme, W3);
          if (z3) {
            const L3 = (0, a.default)(b3.theme, z3);
            o2(L3) ? R3 += ` '${m(z3)}' has the following keys: ${d2(L3)}` : R3 += ` '${m(z3)}' is not an object.`;
          } else
            R3 += ` Your theme has the following top-level keys: ${d2(b3.theme)}`;
        }
        return {
          isValid: false,
          error: R3
        };
      }
      if (!(typeof P3 == "string" || typeof P3 == "number" || typeof P3 == "function" || P3 instanceof String || P3 instanceof Number || Array.isArray(P3))) {
        let R3 = `'${W3}' was found but does not resolve to a string.`;
        if (o2(P3)) {
          let $2 = Object.keys(P3).filter((B3) => _3(b3, [
            ...S3,
            B3
          ]).isValid);
          $2.length && (R3 += ` Did you mean something like '${m([
            ...S3,
            $2[0]
          ])}'?`);
        }
        return {
          isValid: false,
          error: R3
        };
      }
      const [C] = S3;
      return {
        isValid: true,
        value: (0, p.default)(C)(P3, M2)
      };
    }
    function w3(b3, k3, q2) {
      k3 = k3.map((W3) => y2(b3, W3, q2));
      let M2 = [
        ""
      ];
      for (let W3 of k3)
        W3.type === "div" && W3.value === "," ? M2.push("") : M2[M2.length - 1] += l2.default.stringify(W3);
      return M2;
    }
    function y2(b3, k3, q2) {
      if (k3.type === "function" && q2[k3.value] !== void 0) {
        let M2 = w3(b3, k3.nodes, q2);
        k3.type = "word", k3.value = q2[k3.value](b3, ...M2);
      }
      return k3;
    }
    function x(b3, k3, q2) {
      return Object.keys(q2).some((W3) => k3.includes(`${W3}(`)) ? (0, l2.default)(k3).walk((W3) => {
        y2(b3, W3, q2);
      }).toString() : k3;
    }
    let g2 = {
      atrule: "params",
      decl: "value"
    };
    function* O3(b3) {
      b3 = b3.replace(/^['"]+|['"]+$/g, "");
      let k3 = b3.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), q2;
      yield [
        b3,
        void 0
      ], k3 && (b3 = k3[1], q2 = k3[2], yield [
        b3,
        q2
      ]);
    }
    function A(b3, k3, q2) {
      const M2 = Array.from(O3(k3)).map(([S3, P3]) => Object.assign(_3(b3, S3, q2, {
        opacityValue: P3
      }), {
        resolvedPath: S3,
        alpha: P3
      }));
      var W3;
      return (W3 = M2.find((S3) => S3.isValid)) !== null && W3 !== void 0 ? W3 : M2[0];
    }
    function E2(b3) {
      let k3 = b3.tailwindConfig, q2 = {
        theme: (M2, W3, ...S3) => {
          let { isValid: P3, value: C, error: R3, alpha: $2 } = A(k3, W3, S3.length ? S3 : void 0);
          if (!P3) {
            var B3;
            let F = M2.parent, D = (B3 = F == null ? void 0 : F.raws.tailwind) === null || B3 === void 0 ? void 0 : B3.candidate;
            if (F && D !== void 0) {
              b3.markInvalidUtilityNode(F), F.remove(), r2.default.warn("invalid-theme-key-in-class", [
                `The utility \`${D}\` contains an invalid theme value and was not generated.`
              ]);
              return;
            }
            throw M2.error(R3);
          }
          let z3 = (0, e2.parseColorFormat)(C);
          return ($2 !== void 0 || z3 !== void 0 && typeof z3 == "function") && ($2 === void 0 && ($2 = 1), C = (0, t8.withAlphaValue)(z3, $2, z3)), C;
        },
        screen: (M2, W3) => {
          W3 = W3.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
          let P3 = (0, f.normalizeScreens)(k3.theme.screens).find(({ name: C }) => C === W3);
          if (!P3)
            throw M2.error(`The '${W3}' screen does not exist in your theme.`);
          return (0, s2.default)(P3);
        }
      };
      return (M2) => {
        M2.walk((W3) => {
          let S3 = g2[W3.type];
          S3 !== void 0 && (W3[S3] = x(W3, W3[S3], q2));
        });
      };
    }
  })(sn2)), sn2;
}
var uf = lf();
var ff = /* @__PURE__ */ He3(uf);
var Rn3 = {};
var Nt3 = { exports: {} };
var Ft2 = { exports: {} };
var $t3 = { exports: {} };
var Ut3 = { exports: {} };
var zt3 = { exports: {} };
var Wt3 = { exports: {} };
var Qe3 = {};
var Vt3 = { exports: {} };
var $s;
function Bi2() {
  return $s || ($s = 1, (function(u, a) {
    a.__esModule = true, a.default = l2;
    function h2(f) {
      for (var s2 = f.toLowerCase(), c2 = "", t8 = false, e2 = 0; e2 < 6 && s2[e2] !== void 0; e2++) {
        var r2 = s2.charCodeAt(e2), i = r2 >= 97 && r2 <= 102 || r2 >= 48 && r2 <= 57;
        if (t8 = r2 === 32, !i)
          break;
        c2 += s2[e2];
      }
      if (c2.length !== 0) {
        var o2 = parseInt(c2, 16), v3 = o2 >= 55296 && o2 <= 57343;
        return v3 || o2 === 0 || o2 > 1114111 ? ["\uFFFD", c2.length + (t8 ? 1 : 0)] : [String.fromCodePoint(o2), c2.length + (t8 ? 1 : 0)];
      }
    }
    var p = /\\/;
    function l2(f) {
      var s2 = p.test(f);
      if (!s2)
        return f;
      for (var c2 = "", t8 = 0; t8 < f.length; t8++) {
        if (f[t8] === "\\") {
          var e2 = h2(f.slice(t8 + 1, t8 + 7));
          if (e2 !== void 0) {
            c2 += e2[0], t8 += e2[1];
            continue;
          }
          if (f[t8 + 1] === "\\") {
            c2 += "\\", t8++;
            continue;
          }
          f.length === t8 + 1 && (c2 += f[t8]);
          continue;
        }
        c2 += f[t8];
      }
      return c2;
    }
    u.exports = a.default;
  })(Vt3, Vt3.exports)), Vt3.exports;
}
var jt3 = { exports: {} };
var Us2;
function cf() {
  return Us2 || (Us2 = 1, (function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      for (var l2 = arguments.length, f = new Array(l2 > 1 ? l2 - 1 : 0), s2 = 1; s2 < l2; s2++)
        f[s2 - 1] = arguments[s2];
      for (; f.length > 0; ) {
        var c2 = f.shift();
        if (!p[c2])
          return;
        p = p[c2];
      }
      return p;
    }
    u.exports = a.default;
  })(jt3, jt3.exports)), jt3.exports;
}
var Bt3 = { exports: {} };
var zs2;
function df() {
  return zs2 || (zs2 = 1, (function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      for (var l2 = arguments.length, f = new Array(l2 > 1 ? l2 - 1 : 0), s2 = 1; s2 < l2; s2++)
        f[s2 - 1] = arguments[s2];
      for (; f.length > 0; ) {
        var c2 = f.shift();
        p[c2] || (p[c2] = {}), p = p[c2];
      }
    }
    u.exports = a.default;
  })(Bt3, Bt3.exports)), Bt3.exports;
}
var Gt3 = { exports: {} };
var Ws2;
function pf() {
  return Ws2 || (Ws2 = 1, (function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      for (var l2 = "", f = p.indexOf("/*"), s2 = 0; f >= 0; ) {
        l2 = l2 + p.slice(s2, f);
        var c2 = p.indexOf("*/", f + 2);
        if (c2 < 0)
          return l2;
        s2 = c2 + 2, f = p.indexOf("/*", s2);
      }
      return l2 = l2 + p.slice(s2), l2;
    }
    u.exports = a.default;
  })(Gt3, Gt3.exports)), Gt3.exports;
}
var Vs2;
function mr3() {
  if (Vs2) return Qe3;
  Vs2 = 1, Qe3.__esModule = true, Qe3.unesc = Qe3.stripComments = Qe3.getProp = Qe3.ensureObject = void 0;
  var u = l2(Bi2());
  Qe3.unesc = u.default;
  var a = l2(cf());
  Qe3.getProp = a.default;
  var h2 = l2(df());
  Qe3.ensureObject = h2.default;
  var p = l2(pf());
  Qe3.stripComments = p.default;
  function l2(f) {
    return f && f.__esModule ? f : { default: f };
  }
  return Qe3;
}
var js2;
function rt3() {
  return js2 || (js2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = mr3();
    function p(c2, t8) {
      for (var e2 = 0; e2 < t8.length; e2++) {
        var r2 = t8[e2];
        r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(c2, r2.key, r2);
      }
    }
    function l2(c2, t8, e2) {
      return t8 && p(c2.prototype, t8), Object.defineProperty(c2, "prototype", { writable: false }), c2;
    }
    var f = function c2(t8, e2) {
      if (typeof t8 != "object" || t8 === null)
        return t8;
      var r2 = new t8.constructor();
      for (var i in t8)
        if (t8.hasOwnProperty(i)) {
          var o2 = t8[i], v3 = typeof o2;
          i === "parent" && v3 === "object" ? e2 && (r2[i] = e2) : o2 instanceof Array ? r2[i] = o2.map(function(m) {
            return c2(m, r2);
          }) : r2[i] = c2(o2, r2);
        }
      return r2;
    }, s2 = /* @__PURE__ */ (function() {
      function c2(e2) {
        e2 === void 0 && (e2 = {}), Object.assign(this, e2), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
      }
      var t8 = c2.prototype;
      return t8.remove = function() {
        return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
      }, t8.replaceWith = function() {
        if (this.parent) {
          for (var r2 in arguments)
            this.parent.insertBefore(this, arguments[r2]);
          this.remove();
        }
        return this;
      }, t8.next = function() {
        return this.parent.at(this.parent.index(this) + 1);
      }, t8.prev = function() {
        return this.parent.at(this.parent.index(this) - 1);
      }, t8.clone = function(r2) {
        r2 === void 0 && (r2 = {});
        var i = f(this);
        for (var o2 in r2)
          i[o2] = r2[o2];
        return i;
      }, t8.appendToPropertyAndEscape = function(r2, i, o2) {
        this.raws || (this.raws = {});
        var v3 = this[r2], m = this.raws[r2];
        this[r2] = v3 + i, m || o2 !== i ? this.raws[r2] = (m || v3) + o2 : delete this.raws[r2];
      }, t8.setPropertyAndEscape = function(r2, i, o2) {
        this.raws || (this.raws = {}), this[r2] = i, this.raws[r2] = o2;
      }, t8.setPropertyWithoutEscape = function(r2, i) {
        this[r2] = i, this.raws && delete this.raws[r2];
      }, t8.isAtPosition = function(r2, i) {
        if (this.source && this.source.start && this.source.end)
          return !(this.source.start.line > r2 || this.source.end.line < r2 || this.source.start.line === r2 && this.source.start.column > i || this.source.end.line === r2 && this.source.end.column < i);
      }, t8.stringifyProperty = function(r2) {
        return this.raws && this.raws[r2] || this[r2];
      }, t8.valueToString = function() {
        return String(this.stringifyProperty("value"));
      }, t8.toString = function() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      }, l2(c2, [{
        key: "rawSpaceBefore",
        get: function() {
          var r2 = this.raws && this.raws.spaces && this.raws.spaces.before;
          return r2 === void 0 && (r2 = this.spaces && this.spaces.before), r2 || "";
        },
        set: function(r2) {
          (0, h2.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = r2;
        }
      }, {
        key: "rawSpaceAfter",
        get: function() {
          var r2 = this.raws && this.raws.spaces && this.raws.spaces.after;
          return r2 === void 0 && (r2 = this.spaces.after), r2 || "";
        },
        set: function(r2) {
          (0, h2.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = r2;
        }
      }]), c2;
    })();
    a.default = s2, u.exports = a.default;
  })(Wt3, Wt3.exports)), Wt3.exports;
}
var Me3 = {};
var Bs2;
function $e2() {
  if (Bs2) return Me3;
  Bs2 = 1, Me3.__esModule = true, Me3.UNIVERSAL = Me3.TAG = Me3.STRING = Me3.SELECTOR = Me3.ROOT = Me3.PSEUDO = Me3.NESTING = Me3.ID = Me3.COMMENT = Me3.COMBINATOR = Me3.CLASS = Me3.ATTRIBUTE = void 0;
  var u = "tag";
  Me3.TAG = u;
  var a = "string";
  Me3.STRING = a;
  var h2 = "selector";
  Me3.SELECTOR = h2;
  var p = "root";
  Me3.ROOT = p;
  var l2 = "pseudo";
  Me3.PSEUDO = l2;
  var f = "nesting";
  Me3.NESTING = f;
  var s2 = "id";
  Me3.ID = s2;
  var c2 = "comment";
  Me3.COMMENT = c2;
  var t8 = "combinator";
  Me3.COMBINATOR = t8;
  var e2 = "class";
  Me3.CLASS = e2;
  var r2 = "attribute";
  Me3.ATTRIBUTE = r2;
  var i = "universal";
  return Me3.UNIVERSAL = i, Me3;
}
var Gs2;
function Gi2() {
  return Gs2 || (Gs2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = s2(rt3()), p = f($e2());
    function l2(n2) {
      if (typeof WeakMap != "function") return null;
      var d2 = /* @__PURE__ */ new WeakMap(), _3 = /* @__PURE__ */ new WeakMap();
      return (l2 = function(y2) {
        return y2 ? _3 : d2;
      })(n2);
    }
    function f(n2, d2) {
      if (n2 && n2.__esModule)
        return n2;
      if (n2 === null || typeof n2 != "object" && typeof n2 != "function")
        return { default: n2 };
      var _3 = l2(d2);
      if (_3 && _3.has(n2))
        return _3.get(n2);
      var w3 = {}, y2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var x in n2)
        if (x !== "default" && Object.prototype.hasOwnProperty.call(n2, x)) {
          var g2 = y2 ? Object.getOwnPropertyDescriptor(n2, x) : null;
          g2 && (g2.get || g2.set) ? Object.defineProperty(w3, x, g2) : w3[x] = n2[x];
        }
      return w3.default = n2, _3 && _3.set(n2, w3), w3;
    }
    function s2(n2) {
      return n2 && n2.__esModule ? n2 : { default: n2 };
    }
    function c2(n2, d2) {
      var _3 = typeof Symbol < "u" && n2[Symbol.iterator] || n2["@@iterator"];
      if (_3) return (_3 = _3.call(n2)).next.bind(_3);
      if (Array.isArray(n2) || (_3 = t8(n2)) || d2) {
        _3 && (n2 = _3);
        var w3 = 0;
        return function() {
          return w3 >= n2.length ? { done: true } : { done: false, value: n2[w3++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function t8(n2, d2) {
      if (n2) {
        if (typeof n2 == "string") return e2(n2, d2);
        var _3 = Object.prototype.toString.call(n2).slice(8, -1);
        if (_3 === "Object" && n2.constructor && (_3 = n2.constructor.name), _3 === "Map" || _3 === "Set") return Array.from(n2);
        if (_3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_3)) return e2(n2, d2);
      }
    }
    function e2(n2, d2) {
      (d2 == null || d2 > n2.length) && (d2 = n2.length);
      for (var _3 = 0, w3 = new Array(d2); _3 < d2; _3++)
        w3[_3] = n2[_3];
      return w3;
    }
    function r2(n2, d2) {
      for (var _3 = 0; _3 < d2.length; _3++) {
        var w3 = d2[_3];
        w3.enumerable = w3.enumerable || false, w3.configurable = true, "value" in w3 && (w3.writable = true), Object.defineProperty(n2, w3.key, w3);
      }
    }
    function i(n2, d2, _3) {
      return d2 && r2(n2.prototype, d2), Object.defineProperty(n2, "prototype", { writable: false }), n2;
    }
    function o2(n2, d2) {
      n2.prototype = Object.create(d2.prototype), n2.prototype.constructor = n2, v3(n2, d2);
    }
    function v3(n2, d2) {
      return v3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(w3, y2) {
        return w3.__proto__ = y2, w3;
      }, v3(n2, d2);
    }
    var m = /* @__PURE__ */ (function(n2) {
      o2(d2, n2);
      function d2(w3) {
        var y2;
        return y2 = n2.call(this, w3) || this, y2.nodes || (y2.nodes = []), y2;
      }
      var _3 = d2.prototype;
      return _3.append = function(y2) {
        return y2.parent = this, this.nodes.push(y2), this;
      }, _3.prepend = function(y2) {
        return y2.parent = this, this.nodes.unshift(y2), this;
      }, _3.at = function(y2) {
        return this.nodes[y2];
      }, _3.index = function(y2) {
        return typeof y2 == "number" ? y2 : this.nodes.indexOf(y2);
      }, _3.removeChild = function(y2) {
        y2 = this.index(y2), this.at(y2).parent = void 0, this.nodes.splice(y2, 1);
        var x;
        for (var g2 in this.indexes)
          x = this.indexes[g2], x >= y2 && (this.indexes[g2] = x - 1);
        return this;
      }, _3.removeAll = function() {
        for (var y2 = c2(this.nodes), x; !(x = y2()).done; ) {
          var g2 = x.value;
          g2.parent = void 0;
        }
        return this.nodes = [], this;
      }, _3.empty = function() {
        return this.removeAll();
      }, _3.insertAfter = function(y2, x) {
        x.parent = this;
        var g2 = this.index(y2);
        this.nodes.splice(g2 + 1, 0, x), x.parent = this;
        var O3;
        for (var A in this.indexes)
          O3 = this.indexes[A], g2 <= O3 && (this.indexes[A] = O3 + 1);
        return this;
      }, _3.insertBefore = function(y2, x) {
        x.parent = this;
        var g2 = this.index(y2);
        this.nodes.splice(g2, 0, x), x.parent = this;
        var O3;
        for (var A in this.indexes)
          O3 = this.indexes[A], O3 <= g2 && (this.indexes[A] = O3 + 1);
        return this;
      }, _3._findChildAtPosition = function(y2, x) {
        var g2 = void 0;
        return this.each(function(O3) {
          if (O3.atPosition) {
            var A = O3.atPosition(y2, x);
            if (A)
              return g2 = A, false;
          } else if (O3.isAtPosition(y2, x))
            return g2 = O3, false;
        }), g2;
      }, _3.atPosition = function(y2, x) {
        if (this.isAtPosition(y2, x))
          return this._findChildAtPosition(y2, x) || this;
      }, _3._inferEndPosition = function() {
        this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
      }, _3.each = function(y2) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var x = this.lastEach;
        if (this.indexes[x] = 0, !!this.length) {
          for (var g2, O3; this.indexes[x] < this.length && (g2 = this.indexes[x], O3 = y2(this.at(g2), g2), O3 !== false); )
            this.indexes[x] += 1;
          if (delete this.indexes[x], O3 === false)
            return false;
        }
      }, _3.walk = function(y2) {
        return this.each(function(x, g2) {
          var O3 = y2(x, g2);
          if (O3 !== false && x.length && (O3 = x.walk(y2)), O3 === false)
            return false;
        });
      }, _3.walkAttributes = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.ATTRIBUTE)
            return y2.call(x, g2);
        });
      }, _3.walkClasses = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.CLASS)
            return y2.call(x, g2);
        });
      }, _3.walkCombinators = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.COMBINATOR)
            return y2.call(x, g2);
        });
      }, _3.walkComments = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.COMMENT)
            return y2.call(x, g2);
        });
      }, _3.walkIds = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.ID)
            return y2.call(x, g2);
        });
      }, _3.walkNesting = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.NESTING)
            return y2.call(x, g2);
        });
      }, _3.walkPseudos = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.PSEUDO)
            return y2.call(x, g2);
        });
      }, _3.walkTags = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.TAG)
            return y2.call(x, g2);
        });
      }, _3.walkUniversals = function(y2) {
        var x = this;
        return this.walk(function(g2) {
          if (g2.type === p.UNIVERSAL)
            return y2.call(x, g2);
        });
      }, _3.split = function(y2) {
        var x = this, g2 = [];
        return this.reduce(function(O3, A, E2) {
          var b3 = y2.call(x, A);
          return g2.push(A), b3 ? (O3.push(g2), g2 = []) : E2 === x.length - 1 && O3.push(g2), O3;
        }, []);
      }, _3.map = function(y2) {
        return this.nodes.map(y2);
      }, _3.reduce = function(y2, x) {
        return this.nodes.reduce(y2, x);
      }, _3.every = function(y2) {
        return this.nodes.every(y2);
      }, _3.some = function(y2) {
        return this.nodes.some(y2);
      }, _3.filter = function(y2) {
        return this.nodes.filter(y2);
      }, _3.sort = function(y2) {
        return this.nodes.sort(y2);
      }, _3.toString = function() {
        return this.map(String).join("");
      }, i(d2, [{
        key: "first",
        get: function() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function() {
          return this.nodes.length;
        }
      }]), d2;
    })(h2.default);
    a.default = m, u.exports = a.default;
  })(zt3, zt3.exports)), zt3.exports;
}
var Ys2;
function Ul() {
  return Ys2 || (Ys2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(Gi2()), p = $e2();
    function l2(r2) {
      return r2 && r2.__esModule ? r2 : { default: r2 };
    }
    function f(r2, i) {
      for (var o2 = 0; o2 < i.length; o2++) {
        var v3 = i[o2];
        v3.enumerable = v3.enumerable || false, v3.configurable = true, "value" in v3 && (v3.writable = true), Object.defineProperty(r2, v3.key, v3);
      }
    }
    function s2(r2, i, o2) {
      return i && f(r2.prototype, i), Object.defineProperty(r2, "prototype", { writable: false }), r2;
    }
    function c2(r2, i) {
      r2.prototype = Object.create(i.prototype), r2.prototype.constructor = r2, t8(r2, i);
    }
    function t8(r2, i) {
      return t8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v3, m) {
        return v3.__proto__ = m, v3;
      }, t8(r2, i);
    }
    var e2 = /* @__PURE__ */ (function(r2) {
      c2(i, r2);
      function i(v3) {
        var m;
        return m = r2.call(this, v3) || this, m.type = p.ROOT, m;
      }
      var o2 = i.prototype;
      return o2.toString = function() {
        var m = this.reduce(function(n2, d2) {
          return n2.push(String(d2)), n2;
        }, []).join(",");
        return this.trailingComma ? m + "," : m;
      }, o2.error = function(m, n2) {
        return this._error ? this._error(m, n2) : new Error(m);
      }, s2(i, [{
        key: "errorGenerator",
        set: function(m) {
          this._error = m;
        }
      }]), i;
    })(h2.default);
    a.default = e2, u.exports = a.default;
  })(Ut3, Ut3.exports)), Ut3.exports;
}
var Yt3 = { exports: {} };
var Qs;
function zl() {
  return Qs || (Qs = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(Gi2()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.SELECTOR, i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(Yt3, Yt3.exports)), Yt3.exports;
}
var Qt3 = { exports: {} };
var Hs2;
function Wl() {
  return Hs2 || (Hs2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = s2(at3()), p = mr3(), l2 = s2(rt3()), f = $e2();
    function s2(o2) {
      return o2 && o2.__esModule ? o2 : { default: o2 };
    }
    function c2(o2, v3) {
      for (var m = 0; m < v3.length; m++) {
        var n2 = v3[m];
        n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(o2, n2.key, n2);
      }
    }
    function t8(o2, v3, m) {
      return v3 && c2(o2.prototype, v3), Object.defineProperty(o2, "prototype", { writable: false }), o2;
    }
    function e2(o2, v3) {
      o2.prototype = Object.create(v3.prototype), o2.prototype.constructor = o2, r2(o2, v3);
    }
    function r2(o2, v3) {
      return r2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, d2) {
        return n2.__proto__ = d2, n2;
      }, r2(o2, v3);
    }
    var i = /* @__PURE__ */ (function(o2) {
      e2(v3, o2);
      function v3(n2) {
        var d2;
        return d2 = o2.call(this, n2) || this, d2.type = f.CLASS, d2._constructed = true, d2;
      }
      var m = v3.prototype;
      return m.valueToString = function() {
        return "." + o2.prototype.valueToString.call(this);
      }, t8(v3, [{
        key: "value",
        get: function() {
          return this._value;
        },
        set: function(d2) {
          if (this._constructed) {
            var _3 = (0, h2.default)(d2, {
              isIdentifier: true
            });
            _3 !== d2 ? ((0, p.ensureObject)(this, "raws"), this.raws.value = _3) : this.raws && delete this.raws.value;
          }
          this._value = d2;
        }
      }]), v3;
    })(l2.default);
    a.default = i, u.exports = a.default;
  })(Qt3, Qt3.exports)), Qt3.exports;
}
var Ht3 = { exports: {} };
var Js;
function Vl() {
  return Js || (Js = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(rt3()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.COMMENT, i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(Ht3, Ht3.exports)), Ht3.exports;
}
var Jt2 = { exports: {} };
var Ks2;
function jl() {
  return Ks2 || (Ks2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(rt3()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(i) {
        var o2;
        return o2 = t8.call(this, i) || this, o2.type = p.ID, o2;
      }
      var r2 = e2.prototype;
      return r2.valueToString = function() {
        return "#" + t8.prototype.valueToString.call(this);
      }, e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(Jt2, Jt2.exports)), Jt2.exports;
}
var Kt3 = { exports: {} };
var Xt3 = { exports: {} };
var Xs2;
function Yi2() {
  return Xs2 || (Xs2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = f(at3()), p = mr3(), l2 = f(rt3());
    function f(i) {
      return i && i.__esModule ? i : { default: i };
    }
    function s2(i, o2) {
      for (var v3 = 0; v3 < o2.length; v3++) {
        var m = o2[v3];
        m.enumerable = m.enumerable || false, m.configurable = true, "value" in m && (m.writable = true), Object.defineProperty(i, m.key, m);
      }
    }
    function c2(i, o2, v3) {
      return o2 && s2(i.prototype, o2), Object.defineProperty(i, "prototype", { writable: false }), i;
    }
    function t8(i, o2) {
      i.prototype = Object.create(o2.prototype), i.prototype.constructor = i, e2(i, o2);
    }
    function e2(i, o2) {
      return e2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, n2) {
        return m.__proto__ = n2, m;
      }, e2(i, o2);
    }
    var r2 = /* @__PURE__ */ (function(i) {
      t8(o2, i);
      function o2() {
        return i.apply(this, arguments) || this;
      }
      var v3 = o2.prototype;
      return v3.qualifiedName = function(n2) {
        return this.namespace ? this.namespaceString + "|" + n2 : n2;
      }, v3.valueToString = function() {
        return this.qualifiedName(i.prototype.valueToString.call(this));
      }, c2(o2, [{
        key: "namespace",
        get: function() {
          return this._namespace;
        },
        set: function(n2) {
          if (n2 === true || n2 === "*" || n2 === "&") {
            this._namespace = n2, this.raws && delete this.raws.namespace;
            return;
          }
          var d2 = (0, h2.default)(n2, {
            isIdentifier: true
          });
          this._namespace = n2, d2 !== n2 ? ((0, p.ensureObject)(this, "raws"), this.raws.namespace = d2) : this.raws && delete this.raws.namespace;
        }
      }, {
        key: "ns",
        get: function() {
          return this._namespace;
        },
        set: function(n2) {
          this.namespace = n2;
        }
      }, {
        key: "namespaceString",
        get: function() {
          if (this.namespace) {
            var n2 = this.stringifyProperty("namespace");
            return n2 === true ? "" : n2;
          } else
            return "";
        }
      }]), o2;
    })(l2.default);
    a.default = r2, u.exports = a.default;
  })(Xt3, Xt3.exports)), Xt3.exports;
}
var Zs;
function Bl() {
  return Zs || (Zs = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(Yi2()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.TAG, i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(Kt3, Kt3.exports)), Kt3.exports;
}
var Zt2 = { exports: {} };
var eo3;
function Gl() {
  return eo3 || (eo3 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(rt3()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.STRING, i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(Zt2, Zt2.exports)), Zt2.exports;
}
var er2 = { exports: {} };
var to3;
function Yl() {
  return to3 || (to3 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(Gi2()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(i) {
        var o2;
        return o2 = t8.call(this, i) || this, o2.type = p.PSEUDO, o2;
      }
      var r2 = e2.prototype;
      return r2.toString = function() {
        var o2 = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), o2, this.rawSpaceAfter].join("");
      }, e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(er2, er2.exports)), er2.exports;
}
var In3 = {};
var ro3;
function Ql() {
  return ro3 || (ro3 = 1, (function(u) {
    u.__esModule = true, u.default = void 0, u.unescapeValue = d2;
    var a = s2(at3()), h2 = s2(Bi2()), p = s2(Yi2()), l2 = $e2(), f;
    function s2(g2) {
      return g2 && g2.__esModule ? g2 : { default: g2 };
    }
    function c2(g2, O3) {
      for (var A = 0; A < O3.length; A++) {
        var E2 = O3[A];
        E2.enumerable = E2.enumerable || false, E2.configurable = true, "value" in E2 && (E2.writable = true), Object.defineProperty(g2, E2.key, E2);
      }
    }
    function t8(g2, O3, A) {
      return O3 && c2(g2.prototype, O3), Object.defineProperty(g2, "prototype", { writable: false }), g2;
    }
    function e2(g2, O3) {
      g2.prototype = Object.create(O3.prototype), g2.prototype.constructor = g2, r2(g2, O3);
    }
    function r2(g2, O3) {
      return r2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(E2, b3) {
        return E2.__proto__ = b3, E2;
      }, r2(g2, O3);
    }
    var i = Rl(), o2 = /^('|")([^]*)\1$/, v3 = i(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), m = i(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), n2 = i(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function d2(g2) {
      var O3 = false, A = null, E2 = g2, b3 = E2.match(o2);
      return b3 && (A = b3[1], E2 = b3[2]), E2 = (0, h2.default)(E2), E2 !== g2 && (O3 = true), {
        deprecatedUsage: O3,
        unescaped: E2,
        quoteMark: A
      };
    }
    function _3(g2) {
      if (g2.quoteMark !== void 0 || g2.value === void 0)
        return g2;
      n2();
      var O3 = d2(g2.value), A = O3.quoteMark, E2 = O3.unescaped;
      return g2.raws || (g2.raws = {}), g2.raws.value === void 0 && (g2.raws.value = g2.value), g2.value = E2, g2.quoteMark = A, g2;
    }
    var w3 = /* @__PURE__ */ (function(g2) {
      e2(O3, g2);
      function O3(E2) {
        var b3;
        return E2 === void 0 && (E2 = {}), b3 = g2.call(this, _3(E2)) || this, b3.type = l2.ATTRIBUTE, b3.raws = b3.raws || {}, Object.defineProperty(b3.raws, "unquoted", {
          get: i(function() {
            return b3.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: i(function() {
            return b3.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        }), b3._constructed = true, b3;
      }
      var A = O3.prototype;
      return A.getQuotedValue = function(b3) {
        b3 === void 0 && (b3 = {});
        var k3 = this._determineQuoteMark(b3), q2 = y2[k3], M2 = (0, a.default)(this._value, q2);
        return M2;
      }, A._determineQuoteMark = function(b3) {
        return b3.smart ? this.smartQuoteMark(b3) : this.preferredQuoteMark(b3);
      }, A.setValue = function(b3, k3) {
        k3 === void 0 && (k3 = {}), this._value = b3, this._quoteMark = this._determineQuoteMark(k3), this._syncRawValue();
      }, A.smartQuoteMark = function(b3) {
        var k3 = this.value, q2 = k3.replace(/[^']/g, "").length, M2 = k3.replace(/[^"]/g, "").length;
        if (q2 + M2 === 0) {
          var W3 = (0, a.default)(k3, {
            isIdentifier: true
          });
          if (W3 === k3)
            return O3.NO_QUOTE;
          var S3 = this.preferredQuoteMark(b3);
          if (S3 === O3.NO_QUOTE) {
            var P3 = this.quoteMark || b3.quoteMark || O3.DOUBLE_QUOTE, C = y2[P3], R3 = (0, a.default)(k3, C);
            if (R3.length < W3.length)
              return P3;
          }
          return S3;
        } else return M2 === q2 ? this.preferredQuoteMark(b3) : M2 < q2 ? O3.DOUBLE_QUOTE : O3.SINGLE_QUOTE;
      }, A.preferredQuoteMark = function(b3) {
        var k3 = b3.preferCurrentQuoteMark ? this.quoteMark : b3.quoteMark;
        return k3 === void 0 && (k3 = b3.preferCurrentQuoteMark ? b3.quoteMark : this.quoteMark), k3 === void 0 && (k3 = O3.DOUBLE_QUOTE), k3;
      }, A._syncRawValue = function() {
        var b3 = (0, a.default)(this._value, y2[this.quoteMark]);
        b3 === this._value ? this.raws && delete this.raws.value : this.raws.value = b3;
      }, A._handleEscapes = function(b3, k3) {
        if (this._constructed) {
          var q2 = (0, a.default)(k3, {
            isIdentifier: true
          });
          q2 !== k3 ? this.raws[b3] = q2 : delete this.raws[b3];
        }
      }, A._spacesFor = function(b3) {
        var k3 = {
          before: "",
          after: ""
        }, q2 = this.spaces[b3] || {}, M2 = this.raws.spaces && this.raws.spaces[b3] || {};
        return Object.assign(k3, q2, M2);
      }, A._stringFor = function(b3, k3, q2) {
        k3 === void 0 && (k3 = b3), q2 === void 0 && (q2 = x);
        var M2 = this._spacesFor(k3);
        return q2(this.stringifyProperty(b3), M2);
      }, A.offsetOf = function(b3) {
        var k3 = 1, q2 = this._spacesFor("attribute");
        if (k3 += q2.before.length, b3 === "namespace" || b3 === "ns")
          return this.namespace ? k3 : -1;
        if (b3 === "attributeNS" || (k3 += this.namespaceString.length, this.namespace && (k3 += 1), b3 === "attribute"))
          return k3;
        k3 += this.stringifyProperty("attribute").length, k3 += q2.after.length;
        var M2 = this._spacesFor("operator");
        k3 += M2.before.length;
        var W3 = this.stringifyProperty("operator");
        if (b3 === "operator")
          return W3 ? k3 : -1;
        k3 += W3.length, k3 += M2.after.length;
        var S3 = this._spacesFor("value");
        k3 += S3.before.length;
        var P3 = this.stringifyProperty("value");
        if (b3 === "value")
          return P3 ? k3 : -1;
        k3 += P3.length, k3 += S3.after.length;
        var C = this._spacesFor("insensitive");
        return k3 += C.before.length, b3 === "insensitive" && this.insensitive ? k3 : -1;
      }, A.toString = function() {
        var b3 = this, k3 = [this.rawSpaceBefore, "["];
        return k3.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (k3.push(this._stringFor("operator")), k3.push(this._stringFor("value")), k3.push(this._stringFor("insensitiveFlag", "insensitive", function(q2, M2) {
          return q2.length > 0 && !b3.quoted && M2.before.length === 0 && !(b3.spaces.value && b3.spaces.value.after) && (M2.before = " "), x(q2, M2);
        }))), k3.push("]"), k3.push(this.rawSpaceAfter), k3.join("");
      }, t8(O3, [{
        key: "quoted",
        get: function() {
          var b3 = this.quoteMark;
          return b3 === "'" || b3 === '"';
        },
        set: function(b3) {
          m();
        }
        /**
         * returns a single (`'`) or double (`"`) quote character if the value is quoted.
         * returns `null` if the value is not quoted.
         * returns `undefined` if the quotation state is unknown (this can happen when
         * the attribute is constructed without specifying a quote mark.)
         */
      }, {
        key: "quoteMark",
        get: function() {
          return this._quoteMark;
        },
        set: function(b3) {
          if (!this._constructed) {
            this._quoteMark = b3;
            return;
          }
          this._quoteMark !== b3 && (this._quoteMark = b3, this._syncRawValue());
        }
      }, {
        key: "qualifiedAttribute",
        get: function() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function() {
          return this._value;
        },
        set: (
          /**
           * Before 3.0, the value had to be set to an escaped value including any wrapped
           * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
           * is unescaped during parsing and any quote marks are removed.
           *
           * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
           * a deprecation warning is raised when the new value contains any characters that would
           * require escaping (including if it contains wrapped quotes).
           *
           * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
           * how the new value is quoted.
           */
          (function(b3) {
            if (this._constructed) {
              var k3 = d2(b3), q2 = k3.deprecatedUsage, M2 = k3.unescaped, W3 = k3.quoteMark;
              if (q2 && v3(), M2 === this._value && W3 === this._quoteMark)
                return;
              this._value = M2, this._quoteMark = W3, this._syncRawValue();
            } else
              this._value = b3;
          })
        )
      }, {
        key: "insensitive",
        get: function() {
          return this._insensitive;
        },
        set: function(b3) {
          b3 || (this._insensitive = false, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = b3;
        }
      }, {
        key: "attribute",
        get: function() {
          return this._attribute;
        },
        set: function(b3) {
          this._handleEscapes("attribute", b3), this._attribute = b3;
        }
      }]), O3;
    })(p.default);
    u.default = w3, w3.NO_QUOTE = null, w3.SINGLE_QUOTE = "'", w3.DOUBLE_QUOTE = '"';
    var y2 = (f = {
      "'": {
        quotes: "single",
        wrap: true
      },
      '"': {
        quotes: "double",
        wrap: true
      }
    }, f[null] = {
      isIdentifier: true
    }, f);
    function x(g2, O3) {
      return "" + O3.before + g2 + O3.after;
    }
  })(In3)), In3;
}
var tr2 = { exports: {} };
var no3;
function Hl() {
  return no3 || (no3 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(Yi2()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.UNIVERSAL, i.value = "*", i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(tr2, tr2.exports)), tr2.exports;
}
var rr3 = { exports: {} };
var io3;
function Jl() {
  return io3 || (io3 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(rt3()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.COMBINATOR, i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(rr3, rr3.exports)), rr3.exports;
}
var nr3 = { exports: {} };
var ao3;
function Kl() {
  return ao3 || (ao3 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = l2(rt3()), p = $e2();
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : { default: t8 };
    }
    function f(t8, e2) {
      t8.prototype = Object.create(e2.prototype), t8.prototype.constructor = t8, s2(t8, e2);
    }
    function s2(t8, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, o2) {
        return i.__proto__ = o2, i;
      }, s2(t8, e2);
    }
    var c2 = /* @__PURE__ */ (function(t8) {
      f(e2, t8);
      function e2(r2) {
        var i;
        return i = t8.call(this, r2) || this, i.type = p.NESTING, i.value = "&", i;
      }
      return e2;
    })(h2.default);
    a.default = c2, u.exports = a.default;
  })(nr3, nr3.exports)), nr3.exports;
}
var ir3 = { exports: {} };
var so3;
function hf() {
  return so3 || (so3 = 1, (function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      return p.sort(function(l2, f) {
        return l2 - f;
      });
    }
    u.exports = a.default;
  })(ir3, ir3.exports)), ir3.exports;
}
var Mn3 = {};
var le3 = {};
var oo3;
function Xl() {
  if (oo3) return le3;
  oo3 = 1, le3.__esModule = true, le3.word = le3.tilde = le3.tab = le3.str = le3.space = le3.slash = le3.singleQuote = le3.semicolon = le3.plus = le3.pipe = le3.openSquare = le3.openParenthesis = le3.newline = le3.greaterThan = le3.feed = le3.equals = le3.doubleQuote = le3.dollar = le3.cr = le3.comment = le3.comma = le3.combinator = le3.colon = le3.closeSquare = le3.closeParenthesis = le3.caret = le3.bang = le3.backslash = le3.at = le3.asterisk = le3.ampersand = void 0;
  var u = 38;
  le3.ampersand = u;
  var a = 42;
  le3.asterisk = a;
  var h2 = 64;
  le3.at = h2;
  var p = 44;
  le3.comma = p;
  var l2 = 58;
  le3.colon = l2;
  var f = 59;
  le3.semicolon = f;
  var s2 = 40;
  le3.openParenthesis = s2;
  var c2 = 41;
  le3.closeParenthesis = c2;
  var t8 = 91;
  le3.openSquare = t8;
  var e2 = 93;
  le3.closeSquare = e2;
  var r2 = 36;
  le3.dollar = r2;
  var i = 126;
  le3.tilde = i;
  var o2 = 94;
  le3.caret = o2;
  var v3 = 43;
  le3.plus = v3;
  var m = 61;
  le3.equals = m;
  var n2 = 124;
  le3.pipe = n2;
  var d2 = 62;
  le3.greaterThan = d2;
  var _3 = 32;
  le3.space = _3;
  var w3 = 39;
  le3.singleQuote = w3;
  var y2 = 34;
  le3.doubleQuote = y2;
  var x = 47;
  le3.slash = x;
  var g2 = 33;
  le3.bang = g2;
  var O3 = 92;
  le3.backslash = O3;
  var A = 13;
  le3.cr = A;
  var E2 = 12;
  le3.feed = E2;
  var b3 = 10;
  le3.newline = b3;
  var k3 = 9;
  le3.tab = k3;
  var q2 = w3;
  le3.str = q2;
  var M2 = -1;
  le3.comment = M2;
  var W3 = -2;
  le3.word = W3;
  var S3 = -3;
  return le3.combinator = S3, le3;
}
var lo3;
function vf() {
  return lo3 || (lo3 = 1, (function(u) {
    u.__esModule = true, u.FIELDS = void 0, u.default = m;
    var a = f(Xl()), h2, p;
    function l2(n2) {
      if (typeof WeakMap != "function") return null;
      var d2 = /* @__PURE__ */ new WeakMap(), _3 = /* @__PURE__ */ new WeakMap();
      return (l2 = function(y2) {
        return y2 ? _3 : d2;
      })(n2);
    }
    function f(n2, d2) {
      if (n2 && n2.__esModule)
        return n2;
      if (n2 === null || typeof n2 != "object" && typeof n2 != "function")
        return { default: n2 };
      var _3 = l2(d2);
      if (_3 && _3.has(n2))
        return _3.get(n2);
      var w3 = {}, y2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var x in n2)
        if (x !== "default" && Object.prototype.hasOwnProperty.call(n2, x)) {
          var g2 = y2 ? Object.getOwnPropertyDescriptor(n2, x) : null;
          g2 && (g2.get || g2.set) ? Object.defineProperty(w3, x, g2) : w3[x] = n2[x];
        }
      return w3.default = n2, _3 && _3.set(n2, w3), w3;
    }
    for (var s2 = (h2 = {}, h2[a.tab] = true, h2[a.newline] = true, h2[a.cr] = true, h2[a.feed] = true, h2), c2 = (p = {}, p[a.space] = true, p[a.tab] = true, p[a.newline] = true, p[a.cr] = true, p[a.feed] = true, p[a.ampersand] = true, p[a.asterisk] = true, p[a.bang] = true, p[a.comma] = true, p[a.colon] = true, p[a.semicolon] = true, p[a.openParenthesis] = true, p[a.closeParenthesis] = true, p[a.openSquare] = true, p[a.closeSquare] = true, p[a.singleQuote] = true, p[a.doubleQuote] = true, p[a.plus] = true, p[a.pipe] = true, p[a.tilde] = true, p[a.greaterThan] = true, p[a.equals] = true, p[a.dollar] = true, p[a.caret] = true, p[a.slash] = true, p), t8 = {}, e2 = "0123456789abcdefABCDEF", r2 = 0; r2 < e2.length; r2++)
      t8[e2.charCodeAt(r2)] = true;
    function i(n2, d2) {
      var _3 = d2, w3;
      do {
        if (w3 = n2.charCodeAt(_3), c2[w3])
          return _3 - 1;
        w3 === a.backslash ? _3 = o2(n2, _3) + 1 : _3++;
      } while (_3 < n2.length);
      return _3 - 1;
    }
    function o2(n2, d2) {
      var _3 = d2, w3 = n2.charCodeAt(_3 + 1);
      if (!s2[w3]) if (t8[w3]) {
        var y2 = 0;
        do
          _3++, y2++, w3 = n2.charCodeAt(_3 + 1);
        while (t8[w3] && y2 < 6);
        y2 < 6 && w3 === a.space && _3++;
      } else
        _3++;
      return _3;
    }
    var v3 = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    u.FIELDS = v3;
    function m(n2) {
      var d2 = [], _3 = n2.css.valueOf(), w3 = _3, y2 = w3.length, x = -1, g2 = 1, O3 = 0, A = 0, E2, b3, k3, q2, M2, W3, S3, P3, C, R3, $2, B3, z3;
      function L3(F, D) {
        if (n2.safe)
          _3 += D, C = _3.length - 1;
        else
          throw n2.error("Unclosed " + F, g2, O3 - x, O3);
      }
      for (; O3 < y2; ) {
        switch (E2 = _3.charCodeAt(O3), E2 === a.newline && (x = O3, g2 += 1), E2) {
          case a.space:
          case a.tab:
          case a.newline:
          case a.cr:
          case a.feed:
            C = O3;
            do
              C += 1, E2 = _3.charCodeAt(C), E2 === a.newline && (x = C, g2 += 1);
            while (E2 === a.space || E2 === a.newline || E2 === a.tab || E2 === a.cr || E2 === a.feed);
            z3 = a.space, q2 = g2, k3 = C - x - 1, A = C;
            break;
          case a.plus:
          case a.greaterThan:
          case a.tilde:
          case a.pipe:
            C = O3;
            do
              C += 1, E2 = _3.charCodeAt(C);
            while (E2 === a.plus || E2 === a.greaterThan || E2 === a.tilde || E2 === a.pipe);
            z3 = a.combinator, q2 = g2, k3 = O3 - x, A = C;
            break;
          // Consume these characters as single tokens.
          case a.asterisk:
          case a.ampersand:
          case a.bang:
          case a.comma:
          case a.equals:
          case a.dollar:
          case a.caret:
          case a.openSquare:
          case a.closeSquare:
          case a.colon:
          case a.semicolon:
          case a.openParenthesis:
          case a.closeParenthesis:
            C = O3, z3 = E2, q2 = g2, k3 = O3 - x, A = C + 1;
            break;
          case a.singleQuote:
          case a.doubleQuote:
            B3 = E2 === a.singleQuote ? "'" : '"', C = O3;
            do
              for (M2 = false, C = _3.indexOf(B3, C + 1), C === -1 && L3("quote", B3), W3 = C; _3.charCodeAt(W3 - 1) === a.backslash; )
                W3 -= 1, M2 = !M2;
            while (M2);
            z3 = a.str, q2 = g2, k3 = O3 - x, A = C + 1;
            break;
          default:
            E2 === a.slash && _3.charCodeAt(O3 + 1) === a.asterisk ? (C = _3.indexOf("*/", O3 + 2) + 1, C === 0 && L3("comment", "*/"), b3 = _3.slice(O3, C + 1), P3 = b3.split(`
`), S3 = P3.length - 1, S3 > 0 ? (R3 = g2 + S3, $2 = C - P3[S3].length) : (R3 = g2, $2 = x), z3 = a.comment, g2 = R3, q2 = R3, k3 = C - $2) : E2 === a.slash ? (C = O3, z3 = E2, q2 = g2, k3 = O3 - x, A = C + 1) : (C = i(_3, O3), z3 = a.word, q2 = g2, k3 = C - x), A = C + 1;
            break;
        }
        d2.push([
          z3,
          // [0] Token type
          g2,
          // [1] Starting line
          O3 - x,
          // [2] Starting column
          q2,
          // [3] Ending line
          k3,
          // [4] Ending column
          O3,
          // [5] Start position / Source index
          A
          // [6] End position
        ]), $2 && (x = $2, $2 = null), O3 = A;
      }
      return d2;
    }
  })(Mn3)), Mn3;
}
var uo3;
function gf() {
  return uo3 || (uo3 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = A(Ul()), p = A(zl()), l2 = A(Wl()), f = A(Vl()), s2 = A(jl()), c2 = A(Bl()), t8 = A(Gl()), e2 = A(Yl()), r2 = O3(Ql()), i = A(Hl()), o2 = A(Jl()), v3 = A(Kl()), m = A(hf()), n2 = O3(vf()), d2 = O3(Xl()), _3 = O3($e2()), w3 = mr3(), y2, x;
    function g2(L3) {
      if (typeof WeakMap != "function") return null;
      var F = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap();
      return (g2 = function(N3) {
        return N3 ? D : F;
      })(L3);
    }
    function O3(L3, F) {
      if (L3 && L3.__esModule)
        return L3;
      if (L3 === null || typeof L3 != "object" && typeof L3 != "function")
        return { default: L3 };
      var D = g2(F);
      if (D && D.has(L3))
        return D.get(L3);
      var I3 = {}, N3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var J3 in L3)
        if (J3 !== "default" && Object.prototype.hasOwnProperty.call(L3, J3)) {
          var T3 = N3 ? Object.getOwnPropertyDescriptor(L3, J3) : null;
          T3 && (T3.get || T3.set) ? Object.defineProperty(I3, J3, T3) : I3[J3] = L3[J3];
        }
      return I3.default = L3, D && D.set(L3, I3), I3;
    }
    function A(L3) {
      return L3 && L3.__esModule ? L3 : { default: L3 };
    }
    function E2(L3, F) {
      for (var D = 0; D < F.length; D++) {
        var I3 = F[D];
        I3.enumerable = I3.enumerable || false, I3.configurable = true, "value" in I3 && (I3.writable = true), Object.defineProperty(L3, I3.key, I3);
      }
    }
    function b3(L3, F, D) {
      return F && E2(L3.prototype, F), Object.defineProperty(L3, "prototype", { writable: false }), L3;
    }
    var k3 = (y2 = {}, y2[d2.space] = true, y2[d2.cr] = true, y2[d2.feed] = true, y2[d2.newline] = true, y2[d2.tab] = true, y2), q2 = Object.assign({}, k3, (x = {}, x[d2.comment] = true, x));
    function M2(L3) {
      return {
        line: L3[n2.FIELDS.START_LINE],
        column: L3[n2.FIELDS.START_COL]
      };
    }
    function W3(L3) {
      return {
        line: L3[n2.FIELDS.END_LINE],
        column: L3[n2.FIELDS.END_COL]
      };
    }
    function S3(L3, F, D, I3) {
      return {
        start: {
          line: L3,
          column: F
        },
        end: {
          line: D,
          column: I3
        }
      };
    }
    function P3(L3) {
      return S3(L3[n2.FIELDS.START_LINE], L3[n2.FIELDS.START_COL], L3[n2.FIELDS.END_LINE], L3[n2.FIELDS.END_COL]);
    }
    function C(L3, F) {
      if (L3)
        return S3(L3[n2.FIELDS.START_LINE], L3[n2.FIELDS.START_COL], F[n2.FIELDS.END_LINE], F[n2.FIELDS.END_COL]);
    }
    function R3(L3, F) {
      var D = L3[F];
      if (typeof D == "string")
        return D.indexOf("\\") !== -1 && ((0, w3.ensureObject)(L3, "raws"), L3[F] = (0, w3.unesc)(D), L3.raws[F] === void 0 && (L3.raws[F] = D)), L3;
    }
    function $2(L3, F) {
      for (var D = -1, I3 = []; (D = L3.indexOf(F, D + 1)) !== -1; )
        I3.push(D);
      return I3;
    }
    function B3() {
      var L3 = Array.prototype.concat.apply([], arguments);
      return L3.filter(function(F, D) {
        return D === L3.indexOf(F);
      });
    }
    var z3 = /* @__PURE__ */ (function() {
      function L3(D, I3) {
        I3 === void 0 && (I3 = {}), this.rule = D, this.options = Object.assign({
          lossy: false,
          safe: false
        }, I3), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, n2.default)({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var N3 = C(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new h2.default({
          source: N3
        }), this.root.errorGenerator = this._errorGenerator();
        var J3 = new p.default({
          source: {
            start: {
              line: 1,
              column: 1
            }
          },
          sourceIndex: 0
        });
        this.root.append(J3), this.current = J3, this.loop();
      }
      var F = L3.prototype;
      return F._errorGenerator = function() {
        var I3 = this;
        return function(N3, J3) {
          return typeof I3.rule == "string" ? new Error(N3) : I3.rule.error(N3, J3);
        };
      }, F.attribute = function() {
        var I3 = [], N3 = this.currToken;
        for (this.position++; this.position < this.tokens.length && this.currToken[n2.FIELDS.TYPE] !== d2.closeSquare; )
          I3.push(this.currToken), this.position++;
        if (this.currToken[n2.FIELDS.TYPE] !== d2.closeSquare)
          return this.expected("closing square bracket", this.currToken[n2.FIELDS.START_POS]);
        var J3 = I3.length, T3 = {
          source: S3(N3[1], N3[2], this.currToken[3], this.currToken[4]),
          sourceIndex: N3[n2.FIELDS.START_POS]
        };
        if (J3 === 1 && !~[d2.word].indexOf(I3[0][n2.FIELDS.TYPE]))
          return this.expected("attribute", I3[0][n2.FIELDS.START_POS]);
        for (var U2 = 0, j3 = "", H3 = "", V4 = null, K3 = false; U2 < J3; ) {
          var X3 = I3[U2], Q3 = this.content(X3), ne3 = I3[U2 + 1];
          switch (X3[n2.FIELDS.TYPE]) {
            case d2.space:
              if (K3 = true, this.options.lossy)
                break;
              if (V4) {
                (0, w3.ensureObject)(T3, "spaces", V4);
                var de3 = T3.spaces[V4].after || "";
                T3.spaces[V4].after = de3 + Q3;
                var _e3 = (0, w3.getProp)(T3, "raws", "spaces", V4, "after") || null;
                _e3 && (T3.raws.spaces[V4].after = _e3 + Q3);
              } else
                j3 = j3 + Q3, H3 = H3 + Q3;
              break;
            case d2.asterisk:
              if (ne3[n2.FIELDS.TYPE] === d2.equals)
                T3.operator = Q3, V4 = "operator";
              else if ((!T3.namespace || V4 === "namespace" && !K3) && ne3) {
                j3 && ((0, w3.ensureObject)(T3, "spaces", "attribute"), T3.spaces.attribute.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T3, "raws", "spaces", "attribute"), T3.raws.spaces.attribute.before = j3, H3 = ""), T3.namespace = (T3.namespace || "") + Q3;
                var be3 = (0, w3.getProp)(T3, "raws", "namespace") || null;
                be3 && (T3.raws.namespace += Q3), V4 = "namespace";
              }
              K3 = false;
              break;
            case d2.dollar:
              if (V4 === "value") {
                var ie3 = (0, w3.getProp)(T3, "raws", "value");
                T3.value += "$", ie3 && (T3.raws.value = ie3 + "$");
                break;
              }
            // Falls through
            case d2.caret:
              ne3[n2.FIELDS.TYPE] === d2.equals && (T3.operator = Q3, V4 = "operator"), K3 = false;
              break;
            case d2.combinator:
              if (Q3 === "~" && ne3[n2.FIELDS.TYPE] === d2.equals && (T3.operator = Q3, V4 = "operator"), Q3 !== "|") {
                K3 = false;
                break;
              }
              ne3[n2.FIELDS.TYPE] === d2.equals ? (T3.operator = Q3, V4 = "operator") : !T3.namespace && !T3.attribute && (T3.namespace = true), K3 = false;
              break;
            case d2.word:
              if (ne3 && this.content(ne3) === "|" && I3[U2 + 2] && I3[U2 + 2][n2.FIELDS.TYPE] !== d2.equals && // this look-ahead probably fails with comment nodes involved.
              !T3.operator && !T3.namespace)
                T3.namespace = Q3, V4 = "namespace";
              else if (!T3.attribute || V4 === "attribute" && !K3) {
                j3 && ((0, w3.ensureObject)(T3, "spaces", "attribute"), T3.spaces.attribute.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T3, "raws", "spaces", "attribute"), T3.raws.spaces.attribute.before = H3, H3 = ""), T3.attribute = (T3.attribute || "") + Q3;
                var ke3 = (0, w3.getProp)(T3, "raws", "attribute") || null;
                ke3 && (T3.raws.attribute += Q3), V4 = "attribute";
              } else if (!T3.value && T3.value !== "" || V4 === "value" && !(K3 || T3.quoteMark)) {
                var Y3 = (0, w3.unesc)(Q3), G3 = (0, w3.getProp)(T3, "raws", "value") || "", te2 = T3.value || "";
                T3.value = te2 + Y3, T3.quoteMark = null, (Y3 !== Q3 || G3) && ((0, w3.ensureObject)(T3, "raws"), T3.raws.value = (G3 || te2) + Q3), V4 = "value";
              } else {
                var Z3 = Q3 === "i" || Q3 === "I";
                (T3.value || T3.value === "") && (T3.quoteMark || K3) ? (T3.insensitive = Z3, (!Z3 || Q3 === "I") && ((0, w3.ensureObject)(T3, "raws"), T3.raws.insensitiveFlag = Q3), V4 = "insensitive", j3 && ((0, w3.ensureObject)(T3, "spaces", "insensitive"), T3.spaces.insensitive.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T3, "raws", "spaces", "insensitive"), T3.raws.spaces.insensitive.before = H3, H3 = "")) : (T3.value || T3.value === "") && (V4 = "value", T3.value += Q3, T3.raws.value && (T3.raws.value += Q3));
              }
              K3 = false;
              break;
            case d2.str:
              if (!T3.attribute || !T3.operator)
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: X3[n2.FIELDS.START_POS]
                });
              var ee3 = (0, r2.unescapeValue)(Q3), se3 = ee3.unescaped, ue = ee3.quoteMark;
              T3.value = se3, T3.quoteMark = ue, V4 = "value", (0, w3.ensureObject)(T3, "raws"), T3.raws.value = Q3, K3 = false;
              break;
            case d2.equals:
              if (!T3.attribute)
                return this.expected("attribute", X3[n2.FIELDS.START_POS], Q3);
              if (T3.value)
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: X3[n2.FIELDS.START_POS]
                });
              T3.operator = T3.operator ? T3.operator + Q3 : Q3, V4 = "operator", K3 = false;
              break;
            case d2.comment:
              if (V4)
                if (K3 || ne3 && ne3[n2.FIELDS.TYPE] === d2.space || V4 === "insensitive") {
                  var xe3 = (0, w3.getProp)(T3, "spaces", V4, "after") || "", ce3 = (0, w3.getProp)(T3, "raws", "spaces", V4, "after") || xe3;
                  (0, w3.ensureObject)(T3, "raws", "spaces", V4), T3.raws.spaces[V4].after = ce3 + Q3;
                } else {
                  var Te3 = T3[V4] || "", ve3 = (0, w3.getProp)(T3, "raws", V4) || Te3;
                  (0, w3.ensureObject)(T3, "raws"), T3.raws[V4] = ve3 + Q3;
                }
              else
                H3 = H3 + Q3;
              break;
            default:
              return this.error('Unexpected "' + Q3 + '" found.', {
                index: X3[n2.FIELDS.START_POS]
              });
          }
          U2++;
        }
        R3(T3, "attribute"), R3(T3, "namespace"), this.newNode(new r2.default(T3)), this.position++;
      }, F.parseWhitespaceEquivalentTokens = function(I3) {
        I3 < 0 && (I3 = this.tokens.length);
        var N3 = this.position, J3 = [], T3 = "", U2 = void 0;
        do
          if (k3[this.currToken[n2.FIELDS.TYPE]])
            this.options.lossy || (T3 += this.content());
          else if (this.currToken[n2.FIELDS.TYPE] === d2.comment) {
            var j3 = {};
            T3 && (j3.before = T3, T3 = ""), U2 = new f.default({
              value: this.content(),
              source: P3(this.currToken),
              sourceIndex: this.currToken[n2.FIELDS.START_POS],
              spaces: j3
            }), J3.push(U2);
          }
        while (++this.position < I3);
        if (T3) {
          if (U2)
            U2.spaces.after = T3;
          else if (!this.options.lossy) {
            var H3 = this.tokens[N3], V4 = this.tokens[this.position - 1];
            J3.push(new t8.default({
              value: "",
              source: S3(H3[n2.FIELDS.START_LINE], H3[n2.FIELDS.START_COL], V4[n2.FIELDS.END_LINE], V4[n2.FIELDS.END_COL]),
              sourceIndex: H3[n2.FIELDS.START_POS],
              spaces: {
                before: T3,
                after: ""
              }
            }));
          }
        }
        return J3;
      }, F.convertWhitespaceNodesToSpace = function(I3, N3) {
        var J3 = this;
        N3 === void 0 && (N3 = false);
        var T3 = "", U2 = "";
        I3.forEach(function(H3) {
          var V4 = J3.lossySpace(H3.spaces.before, N3), K3 = J3.lossySpace(H3.rawSpaceBefore, N3);
          T3 += V4 + J3.lossySpace(H3.spaces.after, N3 && V4.length === 0), U2 += V4 + H3.value + J3.lossySpace(H3.rawSpaceAfter, N3 && K3.length === 0);
        }), U2 === T3 && (U2 = void 0);
        var j3 = {
          space: T3,
          rawSpace: U2
        };
        return j3;
      }, F.isNamedCombinator = function(I3) {
        return I3 === void 0 && (I3 = this.position), this.tokens[I3 + 0] && this.tokens[I3 + 0][n2.FIELDS.TYPE] === d2.slash && this.tokens[I3 + 1] && this.tokens[I3 + 1][n2.FIELDS.TYPE] === d2.word && this.tokens[I3 + 2] && this.tokens[I3 + 2][n2.FIELDS.TYPE] === d2.slash;
      }, F.namedCombinator = function() {
        if (this.isNamedCombinator()) {
          var I3 = this.content(this.tokens[this.position + 1]), N3 = (0, w3.unesc)(I3).toLowerCase(), J3 = {};
          N3 !== I3 && (J3.value = "/" + I3 + "/");
          var T3 = new o2.default({
            value: "/" + N3 + "/",
            source: S3(this.currToken[n2.FIELDS.START_LINE], this.currToken[n2.FIELDS.START_COL], this.tokens[this.position + 2][n2.FIELDS.END_LINE], this.tokens[this.position + 2][n2.FIELDS.END_COL]),
            sourceIndex: this.currToken[n2.FIELDS.START_POS],
            raws: J3
          });
          return this.position = this.position + 3, T3;
        } else
          this.unexpected();
      }, F.combinator = function() {
        var I3 = this;
        if (this.content() === "|")
          return this.namespace();
        var N3 = this.locateNextMeaningfulToken(this.position);
        if (N3 < 0 || this.tokens[N3][n2.FIELDS.TYPE] === d2.comma || this.tokens[N3][n2.FIELDS.TYPE] === d2.closeParenthesis) {
          var J3 = this.parseWhitespaceEquivalentTokens(N3);
          if (J3.length > 0) {
            var T3 = this.current.last;
            if (T3) {
              var U2 = this.convertWhitespaceNodesToSpace(J3), j3 = U2.space, H3 = U2.rawSpace;
              H3 !== void 0 && (T3.rawSpaceAfter += H3), T3.spaces.after += j3;
            } else
              J3.forEach(function(G3) {
                return I3.newNode(G3);
              });
          }
          return;
        }
        var V4 = this.currToken, K3 = void 0;
        N3 > this.position && (K3 = this.parseWhitespaceEquivalentTokens(N3));
        var X3;
        if (this.isNamedCombinator() ? X3 = this.namedCombinator() : this.currToken[n2.FIELDS.TYPE] === d2.combinator ? (X3 = new o2.default({
          value: this.content(),
          source: P3(this.currToken),
          sourceIndex: this.currToken[n2.FIELDS.START_POS]
        }), this.position++) : k3[this.currToken[n2.FIELDS.TYPE]] || K3 || this.unexpected(), X3) {
          if (K3) {
            var Q3 = this.convertWhitespaceNodesToSpace(K3), ne3 = Q3.space, de3 = Q3.rawSpace;
            X3.spaces.before = ne3, X3.rawSpaceBefore = de3;
          }
        } else {
          var _e3 = this.convertWhitespaceNodesToSpace(K3, true), be3 = _e3.space, ie3 = _e3.rawSpace;
          ie3 || (ie3 = be3);
          var ke3 = {}, Y3 = {
            spaces: {}
          };
          be3.endsWith(" ") && ie3.endsWith(" ") ? (ke3.before = be3.slice(0, be3.length - 1), Y3.spaces.before = ie3.slice(0, ie3.length - 1)) : be3.startsWith(" ") && ie3.startsWith(" ") ? (ke3.after = be3.slice(1), Y3.spaces.after = ie3.slice(1)) : Y3.value = ie3, X3 = new o2.default({
            value: " ",
            source: C(V4, this.tokens[this.position - 1]),
            sourceIndex: V4[n2.FIELDS.START_POS],
            spaces: ke3,
            raws: Y3
          });
        }
        return this.currToken && this.currToken[n2.FIELDS.TYPE] === d2.space && (X3.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(X3);
      }, F.comma = function() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = true, this.position++;
          return;
        }
        this.current._inferEndPosition();
        var I3 = new p.default({
          source: {
            start: M2(this.tokens[this.position + 1])
          },
          sourceIndex: this.tokens[this.position + 1][n2.FIELDS.START_POS]
        });
        this.current.parent.append(I3), this.current = I3, this.position++;
      }, F.comment = function() {
        var I3 = this.currToken;
        this.newNode(new f.default({
          value: this.content(),
          source: P3(I3),
          sourceIndex: I3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.error = function(I3, N3) {
        throw this.root.error(I3, N3);
      }, F.missingBackslash = function() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[n2.FIELDS.START_POS]
        });
      }, F.missingParenthesis = function() {
        return this.expected("opening parenthesis", this.currToken[n2.FIELDS.START_POS]);
      }, F.missingSquareBracket = function() {
        return this.expected("opening square bracket", this.currToken[n2.FIELDS.START_POS]);
      }, F.unexpected = function() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[n2.FIELDS.START_POS]);
      }, F.unexpectedPipe = function() {
        return this.error("Unexpected '|'.", this.currToken[n2.FIELDS.START_POS]);
      }, F.namespace = function() {
        var I3 = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[n2.FIELDS.TYPE] === d2.word)
          return this.position++, this.word(I3);
        if (this.nextToken[n2.FIELDS.TYPE] === d2.asterisk)
          return this.position++, this.universal(I3);
        this.unexpectedPipe();
      }, F.nesting = function() {
        if (this.nextToken) {
          var I3 = this.content(this.nextToken);
          if (I3 === "|") {
            this.position++;
            return;
          }
        }
        var N3 = this.currToken;
        this.newNode(new v3.default({
          value: this.content(),
          source: P3(N3),
          sourceIndex: N3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.parentheses = function() {
        var I3 = this.current.last, N3 = 1;
        if (this.position++, I3 && I3.type === _3.PSEUDO) {
          var J3 = new p.default({
            source: {
              start: M2(this.tokens[this.position])
            },
            sourceIndex: this.tokens[this.position][n2.FIELDS.START_POS]
          }), T3 = this.current;
          for (I3.append(J3), this.current = J3; this.position < this.tokens.length && N3; )
            this.currToken[n2.FIELDS.TYPE] === d2.openParenthesis && N3++, this.currToken[n2.FIELDS.TYPE] === d2.closeParenthesis && N3--, N3 ? this.parse() : (this.current.source.end = W3(this.currToken), this.current.parent.source.end = W3(this.currToken), this.position++);
          this.current = T3;
        } else {
          for (var U2 = this.currToken, j3 = "(", H3; this.position < this.tokens.length && N3; )
            this.currToken[n2.FIELDS.TYPE] === d2.openParenthesis && N3++, this.currToken[n2.FIELDS.TYPE] === d2.closeParenthesis && N3--, H3 = this.currToken, j3 += this.parseParenthesisToken(this.currToken), this.position++;
          I3 ? I3.appendToPropertyAndEscape("value", j3, j3) : this.newNode(new t8.default({
            value: j3,
            source: S3(U2[n2.FIELDS.START_LINE], U2[n2.FIELDS.START_COL], H3[n2.FIELDS.END_LINE], H3[n2.FIELDS.END_COL]),
            sourceIndex: U2[n2.FIELDS.START_POS]
          }));
        }
        if (N3)
          return this.expected("closing parenthesis", this.currToken[n2.FIELDS.START_POS]);
      }, F.pseudo = function() {
        for (var I3 = this, N3 = "", J3 = this.currToken; this.currToken && this.currToken[n2.FIELDS.TYPE] === d2.colon; )
          N3 += this.content(), this.position++;
        if (!this.currToken)
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        if (this.currToken[n2.FIELDS.TYPE] === d2.word)
          this.splitWord(false, function(T3, U2) {
            N3 += T3, I3.newNode(new e2.default({
              value: N3,
              source: C(J3, I3.currToken),
              sourceIndex: J3[n2.FIELDS.START_POS]
            })), U2 > 1 && I3.nextToken && I3.nextToken[n2.FIELDS.TYPE] === d2.openParenthesis && I3.error("Misplaced parenthesis.", {
              index: I3.nextToken[n2.FIELDS.START_POS]
            });
          });
        else
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[n2.FIELDS.START_POS]);
      }, F.space = function() {
        var I3 = this.content();
        this.position === 0 || this.prevToken[n2.FIELDS.TYPE] === d2.comma || this.prevToken[n2.FIELDS.TYPE] === d2.openParenthesis || this.current.nodes.every(function(N3) {
          return N3.type === "comment";
        }) ? (this.spaces = this.optionalSpace(I3), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[n2.FIELDS.TYPE] === d2.comma || this.nextToken[n2.FIELDS.TYPE] === d2.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(I3), this.position++) : this.combinator();
      }, F.string = function() {
        var I3 = this.currToken;
        this.newNode(new t8.default({
          value: this.content(),
          source: P3(I3),
          sourceIndex: I3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.universal = function(I3) {
        var N3 = this.nextToken;
        if (N3 && this.content(N3) === "|")
          return this.position++, this.namespace();
        var J3 = this.currToken;
        this.newNode(new i.default({
          value: this.content(),
          source: P3(J3),
          sourceIndex: J3[n2.FIELDS.START_POS]
        }), I3), this.position++;
      }, F.splitWord = function(I3, N3) {
        for (var J3 = this, T3 = this.nextToken, U2 = this.content(); T3 && ~[d2.dollar, d2.caret, d2.equals, d2.word].indexOf(T3[n2.FIELDS.TYPE]); ) {
          this.position++;
          var j3 = this.content();
          if (U2 += j3, j3.lastIndexOf("\\") === j3.length - 1) {
            var H3 = this.nextToken;
            H3 && H3[n2.FIELDS.TYPE] === d2.space && (U2 += this.requiredSpace(this.content(H3)), this.position++);
          }
          T3 = this.nextToken;
        }
        var V4 = $2(U2, ".").filter(function(ne3) {
          var de3 = U2[ne3 - 1] === "\\", _e3 = /^\d+\.\d+%$/.test(U2);
          return !de3 && !_e3;
        }), K3 = $2(U2, "#").filter(function(ne3) {
          return U2[ne3 - 1] !== "\\";
        }), X3 = $2(U2, "#{");
        X3.length && (K3 = K3.filter(function(ne3) {
          return !~X3.indexOf(ne3);
        }));
        var Q3 = (0, m.default)(B3([0].concat(V4, K3)));
        Q3.forEach(function(ne3, de3) {
          var _e3 = Q3[de3 + 1] || U2.length, be3 = U2.slice(ne3, _e3);
          if (de3 === 0 && N3)
            return N3.call(J3, be3, Q3.length);
          var ie3, ke3 = J3.currToken, Y3 = ke3[n2.FIELDS.START_POS] + Q3[de3], G3 = S3(ke3[1], ke3[2] + ne3, ke3[3], ke3[2] + (_e3 - 1));
          if (~V4.indexOf(ne3)) {
            var te2 = {
              value: be3.slice(1),
              source: G3,
              sourceIndex: Y3
            };
            ie3 = new l2.default(R3(te2, "value"));
          } else if (~K3.indexOf(ne3)) {
            var Z3 = {
              value: be3.slice(1),
              source: G3,
              sourceIndex: Y3
            };
            ie3 = new s2.default(R3(Z3, "value"));
          } else {
            var ee3 = {
              value: be3,
              source: G3,
              sourceIndex: Y3
            };
            R3(ee3, "value"), ie3 = new c2.default(ee3);
          }
          J3.newNode(ie3, I3), I3 = null;
        }), this.position++;
      }, F.word = function(I3) {
        var N3 = this.nextToken;
        return N3 && this.content(N3) === "|" ? (this.position++, this.namespace()) : this.splitWord(I3);
      }, F.loop = function() {
        for (; this.position < this.tokens.length; )
          this.parse(true);
        return this.current._inferEndPosition(), this.root;
      }, F.parse = function(I3) {
        switch (this.currToken[n2.FIELDS.TYPE]) {
          case d2.space:
            this.space();
            break;
          case d2.comment:
            this.comment();
            break;
          case d2.openParenthesis:
            this.parentheses();
            break;
          case d2.closeParenthesis:
            I3 && this.missingParenthesis();
            break;
          case d2.openSquare:
            this.attribute();
            break;
          case d2.dollar:
          case d2.caret:
          case d2.equals:
          case d2.word:
            this.word();
            break;
          case d2.colon:
            this.pseudo();
            break;
          case d2.comma:
            this.comma();
            break;
          case d2.asterisk:
            this.universal();
            break;
          case d2.ampersand:
            this.nesting();
            break;
          case d2.slash:
          case d2.combinator:
            this.combinator();
            break;
          case d2.str:
            this.string();
            break;
          // These cases throw; no break needed.
          case d2.closeSquare:
            this.missingSquareBracket();
          case d2.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      }, F.expected = function(I3, N3, J3) {
        if (Array.isArray(I3)) {
          var T3 = I3.pop();
          I3 = I3.join(", ") + " or " + T3;
        }
        var U2 = /^[aeiou]/.test(I3[0]) ? "an" : "a";
        return J3 ? this.error("Expected " + U2 + " " + I3 + ', found "' + J3 + '" instead.', {
          index: N3
        }) : this.error("Expected " + U2 + " " + I3 + ".", {
          index: N3
        });
      }, F.requiredSpace = function(I3) {
        return this.options.lossy ? " " : I3;
      }, F.optionalSpace = function(I3) {
        return this.options.lossy ? "" : I3;
      }, F.lossySpace = function(I3, N3) {
        return this.options.lossy ? N3 ? " " : "" : I3;
      }, F.parseParenthesisToken = function(I3) {
        var N3 = this.content(I3);
        return I3[n2.FIELDS.TYPE] === d2.space ? this.requiredSpace(N3) : N3;
      }, F.newNode = function(I3, N3) {
        return N3 && (/^ +$/.test(N3) && (this.options.lossy || (this.spaces = (this.spaces || "") + N3), N3 = true), I3.namespace = N3, R3(I3, "namespace")), this.spaces && (I3.spaces.before = this.spaces, this.spaces = ""), this.current.append(I3);
      }, F.content = function(I3) {
        return I3 === void 0 && (I3 = this.currToken), this.css.slice(I3[n2.FIELDS.START_POS], I3[n2.FIELDS.END_POS]);
      }, F.locateNextMeaningfulToken = function(I3) {
        I3 === void 0 && (I3 = this.position + 1);
        for (var N3 = I3; N3 < this.tokens.length; )
          if (q2[this.tokens[N3][n2.FIELDS.TYPE]]) {
            N3++;
            continue;
          } else
            return N3;
        return -1;
      }, b3(L3, [{
        key: "currToken",
        get: function() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function() {
          return this.tokens[this.position - 1];
        }
      }]), L3;
    })();
    a.default = z3, u.exports = a.default;
  })($t3, $t3.exports)), $t3.exports;
}
var fo2;
function mf() {
  return fo2 || (fo2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = p(gf());
    function p(f) {
      return f && f.__esModule ? f : { default: f };
    }
    var l2 = /* @__PURE__ */ (function() {
      function f(c2, t8) {
        this.func = c2 || function() {
        }, this.funcRes = null, this.options = t8;
      }
      var s2 = f.prototype;
      return s2._shouldUpdateSelector = function(t8, e2) {
        e2 === void 0 && (e2 = {});
        var r2 = Object.assign({}, this.options, e2);
        return r2.updateSelector === false ? false : typeof t8 != "string";
      }, s2._isLossy = function(t8) {
        t8 === void 0 && (t8 = {});
        var e2 = Object.assign({}, this.options, t8);
        return e2.lossless === false;
      }, s2._root = function(t8, e2) {
        e2 === void 0 && (e2 = {});
        var r2 = new h2.default(t8, this._parseOptions(e2));
        return r2.root;
      }, s2._parseOptions = function(t8) {
        return {
          lossy: this._isLossy(t8)
        };
      }, s2._run = function(t8, e2) {
        var r2 = this;
        return e2 === void 0 && (e2 = {}), new Promise(function(i, o2) {
          try {
            var v3 = r2._root(t8, e2);
            Promise.resolve(r2.func(v3)).then(function(m) {
              var n2 = void 0;
              return r2._shouldUpdateSelector(t8, e2) && (n2 = v3.toString(), t8.selector = n2), {
                transform: m,
                root: v3,
                string: n2
              };
            }).then(i, o2);
          } catch (m) {
            o2(m);
            return;
          }
        });
      }, s2._runSync = function(t8, e2) {
        e2 === void 0 && (e2 = {});
        var r2 = this._root(t8, e2), i = this.func(r2);
        if (i && typeof i.then == "function")
          throw new Error("Selector processor returned a promise to a synchronous call.");
        var o2 = void 0;
        return e2.updateSelector && typeof t8 != "string" && (o2 = r2.toString(), t8.selector = o2), {
          transform: i,
          root: r2,
          string: o2
        };
      }, s2.ast = function(t8, e2) {
        return this._run(t8, e2).then(function(r2) {
          return r2.root;
        });
      }, s2.astSync = function(t8, e2) {
        return this._runSync(t8, e2).root;
      }, s2.transform = function(t8, e2) {
        return this._run(t8, e2).then(function(r2) {
          return r2.transform;
        });
      }, s2.transformSync = function(t8, e2) {
        return this._runSync(t8, e2).transform;
      }, s2.process = function(t8, e2) {
        return this._run(t8, e2).then(function(r2) {
          return r2.string || r2.root.toString();
        });
      }, s2.processSync = function(t8, e2) {
        var r2 = this._runSync(t8, e2);
        return r2.string || r2.root.toString();
      }, f;
    })();
    a.default = l2, u.exports = a.default;
  })(Ft2, Ft2.exports)), Ft2.exports;
}
var Dn3 = {};
var De3 = {};
var co3;
function yf() {
  if (co3) return De3;
  co3 = 1, De3.__esModule = true, De3.universal = De3.tag = De3.string = De3.selector = De3.root = De3.pseudo = De3.nesting = De3.id = De3.comment = De3.combinator = De3.className = De3.attribute = void 0;
  var u = o2(Ql()), a = o2(Wl()), h2 = o2(Jl()), p = o2(Vl()), l2 = o2(jl()), f = o2(Kl()), s2 = o2(Yl()), c2 = o2(Ul()), t8 = o2(zl()), e2 = o2(Gl()), r2 = o2(Bl()), i = o2(Hl());
  function o2(b3) {
    return b3 && b3.__esModule ? b3 : { default: b3 };
  }
  var v3 = function(k3) {
    return new u.default(k3);
  };
  De3.attribute = v3;
  var m = function(k3) {
    return new a.default(k3);
  };
  De3.className = m;
  var n2 = function(k3) {
    return new h2.default(k3);
  };
  De3.combinator = n2;
  var d2 = function(k3) {
    return new p.default(k3);
  };
  De3.comment = d2;
  var _3 = function(k3) {
    return new l2.default(k3);
  };
  De3.id = _3;
  var w3 = function(k3) {
    return new f.default(k3);
  };
  De3.nesting = w3;
  var y2 = function(k3) {
    return new s2.default(k3);
  };
  De3.pseudo = y2;
  var x = function(k3) {
    return new c2.default(k3);
  };
  De3.root = x;
  var g2 = function(k3) {
    return new t8.default(k3);
  };
  De3.selector = g2;
  var O3 = function(k3) {
    return new e2.default(k3);
  };
  De3.string = O3;
  var A = function(k3) {
    return new r2.default(k3);
  };
  De3.tag = A;
  var E2 = function(k3) {
    return new i.default(k3);
  };
  return De3.universal = E2, De3;
}
var Ee3 = {};
var po3;
function wf() {
  if (po3) return Ee3;
  po3 = 1, Ee3.__esModule = true, Ee3.isComment = Ee3.isCombinator = Ee3.isClassName = Ee3.isAttribute = void 0, Ee3.isContainer = y2, Ee3.isIdentifier = void 0, Ee3.isNamespace = x, Ee3.isNesting = void 0, Ee3.isNode = p, Ee3.isPseudo = void 0, Ee3.isPseudoClass = w3, Ee3.isPseudoElement = _3, Ee3.isUniversal = Ee3.isTag = Ee3.isString = Ee3.isSelector = Ee3.isRoot = void 0;
  var u = $e2(), a, h2 = (a = {}, a[u.ATTRIBUTE] = true, a[u.CLASS] = true, a[u.COMBINATOR] = true, a[u.COMMENT] = true, a[u.ID] = true, a[u.NESTING] = true, a[u.PSEUDO] = true, a[u.ROOT] = true, a[u.SELECTOR] = true, a[u.STRING] = true, a[u.TAG] = true, a[u.UNIVERSAL] = true, a);
  function p(g2) {
    return typeof g2 == "object" && h2[g2.type];
  }
  function l2(g2, O3) {
    return p(O3) && O3.type === g2;
  }
  var f = l2.bind(null, u.ATTRIBUTE);
  Ee3.isAttribute = f;
  var s2 = l2.bind(null, u.CLASS);
  Ee3.isClassName = s2;
  var c2 = l2.bind(null, u.COMBINATOR);
  Ee3.isCombinator = c2;
  var t8 = l2.bind(null, u.COMMENT);
  Ee3.isComment = t8;
  var e2 = l2.bind(null, u.ID);
  Ee3.isIdentifier = e2;
  var r2 = l2.bind(null, u.NESTING);
  Ee3.isNesting = r2;
  var i = l2.bind(null, u.PSEUDO);
  Ee3.isPseudo = i;
  var o2 = l2.bind(null, u.ROOT);
  Ee3.isRoot = o2;
  var v3 = l2.bind(null, u.SELECTOR);
  Ee3.isSelector = v3;
  var m = l2.bind(null, u.STRING);
  Ee3.isString = m;
  var n2 = l2.bind(null, u.TAG);
  Ee3.isTag = n2;
  var d2 = l2.bind(null, u.UNIVERSAL);
  Ee3.isUniversal = d2;
  function _3(g2) {
    return i(g2) && g2.value && (g2.value.startsWith("::") || g2.value.toLowerCase() === ":before" || g2.value.toLowerCase() === ":after" || g2.value.toLowerCase() === ":first-letter" || g2.value.toLowerCase() === ":first-line");
  }
  function w3(g2) {
    return i(g2) && !_3(g2);
  }
  function y2(g2) {
    return !!(p(g2) && g2.walk);
  }
  function x(g2) {
    return f(g2) || n2(g2);
  }
  return Ee3;
}
var ho2;
function bf() {
  return ho2 || (ho2 = 1, (function(u) {
    u.__esModule = true;
    var a = $e2();
    Object.keys(a).forEach(function(l2) {
      l2 === "default" || l2 === "__esModule" || l2 in u && u[l2] === a[l2] || (u[l2] = a[l2]);
    });
    var h2 = yf();
    Object.keys(h2).forEach(function(l2) {
      l2 === "default" || l2 === "__esModule" || l2 in u && u[l2] === h2[l2] || (u[l2] = h2[l2]);
    });
    var p = wf();
    Object.keys(p).forEach(function(l2) {
      l2 === "default" || l2 === "__esModule" || l2 in u && u[l2] === p[l2] || (u[l2] = p[l2]);
    });
  })(Dn3)), Dn3;
}
var vo2;
function Ke3() {
  return vo2 || (vo2 = 1, (function(u, a) {
    a.__esModule = true, a.default = void 0;
    var h2 = s2(mf()), p = f(bf());
    function l2(e2) {
      if (typeof WeakMap != "function") return null;
      var r2 = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap();
      return (l2 = function(v3) {
        return v3 ? i : r2;
      })(e2);
    }
    function f(e2, r2) {
      if (e2 && e2.__esModule)
        return e2;
      if (e2 === null || typeof e2 != "object" && typeof e2 != "function")
        return { default: e2 };
      var i = l2(r2);
      if (i && i.has(e2))
        return i.get(e2);
      var o2 = {}, v3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var m in e2)
        if (m !== "default" && Object.prototype.hasOwnProperty.call(e2, m)) {
          var n2 = v3 ? Object.getOwnPropertyDescriptor(e2, m) : null;
          n2 && (n2.get || n2.set) ? Object.defineProperty(o2, m, n2) : o2[m] = e2[m];
        }
      return o2.default = e2, i && i.set(e2, o2), o2;
    }
    function s2(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var c2 = function(r2) {
      return new h2.default(r2);
    };
    Object.assign(c2, p), delete c2.__esModule;
    var t8 = c2;
    a.default = t8, u.exports = a.default;
  })(Nt3, Nt3.exports)), Nt3.exports;
}
var qn3 = {};
var Ln3 = {};
var ar3 = { exports: {} };
var go2;
function _f() {
  if (go2) return ar3.exports;
  go2 = 1;
  const { AtRule: u, Rule: a } = Be2();
  let h2 = Ke3();
  function p(_3, w3) {
    let y2;
    try {
      h2((x) => {
        y2 = x;
      }).processSync(_3);
    } catch (x) {
      throw _3.includes(":") ? w3 ? w3.error("Missed semicolon") : x : w3 ? w3.error(x.message) : x;
    }
    return y2.at(0);
  }
  function l2(_3, w3) {
    let y2 = false;
    return _3.each((x) => {
      if (x.type === "nesting") {
        let g2 = w3.clone({});
        x.value !== "&" ? x.replaceWith(
          p(x.value.replace("&", g2.toString()))
        ) : x.replaceWith(g2), y2 = true;
      } else "nodes" in x && x.nodes && l2(x, w3) && (y2 = true);
    }), y2;
  }
  function f(_3, w3) {
    let y2 = [];
    return _3.selectors.forEach((x) => {
      let g2 = p(x, _3);
      w3.selectors.forEach((O3) => {
        if (!O3)
          return;
        let A = p(O3, w3);
        l2(A, g2) || (A.prepend(h2.combinator({ value: " " })), A.prepend(g2.clone({}))), y2.push(A.toString());
      });
    }), y2;
  }
  function s2(_3, w3) {
    let y2 = _3.prev();
    for (w3.after(_3); y2 && y2.type === "comment"; ) {
      let x = y2.prev();
      w3.after(y2), y2 = x;
    }
    return _3;
  }
  function c2(_3) {
    return function w3(y2, x, g2, O3 = g2) {
      let A = [];
      if (x.each((E2) => {
        E2.type === "rule" && g2 ? O3 && (E2.selectors = f(y2, E2)) : E2.type === "atrule" && E2.nodes ? _3[E2.name] ? w3(y2, E2, O3) : x[v3] !== false && A.push(E2) : A.push(E2);
      }), g2 && A.length) {
        let E2 = y2.clone({ nodes: [] });
        for (let b3 of A)
          E2.append(b3);
        x.prepend(E2);
      }
    };
  }
  function t8(_3, w3, y2) {
    let x = new a({
      nodes: [],
      selector: _3
    });
    return x.append(w3), y2.after(x), x;
  }
  function e2(_3, w3) {
    let y2 = {};
    for (let x of _3)
      y2[x] = true;
    if (w3)
      for (let x of w3)
        y2[x.replace(/^@/, "")] = true;
    return y2;
  }
  function r2(_3) {
    _3 = _3.trim();
    let w3 = _3.match(/^\((.*)\)$/);
    if (!w3)
      return { selector: _3, type: "basic" };
    let y2 = w3[1].match(/^(with(?:out)?):(.+)$/);
    if (y2) {
      let x = y2[1] === "with", g2 = Object.fromEntries(
        y2[2].trim().split(/\s+/).map((A) => [A, true])
      );
      if (x && g2.all)
        return { type: "noop" };
      let O3 = (A) => !!g2[A];
      return g2.all ? O3 = () => true : x && (O3 = (A) => A === "all" ? false : !g2[A]), {
        escapes: O3,
        type: "withrules"
      };
    }
    return { type: "unknown" };
  }
  function i(_3) {
    let w3 = [], y2 = _3.parent;
    for (; y2 && y2 instanceof u; )
      w3.push(y2), y2 = y2.parent;
    return w3;
  }
  function o2(_3) {
    let w3 = _3[m];
    if (!w3)
      _3.after(_3.nodes);
    else {
      let y2 = _3.nodes, x, g2 = -1, O3, A, E2, b3 = i(_3);
      if (b3.forEach((k3, q2) => {
        if (w3(k3.name))
          x = k3, g2 = q2, A = E2;
        else {
          let M2 = E2;
          E2 = k3.clone({ nodes: [] }), M2 && E2.append(M2), O3 = O3 || E2;
        }
      }), x ? A ? (O3.append(y2), x.after(A)) : x.after(y2) : _3.after(y2), _3.next() && x) {
        let k3;
        b3.slice(0, g2 + 1).forEach((q2, M2, W3) => {
          let S3 = k3;
          k3 = q2.clone({ nodes: [] }), S3 && k3.append(S3);
          let P3 = [], R3 = (W3[M2 - 1] || _3).next();
          for (; R3; )
            P3.push(R3), R3 = R3.next();
          k3.append(P3);
        }), k3 && (A || y2[y2.length - 1]).after(k3);
      }
    }
    _3.remove();
  }
  const v3 = Symbol("rootRuleMergeSel"), m = Symbol("rootRuleEscapes");
  function n2(_3) {
    let { params: w3 } = _3, { escapes: y2, selector: x, type: g2 } = r2(w3);
    if (g2 === "unknown")
      throw _3.error(
        `Unknown @${_3.name} parameter ${JSON.stringify(w3)}`
      );
    if (g2 === "basic" && x) {
      let O3 = new a({ nodes: _3.nodes, selector: x });
      _3.removeAll(), _3.append(O3);
    }
    _3[m] = y2, _3[v3] = y2 ? !y2("all") : g2 === "noop";
  }
  const d2 = Symbol("hasRootRule");
  return ar3.exports = (_3 = {}) => {
    let w3 = e2(
      ["media", "supports", "layer", "container", "starting-style"],
      _3.bubble
    ), y2 = c2(w3), x = e2(
      [
        "document",
        "font-face",
        "keyframes",
        "-webkit-keyframes",
        "-moz-keyframes"
      ],
      _3.unwrap
    ), g2 = (_3.rootRuleName || "at-root").replace(/^@/, ""), O3 = _3.preserveEmpty;
    return {
      Once(A) {
        A.walkAtRules(g2, (E2) => {
          n2(E2), A[d2] = true;
        });
      },
      postcssPlugin: "postcss-nested",
      RootExit(A) {
        A[d2] && (A.walkAtRules(g2, o2), A[d2] = false);
      },
      Rule(A) {
        let E2 = false, b3 = A, k3 = false, q2 = [];
        A.each((M2) => {
          M2.type === "rule" ? (q2.length && (b3 = t8(A.selector, q2, b3), q2 = []), k3 = true, E2 = true, M2.selectors = f(A, M2), b3 = s2(M2, b3)) : M2.type === "atrule" ? (q2.length && (b3 = t8(A.selector, q2, b3), q2 = []), M2.name === g2 ? (E2 = true, y2(A, M2, true, M2[v3]), b3 = s2(M2, b3)) : w3[M2.name] ? (k3 = true, E2 = true, y2(A, M2, true), b3 = s2(M2, b3)) : x[M2.name] ? (k3 = true, E2 = true, y2(A, M2, false), b3 = s2(M2, b3)) : k3 && q2.push(M2)) : M2.type === "decl" && k3 && q2.push(M2);
        }), q2.length && (b3 = t8(A.selector, q2, b3)), E2 && O3 !== true && (A.raws.semicolon = true, A.nodes.length === 0 && A.remove());
      }
    };
  }, ar3.exports.postcss = true, ar3.exports;
}
var Nn3;
var mo2;
function Sf() {
  if (mo2) return Nn3;
  mo2 = 1;
  var u = /-(\w|$)/g, a = function(l2, f) {
    return f.toUpperCase();
  }, h2 = function(l2) {
    return l2 = l2.toLowerCase(), l2 === "float" ? "cssFloat" : l2.charCodeAt(0) === 45 && l2.charCodeAt(1) === 109 && l2.charCodeAt(2) === 115 && l2.charCodeAt(3) === 45 ? l2.substr(1).replace(u, a) : l2.replace(u, a);
  };
  return Nn3 = h2, Nn3;
}
var Fn3;
var yo2;
function Zl() {
  if (yo2) return Fn3;
  yo2 = 1;
  let u = Sf(), a = {
    boxFlex: true,
    boxFlexGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    strokeDashoffset: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  function h2(l2) {
    return typeof l2.nodes > "u" ? true : p(l2);
  }
  function p(l2) {
    let f, s2 = {};
    return l2.each((c2) => {
      if (c2.type === "atrule")
        f = "@" + c2.name, c2.params && (f += " " + c2.params), typeof s2[f] > "u" ? s2[f] = h2(c2) : Array.isArray(s2[f]) ? s2[f].push(h2(c2)) : s2[f] = [s2[f], h2(c2)];
      else if (c2.type === "rule") {
        let t8 = p(c2);
        if (s2[c2.selector])
          for (let e2 in t8)
            s2[c2.selector][e2] = t8[e2];
        else
          s2[c2.selector] = t8;
      } else if (c2.type === "decl") {
        c2.prop[0] === "-" && c2.prop[1] === "-" || c2.parent && c2.parent.selector === ":export" ? f = c2.prop : f = u(c2.prop);
        let t8 = c2.value;
        !isNaN(c2.value) && a[f] && (t8 = parseFloat(c2.value)), c2.important && (t8 += " !important"), typeof s2[f] > "u" ? s2[f] = t8 : Array.isArray(s2[f]) ? s2[f].push(t8) : s2[f] = [s2[f], t8];
      }
    }), s2;
  }
  return Fn3 = p, Fn3;
}
var $n3;
var wo2;
function Qi2() {
  if (wo2) return $n3;
  wo2 = 1;
  let u = Be2(), a = /\s*!important\s*$/i, h2 = {
    "box-flex": true,
    "box-flex-group": true,
    "column-count": true,
    flex: true,
    "flex-grow": true,
    "flex-positive": true,
    "flex-shrink": true,
    "flex-negative": true,
    "font-weight": true,
    "line-clamp": true,
    "line-height": true,
    opacity: true,
    order: true,
    orphans: true,
    "tab-size": true,
    widows: true,
    "z-index": true,
    zoom: true,
    "fill-opacity": true,
    "stroke-dashoffset": true,
    "stroke-opacity": true,
    "stroke-width": true
  };
  function p(c2) {
    return c2.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
  }
  function l2(c2, t8, e2) {
    e2 === false || e2 === null || (t8.startsWith("--") || (t8 = p(t8)), typeof e2 == "number" && (e2 === 0 || h2[t8] ? e2 = e2.toString() : e2 += "px"), t8 === "css-float" && (t8 = "float"), a.test(e2) ? (e2 = e2.replace(a, ""), c2.push(u.decl({ prop: t8, value: e2, important: true }))) : c2.push(u.decl({ prop: t8, value: e2 })));
  }
  function f(c2, t8, e2) {
    let r2 = u.atRule({ name: t8[1], params: t8[3] || "" });
    typeof e2 == "object" && (r2.nodes = [], s2(e2, r2)), c2.push(r2);
  }
  function s2(c2, t8) {
    let e2, r2, i;
    for (e2 in c2)
      if (r2 = c2[e2], !(r2 === null || typeof r2 > "u"))
        if (e2[0] === "@") {
          let o2 = e2.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
          if (Array.isArray(r2))
            for (let v3 of r2)
              f(t8, o2, v3);
          else
            f(t8, o2, r2);
        } else if (Array.isArray(r2))
          for (let o2 of r2)
            l2(t8, e2, o2);
        else typeof r2 == "object" ? (i = u.rule({ selector: e2 }), s2(r2, i), t8.push(i)) : l2(t8, e2, r2);
  }
  return $n3 = function(c2) {
    let t8 = u.root();
    return s2(c2, t8), t8;
  }, $n3;
}
var Un3;
var bo2;
function eu3() {
  if (bo2) return Un3;
  bo2 = 1;
  let u = Zl();
  return Un3 = function(h2) {
    return console && console.warn && h2.warnings().forEach((p) => {
      let l2 = p.plugin || "PostCSS";
      console.warn(l2 + ": " + p.text);
    }), u(h2.root);
  }, Un3;
}
var zn3;
var _o2;
function xf() {
  if (_o2) return zn3;
  _o2 = 1;
  let u = Be2(), a = eu3(), h2 = Qi2();
  return zn3 = function(l2) {
    let f = u(l2);
    return async (s2) => {
      let c2 = await f.process(s2, {
        parser: h2,
        from: void 0
      });
      return a(c2);
    };
  }, zn3;
}
var Wn3;
var So2;
function Of() {
  if (So2) return Wn3;
  So2 = 1;
  let u = Be2(), a = eu3(), h2 = Qi2();
  return Wn3 = function(p) {
    let l2 = u(p);
    return (f) => {
      let s2 = l2.process(f, { parser: h2, from: void 0 });
      return a(s2);
    };
  }, Wn3;
}
var Vn3;
var xo2;
function kf() {
  if (xo2) return Vn3;
  xo2 = 1;
  let u = Zl(), a = Qi2(), h2 = xf(), p = Of();
  return Vn3 = {
    objectify: u,
    parse: a,
    async: h2,
    sync: p
  }, Vn3;
}
var Oo3;
function tu3() {
  return Oo3 || (Oo3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return f;
      }
    });
    const a = /* @__PURE__ */ l2(Be2()), h2 = /* @__PURE__ */ l2(_f()), p = /* @__PURE__ */ l2(kf());
    function l2(s2) {
      return s2 && s2.__esModule ? s2 : {
        default: s2
      };
    }
    function f(s2) {
      return Array.isArray(s2) ? s2.flatMap((c2) => (0, a.default)([
        (0, h2.default)({
          bubble: [
            "screen"
          ]
        })
      ]).process(c2, {
        parser: p.default
      }).root.nodes) : f([
        s2
      ]);
    }
  })(Ln3)), Ln3;
}
var jn3 = {};
var ko2;
function Hi2() {
  return ko2 || (ko2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(
      u,
      /**
      * @template {string | import('postcss-selector-parser').Root} T
      *
      * Prefix all classes in the selector with the given prefix
      *
      * It can take either a string or a selector AST and will return the same type
      *
      * @param {string} prefix
      * @param {T} selector
      * @param {boolean} prependNegative
      * @returns {T}
      */
      "default",
      {
        enumerable: true,
        get: function() {
          return p;
        }
      }
    );
    const a = /* @__PURE__ */ h2(Ke3());
    function h2(l2) {
      return l2 && l2.__esModule ? l2 : {
        default: l2
      };
    }
    function p(l2, f, s2 = false) {
      if (l2 === "")
        return f;
      let c2 = typeof f == "string" ? (0, a.default)().astSync(f) : f;
      return c2.walkClasses((t8) => {
        let e2 = t8.value, r2 = s2 && e2.startsWith("-");
        t8.value = r2 ? `-${l2}${e2.slice(1)}` : `${l2}${e2}`;
      }), typeof f == "string" ? c2.toString() : c2;
    }
  })(jn3)), jn3;
}
var Bn3 = {};
var Po2;
function yr3() {
  return Po2 || (Po2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(r2, i) {
      for (var o2 in i) Object.defineProperty(r2, o2, {
        enumerable: true,
        get: i[o2]
      });
    }
    a(u, {
      env: function() {
        return h2;
      },
      contextMap: function() {
        return p;
      },
      configContextMap: function() {
        return l2;
      },
      contextSourcesMap: function() {
        return f;
      },
      sourceHashMap: function() {
        return s2;
      },
      NOT_ON_DEMAND: function() {
        return c2;
      },
      NONE: function() {
        return t8;
      },
      resolveDebug: function() {
        return e2;
      }
    });
    const h2 = typeof process < "u" ? {
      NODE_ENV: process.env.NODE_ENV,
      DEBUG: e2(process.env.DEBUG)
    } : {
      NODE_ENV: "production",
      DEBUG: false
    }, p = /* @__PURE__ */ new Map(), l2 = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map(), s2 = /* @__PURE__ */ new Map(), c2 = new String("*"), t8 = Symbol("__NONE__");
    function e2(r2) {
      if (r2 === void 0)
        return false;
      if (r2 === "true" || r2 === "1")
        return true;
      if (r2 === "false" || r2 === "0")
        return false;
      if (r2 === "*")
        return true;
      let i = r2.split(",").map((o2) => o2.split(":")[0]);
      return i.includes("-tailwindcss") ? false : !!i.includes("tailwindcss");
    }
  })(Bn3)), Bn3;
}
var Gn3 = {};
var Yn3 = {};
var Eo2;
function ft3() {
  return Eo2 || (Eo2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = /* @__PURE__ */ p(Ke3()), h2 = /* @__PURE__ */ p(Vi2());
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l2(f) {
      var s2;
      let c2 = a.default.className();
      c2.value = f;
      var t8;
      return (0, h2.default)((t8 = c2 == null || (s2 = c2.raws) === null || s2 === void 0 ? void 0 : s2.value) !== null && t8 !== void 0 ? t8 : c2.value);
    }
  })(Yn3)), Yn3;
}
var Qn3 = {};
var To2;
function Ji2() {
  return To2 || (To2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "movePseudos", {
      enumerable: true,
      get: function() {
        return h2;
      }
    });
    let a = {
      // Pseudo elements from the spec
      "::after": [
        "terminal",
        "jumpable"
      ],
      "::backdrop": [
        "terminal",
        "jumpable"
      ],
      "::before": [
        "terminal",
        "jumpable"
      ],
      "::cue": [
        "terminal"
      ],
      "::cue-region": [
        "terminal"
      ],
      "::first-letter": [
        "terminal",
        "jumpable"
      ],
      "::first-line": [
        "terminal",
        "jumpable"
      ],
      "::grammar-error": [
        "terminal"
      ],
      "::marker": [
        "terminal",
        "jumpable"
      ],
      "::part": [
        "terminal",
        "actionable"
      ],
      "::placeholder": [
        "terminal",
        "jumpable"
      ],
      "::selection": [
        "terminal",
        "jumpable"
      ],
      "::slotted": [
        "terminal"
      ],
      "::spelling-error": [
        "terminal"
      ],
      "::target-text": [
        "terminal"
      ],
      // Pseudo elements from the spec with special rules
      "::file-selector-button": [
        "terminal",
        "actionable"
      ],
      // Library-specific pseudo elements used by component libraries
      // These are Shadow DOM-like
      "::deep": [
        "actionable"
      ],
      "::v-deep": [
        "actionable"
      ],
      "::ng-deep": [
        "actionable"
      ],
      // Note: As a rule, double colons (::) should be used instead of a single colon
      // (:). This distinguishes pseudo-classes from pseudo-elements. However, since
      // this distinction was not present in older versions of the W3C spec, most
      // browsers support both syntaxes for the original pseudo-elements.
      ":after": [
        "terminal",
        "jumpable"
      ],
      ":before": [
        "terminal",
        "jumpable"
      ],
      ":first-letter": [
        "terminal",
        "jumpable"
      ],
      ":first-line": [
        "terminal",
        "jumpable"
      ],
      ":where": [],
      ":is": [],
      ":has": [],
      // The default value is used when the pseudo-element is not recognized
      // Because it's not recognized, we don't know if it's terminal or not
      // So we assume it can be moved AND can have user-action pseudo classes attached to it
      __default__: [
        "terminal",
        "actionable"
      ]
    };
    function h2(t8) {
      let [e2] = p(t8);
      return e2.forEach(([r2, i]) => r2.removeChild(i)), t8.nodes.push(...e2.map(([, r2]) => r2)), t8;
    }
    function p(t8) {
      let e2 = [], r2 = null;
      for (let o2 of t8.nodes)
        if (o2.type === "combinator")
          e2 = e2.filter(([, v3]) => c2(v3).includes("jumpable")), r2 = null;
        else if (o2.type === "pseudo") {
          f(o2) ? (r2 = o2, e2.push([
            t8,
            o2,
            null
          ])) : r2 && s2(o2, r2) ? e2.push([
            t8,
            o2,
            r2
          ]) : r2 = null;
          var i;
          for (let v3 of (i = o2.nodes) !== null && i !== void 0 ? i : []) {
            let [m, n2] = p(v3);
            r2 = n2 || r2, e2.push(...m);
          }
        }
      return [
        e2,
        r2
      ];
    }
    function l2(t8) {
      return t8.value.startsWith("::") || a[t8.value] !== void 0;
    }
    function f(t8) {
      return l2(t8) && c2(t8).includes("terminal");
    }
    function s2(t8, e2) {
      return t8.type !== "pseudo" || l2(t8) ? false : c2(e2).includes("actionable");
    }
    function c2(t8) {
      var e2;
      return (e2 = a[t8.value]) !== null && e2 !== void 0 ? e2 : a.__default__;
    }
  })(Qn3)), Qn3;
}
var Ao2;
function ru3() {
  return Ao2 || (Ao2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(d2, _3) {
      for (var w3 in _3) Object.defineProperty(d2, w3, {
        enumerable: true,
        get: _3[w3]
      });
    }
    a(u, {
      formatVariantSelector: function() {
        return r2;
      },
      eliminateIrrelevantSelectors: function() {
        return v3;
      },
      finalizeSelector: function() {
        return m;
      },
      handleMergePseudo: function() {
        return n2;
      }
    });
    const h2 = /* @__PURE__ */ t8(Ke3()), p = /* @__PURE__ */ t8(Bi2()), l2 = /* @__PURE__ */ t8(ft3()), f = /* @__PURE__ */ t8(Hi2()), s2 = Ji2(), c2 = st3();
    function t8(d2) {
      return d2 && d2.__esModule ? d2 : {
        default: d2
      };
    }
    let e2 = ":merge";
    function r2(d2, { context: _3, candidate: w3 }) {
      var y2;
      let x = (y2 = _3 == null ? void 0 : _3.tailwindConfig.prefix) !== null && y2 !== void 0 ? y2 : "", g2 = d2.map((A) => {
        let E2 = (0, h2.default)().astSync(A.format);
        return {
          ...A,
          ast: A.respectPrefix ? (0, f.default)(x, E2) : E2
        };
      }), O3 = h2.default.root({
        nodes: [
          h2.default.selector({
            nodes: [
              h2.default.className({
                value: (0, l2.default)(w3)
              })
            ]
          })
        ]
      });
      for (let { ast: A } of g2)
        [O3, A] = n2(O3, A), A.walkNesting((E2) => E2.replaceWith(...O3.nodes[0].nodes)), O3 = A;
      return O3;
    }
    function i(d2) {
      let _3 = [];
      for (; d2.prev() && d2.prev().type !== "combinator"; )
        d2 = d2.prev();
      for (; d2 && d2.type !== "combinator"; )
        _3.push(d2), d2 = d2.next();
      return _3;
    }
    function o2(d2) {
      return d2.sort((_3, w3) => _3.type === "tag" && w3.type === "class" ? -1 : _3.type === "class" && w3.type === "tag" ? 1 : _3.type === "class" && w3.type === "pseudo" && w3.value.startsWith("::") ? -1 : _3.type === "pseudo" && _3.value.startsWith("::") && w3.type === "class" ? 1 : d2.index(_3) - d2.index(w3)), d2;
    }
    function v3(d2, _3) {
      let w3 = false;
      d2.walk((y2) => {
        if (y2.type === "class" && y2.value === _3)
          return w3 = true, false;
      }), w3 || d2.remove();
    }
    function m(d2, _3, { context: w3, candidate: y2, base: x }) {
      var g2, O3;
      let A = (O3 = w3 == null || (g2 = w3.tailwindConfig) === null || g2 === void 0 ? void 0 : g2.separator) !== null && O3 !== void 0 ? O3 : ":";
      x = x ?? (0, c2.splitAtTopLevelOnly)(y2, A).pop();
      let E2 = (0, h2.default)().astSync(d2);
      if (E2.walkClasses((M2) => {
        M2.raws && M2.value.includes(x) && (M2.raws.value = (0, l2.default)((0, p.default)(M2.raws.value)));
      }), E2.each((M2) => v3(M2, x)), E2.length === 0)
        return null;
      let b3 = Array.isArray(_3) ? r2(_3, {
        context: w3,
        candidate: y2
      }) : _3;
      if (b3 === null)
        return E2.toString();
      let k3 = h2.default.comment({
        value: "/*__simple__*/"
      }), q2 = h2.default.comment({
        value: "/*__simple__*/"
      });
      return E2.walkClasses((M2) => {
        if (M2.value !== x)
          return;
        let W3 = M2.parent, S3 = b3.nodes[0].nodes;
        if (W3.nodes.length === 1) {
          M2.replaceWith(...S3);
          return;
        }
        let P3 = i(M2);
        W3.insertBefore(P3[0], k3), W3.insertAfter(P3[P3.length - 1], q2);
        for (let R3 of S3)
          W3.insertBefore(P3[0], R3.clone());
        M2.remove(), P3 = i(k3);
        let C = W3.index(k3);
        W3.nodes.splice(C, P3.length, ...o2(h2.default.selector({
          nodes: P3
        })).nodes), k3.remove(), q2.remove();
      }), E2.walkPseudos((M2) => {
        M2.value === e2 && M2.replaceWith(M2.nodes);
      }), E2.each((M2) => (0, s2.movePseudos)(M2)), E2.toString();
    }
    function n2(d2, _3) {
      let w3 = [];
      return d2.walkPseudos((y2) => {
        y2.value === e2 && w3.push({
          pseudo: y2,
          value: y2.nodes[0].toString()
        });
      }), _3.walkPseudos((y2) => {
        if (y2.value !== e2)
          return;
        let x = y2.nodes[0].toString(), g2 = w3.find((b3) => b3.value === x);
        if (!g2)
          return;
        let O3 = [], A = y2.next();
        for (; A && A.type !== "combinator"; )
          O3.push(A), A = A.next();
        let E2 = A;
        g2.pseudo.parent.insertAfter(g2.pseudo, h2.default.selector({
          nodes: O3.map((b3) => b3.clone())
        })), y2.remove(), O3.forEach((b3) => b3.remove()), E2 && E2.type === "combinator" && E2.remove();
      }), [
        d2,
        _3
      ];
    }
  })(Gn3)), Gn3;
}
var Hn3 = {};
var Co;
function nu3() {
  return Co || (Co = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(t8, e2) {
      for (var r2 in e2) Object.defineProperty(t8, r2, {
        enumerable: true,
        get: e2[r2]
      });
    }
    a(u, {
      asClass: function() {
        return f;
      },
      default: function() {
        return s2;
      },
      formatClass: function() {
        return c2;
      }
    });
    const h2 = /* @__PURE__ */ l2(ft3()), p = /* @__PURE__ */ l2(Vi2());
    function l2(t8) {
      return t8 && t8.__esModule ? t8 : {
        default: t8
      };
    }
    function f(t8) {
      return (0, p.default)(`.${(0, h2.default)(t8)}`);
    }
    function s2(t8, e2) {
      return f(c2(t8, e2));
    }
    function c2(t8, e2) {
      return e2 === "DEFAULT" ? t8 : e2 === "-" || e2 === "-DEFAULT" ? `-${t8}` : e2.startsWith("-") ? `-${t8}${e2}` : e2.startsWith("/") ? `${t8}${e2}` : `${t8}-${e2}`;
    }
  })(Hn3)), Hn3;
}
var Jn3 = {};
var Kn3 = {};
var Xn3 = {};
var Ro3;
function Pf() {
  return Ro3 || (Ro3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return p;
      }
    });
    const a = /* @__PURE__ */ h2(pr3());
    function h2(l2) {
      return l2 && l2.__esModule ? l2 : {
        default: l2
      };
    }
    function p(l2, f = [
      [
        l2,
        [
          l2
        ]
      ]
    ], { filterDefault: s2 = false, ...c2 } = {}) {
      let t8 = (0, a.default)(l2);
      return function({ matchUtilities: e2, theme: r2 }) {
        for (let o2 of f) {
          let v3 = Array.isArray(o2[0]) ? o2 : [
            o2
          ];
          var i;
          e2(v3.reduce((m, [n2, d2]) => Object.assign(m, {
            [n2]: (_3) => d2.reduce((w3, y2) => Array.isArray(y2) ? Object.assign(w3, {
              [y2[0]]: y2[1]
            }) : Object.assign(w3, {
              [y2]: t8(_3)
            }), {})
          }), {}), {
            ...c2,
            values: s2 ? Object.fromEntries(Object.entries((i = r2(l2)) !== null && i !== void 0 ? i : {}).filter(([m]) => m !== "DEFAULT")) : r2(l2)
          });
        }
      };
    }
  })(Xn3)), Xn3;
}
var Zn3 = {};
var Io3;
function Ef() {
  return Io3 || (Io3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return i;
      }
    });
    const a = /* @__PURE__ */ new Set([
      "normal",
      "reverse",
      "alternate",
      "alternate-reverse"
    ]), h2 = /* @__PURE__ */ new Set([
      "running",
      "paused"
    ]), p = /* @__PURE__ */ new Set([
      "none",
      "forwards",
      "backwards",
      "both"
    ]), l2 = /* @__PURE__ */ new Set([
      "infinite"
    ]), f = /* @__PURE__ */ new Set([
      "linear",
      "ease",
      "ease-in",
      "ease-out",
      "ease-in-out",
      "step-start",
      "step-end"
    ]), s2 = [
      "cubic-bezier",
      "steps"
    ], c2 = /\,(?![^(]*\))/g, t8 = /\ +(?![^(]*\))/g, e2 = /^(-?[\d.]+m?s)$/, r2 = /^(\d+)$/;
    function i(o2) {
      return o2.split(c2).map((m) => {
        let n2 = m.trim(), d2 = {
          value: n2
        }, _3 = n2.split(t8), w3 = /* @__PURE__ */ new Set();
        for (let y2 of _3)
          !w3.has("DIRECTIONS") && a.has(y2) ? (d2.direction = y2, w3.add("DIRECTIONS")) : !w3.has("PLAY_STATES") && h2.has(y2) ? (d2.playState = y2, w3.add("PLAY_STATES")) : !w3.has("FILL_MODES") && p.has(y2) ? (d2.fillMode = y2, w3.add("FILL_MODES")) : !w3.has("ITERATION_COUNTS") && (l2.has(y2) || r2.test(y2)) ? (d2.iterationCount = y2, w3.add("ITERATION_COUNTS")) : !w3.has("TIMING_FUNCTION") && f.has(y2) || !w3.has("TIMING_FUNCTION") && s2.some((x) => y2.startsWith(`${x}(`)) ? (d2.timingFunction = y2, w3.add("TIMING_FUNCTION")) : !w3.has("DURATION") && e2.test(y2) ? (d2.duration = y2, w3.add("DURATION")) : !w3.has("DELAY") && e2.test(y2) ? (d2.delay = y2, w3.add("DELAY")) : w3.has("NAME") ? (d2.unknown || (d2.unknown = []), d2.unknown.push(y2)) : (d2.name = y2, w3.add("NAME"));
        return d2;
      });
    }
  })(Zn3)), Zn3;
}
var ei2 = {};
var Mo3;
function Tf() {
  return Mo3 || (Mo3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return h2;
      }
    });
    const a = (p) => Object.assign({}, ...Object.entries(p ?? {}).flatMap(([l2, f]) => typeof f == "object" ? Object.entries(a(f)).map(([s2, c2]) => ({
      [l2 + (s2 === "DEFAULT" ? "" : `-${s2}`)]: c2
    })) : [
      {
        [`${l2}`]: f
      }
    ])), h2 = a;
  })(ei2)), ei2;
}
var ti3 = {};
var Do2;
function iu3() {
  return Do2 || (Do2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      return typeof h2 == "function" ? h2({}) : h2;
    }
  })(ti3)), ti3;
}
var Af = "3.4.10";
var Cf = {
  version: Af
};
var ri3 = {};
var qo3;
function Rf() {
  return qo3 || (qo3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "removeAlphaVariables", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2, p) {
      h2.walkDecls((l2) => {
        if (p.includes(l2.prop)) {
          l2.remove();
          return;
        }
        for (let f of p)
          l2.value.includes(`/ var(${f})`) && (l2.value = l2.value.replace(`/ var(${f})`, ""));
      });
    }
  })(ri3)), ri3;
}
var Lo;
function If() {
  return Lo || (Lo = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(S3, P3) {
      for (var C in P3) Object.defineProperty(S3, C, {
        enumerable: true,
        get: P3[C]
      });
    }
    a(u, {
      variantPlugins: function() {
        return b3;
      },
      corePlugins: function() {
        return W3;
      }
    });
    const h2 = /* @__PURE__ */ O3(Ne3), p = /* @__PURE__ */ E2(Ne3), l2 = /* @__PURE__ */ O3(Be2()), f = /* @__PURE__ */ O3(Pf()), s2 = /* @__PURE__ */ O3(zi2()), c2 = /* @__PURE__ */ O3(ft3()), t8 = /* @__PURE__ */ O3(Ef()), e2 = /* @__PURE__ */ O3(Tf()), r2 = /* @__PURE__ */ E2(hr3()), i = /* @__PURE__ */ O3(iu3()), o2 = /* @__PURE__ */ O3(ut3()), v3 = /* @__PURE__ */ O3(pr3()), m = Cf, n2 = /* @__PURE__ */ O3(tt3()), d2 = Ui2(), _3 = $l(), w3 = Rf(), y2 = it3(), x = vr3(), g2 = Ki2();
    function O3(S3) {
      return S3 && S3.__esModule ? S3 : {
        default: S3
      };
    }
    function A(S3) {
      if (typeof WeakMap != "function") return null;
      var P3 = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap();
      return (A = function(R3) {
        return R3 ? C : P3;
      })(S3);
    }
    function E2(S3, P3) {
      if (S3 && S3.__esModule)
        return S3;
      if (S3 === null || typeof S3 != "object" && typeof S3 != "function")
        return {
          default: S3
        };
      var C = A(P3);
      if (C && C.has(S3))
        return C.get(S3);
      var R3 = {}, $2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var B3 in S3)
        if (B3 !== "default" && Object.prototype.hasOwnProperty.call(S3, B3)) {
          var z3 = $2 ? Object.getOwnPropertyDescriptor(S3, B3) : null;
          z3 && (z3.get || z3.set) ? Object.defineProperty(R3, B3, z3) : R3[B3] = S3[B3];
        }
      return R3.default = S3, C && C.set(S3, R3), R3;
    }
    let b3 = {
      childVariant: ({ addVariant: S3 }) => {
        S3("*", "& > *");
      },
      pseudoElementVariants: ({ addVariant: S3 }) => {
        S3("first-letter", "&::first-letter"), S3("first-line", "&::first-line"), S3("marker", [
          ({ container: P3 }) => ((0, w3.removeAlphaVariables)(P3, [
            "--tw-text-opacity"
          ]), "& *::marker"),
          ({ container: P3 }) => ((0, w3.removeAlphaVariables)(P3, [
            "--tw-text-opacity"
          ]), "&::marker")
        ]), S3("selection", [
          "& *::selection",
          "&::selection"
        ]), S3("file", "&::file-selector-button"), S3("placeholder", "&::placeholder"), S3("backdrop", "&::backdrop"), S3("before", ({ container: P3 }) => (P3.walkRules((C) => {
          let R3 = false;
          C.walkDecls("content", () => {
            R3 = true;
          }), R3 || C.prepend(l2.default.decl({
            prop: "content",
            value: "var(--tw-content)"
          }));
        }), "&::before")), S3("after", ({ container: P3 }) => (P3.walkRules((C) => {
          let R3 = false;
          C.walkDecls("content", () => {
            R3 = true;
          }), R3 || C.prepend(l2.default.decl({
            prop: "content",
            value: "var(--tw-content)"
          }));
        }), "&::after"));
      },
      pseudoClassVariants: ({ addVariant: S3, matchVariant: P3, config: C, prefix: R3 }) => {
        let $2 = [
          // Positional
          [
            "first",
            "&:first-child"
          ],
          [
            "last",
            "&:last-child"
          ],
          [
            "only",
            "&:only-child"
          ],
          [
            "odd",
            "&:nth-child(odd)"
          ],
          [
            "even",
            "&:nth-child(even)"
          ],
          "first-of-type",
          "last-of-type",
          "only-of-type",
          // State
          [
            "visited",
            ({ container: z3 }) => ((0, w3.removeAlphaVariables)(z3, [
              "--tw-text-opacity",
              "--tw-border-opacity",
              "--tw-bg-opacity"
            ]), "&:visited")
          ],
          "target",
          [
            "open",
            "&[open]"
          ],
          // Forms
          "default",
          "checked",
          "indeterminate",
          "placeholder-shown",
          "autofill",
          "optional",
          "required",
          "valid",
          "invalid",
          "in-range",
          "out-of-range",
          "read-only",
          // Content
          "empty",
          // Interactive
          "focus-within",
          [
            "hover",
            (0, y2.flagEnabled)(C(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"
          ],
          "focus",
          "focus-visible",
          "active",
          "enabled",
          "disabled"
        ].map((z3) => Array.isArray(z3) ? z3 : [
          z3,
          `&:${z3}`
        ]);
        for (let [z3, L3] of $2)
          S3(z3, (F) => typeof L3 == "function" ? L3(F) : L3);
        let B3 = {
          group: (z3, { modifier: L3 }) => L3 ? [
            `:merge(${R3(".group")}\\/${(0, c2.default)(L3)})`,
            " &"
          ] : [
            `:merge(${R3(".group")})`,
            " &"
          ],
          peer: (z3, { modifier: L3 }) => L3 ? [
            `:merge(${R3(".peer")}\\/${(0, c2.default)(L3)})`,
            " ~ &"
          ] : [
            `:merge(${R3(".peer")})`,
            " ~ &"
          ]
        };
        for (let [z3, L3] of Object.entries(B3))
          P3(z3, (F = "", D) => {
            let I3 = (0, x.normalize)(typeof F == "function" ? F(D) : F);
            I3.includes("&") || (I3 = "&" + I3);
            let [N3, J3] = L3("", D), T3 = null, U2 = null, j3 = 0;
            for (let H3 = 0; H3 < I3.length; ++H3) {
              let V4 = I3[H3];
              V4 === "&" ? T3 = H3 : V4 === "'" || V4 === '"' ? j3 += 1 : T3 !== null && V4 === " " && !j3 && (U2 = H3);
            }
            return T3 !== null && U2 === null && (U2 = I3.length), I3.slice(0, T3) + N3 + I3.slice(T3 + 1, U2) + J3 + I3.slice(U2);
          }, {
            values: Object.fromEntries($2),
            [g2.INTERNAL_FEATURES]: {
              respectPrefix: false
            }
          });
      },
      directionVariants: ({ addVariant: S3 }) => {
        S3("ltr", '&:where([dir="ltr"], [dir="ltr"] *)'), S3("rtl", '&:where([dir="rtl"], [dir="rtl"] *)');
      },
      reducedMotionVariants: ({ addVariant: S3 }) => {
        S3("motion-safe", "@media (prefers-reduced-motion: no-preference)"), S3("motion-reduce", "@media (prefers-reduced-motion: reduce)");
      },
      darkVariants: ({ config: S3, addVariant: P3 }) => {
        let [C, R3 = ".dark"] = [].concat(S3("darkMode", "media"));
        if (C === false && (C = "media", n2.default.warn("darkmode-false", [
          "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
          "Change `darkMode` to `media` or remove it entirely.",
          "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
        ])), C === "variant") {
          let $2;
          if (Array.isArray(R3) || typeof R3 == "function" ? $2 = R3 : typeof R3 == "string" && ($2 = [
            R3
          ]), Array.isArray($2))
            for (let B3 of $2)
              B3 === ".dark" ? (C = false, n2.default.warn("darkmode-variant-without-selector", [
                "When using `variant` for `darkMode`, you must provide a selector.",
                'Example: `darkMode: ["variant", ".your-selector &"]`'
              ])) : B3.includes("&") || (C = false, n2.default.warn("darkmode-variant-without-ampersand", [
                "When using `variant` for `darkMode`, your selector must contain `&`.",
                'Example `darkMode: ["variant", ".your-selector &"]`'
              ]));
          R3 = $2;
        }
        C === "selector" ? P3("dark", `&:where(${R3}, ${R3} *)`) : C === "media" ? P3("dark", "@media (prefers-color-scheme: dark)") : C === "variant" ? P3("dark", R3) : C === "class" && P3("dark", `&:is(${R3} *)`);
      },
      printVariant: ({ addVariant: S3 }) => {
        S3("print", "@media print");
      },
      screenVariants: ({ theme: S3, addVariant: P3, matchVariant: C }) => {
        var R3;
        let $2 = (R3 = S3("screens")) !== null && R3 !== void 0 ? R3 : {}, B3 = Object.values($2).every((K3) => typeof K3 == "string"), z3 = (0, d2.normalizeScreens)(S3("screens")), L3 = /* @__PURE__ */ new Set([]);
        function F(K3) {
          var X3, Q3;
          return (Q3 = (X3 = K3.match(/(\D+)$/)) === null || X3 === void 0 ? void 0 : X3[1]) !== null && Q3 !== void 0 ? Q3 : "(none)";
        }
        function D(K3) {
          K3 !== void 0 && L3.add(F(K3));
        }
        function I3(K3) {
          return D(K3), L3.size === 1;
        }
        for (const K3 of z3)
          for (const X3 of K3.values)
            D(X3.min), D(X3.max);
        let N3 = L3.size <= 1;
        function J3(K3) {
          return Object.fromEntries(z3.filter((X3) => (0, d2.isScreenSortable)(X3).result).map((X3) => {
            let { min: Q3, max: ne3 } = X3.values[0];
            if (ne3 !== void 0)
              return X3;
            if (Q3 !== void 0)
              return {
                ...X3,
                not: !X3.not
              };
          }).map((X3) => [
            X3.name,
            X3
          ]));
        }
        function T3(K3) {
          return (X3, Q3) => (0, d2.compareScreens)(K3, X3.value, Q3.value);
        }
        let U2 = T3("max"), j3 = T3("min");
        function H3(K3) {
          return (X3) => {
            if (B3)
              if (N3) {
                if (typeof X3 == "string" && !I3(X3))
                  return n2.default.warn("minmax-have-mixed-units", [
                    "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
                  ]), [];
              } else return n2.default.warn("mixed-screen-units", [
                "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
              ]), [];
            else return n2.default.warn("complex-screen-config", [
              "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
            ]), [];
            return [
              `@media ${(0, s2.default)((0, d2.toScreen)(X3, K3))}`
            ];
          };
        }
        C("max", H3("max"), {
          sort: U2,
          values: B3 ? J3() : {}
        });
        let V4 = "min-screens";
        for (let K3 of z3)
          P3(K3.name, `@media ${(0, s2.default)(K3)}`, {
            id: V4,
            sort: B3 && N3 ? j3 : void 0,
            value: K3
          });
        C("min", H3("min"), {
          id: V4,
          sort: j3
        });
      },
      supportsVariants: ({ matchVariant: S3, theme: P3 }) => {
        var C;
        S3("supports", (R3 = "") => {
          let $2 = (0, x.normalize)(R3), B3 = /^\w*\s*\(/.test($2);
          return $2 = B3 ? $2.replace(/\b(and|or|not)\b/g, " $1 ") : $2, B3 ? `@supports ${$2}` : ($2.includes(":") || ($2 = `${$2}: var(--tw)`), $2.startsWith("(") && $2.endsWith(")") || ($2 = `(${$2})`), `@supports ${$2}`);
        }, {
          values: (C = P3("supports")) !== null && C !== void 0 ? C : {}
        });
      },
      hasVariants: ({ matchVariant: S3, prefix: P3 }) => {
        S3("has", (C) => `&:has(${(0, x.normalize)(C)})`, {
          values: {},
          [g2.INTERNAL_FEATURES]: {
            respectPrefix: false
          }
        }), S3("group-has", (C, { modifier: R3 }) => R3 ? `:merge(${P3(".group")}\\/${R3}):has(${(0, x.normalize)(C)}) &` : `:merge(${P3(".group")}):has(${(0, x.normalize)(C)}) &`, {
          values: {},
          [g2.INTERNAL_FEATURES]: {
            respectPrefix: false
          }
        }), S3("peer-has", (C, { modifier: R3 }) => R3 ? `:merge(${P3(".peer")}\\/${R3}):has(${(0, x.normalize)(C)}) ~ &` : `:merge(${P3(".peer")}):has(${(0, x.normalize)(C)}) ~ &`, {
          values: {},
          [g2.INTERNAL_FEATURES]: {
            respectPrefix: false
          }
        });
      },
      ariaVariants: ({ matchVariant: S3, theme: P3 }) => {
        var C;
        S3("aria", (B3) => `&[aria-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}]`, {
          values: (C = P3("aria")) !== null && C !== void 0 ? C : {}
        });
        var R3;
        S3("group-aria", (B3, { modifier: z3 }) => z3 ? `:merge(.group\\/${z3})[aria-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] &` : `:merge(.group)[aria-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] &`, {
          values: (R3 = P3("aria")) !== null && R3 !== void 0 ? R3 : {}
        });
        var $2;
        S3("peer-aria", (B3, { modifier: z3 }) => z3 ? `:merge(.peer\\/${z3})[aria-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] ~ &` : `:merge(.peer)[aria-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] ~ &`, {
          values: ($2 = P3("aria")) !== null && $2 !== void 0 ? $2 : {}
        });
      },
      dataVariants: ({ matchVariant: S3, theme: P3 }) => {
        var C;
        S3("data", (B3) => `&[data-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}]`, {
          values: (C = P3("data")) !== null && C !== void 0 ? C : {}
        });
        var R3;
        S3("group-data", (B3, { modifier: z3 }) => z3 ? `:merge(.group\\/${z3})[data-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] &` : `:merge(.group)[data-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] &`, {
          values: (R3 = P3("data")) !== null && R3 !== void 0 ? R3 : {}
        });
        var $2;
        S3("peer-data", (B3, { modifier: z3 }) => z3 ? `:merge(.peer\\/${z3})[data-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] ~ &` : `:merge(.peer)[data-${(0, x.normalizeAttributeSelectors)((0, x.normalize)(B3))}] ~ &`, {
          values: ($2 = P3("data")) !== null && $2 !== void 0 ? $2 : {}
        });
      },
      orientationVariants: ({ addVariant: S3 }) => {
        S3("portrait", "@media (orientation: portrait)"), S3("landscape", "@media (orientation: landscape)");
      },
      prefersContrastVariants: ({ addVariant: S3 }) => {
        S3("contrast-more", "@media (prefers-contrast: more)"), S3("contrast-less", "@media (prefers-contrast: less)");
      },
      forcedColorsVariants: ({ addVariant: S3 }) => {
        S3("forced-colors", "@media (forced-colors: active)");
      }
    }, k3 = [
      "translate(var(--tw-translate-x), var(--tw-translate-y))",
      "rotate(var(--tw-rotate))",
      "skewX(var(--tw-skew-x))",
      "skewY(var(--tw-skew-y))",
      "scaleX(var(--tw-scale-x))",
      "scaleY(var(--tw-scale-y))"
    ].join(" "), q2 = [
      "var(--tw-blur)",
      "var(--tw-brightness)",
      "var(--tw-contrast)",
      "var(--tw-grayscale)",
      "var(--tw-hue-rotate)",
      "var(--tw-invert)",
      "var(--tw-saturate)",
      "var(--tw-sepia)",
      "var(--tw-drop-shadow)"
    ].join(" "), M2 = [
      "var(--tw-backdrop-blur)",
      "var(--tw-backdrop-brightness)",
      "var(--tw-backdrop-contrast)",
      "var(--tw-backdrop-grayscale)",
      "var(--tw-backdrop-hue-rotate)",
      "var(--tw-backdrop-invert)",
      "var(--tw-backdrop-opacity)",
      "var(--tw-backdrop-saturate)",
      "var(--tw-backdrop-sepia)"
    ].join(" "), W3 = {
      preflight: ({ addBase: S3 }) => {
        let P3 = l2.default.parse(h2.default.readFileSync(p.join(__dirname, "./css/preflight.css"), "utf8"));
        S3([
          l2.default.comment({
            text: `! tailwindcss v${m.version} | MIT License | https://tailwindcss.com`
          }),
          ...P3.nodes
        ]);
      },
      container: /* @__PURE__ */ (() => {
        function S3(C = []) {
          return C.flatMap((R3) => R3.values.map(($2) => $2.min)).filter((R3) => R3 !== void 0);
        }
        function P3(C, R3, $2) {
          if (typeof $2 > "u")
            return [];
          if (!(typeof $2 == "object" && $2 !== null))
            return [
              {
                screen: "DEFAULT",
                minWidth: 0,
                padding: $2
              }
            ];
          let B3 = [];
          $2.DEFAULT && B3.push({
            screen: "DEFAULT",
            minWidth: 0,
            padding: $2.DEFAULT
          });
          for (let z3 of C)
            for (let L3 of R3)
              for (let { min: F } of L3.values)
                F === z3 && B3.push({
                  minWidth: z3,
                  padding: $2[L3.name]
                });
          return B3;
        }
        return function({ addComponents: C, theme: R3 }) {
          let $2 = (0, d2.normalizeScreens)(R3("container.screens", R3("screens"))), B3 = S3($2), z3 = P3(B3, $2, R3("container.padding")), L3 = (D) => {
            let I3 = z3.find((N3) => N3.minWidth === D);
            return I3 ? {
              paddingRight: I3.padding,
              paddingLeft: I3.padding
            } : {};
          }, F = Array.from(new Set(B3.slice().sort((D, I3) => parseInt(D) - parseInt(I3)))).map((D) => ({
            [`@media (min-width: ${D})`]: {
              ".container": {
                "max-width": D,
                ...L3(D)
              }
            }
          }));
          C([
            {
              ".container": Object.assign({
                width: "100%"
              }, R3("container.center", false) ? {
                marginRight: "auto",
                marginLeft: "auto"
              } : {}, L3(0))
            },
            ...F
          ]);
        };
      })(),
      accessibility: ({ addUtilities: S3 }) => {
        S3({
          ".sr-only": {
            position: "absolute",
            width: "1px",
            height: "1px",
            padding: "0",
            margin: "-1px",
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            whiteSpace: "nowrap",
            borderWidth: "0"
          },
          ".not-sr-only": {
            position: "static",
            width: "auto",
            height: "auto",
            padding: "0",
            margin: "0",
            overflow: "visible",
            clip: "auto",
            whiteSpace: "normal"
          }
        });
      },
      pointerEvents: ({ addUtilities: S3 }) => {
        S3({
          ".pointer-events-none": {
            "pointer-events": "none"
          },
          ".pointer-events-auto": {
            "pointer-events": "auto"
          }
        });
      },
      visibility: ({ addUtilities: S3 }) => {
        S3({
          ".visible": {
            visibility: "visible"
          },
          ".invisible": {
            visibility: "hidden"
          },
          ".collapse": {
            visibility: "collapse"
          }
        });
      },
      position: ({ addUtilities: S3 }) => {
        S3({
          ".static": {
            position: "static"
          },
          ".fixed": {
            position: "fixed"
          },
          ".absolute": {
            position: "absolute"
          },
          ".relative": {
            position: "relative"
          },
          ".sticky": {
            position: "sticky"
          }
        });
      },
      inset: (0, f.default)("inset", [
        [
          "inset",
          [
            "inset"
          ]
        ],
        [
          [
            "inset-x",
            [
              "left",
              "right"
            ]
          ],
          [
            "inset-y",
            [
              "top",
              "bottom"
            ]
          ]
        ],
        [
          [
            "start",
            [
              "inset-inline-start"
            ]
          ],
          [
            "end",
            [
              "inset-inline-end"
            ]
          ],
          [
            "top",
            [
              "top"
            ]
          ],
          [
            "right",
            [
              "right"
            ]
          ],
          [
            "bottom",
            [
              "bottom"
            ]
          ],
          [
            "left",
            [
              "left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      isolation: ({ addUtilities: S3 }) => {
        S3({
          ".isolate": {
            isolation: "isolate"
          },
          ".isolation-auto": {
            isolation: "auto"
          }
        });
      },
      zIndex: (0, f.default)("zIndex", [
        [
          "z",
          [
            "zIndex"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      order: (0, f.default)("order", void 0, {
        supportsNegativeValues: true
      }),
      gridColumn: (0, f.default)("gridColumn", [
        [
          "col",
          [
            "gridColumn"
          ]
        ]
      ]),
      gridColumnStart: (0, f.default)("gridColumnStart", [
        [
          "col-start",
          [
            "gridColumnStart"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      gridColumnEnd: (0, f.default)("gridColumnEnd", [
        [
          "col-end",
          [
            "gridColumnEnd"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      gridRow: (0, f.default)("gridRow", [
        [
          "row",
          [
            "gridRow"
          ]
        ]
      ]),
      gridRowStart: (0, f.default)("gridRowStart", [
        [
          "row-start",
          [
            "gridRowStart"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      gridRowEnd: (0, f.default)("gridRowEnd", [
        [
          "row-end",
          [
            "gridRowEnd"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      float: ({ addUtilities: S3 }) => {
        S3({
          ".float-start": {
            float: "inline-start"
          },
          ".float-end": {
            float: "inline-end"
          },
          ".float-right": {
            float: "right"
          },
          ".float-left": {
            float: "left"
          },
          ".float-none": {
            float: "none"
          }
        });
      },
      clear: ({ addUtilities: S3 }) => {
        S3({
          ".clear-start": {
            clear: "inline-start"
          },
          ".clear-end": {
            clear: "inline-end"
          },
          ".clear-left": {
            clear: "left"
          },
          ".clear-right": {
            clear: "right"
          },
          ".clear-both": {
            clear: "both"
          },
          ".clear-none": {
            clear: "none"
          }
        });
      },
      margin: (0, f.default)("margin", [
        [
          "m",
          [
            "margin"
          ]
        ],
        [
          [
            "mx",
            [
              "margin-left",
              "margin-right"
            ]
          ],
          [
            "my",
            [
              "margin-top",
              "margin-bottom"
            ]
          ]
        ],
        [
          [
            "ms",
            [
              "margin-inline-start"
            ]
          ],
          [
            "me",
            [
              "margin-inline-end"
            ]
          ],
          [
            "mt",
            [
              "margin-top"
            ]
          ],
          [
            "mr",
            [
              "margin-right"
            ]
          ],
          [
            "mb",
            [
              "margin-bottom"
            ]
          ],
          [
            "ml",
            [
              "margin-left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      boxSizing: ({ addUtilities: S3 }) => {
        S3({
          ".box-border": {
            "box-sizing": "border-box"
          },
          ".box-content": {
            "box-sizing": "content-box"
          }
        });
      },
      lineClamp: ({ matchUtilities: S3, addUtilities: P3, theme: C }) => {
        S3({
          "line-clamp": (R3) => ({
            overflow: "hidden",
            display: "-webkit-box",
            "-webkit-box-orient": "vertical",
            "-webkit-line-clamp": `${R3}`
          })
        }, {
          values: C("lineClamp")
        }), P3({
          ".line-clamp-none": {
            overflow: "visible",
            display: "block",
            "-webkit-box-orient": "horizontal",
            "-webkit-line-clamp": "none"
          }
        });
      },
      display: ({ addUtilities: S3 }) => {
        S3({
          ".block": {
            display: "block"
          },
          ".inline-block": {
            display: "inline-block"
          },
          ".inline": {
            display: "inline"
          },
          ".flex": {
            display: "flex"
          },
          ".inline-flex": {
            display: "inline-flex"
          },
          ".table": {
            display: "table"
          },
          ".inline-table": {
            display: "inline-table"
          },
          ".table-caption": {
            display: "table-caption"
          },
          ".table-cell": {
            display: "table-cell"
          },
          ".table-column": {
            display: "table-column"
          },
          ".table-column-group": {
            display: "table-column-group"
          },
          ".table-footer-group": {
            display: "table-footer-group"
          },
          ".table-header-group": {
            display: "table-header-group"
          },
          ".table-row-group": {
            display: "table-row-group"
          },
          ".table-row": {
            display: "table-row"
          },
          ".flow-root": {
            display: "flow-root"
          },
          ".grid": {
            display: "grid"
          },
          ".inline-grid": {
            display: "inline-grid"
          },
          ".contents": {
            display: "contents"
          },
          ".list-item": {
            display: "list-item"
          },
          ".hidden": {
            display: "none"
          }
        });
      },
      aspectRatio: (0, f.default)("aspectRatio", [
        [
          "aspect",
          [
            "aspect-ratio"
          ]
        ]
      ]),
      size: (0, f.default)("size", [
        [
          "size",
          [
            "width",
            "height"
          ]
        ]
      ]),
      height: (0, f.default)("height", [
        [
          "h",
          [
            "height"
          ]
        ]
      ]),
      maxHeight: (0, f.default)("maxHeight", [
        [
          "max-h",
          [
            "maxHeight"
          ]
        ]
      ]),
      minHeight: (0, f.default)("minHeight", [
        [
          "min-h",
          [
            "minHeight"
          ]
        ]
      ]),
      width: (0, f.default)("width", [
        [
          "w",
          [
            "width"
          ]
        ]
      ]),
      minWidth: (0, f.default)("minWidth", [
        [
          "min-w",
          [
            "minWidth"
          ]
        ]
      ]),
      maxWidth: (0, f.default)("maxWidth", [
        [
          "max-w",
          [
            "maxWidth"
          ]
        ]
      ]),
      flex: (0, f.default)("flex"),
      flexShrink: (0, f.default)("flexShrink", [
        [
          "flex-shrink",
          [
            "flex-shrink"
          ]
        ],
        [
          "shrink",
          [
            "flex-shrink"
          ]
        ]
      ]),
      flexGrow: (0, f.default)("flexGrow", [
        [
          "flex-grow",
          [
            "flex-grow"
          ]
        ],
        [
          "grow",
          [
            "flex-grow"
          ]
        ]
      ]),
      flexBasis: (0, f.default)("flexBasis", [
        [
          "basis",
          [
            "flex-basis"
          ]
        ]
      ]),
      tableLayout: ({ addUtilities: S3 }) => {
        S3({
          ".table-auto": {
            "table-layout": "auto"
          },
          ".table-fixed": {
            "table-layout": "fixed"
          }
        });
      },
      captionSide: ({ addUtilities: S3 }) => {
        S3({
          ".caption-top": {
            "caption-side": "top"
          },
          ".caption-bottom": {
            "caption-side": "bottom"
          }
        });
      },
      borderCollapse: ({ addUtilities: S3 }) => {
        S3({
          ".border-collapse": {
            "border-collapse": "collapse"
          },
          ".border-separate": {
            "border-collapse": "separate"
          }
        });
      },
      borderSpacing: ({ addDefaults: S3, matchUtilities: P3, theme: C }) => {
        S3("border-spacing", {
          "--tw-border-spacing-x": 0,
          "--tw-border-spacing-y": 0
        }), P3({
          "border-spacing": (R3) => ({
            "--tw-border-spacing-x": R3,
            "--tw-border-spacing-y": R3,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          }),
          "border-spacing-x": (R3) => ({
            "--tw-border-spacing-x": R3,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          }),
          "border-spacing-y": (R3) => ({
            "--tw-border-spacing-y": R3,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          })
        }, {
          values: C("borderSpacing")
        });
      },
      transformOrigin: (0, f.default)("transformOrigin", [
        [
          "origin",
          [
            "transformOrigin"
          ]
        ]
      ]),
      translate: (0, f.default)("translate", [
        [
          [
            "translate-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-translate-x",
              [
                "transform",
                k3
              ]
            ]
          ],
          [
            "translate-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-translate-y",
              [
                "transform",
                k3
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      rotate: (0, f.default)("rotate", [
        [
          "rotate",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-rotate",
            [
              "transform",
              k3
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      skew: (0, f.default)("skew", [
        [
          [
            "skew-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-skew-x",
              [
                "transform",
                k3
              ]
            ]
          ],
          [
            "skew-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-skew-y",
              [
                "transform",
                k3
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      scale: (0, f.default)("scale", [
        [
          "scale",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-scale-x",
            "--tw-scale-y",
            [
              "transform",
              k3
            ]
          ]
        ],
        [
          [
            "scale-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-scale-x",
              [
                "transform",
                k3
              ]
            ]
          ],
          [
            "scale-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-scale-y",
              [
                "transform",
                k3
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      transform: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("transform", {
          "--tw-translate-x": "0",
          "--tw-translate-y": "0",
          "--tw-rotate": "0",
          "--tw-skew-x": "0",
          "--tw-skew-y": "0",
          "--tw-scale-x": "1",
          "--tw-scale-y": "1"
        }), P3({
          ".transform": {
            "@defaults transform": {},
            transform: k3
          },
          ".transform-cpu": {
            transform: k3
          },
          ".transform-gpu": {
            transform: k3.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)")
          },
          ".transform-none": {
            transform: "none"
          }
        });
      },
      animation: ({ matchUtilities: S3, theme: P3, config: C }) => {
        let R3 = (z3) => (0, c2.default)(C("prefix") + z3);
        var $2;
        let B3 = Object.fromEntries(Object.entries(($2 = P3("keyframes")) !== null && $2 !== void 0 ? $2 : {}).map(([z3, L3]) => [
          z3,
          {
            [`@keyframes ${R3(z3)}`]: L3
          }
        ]));
        S3({
          animate: (z3) => {
            let L3 = (0, t8.default)(z3);
            return [
              ...L3.flatMap((F) => B3[F.name]),
              {
                animation: L3.map(({ name: F, value: D }) => F === void 0 || B3[F] === void 0 ? D : D.replace(F, R3(F))).join(", ")
              }
            ];
          }
        }, {
          values: P3("animation")
        });
      },
      cursor: (0, f.default)("cursor"),
      touchAction: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("touch-action", {
          "--tw-pan-x": " ",
          "--tw-pan-y": " ",
          "--tw-pinch-zoom": " "
        });
        let C = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
        P3({
          ".touch-auto": {
            "touch-action": "auto"
          },
          ".touch-none": {
            "touch-action": "none"
          },
          ".touch-pan-x": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-x",
            "touch-action": C
          },
          ".touch-pan-left": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-left",
            "touch-action": C
          },
          ".touch-pan-right": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-right",
            "touch-action": C
          },
          ".touch-pan-y": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-y",
            "touch-action": C
          },
          ".touch-pan-up": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-up",
            "touch-action": C
          },
          ".touch-pan-down": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-down",
            "touch-action": C
          },
          ".touch-pinch-zoom": {
            "@defaults touch-action": {},
            "--tw-pinch-zoom": "pinch-zoom",
            "touch-action": C
          },
          ".touch-manipulation": {
            "touch-action": "manipulation"
          }
        });
      },
      userSelect: ({ addUtilities: S3 }) => {
        S3({
          ".select-none": {
            "user-select": "none"
          },
          ".select-text": {
            "user-select": "text"
          },
          ".select-all": {
            "user-select": "all"
          },
          ".select-auto": {
            "user-select": "auto"
          }
        });
      },
      resize: ({ addUtilities: S3 }) => {
        S3({
          ".resize-none": {
            resize: "none"
          },
          ".resize-y": {
            resize: "vertical"
          },
          ".resize-x": {
            resize: "horizontal"
          },
          ".resize": {
            resize: "both"
          }
        });
      },
      scrollSnapType: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("scroll-snap-type", {
          "--tw-scroll-snap-strictness": "proximity"
        }), P3({
          ".snap-none": {
            "scroll-snap-type": "none"
          },
          ".snap-x": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
          },
          ".snap-y": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
          },
          ".snap-both": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
          },
          ".snap-mandatory": {
            "--tw-scroll-snap-strictness": "mandatory"
          },
          ".snap-proximity": {
            "--tw-scroll-snap-strictness": "proximity"
          }
        });
      },
      scrollSnapAlign: ({ addUtilities: S3 }) => {
        S3({
          ".snap-start": {
            "scroll-snap-align": "start"
          },
          ".snap-end": {
            "scroll-snap-align": "end"
          },
          ".snap-center": {
            "scroll-snap-align": "center"
          },
          ".snap-align-none": {
            "scroll-snap-align": "none"
          }
        });
      },
      scrollSnapStop: ({ addUtilities: S3 }) => {
        S3({
          ".snap-normal": {
            "scroll-snap-stop": "normal"
          },
          ".snap-always": {
            "scroll-snap-stop": "always"
          }
        });
      },
      scrollMargin: (0, f.default)("scrollMargin", [
        [
          "scroll-m",
          [
            "scroll-margin"
          ]
        ],
        [
          [
            "scroll-mx",
            [
              "scroll-margin-left",
              "scroll-margin-right"
            ]
          ],
          [
            "scroll-my",
            [
              "scroll-margin-top",
              "scroll-margin-bottom"
            ]
          ]
        ],
        [
          [
            "scroll-ms",
            [
              "scroll-margin-inline-start"
            ]
          ],
          [
            "scroll-me",
            [
              "scroll-margin-inline-end"
            ]
          ],
          [
            "scroll-mt",
            [
              "scroll-margin-top"
            ]
          ],
          [
            "scroll-mr",
            [
              "scroll-margin-right"
            ]
          ],
          [
            "scroll-mb",
            [
              "scroll-margin-bottom"
            ]
          ],
          [
            "scroll-ml",
            [
              "scroll-margin-left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      scrollPadding: (0, f.default)("scrollPadding", [
        [
          "scroll-p",
          [
            "scroll-padding"
          ]
        ],
        [
          [
            "scroll-px",
            [
              "scroll-padding-left",
              "scroll-padding-right"
            ]
          ],
          [
            "scroll-py",
            [
              "scroll-padding-top",
              "scroll-padding-bottom"
            ]
          ]
        ],
        [
          [
            "scroll-ps",
            [
              "scroll-padding-inline-start"
            ]
          ],
          [
            "scroll-pe",
            [
              "scroll-padding-inline-end"
            ]
          ],
          [
            "scroll-pt",
            [
              "scroll-padding-top"
            ]
          ],
          [
            "scroll-pr",
            [
              "scroll-padding-right"
            ]
          ],
          [
            "scroll-pb",
            [
              "scroll-padding-bottom"
            ]
          ],
          [
            "scroll-pl",
            [
              "scroll-padding-left"
            ]
          ]
        ]
      ]),
      listStylePosition: ({ addUtilities: S3 }) => {
        S3({
          ".list-inside": {
            "list-style-position": "inside"
          },
          ".list-outside": {
            "list-style-position": "outside"
          }
        });
      },
      listStyleType: (0, f.default)("listStyleType", [
        [
          "list",
          [
            "listStyleType"
          ]
        ]
      ]),
      listStyleImage: (0, f.default)("listStyleImage", [
        [
          "list-image",
          [
            "listStyleImage"
          ]
        ]
      ]),
      appearance: ({ addUtilities: S3 }) => {
        S3({
          ".appearance-none": {
            appearance: "none"
          },
          ".appearance-auto": {
            appearance: "auto"
          }
        });
      },
      columns: (0, f.default)("columns", [
        [
          "columns",
          [
            "columns"
          ]
        ]
      ]),
      breakBefore: ({ addUtilities: S3 }) => {
        S3({
          ".break-before-auto": {
            "break-before": "auto"
          },
          ".break-before-avoid": {
            "break-before": "avoid"
          },
          ".break-before-all": {
            "break-before": "all"
          },
          ".break-before-avoid-page": {
            "break-before": "avoid-page"
          },
          ".break-before-page": {
            "break-before": "page"
          },
          ".break-before-left": {
            "break-before": "left"
          },
          ".break-before-right": {
            "break-before": "right"
          },
          ".break-before-column": {
            "break-before": "column"
          }
        });
      },
      breakInside: ({ addUtilities: S3 }) => {
        S3({
          ".break-inside-auto": {
            "break-inside": "auto"
          },
          ".break-inside-avoid": {
            "break-inside": "avoid"
          },
          ".break-inside-avoid-page": {
            "break-inside": "avoid-page"
          },
          ".break-inside-avoid-column": {
            "break-inside": "avoid-column"
          }
        });
      },
      breakAfter: ({ addUtilities: S3 }) => {
        S3({
          ".break-after-auto": {
            "break-after": "auto"
          },
          ".break-after-avoid": {
            "break-after": "avoid"
          },
          ".break-after-all": {
            "break-after": "all"
          },
          ".break-after-avoid-page": {
            "break-after": "avoid-page"
          },
          ".break-after-page": {
            "break-after": "page"
          },
          ".break-after-left": {
            "break-after": "left"
          },
          ".break-after-right": {
            "break-after": "right"
          },
          ".break-after-column": {
            "break-after": "column"
          }
        });
      },
      gridAutoColumns: (0, f.default)("gridAutoColumns", [
        [
          "auto-cols",
          [
            "gridAutoColumns"
          ]
        ]
      ]),
      gridAutoFlow: ({ addUtilities: S3 }) => {
        S3({
          ".grid-flow-row": {
            gridAutoFlow: "row"
          },
          ".grid-flow-col": {
            gridAutoFlow: "column"
          },
          ".grid-flow-dense": {
            gridAutoFlow: "dense"
          },
          ".grid-flow-row-dense": {
            gridAutoFlow: "row dense"
          },
          ".grid-flow-col-dense": {
            gridAutoFlow: "column dense"
          }
        });
      },
      gridAutoRows: (0, f.default)("gridAutoRows", [
        [
          "auto-rows",
          [
            "gridAutoRows"
          ]
        ]
      ]),
      gridTemplateColumns: (0, f.default)("gridTemplateColumns", [
        [
          "grid-cols",
          [
            "gridTemplateColumns"
          ]
        ]
      ]),
      gridTemplateRows: (0, f.default)("gridTemplateRows", [
        [
          "grid-rows",
          [
            "gridTemplateRows"
          ]
        ]
      ]),
      flexDirection: ({ addUtilities: S3 }) => {
        S3({
          ".flex-row": {
            "flex-direction": "row"
          },
          ".flex-row-reverse": {
            "flex-direction": "row-reverse"
          },
          ".flex-col": {
            "flex-direction": "column"
          },
          ".flex-col-reverse": {
            "flex-direction": "column-reverse"
          }
        });
      },
      flexWrap: ({ addUtilities: S3 }) => {
        S3({
          ".flex-wrap": {
            "flex-wrap": "wrap"
          },
          ".flex-wrap-reverse": {
            "flex-wrap": "wrap-reverse"
          },
          ".flex-nowrap": {
            "flex-wrap": "nowrap"
          }
        });
      },
      placeContent: ({ addUtilities: S3 }) => {
        S3({
          ".place-content-center": {
            "place-content": "center"
          },
          ".place-content-start": {
            "place-content": "start"
          },
          ".place-content-end": {
            "place-content": "end"
          },
          ".place-content-between": {
            "place-content": "space-between"
          },
          ".place-content-around": {
            "place-content": "space-around"
          },
          ".place-content-evenly": {
            "place-content": "space-evenly"
          },
          ".place-content-baseline": {
            "place-content": "baseline"
          },
          ".place-content-stretch": {
            "place-content": "stretch"
          }
        });
      },
      placeItems: ({ addUtilities: S3 }) => {
        S3({
          ".place-items-start": {
            "place-items": "start"
          },
          ".place-items-end": {
            "place-items": "end"
          },
          ".place-items-center": {
            "place-items": "center"
          },
          ".place-items-baseline": {
            "place-items": "baseline"
          },
          ".place-items-stretch": {
            "place-items": "stretch"
          }
        });
      },
      alignContent: ({ addUtilities: S3 }) => {
        S3({
          ".content-normal": {
            "align-content": "normal"
          },
          ".content-center": {
            "align-content": "center"
          },
          ".content-start": {
            "align-content": "flex-start"
          },
          ".content-end": {
            "align-content": "flex-end"
          },
          ".content-between": {
            "align-content": "space-between"
          },
          ".content-around": {
            "align-content": "space-around"
          },
          ".content-evenly": {
            "align-content": "space-evenly"
          },
          ".content-baseline": {
            "align-content": "baseline"
          },
          ".content-stretch": {
            "align-content": "stretch"
          }
        });
      },
      alignItems: ({ addUtilities: S3 }) => {
        S3({
          ".items-start": {
            "align-items": "flex-start"
          },
          ".items-end": {
            "align-items": "flex-end"
          },
          ".items-center": {
            "align-items": "center"
          },
          ".items-baseline": {
            "align-items": "baseline"
          },
          ".items-stretch": {
            "align-items": "stretch"
          }
        });
      },
      justifyContent: ({ addUtilities: S3 }) => {
        S3({
          ".justify-normal": {
            "justify-content": "normal"
          },
          ".justify-start": {
            "justify-content": "flex-start"
          },
          ".justify-end": {
            "justify-content": "flex-end"
          },
          ".justify-center": {
            "justify-content": "center"
          },
          ".justify-between": {
            "justify-content": "space-between"
          },
          ".justify-around": {
            "justify-content": "space-around"
          },
          ".justify-evenly": {
            "justify-content": "space-evenly"
          },
          ".justify-stretch": {
            "justify-content": "stretch"
          }
        });
      },
      justifyItems: ({ addUtilities: S3 }) => {
        S3({
          ".justify-items-start": {
            "justify-items": "start"
          },
          ".justify-items-end": {
            "justify-items": "end"
          },
          ".justify-items-center": {
            "justify-items": "center"
          },
          ".justify-items-stretch": {
            "justify-items": "stretch"
          }
        });
      },
      gap: (0, f.default)("gap", [
        [
          "gap",
          [
            "gap"
          ]
        ],
        [
          [
            "gap-x",
            [
              "columnGap"
            ]
          ],
          [
            "gap-y",
            [
              "rowGap"
            ]
          ]
        ]
      ]),
      space: ({ matchUtilities: S3, addUtilities: P3, theme: C }) => {
        S3({
          "space-x": (R3) => (R3 = R3 === "0" ? "0px" : R3, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-x-reverse": "0",
              "margin-right": `calc(${R3} * var(--tw-space-x-reverse))`,
              "margin-left": `calc(${R3} * calc(1 - var(--tw-space-x-reverse)))`
            }
          }),
          "space-y": (R3) => (R3 = R3 === "0" ? "0px" : R3, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-y-reverse": "0",
              "margin-top": `calc(${R3} * calc(1 - var(--tw-space-y-reverse)))`,
              "margin-bottom": `calc(${R3} * var(--tw-space-y-reverse))`
            }
          })
        }, {
          values: C("space"),
          supportsNegativeValues: true
        }), P3({
          ".space-y-reverse > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-y-reverse": "1"
          },
          ".space-x-reverse > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-x-reverse": "1"
          }
        });
      },
      divideWidth: ({ matchUtilities: S3, addUtilities: P3, theme: C }) => {
        S3({
          "divide-x": (R3) => (R3 = R3 === "0" ? "0px" : R3, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-x-reverse": "0",
              "border-right-width": `calc(${R3} * var(--tw-divide-x-reverse))`,
              "border-left-width": `calc(${R3} * calc(1 - var(--tw-divide-x-reverse)))`
            }
          }),
          "divide-y": (R3) => (R3 = R3 === "0" ? "0px" : R3, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-y-reverse": "0",
              "border-top-width": `calc(${R3} * calc(1 - var(--tw-divide-y-reverse)))`,
              "border-bottom-width": `calc(${R3} * var(--tw-divide-y-reverse))`
            }
          })
        }, {
          values: C("divideWidth"),
          type: [
            "line-width",
            "length",
            "any"
          ]
        }), P3({
          ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-y-reverse": "1"
          },
          ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-x-reverse": "1"
          }
        });
      },
      divideStyle: ({ addUtilities: S3 }) => {
        S3({
          ".divide-solid > :not([hidden]) ~ :not([hidden])": {
            "border-style": "solid"
          },
          ".divide-dashed > :not([hidden]) ~ :not([hidden])": {
            "border-style": "dashed"
          },
          ".divide-dotted > :not([hidden]) ~ :not([hidden])": {
            "border-style": "dotted"
          },
          ".divide-double > :not([hidden]) ~ :not([hidden])": {
            "border-style": "double"
          },
          ".divide-none > :not([hidden]) ~ :not([hidden])": {
            "border-style": "none"
          }
        });
      },
      divideColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          divide: (R3) => C("divideOpacity") ? {
            "& > :not([hidden]) ~ :not([hidden])": (0, r2.default)({
              color: R3,
              property: "border-color",
              variable: "--tw-divide-opacity"
            })
          } : {
            "& > :not([hidden]) ~ :not([hidden])": {
              "border-color": (0, i.default)(R3)
            }
          }
        }, {
          values: (({ DEFAULT: R3, ...$2 }) => $2)((0, e2.default)(P3("divideColor"))),
          type: [
            "color",
            "any"
          ]
        });
      },
      divideOpacity: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "divide-opacity": (C) => ({
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-divide-opacity": C
            }
          })
        }, {
          values: P3("divideOpacity")
        });
      },
      placeSelf: ({ addUtilities: S3 }) => {
        S3({
          ".place-self-auto": {
            "place-self": "auto"
          },
          ".place-self-start": {
            "place-self": "start"
          },
          ".place-self-end": {
            "place-self": "end"
          },
          ".place-self-center": {
            "place-self": "center"
          },
          ".place-self-stretch": {
            "place-self": "stretch"
          }
        });
      },
      alignSelf: ({ addUtilities: S3 }) => {
        S3({
          ".self-auto": {
            "align-self": "auto"
          },
          ".self-start": {
            "align-self": "flex-start"
          },
          ".self-end": {
            "align-self": "flex-end"
          },
          ".self-center": {
            "align-self": "center"
          },
          ".self-stretch": {
            "align-self": "stretch"
          },
          ".self-baseline": {
            "align-self": "baseline"
          }
        });
      },
      justifySelf: ({ addUtilities: S3 }) => {
        S3({
          ".justify-self-auto": {
            "justify-self": "auto"
          },
          ".justify-self-start": {
            "justify-self": "start"
          },
          ".justify-self-end": {
            "justify-self": "end"
          },
          ".justify-self-center": {
            "justify-self": "center"
          },
          ".justify-self-stretch": {
            "justify-self": "stretch"
          }
        });
      },
      overflow: ({ addUtilities: S3 }) => {
        S3({
          ".overflow-auto": {
            overflow: "auto"
          },
          ".overflow-hidden": {
            overflow: "hidden"
          },
          ".overflow-clip": {
            overflow: "clip"
          },
          ".overflow-visible": {
            overflow: "visible"
          },
          ".overflow-scroll": {
            overflow: "scroll"
          },
          ".overflow-x-auto": {
            "overflow-x": "auto"
          },
          ".overflow-y-auto": {
            "overflow-y": "auto"
          },
          ".overflow-x-hidden": {
            "overflow-x": "hidden"
          },
          ".overflow-y-hidden": {
            "overflow-y": "hidden"
          },
          ".overflow-x-clip": {
            "overflow-x": "clip"
          },
          ".overflow-y-clip": {
            "overflow-y": "clip"
          },
          ".overflow-x-visible": {
            "overflow-x": "visible"
          },
          ".overflow-y-visible": {
            "overflow-y": "visible"
          },
          ".overflow-x-scroll": {
            "overflow-x": "scroll"
          },
          ".overflow-y-scroll": {
            "overflow-y": "scroll"
          }
        });
      },
      overscrollBehavior: ({ addUtilities: S3 }) => {
        S3({
          ".overscroll-auto": {
            "overscroll-behavior": "auto"
          },
          ".overscroll-contain": {
            "overscroll-behavior": "contain"
          },
          ".overscroll-none": {
            "overscroll-behavior": "none"
          },
          ".overscroll-y-auto": {
            "overscroll-behavior-y": "auto"
          },
          ".overscroll-y-contain": {
            "overscroll-behavior-y": "contain"
          },
          ".overscroll-y-none": {
            "overscroll-behavior-y": "none"
          },
          ".overscroll-x-auto": {
            "overscroll-behavior-x": "auto"
          },
          ".overscroll-x-contain": {
            "overscroll-behavior-x": "contain"
          },
          ".overscroll-x-none": {
            "overscroll-behavior-x": "none"
          }
        });
      },
      scrollBehavior: ({ addUtilities: S3 }) => {
        S3({
          ".scroll-auto": {
            "scroll-behavior": "auto"
          },
          ".scroll-smooth": {
            "scroll-behavior": "smooth"
          }
        });
      },
      textOverflow: ({ addUtilities: S3 }) => {
        S3({
          ".truncate": {
            overflow: "hidden",
            "text-overflow": "ellipsis",
            "white-space": "nowrap"
          },
          ".overflow-ellipsis": {
            "text-overflow": "ellipsis"
          },
          ".text-ellipsis": {
            "text-overflow": "ellipsis"
          },
          ".text-clip": {
            "text-overflow": "clip"
          }
        });
      },
      hyphens: ({ addUtilities: S3 }) => {
        S3({
          ".hyphens-none": {
            hyphens: "none"
          },
          ".hyphens-manual": {
            hyphens: "manual"
          },
          ".hyphens-auto": {
            hyphens: "auto"
          }
        });
      },
      whitespace: ({ addUtilities: S3 }) => {
        S3({
          ".whitespace-normal": {
            "white-space": "normal"
          },
          ".whitespace-nowrap": {
            "white-space": "nowrap"
          },
          ".whitespace-pre": {
            "white-space": "pre"
          },
          ".whitespace-pre-line": {
            "white-space": "pre-line"
          },
          ".whitespace-pre-wrap": {
            "white-space": "pre-wrap"
          },
          ".whitespace-break-spaces": {
            "white-space": "break-spaces"
          }
        });
      },
      textWrap: ({ addUtilities: S3 }) => {
        S3({
          ".text-wrap": {
            "text-wrap": "wrap"
          },
          ".text-nowrap": {
            "text-wrap": "nowrap"
          },
          ".text-balance": {
            "text-wrap": "balance"
          },
          ".text-pretty": {
            "text-wrap": "pretty"
          }
        });
      },
      wordBreak: ({ addUtilities: S3 }) => {
        S3({
          ".break-normal": {
            "overflow-wrap": "normal",
            "word-break": "normal"
          },
          ".break-words": {
            "overflow-wrap": "break-word"
          },
          ".break-all": {
            "word-break": "break-all"
          },
          ".break-keep": {
            "word-break": "keep-all"
          }
        });
      },
      borderRadius: (0, f.default)("borderRadius", [
        [
          "rounded",
          [
            "border-radius"
          ]
        ],
        [
          [
            "rounded-s",
            [
              "border-start-start-radius",
              "border-end-start-radius"
            ]
          ],
          [
            "rounded-e",
            [
              "border-start-end-radius",
              "border-end-end-radius"
            ]
          ],
          [
            "rounded-t",
            [
              "border-top-left-radius",
              "border-top-right-radius"
            ]
          ],
          [
            "rounded-r",
            [
              "border-top-right-radius",
              "border-bottom-right-radius"
            ]
          ],
          [
            "rounded-b",
            [
              "border-bottom-right-radius",
              "border-bottom-left-radius"
            ]
          ],
          [
            "rounded-l",
            [
              "border-top-left-radius",
              "border-bottom-left-radius"
            ]
          ]
        ],
        [
          [
            "rounded-ss",
            [
              "border-start-start-radius"
            ]
          ],
          [
            "rounded-se",
            [
              "border-start-end-radius"
            ]
          ],
          [
            "rounded-ee",
            [
              "border-end-end-radius"
            ]
          ],
          [
            "rounded-es",
            [
              "border-end-start-radius"
            ]
          ],
          [
            "rounded-tl",
            [
              "border-top-left-radius"
            ]
          ],
          [
            "rounded-tr",
            [
              "border-top-right-radius"
            ]
          ],
          [
            "rounded-br",
            [
              "border-bottom-right-radius"
            ]
          ],
          [
            "rounded-bl",
            [
              "border-bottom-left-radius"
            ]
          ]
        ]
      ]),
      borderWidth: (0, f.default)("borderWidth", [
        [
          "border",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-width"
          ]
        ],
        [
          [
            "border-x",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-left-width",
              "border-right-width"
            ]
          ],
          [
            "border-y",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-top-width",
              "border-bottom-width"
            ]
          ]
        ],
        [
          [
            "border-s",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-inline-start-width"
            ]
          ],
          [
            "border-e",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-inline-end-width"
            ]
          ],
          [
            "border-t",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-top-width"
            ]
          ],
          [
            "border-r",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-right-width"
            ]
          ],
          [
            "border-b",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-bottom-width"
            ]
          ],
          [
            "border-l",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-left-width"
            ]
          ]
        ]
      ], {
        type: [
          "line-width",
          "length"
        ]
      }),
      borderStyle: ({ addUtilities: S3 }) => {
        S3({
          ".border-solid": {
            "border-style": "solid"
          },
          ".border-dashed": {
            "border-style": "dashed"
          },
          ".border-dotted": {
            "border-style": "dotted"
          },
          ".border-double": {
            "border-style": "double"
          },
          ".border-hidden": {
            "border-style": "hidden"
          },
          ".border-none": {
            "border-style": "none"
          }
        });
      },
      borderColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          border: (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-color": (0, i.default)(R3)
          }
        }, {
          values: (({ DEFAULT: R3, ...$2 }) => $2)((0, e2.default)(P3("borderColor"))),
          type: [
            "color",
            "any"
          ]
        }), S3({
          "border-x": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: [
              "border-left-color",
              "border-right-color"
            ],
            variable: "--tw-border-opacity"
          }) : {
            "border-left-color": (0, i.default)(R3),
            "border-right-color": (0, i.default)(R3)
          },
          "border-y": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: [
              "border-top-color",
              "border-bottom-color"
            ],
            variable: "--tw-border-opacity"
          }) : {
            "border-top-color": (0, i.default)(R3),
            "border-bottom-color": (0, i.default)(R3)
          }
        }, {
          values: (({ DEFAULT: R3, ...$2 }) => $2)((0, e2.default)(P3("borderColor"))),
          type: [
            "color",
            "any"
          ]
        }), S3({
          "border-s": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-inline-start-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-inline-start-color": (0, i.default)(R3)
          },
          "border-e": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-inline-end-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-inline-end-color": (0, i.default)(R3)
          },
          "border-t": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-top-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-top-color": (0, i.default)(R3)
          },
          "border-r": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-right-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-right-color": (0, i.default)(R3)
          },
          "border-b": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-bottom-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-bottom-color": (0, i.default)(R3)
          },
          "border-l": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-left-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-left-color": (0, i.default)(R3)
          }
        }, {
          values: (({ DEFAULT: R3, ...$2 }) => $2)((0, e2.default)(P3("borderColor"))),
          type: [
            "color",
            "any"
          ]
        });
      },
      borderOpacity: (0, f.default)("borderOpacity", [
        [
          "border-opacity",
          [
            "--tw-border-opacity"
          ]
        ]
      ]),
      backgroundColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          bg: (R3) => C("backgroundOpacity") ? (0, r2.default)({
            color: R3,
            property: "background-color",
            variable: "--tw-bg-opacity"
          }) : {
            "background-color": (0, i.default)(R3)
          }
        }, {
          values: (0, e2.default)(P3("backgroundColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      backgroundOpacity: (0, f.default)("backgroundOpacity", [
        [
          "bg-opacity",
          [
            "--tw-bg-opacity"
          ]
        ]
      ]),
      backgroundImage: (0, f.default)("backgroundImage", [
        [
          "bg",
          [
            "background-image"
          ]
        ]
      ], {
        type: [
          "lookup",
          "image",
          "url"
        ]
      }),
      gradientColorStops: /* @__PURE__ */ (() => {
        function S3(P3) {
          return (0, r2.withAlphaValue)(P3, 0, "rgb(255 255 255 / 0)");
        }
        return function({ matchUtilities: P3, theme: C, addDefaults: R3 }) {
          R3("gradient-color-stops", {
            "--tw-gradient-from-position": " ",
            "--tw-gradient-via-position": " ",
            "--tw-gradient-to-position": " "
          });
          let $2 = {
            values: (0, e2.default)(C("gradientColorStops")),
            type: [
              "color",
              "any"
            ]
          }, B3 = {
            values: C("gradientColorStopPositions"),
            type: [
              "length",
              "percentage"
            ]
          };
          P3({
            from: (z3) => {
              let L3 = S3(z3);
              return {
                "@defaults gradient-color-stops": {},
                "--tw-gradient-from": `${(0, i.default)(z3)} var(--tw-gradient-from-position)`,
                "--tw-gradient-to": `${L3} var(--tw-gradient-to-position)`,
                "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)"
              };
            }
          }, $2), P3({
            from: (z3) => ({
              "--tw-gradient-from-position": z3
            })
          }, B3), P3({
            via: (z3) => {
              let L3 = S3(z3);
              return {
                "@defaults gradient-color-stops": {},
                "--tw-gradient-to": `${L3}  var(--tw-gradient-to-position)`,
                "--tw-gradient-stops": `var(--tw-gradient-from), ${(0, i.default)(z3)} var(--tw-gradient-via-position), var(--tw-gradient-to)`
              };
            }
          }, $2), P3({
            via: (z3) => ({
              "--tw-gradient-via-position": z3
            })
          }, B3), P3({
            to: (z3) => ({
              "@defaults gradient-color-stops": {},
              "--tw-gradient-to": `${(0, i.default)(z3)} var(--tw-gradient-to-position)`
            })
          }, $2), P3({
            to: (z3) => ({
              "--tw-gradient-to-position": z3
            })
          }, B3);
        };
      })(),
      boxDecorationBreak: ({ addUtilities: S3 }) => {
        S3({
          ".decoration-slice": {
            "box-decoration-break": "slice"
          },
          ".decoration-clone": {
            "box-decoration-break": "clone"
          },
          ".box-decoration-slice": {
            "box-decoration-break": "slice"
          },
          ".box-decoration-clone": {
            "box-decoration-break": "clone"
          }
        });
      },
      backgroundSize: (0, f.default)("backgroundSize", [
        [
          "bg",
          [
            "background-size"
          ]
        ]
      ], {
        type: [
          "lookup",
          "length",
          "percentage",
          "size"
        ]
      }),
      backgroundAttachment: ({ addUtilities: S3 }) => {
        S3({
          ".bg-fixed": {
            "background-attachment": "fixed"
          },
          ".bg-local": {
            "background-attachment": "local"
          },
          ".bg-scroll": {
            "background-attachment": "scroll"
          }
        });
      },
      backgroundClip: ({ addUtilities: S3 }) => {
        S3({
          ".bg-clip-border": {
            "background-clip": "border-box"
          },
          ".bg-clip-padding": {
            "background-clip": "padding-box"
          },
          ".bg-clip-content": {
            "background-clip": "content-box"
          },
          ".bg-clip-text": {
            "background-clip": "text"
          }
        });
      },
      backgroundPosition: (0, f.default)("backgroundPosition", [
        [
          "bg",
          [
            "background-position"
          ]
        ]
      ], {
        type: [
          "lookup",
          [
            "position",
            {
              preferOnConflict: true
            }
          ]
        ]
      }),
      backgroundRepeat: ({ addUtilities: S3 }) => {
        S3({
          ".bg-repeat": {
            "background-repeat": "repeat"
          },
          ".bg-no-repeat": {
            "background-repeat": "no-repeat"
          },
          ".bg-repeat-x": {
            "background-repeat": "repeat-x"
          },
          ".bg-repeat-y": {
            "background-repeat": "repeat-y"
          },
          ".bg-repeat-round": {
            "background-repeat": "round"
          },
          ".bg-repeat-space": {
            "background-repeat": "space"
          }
        });
      },
      backgroundOrigin: ({ addUtilities: S3 }) => {
        S3({
          ".bg-origin-border": {
            "background-origin": "border-box"
          },
          ".bg-origin-padding": {
            "background-origin": "padding-box"
          },
          ".bg-origin-content": {
            "background-origin": "content-box"
          }
        });
      },
      fill: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          fill: (C) => ({
            fill: (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("fill")),
          type: [
            "color",
            "any"
          ]
        });
      },
      stroke: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          stroke: (C) => ({
            stroke: (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("stroke")),
          type: [
            "color",
            "url",
            "any"
          ]
        });
      },
      strokeWidth: (0, f.default)("strokeWidth", [
        [
          "stroke",
          [
            "stroke-width"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage"
        ]
      }),
      objectFit: ({ addUtilities: S3 }) => {
        S3({
          ".object-contain": {
            "object-fit": "contain"
          },
          ".object-cover": {
            "object-fit": "cover"
          },
          ".object-fill": {
            "object-fit": "fill"
          },
          ".object-none": {
            "object-fit": "none"
          },
          ".object-scale-down": {
            "object-fit": "scale-down"
          }
        });
      },
      objectPosition: (0, f.default)("objectPosition", [
        [
          "object",
          [
            "object-position"
          ]
        ]
      ]),
      padding: (0, f.default)("padding", [
        [
          "p",
          [
            "padding"
          ]
        ],
        [
          [
            "px",
            [
              "padding-left",
              "padding-right"
            ]
          ],
          [
            "py",
            [
              "padding-top",
              "padding-bottom"
            ]
          ]
        ],
        [
          [
            "ps",
            [
              "padding-inline-start"
            ]
          ],
          [
            "pe",
            [
              "padding-inline-end"
            ]
          ],
          [
            "pt",
            [
              "padding-top"
            ]
          ],
          [
            "pr",
            [
              "padding-right"
            ]
          ],
          [
            "pb",
            [
              "padding-bottom"
            ]
          ],
          [
            "pl",
            [
              "padding-left"
            ]
          ]
        ]
      ]),
      textAlign: ({ addUtilities: S3 }) => {
        S3({
          ".text-left": {
            "text-align": "left"
          },
          ".text-center": {
            "text-align": "center"
          },
          ".text-right": {
            "text-align": "right"
          },
          ".text-justify": {
            "text-align": "justify"
          },
          ".text-start": {
            "text-align": "start"
          },
          ".text-end": {
            "text-align": "end"
          }
        });
      },
      textIndent: (0, f.default)("textIndent", [
        [
          "indent",
          [
            "text-indent"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      verticalAlign: ({ addUtilities: S3, matchUtilities: P3 }) => {
        S3({
          ".align-baseline": {
            "vertical-align": "baseline"
          },
          ".align-top": {
            "vertical-align": "top"
          },
          ".align-middle": {
            "vertical-align": "middle"
          },
          ".align-bottom": {
            "vertical-align": "bottom"
          },
          ".align-text-top": {
            "vertical-align": "text-top"
          },
          ".align-text-bottom": {
            "vertical-align": "text-bottom"
          },
          ".align-sub": {
            "vertical-align": "sub"
          },
          ".align-super": {
            "vertical-align": "super"
          }
        }), P3({
          align: (C) => ({
            "vertical-align": C
          })
        });
      },
      fontFamily: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          font: (C) => {
            let [R3, $2 = {}] = Array.isArray(C) && (0, o2.default)(C[1]) ? C : [
              C
            ], { fontFeatureSettings: B3, fontVariationSettings: z3 } = $2;
            return {
              "font-family": Array.isArray(R3) ? R3.join(", ") : R3,
              ...B3 === void 0 ? {} : {
                "font-feature-settings": B3
              },
              ...z3 === void 0 ? {} : {
                "font-variation-settings": z3
              }
            };
          }
        }, {
          values: P3("fontFamily"),
          type: [
            "lookup",
            "generic-name",
            "family-name"
          ]
        });
      },
      fontSize: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          text: (C, { modifier: R3 }) => {
            let [$2, B3] = Array.isArray(C) ? C : [
              C
            ];
            if (R3)
              return {
                "font-size": $2,
                "line-height": R3
              };
            let { lineHeight: z3, letterSpacing: L3, fontWeight: F } = (0, o2.default)(B3) ? B3 : {
              lineHeight: B3
            };
            return {
              "font-size": $2,
              ...z3 === void 0 ? {} : {
                "line-height": z3
              },
              ...L3 === void 0 ? {} : {
                "letter-spacing": L3
              },
              ...F === void 0 ? {} : {
                "font-weight": F
              }
            };
          }
        }, {
          values: P3("fontSize"),
          modifiers: P3("lineHeight"),
          type: [
            "absolute-size",
            "relative-size",
            "length",
            "percentage"
          ]
        });
      },
      fontWeight: (0, f.default)("fontWeight", [
        [
          "font",
          [
            "fontWeight"
          ]
        ]
      ], {
        type: [
          "lookup",
          "number",
          "any"
        ]
      }),
      textTransform: ({ addUtilities: S3 }) => {
        S3({
          ".uppercase": {
            "text-transform": "uppercase"
          },
          ".lowercase": {
            "text-transform": "lowercase"
          },
          ".capitalize": {
            "text-transform": "capitalize"
          },
          ".normal-case": {
            "text-transform": "none"
          }
        });
      },
      fontStyle: ({ addUtilities: S3 }) => {
        S3({
          ".italic": {
            "font-style": "italic"
          },
          ".not-italic": {
            "font-style": "normal"
          }
        });
      },
      fontVariantNumeric: ({ addDefaults: S3, addUtilities: P3 }) => {
        let C = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
        S3("font-variant-numeric", {
          "--tw-ordinal": " ",
          "--tw-slashed-zero": " ",
          "--tw-numeric-figure": " ",
          "--tw-numeric-spacing": " ",
          "--tw-numeric-fraction": " "
        }), P3({
          ".normal-nums": {
            "font-variant-numeric": "normal"
          },
          ".ordinal": {
            "@defaults font-variant-numeric": {},
            "--tw-ordinal": "ordinal",
            "font-variant-numeric": C
          },
          ".slashed-zero": {
            "@defaults font-variant-numeric": {},
            "--tw-slashed-zero": "slashed-zero",
            "font-variant-numeric": C
          },
          ".lining-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-figure": "lining-nums",
            "font-variant-numeric": C
          },
          ".oldstyle-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-figure": "oldstyle-nums",
            "font-variant-numeric": C
          },
          ".proportional-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-spacing": "proportional-nums",
            "font-variant-numeric": C
          },
          ".tabular-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-spacing": "tabular-nums",
            "font-variant-numeric": C
          },
          ".diagonal-fractions": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-fraction": "diagonal-fractions",
            "font-variant-numeric": C
          },
          ".stacked-fractions": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-fraction": "stacked-fractions",
            "font-variant-numeric": C
          }
        });
      },
      lineHeight: (0, f.default)("lineHeight", [
        [
          "leading",
          [
            "lineHeight"
          ]
        ]
      ]),
      letterSpacing: (0, f.default)("letterSpacing", [
        [
          "tracking",
          [
            "letterSpacing"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      textColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          text: (R3) => C("textOpacity") ? (0, r2.default)({
            color: R3,
            property: "color",
            variable: "--tw-text-opacity"
          }) : {
            color: (0, i.default)(R3)
          }
        }, {
          values: (0, e2.default)(P3("textColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      textOpacity: (0, f.default)("textOpacity", [
        [
          "text-opacity",
          [
            "--tw-text-opacity"
          ]
        ]
      ]),
      textDecoration: ({ addUtilities: S3 }) => {
        S3({
          ".underline": {
            "text-decoration-line": "underline"
          },
          ".overline": {
            "text-decoration-line": "overline"
          },
          ".line-through": {
            "text-decoration-line": "line-through"
          },
          ".no-underline": {
            "text-decoration-line": "none"
          }
        });
      },
      textDecorationColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          decoration: (C) => ({
            "text-decoration-color": (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("textDecorationColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      textDecorationStyle: ({ addUtilities: S3 }) => {
        S3({
          ".decoration-solid": {
            "text-decoration-style": "solid"
          },
          ".decoration-double": {
            "text-decoration-style": "double"
          },
          ".decoration-dotted": {
            "text-decoration-style": "dotted"
          },
          ".decoration-dashed": {
            "text-decoration-style": "dashed"
          },
          ".decoration-wavy": {
            "text-decoration-style": "wavy"
          }
        });
      },
      textDecorationThickness: (0, f.default)("textDecorationThickness", [
        [
          "decoration",
          [
            "text-decoration-thickness"
          ]
        ]
      ], {
        type: [
          "length",
          "percentage"
        ]
      }),
      textUnderlineOffset: (0, f.default)("textUnderlineOffset", [
        [
          "underline-offset",
          [
            "text-underline-offset"
          ]
        ]
      ], {
        type: [
          "length",
          "percentage",
          "any"
        ]
      }),
      fontSmoothing: ({ addUtilities: S3 }) => {
        S3({
          ".antialiased": {
            "-webkit-font-smoothing": "antialiased",
            "-moz-osx-font-smoothing": "grayscale"
          },
          ".subpixel-antialiased": {
            "-webkit-font-smoothing": "auto",
            "-moz-osx-font-smoothing": "auto"
          }
        });
      },
      placeholderColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          placeholder: (R3) => C("placeholderOpacity") ? {
            "&::placeholder": (0, r2.default)({
              color: R3,
              property: "color",
              variable: "--tw-placeholder-opacity"
            })
          } : {
            "&::placeholder": {
              color: (0, i.default)(R3)
            }
          }
        }, {
          values: (0, e2.default)(P3("placeholderColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      placeholderOpacity: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "placeholder-opacity": (C) => ({
            "&::placeholder": {
              "--tw-placeholder-opacity": C
            }
          })
        }, {
          values: P3("placeholderOpacity")
        });
      },
      caretColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          caret: (C) => ({
            "caret-color": (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("caretColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      accentColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          accent: (C) => ({
            "accent-color": (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("accentColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      opacity: (0, f.default)("opacity", [
        [
          "opacity",
          [
            "opacity"
          ]
        ]
      ]),
      backgroundBlendMode: ({ addUtilities: S3 }) => {
        S3({
          ".bg-blend-normal": {
            "background-blend-mode": "normal"
          },
          ".bg-blend-multiply": {
            "background-blend-mode": "multiply"
          },
          ".bg-blend-screen": {
            "background-blend-mode": "screen"
          },
          ".bg-blend-overlay": {
            "background-blend-mode": "overlay"
          },
          ".bg-blend-darken": {
            "background-blend-mode": "darken"
          },
          ".bg-blend-lighten": {
            "background-blend-mode": "lighten"
          },
          ".bg-blend-color-dodge": {
            "background-blend-mode": "color-dodge"
          },
          ".bg-blend-color-burn": {
            "background-blend-mode": "color-burn"
          },
          ".bg-blend-hard-light": {
            "background-blend-mode": "hard-light"
          },
          ".bg-blend-soft-light": {
            "background-blend-mode": "soft-light"
          },
          ".bg-blend-difference": {
            "background-blend-mode": "difference"
          },
          ".bg-blend-exclusion": {
            "background-blend-mode": "exclusion"
          },
          ".bg-blend-hue": {
            "background-blend-mode": "hue"
          },
          ".bg-blend-saturation": {
            "background-blend-mode": "saturation"
          },
          ".bg-blend-color": {
            "background-blend-mode": "color"
          },
          ".bg-blend-luminosity": {
            "background-blend-mode": "luminosity"
          }
        });
      },
      mixBlendMode: ({ addUtilities: S3 }) => {
        S3({
          ".mix-blend-normal": {
            "mix-blend-mode": "normal"
          },
          ".mix-blend-multiply": {
            "mix-blend-mode": "multiply"
          },
          ".mix-blend-screen": {
            "mix-blend-mode": "screen"
          },
          ".mix-blend-overlay": {
            "mix-blend-mode": "overlay"
          },
          ".mix-blend-darken": {
            "mix-blend-mode": "darken"
          },
          ".mix-blend-lighten": {
            "mix-blend-mode": "lighten"
          },
          ".mix-blend-color-dodge": {
            "mix-blend-mode": "color-dodge"
          },
          ".mix-blend-color-burn": {
            "mix-blend-mode": "color-burn"
          },
          ".mix-blend-hard-light": {
            "mix-blend-mode": "hard-light"
          },
          ".mix-blend-soft-light": {
            "mix-blend-mode": "soft-light"
          },
          ".mix-blend-difference": {
            "mix-blend-mode": "difference"
          },
          ".mix-blend-exclusion": {
            "mix-blend-mode": "exclusion"
          },
          ".mix-blend-hue": {
            "mix-blend-mode": "hue"
          },
          ".mix-blend-saturation": {
            "mix-blend-mode": "saturation"
          },
          ".mix-blend-color": {
            "mix-blend-mode": "color"
          },
          ".mix-blend-luminosity": {
            "mix-blend-mode": "luminosity"
          },
          ".mix-blend-plus-darker": {
            "mix-blend-mode": "plus-darker"
          },
          ".mix-blend-plus-lighter": {
            "mix-blend-mode": "plus-lighter"
          }
        });
      },
      boxShadow: (() => {
        let S3 = (0, v3.default)("boxShadow"), P3 = [
          "var(--tw-ring-offset-shadow, 0 0 #0000)",
          "var(--tw-ring-shadow, 0 0 #0000)",
          "var(--tw-shadow)"
        ].join(", ");
        return function({ matchUtilities: C, addDefaults: R3, theme: $2 }) {
          R3("box-shadow", {
            "--tw-ring-offset-shadow": "0 0 #0000",
            "--tw-ring-shadow": "0 0 #0000",
            "--tw-shadow": "0 0 #0000",
            "--tw-shadow-colored": "0 0 #0000"
          }), C({
            shadow: (B3) => {
              B3 = S3(B3);
              let z3 = (0, _3.parseBoxShadowValue)(B3);
              for (let L3 of z3)
                L3.valid && (L3.color = "var(--tw-shadow-color)");
              return {
                "@defaults box-shadow": {},
                "--tw-shadow": B3 === "none" ? "0 0 #0000" : B3,
                "--tw-shadow-colored": B3 === "none" ? "0 0 #0000" : (0, _3.formatBoxShadowValue)(z3),
                "box-shadow": P3
              };
            }
          }, {
            values: $2("boxShadow"),
            type: [
              "shadow"
            ]
          });
        };
      })(),
      boxShadowColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          shadow: (C) => ({
            "--tw-shadow-color": (0, i.default)(C),
            "--tw-shadow": "var(--tw-shadow-colored)"
          })
        }, {
          values: (0, e2.default)(P3("boxShadowColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      outlineStyle: ({ addUtilities: S3 }) => {
        S3({
          ".outline-none": {
            outline: "2px solid transparent",
            "outline-offset": "2px"
          },
          ".outline": {
            "outline-style": "solid"
          },
          ".outline-dashed": {
            "outline-style": "dashed"
          },
          ".outline-dotted": {
            "outline-style": "dotted"
          },
          ".outline-double": {
            "outline-style": "double"
          }
        });
      },
      outlineWidth: (0, f.default)("outlineWidth", [
        [
          "outline",
          [
            "outline-width"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage"
        ]
      }),
      outlineOffset: (0, f.default)("outlineOffset", [
        [
          "outline-offset",
          [
            "outline-offset"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage",
          "any"
        ],
        supportsNegativeValues: true
      }),
      outlineColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          outline: (C) => ({
            "outline-color": (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("outlineColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      ringWidth: ({ matchUtilities: S3, addDefaults: P3, addUtilities: C, theme: R3, config: $2 }) => {
        let B3 = (() => {
          var z3, L3;
          if ((0, y2.flagEnabled)($2(), "respectDefaultRingColorOpacity"))
            return R3("ringColor.DEFAULT");
          let F = R3("ringOpacity.DEFAULT", "0.5");
          return !((z3 = R3("ringColor")) === null || z3 === void 0) && z3.DEFAULT ? (0, r2.withAlphaValue)((L3 = R3("ringColor")) === null || L3 === void 0 ? void 0 : L3.DEFAULT, F, `rgb(147 197 253 / ${F})`) : `rgb(147 197 253 / ${F})`;
        })();
        P3("ring-width", {
          "--tw-ring-inset": " ",
          "--tw-ring-offset-width": R3("ringOffsetWidth.DEFAULT", "0px"),
          "--tw-ring-offset-color": R3("ringOffsetColor.DEFAULT", "#fff"),
          "--tw-ring-color": B3,
          "--tw-ring-offset-shadow": "0 0 #0000",
          "--tw-ring-shadow": "0 0 #0000",
          "--tw-shadow": "0 0 #0000",
          "--tw-shadow-colored": "0 0 #0000"
        }), S3({
          ring: (z3) => ({
            "@defaults ring-width": {},
            "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)",
            "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${z3} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
            "box-shadow": [
              "var(--tw-ring-offset-shadow)",
              "var(--tw-ring-shadow)",
              "var(--tw-shadow, 0 0 #0000)"
            ].join(", ")
          })
        }, {
          values: R3("ringWidth"),
          type: "length"
        }), C({
          ".ring-inset": {
            "@defaults ring-width": {},
            "--tw-ring-inset": "inset"
          }
        });
      },
      ringColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          ring: (R3) => C("ringOpacity") ? (0, r2.default)({
            color: R3,
            property: "--tw-ring-color",
            variable: "--tw-ring-opacity"
          }) : {
            "--tw-ring-color": (0, i.default)(R3)
          }
        }, {
          values: Object.fromEntries(Object.entries((0, e2.default)(P3("ringColor"))).filter(([R3]) => R3 !== "DEFAULT")),
          type: [
            "color",
            "any"
          ]
        });
      },
      ringOpacity: (S3) => {
        let { config: P3 } = S3;
        return (0, f.default)("ringOpacity", [
          [
            "ring-opacity",
            [
              "--tw-ring-opacity"
            ]
          ]
        ], {
          filterDefault: !(0, y2.flagEnabled)(P3(), "respectDefaultRingColorOpacity")
        })(S3);
      },
      ringOffsetWidth: (0, f.default)("ringOffsetWidth", [
        [
          "ring-offset",
          [
            "--tw-ring-offset-width"
          ]
        ]
      ], {
        type: "length"
      }),
      ringOffsetColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "ring-offset": (C) => ({
            "--tw-ring-offset-color": (0, i.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("ringOffsetColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      blur: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          blur: (C) => ({
            "--tw-blur": C.trim() === "" ? " " : `blur(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("blur")
        });
      },
      brightness: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          brightness: (C) => ({
            "--tw-brightness": `brightness(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("brightness")
        });
      },
      contrast: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          contrast: (C) => ({
            "--tw-contrast": `contrast(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("contrast")
        });
      },
      dropShadow: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "drop-shadow": (C) => ({
            "--tw-drop-shadow": Array.isArray(C) ? C.map((R3) => `drop-shadow(${R3})`).join(" ") : `drop-shadow(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("dropShadow")
        });
      },
      grayscale: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          grayscale: (C) => ({
            "--tw-grayscale": `grayscale(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("grayscale")
        });
      },
      hueRotate: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "hue-rotate": (C) => ({
            "--tw-hue-rotate": `hue-rotate(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("hueRotate"),
          supportsNegativeValues: true
        });
      },
      invert: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          invert: (C) => ({
            "--tw-invert": `invert(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("invert")
        });
      },
      saturate: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          saturate: (C) => ({
            "--tw-saturate": `saturate(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("saturate")
        });
      },
      sepia: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          sepia: (C) => ({
            "--tw-sepia": `sepia(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("sepia")
        });
      },
      filter: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("filter", {
          "--tw-blur": " ",
          "--tw-brightness": " ",
          "--tw-contrast": " ",
          "--tw-grayscale": " ",
          "--tw-hue-rotate": " ",
          "--tw-invert": " ",
          "--tw-saturate": " ",
          "--tw-sepia": " ",
          "--tw-drop-shadow": " "
        }), P3({
          ".filter": {
            "@defaults filter": {},
            filter: q2
          },
          ".filter-none": {
            filter: "none"
          }
        });
      },
      backdropBlur: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-blur": (C) => ({
            "--tw-backdrop-blur": C.trim() === "" ? " " : `blur(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropBlur")
        });
      },
      backdropBrightness: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-brightness": (C) => ({
            "--tw-backdrop-brightness": `brightness(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropBrightness")
        });
      },
      backdropContrast: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-contrast": (C) => ({
            "--tw-backdrop-contrast": `contrast(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropContrast")
        });
      },
      backdropGrayscale: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-grayscale": (C) => ({
            "--tw-backdrop-grayscale": `grayscale(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropGrayscale")
        });
      },
      backdropHueRotate: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-hue-rotate": (C) => ({
            "--tw-backdrop-hue-rotate": `hue-rotate(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropHueRotate"),
          supportsNegativeValues: true
        });
      },
      backdropInvert: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-invert": (C) => ({
            "--tw-backdrop-invert": `invert(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropInvert")
        });
      },
      backdropOpacity: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-opacity": (C) => ({
            "--tw-backdrop-opacity": `opacity(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropOpacity")
        });
      },
      backdropSaturate: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-saturate": (C) => ({
            "--tw-backdrop-saturate": `saturate(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropSaturate")
        });
      },
      backdropSepia: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-sepia": (C) => ({
            "--tw-backdrop-sepia": `sepia(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropSepia")
        });
      },
      backdropFilter: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("backdrop-filter", {
          "--tw-backdrop-blur": " ",
          "--tw-backdrop-brightness": " ",
          "--tw-backdrop-contrast": " ",
          "--tw-backdrop-grayscale": " ",
          "--tw-backdrop-hue-rotate": " ",
          "--tw-backdrop-invert": " ",
          "--tw-backdrop-opacity": " ",
          "--tw-backdrop-saturate": " ",
          "--tw-backdrop-sepia": " "
        }), P3({
          ".backdrop-filter": {
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          },
          ".backdrop-filter-none": {
            "-webkit-backdrop-filter": "none",
            "backdrop-filter": "none"
          }
        });
      },
      transitionProperty: ({ matchUtilities: S3, theme: P3 }) => {
        let C = P3("transitionTimingFunction.DEFAULT"), R3 = P3("transitionDuration.DEFAULT");
        S3({
          transition: ($2) => ({
            "transition-property": $2,
            ...$2 === "none" ? {} : {
              "transition-timing-function": C,
              "transition-duration": R3
            }
          })
        }, {
          values: P3("transitionProperty")
        });
      },
      transitionDelay: (0, f.default)("transitionDelay", [
        [
          "delay",
          [
            "transitionDelay"
          ]
        ]
      ]),
      transitionDuration: (0, f.default)("transitionDuration", [
        [
          "duration",
          [
            "transitionDuration"
          ]
        ]
      ], {
        filterDefault: true
      }),
      transitionTimingFunction: (0, f.default)("transitionTimingFunction", [
        [
          "ease",
          [
            "transitionTimingFunction"
          ]
        ]
      ], {
        filterDefault: true
      }),
      willChange: (0, f.default)("willChange", [
        [
          "will-change",
          [
            "will-change"
          ]
        ]
      ]),
      contain: ({ addDefaults: S3, addUtilities: P3 }) => {
        let C = "var(--tw-contain-size) var(--tw-contain-layout) var(--tw-contain-paint) var(--tw-contain-style)";
        S3("contain", {
          "--tw-contain-size": " ",
          "--tw-contain-layout": " ",
          "--tw-contain-paint": " ",
          "--tw-contain-style": " "
        }), P3({
          ".contain-none": {
            contain: "none"
          },
          ".contain-content": {
            contain: "content"
          },
          ".contain-strict": {
            contain: "strict"
          },
          ".contain-size": {
            "@defaults contain": {},
            "--tw-contain-size": "size",
            contain: C
          },
          ".contain-inline-size": {
            "@defaults contain": {},
            "--tw-contain-size": "inline-size",
            contain: C
          },
          ".contain-layout": {
            "@defaults contain": {},
            "--tw-contain-layout": "layout",
            contain: C
          },
          ".contain-paint": {
            "@defaults contain": {},
            "--tw-contain-paint": "paint",
            contain: C
          },
          ".contain-style": {
            "@defaults contain": {},
            "--tw-contain-style": "style",
            contain: C
          }
        });
      },
      content: (0, f.default)("content", [
        [
          "content",
          [
            "--tw-content",
            [
              "content",
              "var(--tw-content)"
            ]
          ]
        ]
      ]),
      forcedColorAdjust: ({ addUtilities: S3 }) => {
        S3({
          ".forced-color-adjust-auto": {
            "forced-color-adjust": "auto"
          },
          ".forced-color-adjust-none": {
            "forced-color-adjust": "none"
          }
        });
      }
    };
  })(Kn3)), Kn3;
}
var ni3 = {};
var No2;
function au3() {
  return No2 || (No2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(
      u,
      // Arbitrary values must contain balanced brackets (), [] and {}. Escaped
      // values don't count, and brackets inside quotes also don't count.
      //
      // E.g.: w-[this-is]w-[weird-and-invalid]
      // E.g.: w-[this-is\\]w-\\[weird-but-valid]
      // E.g.: content-['this-is-also-valid]-weirdly-enough']
      "default",
      {
        enumerable: true,
        get: function() {
          return l2;
        }
      }
    );
    let a = /* @__PURE__ */ new Map([
      [
        "{",
        "}"
      ],
      [
        "[",
        "]"
      ],
      [
        "(",
        ")"
      ]
    ]), h2 = new Map(Array.from(a.entries()).map(([f, s2]) => [
      s2,
      f
    ])), p = /* @__PURE__ */ new Set([
      '"',
      "'",
      "`"
    ]);
    function l2(f) {
      let s2 = [], c2 = false;
      for (let t8 = 0; t8 < f.length; t8++) {
        let e2 = f[t8];
        if (e2 === ":" && !c2 && s2.length === 0)
          return false;
        if (p.has(e2) && f[t8 - 1] !== "\\" && (c2 = !c2), !c2 && f[t8 - 1] !== "\\") {
          if (a.has(e2))
            s2.push(e2);
          else if (h2.has(e2)) {
            let r2 = h2.get(e2);
            if (s2.length <= 0 || s2.pop() !== r2)
              return false;
          }
        }
      }
      return !(s2.length > 0);
    }
  })(ni3)), ni3;
}
var ii2 = {};
var Fo2;
function Mf() {
  return Fo2 || (Fo2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "hasContentChanged", {
      enumerable: true,
      get: function() {
        return c2;
      }
    });
    const a = /* @__PURE__ */ p(Ne3), h2 = /* @__PURE__ */ f(yr3());
    function p(t8) {
      return t8 && t8.__esModule ? t8 : {
        default: t8
      };
    }
    function l2(t8) {
      if (typeof WeakMap != "function") return null;
      var e2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
      return (l2 = function(i) {
        return i ? r2 : e2;
      })(t8);
    }
    function f(t8, e2) {
      if (t8 && t8.__esModule)
        return t8;
      if (t8 === null || typeof t8 != "object" && typeof t8 != "function")
        return {
          default: t8
        };
      var r2 = l2(e2);
      if (r2 && r2.has(t8))
        return r2.get(t8);
      var i = {}, o2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var v3 in t8)
        if (v3 !== "default" && Object.prototype.hasOwnProperty.call(t8, v3)) {
          var m = o2 ? Object.getOwnPropertyDescriptor(t8, v3) : null;
          m && (m.get || m.set) ? Object.defineProperty(i, v3, m) : i[v3] = t8[v3];
        }
      return i.default = t8, r2 && r2.set(t8, i), i;
    }
    function s2(t8) {
      try {
        return a.default.createHash("md5").update(t8, "utf-8").digest("binary");
      } catch {
        return "";
      }
    }
    function c2(t8, e2) {
      let r2 = e2.toString();
      if (!r2.includes("@tailwind"))
        return false;
      let i = h2.sourceHashMap.get(t8), o2 = s2(r2), v3 = i !== o2;
      return h2.sourceHashMap.set(t8, o2), v3;
    }
  })(ii2)), ii2;
}
var ai = {};
var si2 = {};
var $o3;
function Df() {
  return $o3 || ($o3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      return (h2 > 0n) - (h2 < 0n);
    }
  })(si2)), si2;
}
var oi = {};
var Uo3;
function qf() {
  return Uo3 || (Uo3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "remapBitfield", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2, p) {
      let l2 = 0n, f = 0n;
      for (let [s2, c2] of p)
        h2 & s2 && (l2 = l2 | s2, f = f | c2);
      return h2 & ~l2 | f;
    }
  })(oi)), oi;
}
var zo3;
function Lf() {
  return zo3 || (zo3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "Offsets", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = /* @__PURE__ */ p(Df()), h2 = qf();
    function p(c2) {
      return c2 && c2.__esModule ? c2 : {
        default: c2
      };
    }
    class l2 {
      constructor() {
        this.offsets = {
          defaults: 0n,
          base: 0n,
          components: 0n,
          utilities: 0n,
          variants: 0n,
          user: 0n
        }, this.layerPositions = {
          defaults: 0n,
          base: 1n,
          components: 2n,
          utilities: 3n,
          // There isn't technically a "user" layer, but we need to give it a position
          // Because it's used for ordering user-css from @apply
          user: 4n,
          variants: 5n
        }, this.reservedVariantBits = 0n, this.variantOffsets = /* @__PURE__ */ new Map();
      }
      /**
      * @param {Layer} layer
      * @returns {RuleOffset}
      */
      create(t8) {
        return {
          layer: t8,
          parentLayer: t8,
          arbitrary: 0n,
          variants: 0n,
          parallelIndex: 0n,
          index: this.offsets[t8]++,
          propertyOffset: 0n,
          property: "",
          options: []
        };
      }
      /**
      * @param {string} name
      * @returns {RuleOffset}
      */
      arbitraryProperty(t8) {
        return {
          ...this.create("utilities"),
          arbitrary: 1n,
          property: t8
        };
      }
      /**
      * Get the offset for a variant
      *
      * @param {string} variant
      * @param {number} index
      * @returns {RuleOffset}
      */
      forVariant(t8, e2 = 0) {
        let r2 = this.variantOffsets.get(t8);
        if (r2 === void 0)
          throw new Error(`Cannot find offset for unknown variant ${t8}`);
        return {
          ...this.create("variants"),
          variants: r2 << BigInt(e2)
        };
      }
      /**
      * @param {RuleOffset} rule
      * @param {RuleOffset} variant
      * @param {VariantOption} options
      * @returns {RuleOffset}
      */
      applyVariantOffset(t8, e2, r2) {
        return r2.variant = e2.variants, {
          ...t8,
          layer: "variants",
          parentLayer: t8.layer === "variants" ? t8.parentLayer : t8.layer,
          variants: t8.variants | e2.variants,
          options: r2.sort ? [].concat(r2, t8.options) : t8.options,
          // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.
          // We'll take the max of all the parallel indexes for now.
          // @ts-ignore
          parallelIndex: f([
            t8.parallelIndex,
            e2.parallelIndex
          ])
        };
      }
      /**
      * @param {RuleOffset} offset
      * @param {number} parallelIndex
      * @returns {RuleOffset}
      */
      applyParallelOffset(t8, e2) {
        return {
          ...t8,
          parallelIndex: BigInt(e2)
        };
      }
      /**
      * Each variant gets 1 bit per function / rule registered.
      * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.
      * Additionally, every unique group of variants is grouped together in the stylesheet.
      *
      * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.
      *
      * @param {string[]} variants
      * @param {(name: string) => number} getLength
      */
      recordVariants(t8, e2) {
        for (let r2 of t8)
          this.recordVariant(r2, e2(r2));
      }
      /**
      * The same as `recordVariants` but for a single arbitrary variant at runtime.
      * @param {string} variant
      * @param {number} fnCount
      *
      * @returns {RuleOffset} The highest offset for this variant
      */
      recordVariant(t8, e2 = 1) {
        return this.variantOffsets.set(t8, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(e2), {
          ...this.create("variants"),
          variants: this.variantOffsets.get(t8)
        };
      }
      /**
      * @param {RuleOffset} a
      * @param {RuleOffset} b
      * @returns {bigint}
      */
      compare(t8, e2) {
        if (t8.layer !== e2.layer)
          return this.layerPositions[t8.layer] - this.layerPositions[e2.layer];
        if (t8.parentLayer !== e2.parentLayer)
          return this.layerPositions[t8.parentLayer] - this.layerPositions[e2.parentLayer];
        for (let i of t8.options)
          for (let o2 of e2.options) {
            if (i.id !== o2.id || !i.sort || !o2.sort) continue;
            var r2;
            let v3 = (r2 = f([
              i.variant,
              o2.variant
            ])) !== null && r2 !== void 0 ? r2 : 0n, m = ~(v3 | v3 - 1n), n2 = t8.variants & m, d2 = e2.variants & m;
            if (n2 !== d2)
              continue;
            let _3 = i.sort({
              value: i.value,
              modifier: i.modifier
            }, {
              value: o2.value,
              modifier: o2.modifier
            });
            if (_3 !== 0) return _3;
          }
        return t8.variants !== e2.variants ? t8.variants - e2.variants : t8.parallelIndex !== e2.parallelIndex ? t8.parallelIndex - e2.parallelIndex : t8.arbitrary !== e2.arbitrary ? t8.arbitrary - e2.arbitrary : t8.propertyOffset !== e2.propertyOffset ? t8.propertyOffset - e2.propertyOffset : t8.index - e2.index;
      }
      /**
      * Arbitrary variants are recorded in the order they're encountered.
      * This means that the order is not stable between environments and sets of content files.
      *
      * In order to make the order stable, we need to remap the arbitrary variant offsets to
      * be in alphabetical order starting from the offset of the first arbitrary variant.
      */
      recalculateVariantOffsets() {
        let t8 = Array.from(this.variantOffsets.entries()).filter(([i]) => i.startsWith("[")).sort(([i], [o2]) => s2(i, o2)), e2 = t8.map(([, i]) => i).sort((i, o2) => (0, a.default)(i - o2));
        return t8.map(([, i], o2) => [
          i,
          e2[o2]
        ]).filter(([i, o2]) => i !== o2);
      }
      /**
      * @template T
      * @param {[RuleOffset, T][]} list
      * @returns {[RuleOffset, T][]}
      */
      remapArbitraryVariantOffsets(t8) {
        let e2 = this.recalculateVariantOffsets();
        return e2.length === 0 ? t8 : t8.map((r2) => {
          let [i, o2] = r2;
          return i = {
            ...i,
            variants: (0, h2.remapBitfield)(i.variants, e2)
          }, [
            i,
            o2
          ];
        });
      }
      /**
      * @template T
      * @param {[RuleOffset, T][]} list
      * @returns {[RuleOffset, T][]}
      */
      sortArbitraryProperties(t8) {
        let e2 = /* @__PURE__ */ new Set();
        for (let [v3] of t8)
          v3.arbitrary === 1n && e2.add(v3.property);
        if (e2.size === 0)
          return t8;
        let r2 = Array.from(e2).sort(), i = /* @__PURE__ */ new Map(), o2 = 1n;
        for (let v3 of r2)
          i.set(v3, o2++);
        return t8.map((v3) => {
          let [m, n2] = v3;
          var d2;
          return m = {
            ...m,
            propertyOffset: (d2 = i.get(m.property)) !== null && d2 !== void 0 ? d2 : 0n
          }, [
            m,
            n2
          ];
        });
      }
      /**
      * @template T
      * @param {[RuleOffset, T][]} list
      * @returns {[RuleOffset, T][]}
      */
      sort(t8) {
        return t8 = this.remapArbitraryVariantOffsets(t8), t8 = this.sortArbitraryProperties(t8), t8.sort(([e2], [r2]) => (0, a.default)(this.compare(e2, r2)));
      }
    }
    function f(c2) {
      let t8 = null;
      for (const e2 of c2)
        t8 = t8 ?? e2, t8 = t8 > e2 ? t8 : e2;
      return t8;
    }
    function s2(c2, t8) {
      let e2 = c2.length, r2 = t8.length, i = e2 < r2 ? e2 : r2;
      for (let o2 = 0; o2 < i; o2++) {
        let v3 = c2.charCodeAt(o2) - t8.charCodeAt(o2);
        if (v3 !== 0) return v3;
      }
      return e2 - r2;
    }
  })(ai)), ai;
}
var Wo3;
function Ki2() {
  return Wo3 || (Wo3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(Y3, G3) {
      for (var te2 in G3) Object.defineProperty(Y3, te2, {
        enumerable: true,
        get: G3[te2]
      });
    }
    a(u, {
      INTERNAL_FEATURES: function() {
        return M2;
      },
      isValidVariantFormatString: function() {
        return I3;
      },
      parseVariant: function() {
        return N3;
      },
      getFileModifiedMap: function() {
        return U2;
      },
      createContext: function() {
        return de3;
      },
      getContext: function() {
        return ke3;
      }
    });
    const h2 = /* @__PURE__ */ b3(Ne3), p = /* @__PURE__ */ b3(Ne3), l2 = /* @__PURE__ */ b3(Be2()), f = /* @__PURE__ */ b3(Nl()), s2 = /* @__PURE__ */ b3(Ke3()), c2 = /* @__PURE__ */ b3(pr3()), t8 = /* @__PURE__ */ b3(tu3()), e2 = /* @__PURE__ */ b3(Hi2()), r2 = /* @__PURE__ */ b3(ut3()), i = /* @__PURE__ */ b3(ft3()), o2 = /* @__PURE__ */ q2(nu3()), v3 = gr3(), m = If(), n2 = /* @__PURE__ */ q2(yr3()), d2 = Wi2(), _3 = /* @__PURE__ */ b3(tt3()), w3 = /* @__PURE__ */ b3(ji2()), y2 = /* @__PURE__ */ b3(au3()), x = wr3(), g2 = Mf(), O3 = Lf(), A = it3(), E2 = ru3();
    function b3(Y3) {
      return Y3 && Y3.__esModule ? Y3 : {
        default: Y3
      };
    }
    function k3(Y3) {
      if (typeof WeakMap != "function") return null;
      var G3 = /* @__PURE__ */ new WeakMap(), te2 = /* @__PURE__ */ new WeakMap();
      return (k3 = function(Z3) {
        return Z3 ? te2 : G3;
      })(Y3);
    }
    function q2(Y3, G3) {
      if (Y3 && Y3.__esModule)
        return Y3;
      if (Y3 === null || typeof Y3 != "object" && typeof Y3 != "function")
        return {
          default: Y3
        };
      var te2 = k3(G3);
      if (te2 && te2.has(Y3))
        return te2.get(Y3);
      var Z3 = {}, ee3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var se3 in Y3)
        if (se3 !== "default" && Object.prototype.hasOwnProperty.call(Y3, se3)) {
          var ue = ee3 ? Object.getOwnPropertyDescriptor(Y3, se3) : null;
          ue && (ue.get || ue.set) ? Object.defineProperty(Z3, se3, ue) : Z3[se3] = Y3[se3];
        }
      return Z3.default = Y3, te2 && te2.set(Y3, Z3), Z3;
    }
    const M2 = Symbol(), W3 = {
      MatchVariant: Symbol.for("MATCH_VARIANT")
    }, S3 = {
      Base: 1,
      Dynamic: 2
    };
    function P3(Y3, G3) {
      let te2 = Y3.tailwindConfig.prefix;
      return typeof te2 == "function" ? te2(G3) : te2 + G3;
    }
    function C({ type: Y3 = "any", ...G3 }) {
      let te2 = [].concat(Y3);
      return {
        ...G3,
        types: te2.map((Z3) => Array.isArray(Z3) ? {
          type: Z3[0],
          ...Z3[1]
        } : {
          type: Z3,
          preferOnConflict: false
        })
      };
    }
    function R3(Y3) {
      let G3 = [], te2 = "", Z3 = 0;
      for (let ee3 = 0; ee3 < Y3.length; ee3++) {
        let se3 = Y3[ee3];
        if (se3 === "\\")
          te2 += "\\" + Y3[++ee3];
        else if (se3 === "{")
          ++Z3, G3.push(te2.trim()), te2 = "";
        else if (se3 === "}") {
          if (--Z3 < 0)
            throw new Error("Your { and } are unbalanced.");
          G3.push(te2.trim()), te2 = "";
        } else
          te2 += se3;
      }
      return te2.length > 0 && G3.push(te2.trim()), G3 = G3.filter((ee3) => ee3 !== ""), G3;
    }
    function $2(Y3, G3, { before: te2 = [] } = {}) {
      if (te2 = [].concat(te2), te2.length <= 0) {
        Y3.push(G3);
        return;
      }
      let Z3 = Y3.length - 1;
      for (let ee3 of te2) {
        let se3 = Y3.indexOf(ee3);
        se3 !== -1 && (Z3 = Math.min(Z3, se3));
      }
      Y3.splice(Z3, 0, G3);
    }
    function B3(Y3) {
      return Array.isArray(Y3) ? Y3.flatMap((G3) => !Array.isArray(G3) && !(0, r2.default)(G3) ? G3 : (0, t8.default)(G3)) : B3([
        Y3
      ]);
    }
    function z3(Y3, G3) {
      return (0, s2.default)((Z3) => {
        let ee3 = [];
        return G3 && G3(Z3), Z3.walkClasses((se3) => {
          ee3.push(se3.value);
        }), ee3;
      }).transformSync(Y3);
    }
    function L3(Y3) {
      Y3.walkPseudos((G3) => {
        G3.value === ":not" && G3.remove();
      });
    }
    function F(Y3, G3 = {
      containsNonOnDemandable: false
    }, te2 = 0) {
      let Z3 = [], ee3 = [];
      Y3.type === "rule" ? ee3.push(...Y3.selectors) : Y3.type === "atrule" && Y3.walkRules((se3) => ee3.push(...se3.selectors));
      for (let se3 of ee3) {
        let ue = z3(se3, L3);
        ue.length === 0 && (G3.containsNonOnDemandable = true);
        for (let xe3 of ue)
          Z3.push(xe3);
      }
      return te2 === 0 ? [
        G3.containsNonOnDemandable || Z3.length === 0,
        Z3
      ] : Z3;
    }
    function D(Y3) {
      return B3(Y3).flatMap((G3) => {
        let te2 = /* @__PURE__ */ new Map(), [Z3, ee3] = F(G3);
        return Z3 && ee3.unshift(n2.NOT_ON_DEMAND), ee3.map((se3) => (te2.has(G3) || te2.set(G3, G3), [
          se3,
          te2.get(G3)
        ]));
      });
    }
    function I3(Y3) {
      return Y3.startsWith("@") || Y3.includes("&");
    }
    function N3(Y3) {
      Y3 = Y3.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
      let G3 = R3(Y3).map((te2) => {
        if (!te2.startsWith("@"))
          return ({ format: ue }) => ue(te2);
        let [, Z3, ee3] = /@(\S*)( .+|[({].*)?/g.exec(te2);
        var se3;
        return ({ wrap: ue }) => ue(l2.default.atRule({
          name: Z3,
          params: (se3 = ee3 == null ? void 0 : ee3.trim()) !== null && se3 !== void 0 ? se3 : ""
        }));
      }).reverse();
      return (te2) => {
        for (let Z3 of G3)
          Z3(te2);
      };
    }
    function J3(Y3, G3, { variantList: te2, variantMap: Z3, offsets: ee3, classList: se3 }) {
      function ue(ae3, re3) {
        return ae3 ? (0, f.default)(Y3, ae3, re3) : Y3;
      }
      function xe3(ae3) {
        return (0, e2.default)(Y3.prefix, ae3);
      }
      function ce3(ae3, re3) {
        return ae3 === n2.NOT_ON_DEMAND ? n2.NOT_ON_DEMAND : re3.respectPrefix ? G3.tailwindConfig.prefix + ae3 : ae3;
      }
      function Te3(ae3, re3, fe3 = {}) {
        let we3 = (0, d2.toPath)(ae3), ye2 = ue([
          "theme",
          ...we3
        ], re3);
        return (0, c2.default)(we3[0])(ye2, fe3);
      }
      let ve3 = 0, Ae3 = {
        postcss: l2.default,
        prefix: xe3,
        e: i.default,
        config: ue,
        theme: Te3,
        corePlugins: (ae3) => Array.isArray(Y3.corePlugins) ? Y3.corePlugins.includes(ae3) : ue([
          "corePlugins",
          ae3
        ], true),
        variants: () => [],
        addBase(ae3) {
          for (let [re3, fe3] of D(ae3)) {
            let we3 = ce3(re3, {}), ye2 = ee3.create("base");
            G3.candidateRuleMap.has(we3) || G3.candidateRuleMap.set(we3, []), G3.candidateRuleMap.get(we3).push([
              {
                sort: ye2,
                layer: "base"
              },
              fe3
            ]);
          }
        },
        /**
        * @param {string} group
        * @param {Record<string, string | string[]>} declarations
        */
        addDefaults(ae3, re3) {
          const fe3 = {
            [`@defaults ${ae3}`]: re3
          };
          for (let [we3, ye2] of D(fe3)) {
            let he3 = ce3(we3, {});
            G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push([
              {
                sort: ee3.create("defaults"),
                layer: "defaults"
              },
              ye2
            ]);
          }
        },
        addComponents(ae3, re3) {
          re3 = Object.assign({}, {
            preserveSource: false,
            respectPrefix: true,
            respectImportant: false
          }, Array.isArray(re3) ? {} : re3);
          for (let [we3, ye2] of D(ae3)) {
            let he3 = ce3(we3, re3);
            se3.add(he3), G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push([
              {
                sort: ee3.create("components"),
                layer: "components",
                options: re3
              },
              ye2
            ]);
          }
        },
        addUtilities(ae3, re3) {
          re3 = Object.assign({}, {
            preserveSource: false,
            respectPrefix: true,
            respectImportant: true
          }, Array.isArray(re3) ? {} : re3);
          for (let [we3, ye2] of D(ae3)) {
            let he3 = ce3(we3, re3);
            se3.add(he3), G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push([
              {
                sort: ee3.create("utilities"),
                layer: "utilities",
                options: re3
              },
              ye2
            ]);
          }
        },
        matchUtilities: function(ae3, re3) {
          re3 = C({
            ...{
              respectPrefix: true,
              respectImportant: true,
              modifiers: false
            },
            ...re3
          });
          let we3 = ee3.create("utilities");
          for (let ye2 in ae3) {
            let qe3 = function(Se3, { isOnlyPlugin: me3 }) {
              let [pe3, Oe3, Ue3] = (0, v3.coerceValue)(re3.types, Se3, re3, Y3);
              if (pe3 === void 0)
                return [];
              if (!re3.types.some(({ type: We2 }) => We2 === Oe3))
                if (me3)
                  _3.default.warn([
                    `Unnecessary typehint \`${Oe3}\` in \`${ye2}-${Se3}\`.`,
                    `You can safely update it to \`${ye2}-${Se3.replace(Oe3 + ":", "")}\`.`
                  ]);
                else
                  return [];
              if (!(0, y2.default)(pe3))
                return [];
              let Xe3 = {
                get modifier() {
                  return re3.modifiers || _3.default.warn(`modifier-used-without-options-for-${ye2}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]), Ue3;
                }
              }, ze3 = (0, A.flagEnabled)(Y3, "generalizedModifiers");
              return [].concat(ze3 ? Ce3(pe3, Xe3) : Ce3(pe3)).filter(Boolean).map((We2) => ({
                [(0, o2.default)(ye2, Se3)]: We2
              }));
            }, he3 = ce3(ye2, re3), Ce3 = ae3[ye2];
            se3.add([
              he3,
              re3
            ]);
            let ge3 = [
              {
                sort: we3,
                layer: "utilities",
                options: re3
              },
              qe3
            ];
            G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push(ge3);
          }
        },
        matchComponents: function(ae3, re3) {
          re3 = C({
            ...{
              respectPrefix: true,
              respectImportant: false,
              modifiers: false
            },
            ...re3
          });
          let we3 = ee3.create("components");
          for (let ye2 in ae3) {
            let qe3 = function(Se3, { isOnlyPlugin: me3 }) {
              let [pe3, Oe3, Ue3] = (0, v3.coerceValue)(re3.types, Se3, re3, Y3);
              if (pe3 === void 0)
                return [];
              if (!re3.types.some(({ type: We2 }) => We2 === Oe3))
                if (me3)
                  _3.default.warn([
                    `Unnecessary typehint \`${Oe3}\` in \`${ye2}-${Se3}\`.`,
                    `You can safely update it to \`${ye2}-${Se3.replace(Oe3 + ":", "")}\`.`
                  ]);
                else
                  return [];
              if (!(0, y2.default)(pe3))
                return [];
              let Xe3 = {
                get modifier() {
                  return re3.modifiers || _3.default.warn(`modifier-used-without-options-for-${ye2}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]), Ue3;
                }
              }, ze3 = (0, A.flagEnabled)(Y3, "generalizedModifiers");
              return [].concat(ze3 ? Ce3(pe3, Xe3) : Ce3(pe3)).filter(Boolean).map((We2) => ({
                [(0, o2.default)(ye2, Se3)]: We2
              }));
            }, he3 = ce3(ye2, re3), Ce3 = ae3[ye2];
            se3.add([
              he3,
              re3
            ]);
            let ge3 = [
              {
                sort: we3,
                layer: "components",
                options: re3
              },
              qe3
            ];
            G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push(ge3);
          }
        },
        addVariant(ae3, re3, fe3 = {}) {
          re3 = [].concat(re3).map((we3) => {
            if (typeof we3 != "string")
              return (ye2 = {}) => {
                let { args: he3, modifySelectors: Ce3, container: qe3, separator: ge3, wrap: Se3, format: me3 } = ye2, pe3 = we3(Object.assign({
                  modifySelectors: Ce3,
                  container: qe3,
                  separator: ge3
                }, fe3.type === W3.MatchVariant && {
                  args: he3,
                  wrap: Se3,
                  format: me3
                }));
                if (typeof pe3 == "string" && !I3(pe3))
                  throw new Error(`Your custom variant \`${ae3}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
                return Array.isArray(pe3) ? pe3.filter((Oe3) => typeof Oe3 == "string").map((Oe3) => N3(Oe3)) : pe3 && typeof pe3 == "string" && N3(pe3)(ye2);
              };
            if (!I3(we3))
              throw new Error(`Your custom variant \`${ae3}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
            return N3(we3);
          }), $2(te2, ae3, fe3), Z3.set(ae3, re3), G3.variantOptions.set(ae3, fe3);
        },
        matchVariant(ae3, re3, fe3) {
          var we3;
          let ye2 = (we3 = fe3 == null ? void 0 : fe3.id) !== null && we3 !== void 0 ? we3 : ++ve3, he3 = ae3 === "@", Ce3 = (0, A.flagEnabled)(Y3, "generalizedModifiers");
          var qe3;
          for (let [me3, pe3] of Object.entries((qe3 = fe3 == null ? void 0 : fe3.values) !== null && qe3 !== void 0 ? qe3 : {}))
            me3 !== "DEFAULT" && Ae3.addVariant(he3 ? `${ae3}${me3}` : `${ae3}-${me3}`, ({ args: Oe3, container: Ue3 }) => re3(pe3, Ce3 ? {
              modifier: Oe3 == null ? void 0 : Oe3.modifier,
              container: Ue3
            } : {
              container: Ue3
            }), {
              ...fe3,
              value: pe3,
              id: ye2,
              type: W3.MatchVariant,
              variantInfo: S3.Base
            });
          var ge3;
          let Se3 = "DEFAULT" in ((ge3 = fe3 == null ? void 0 : fe3.values) !== null && ge3 !== void 0 ? ge3 : {});
          Ae3.addVariant(ae3, ({ args: me3, container: pe3 }) => {
            if ((me3 == null ? void 0 : me3.value) === n2.NONE && !Se3)
              return null;
            var Oe3;
            return re3((me3 == null ? void 0 : me3.value) === n2.NONE ? fe3.values.DEFAULT : (Oe3 = me3 == null ? void 0 : me3.value) !== null && Oe3 !== void 0 ? Oe3 : typeof me3 == "string" ? me3 : "", Ce3 ? {
              modifier: me3 == null ? void 0 : me3.modifier,
              container: pe3
            } : {
              container: pe3
            });
          }, {
            ...fe3,
            id: ye2,
            type: W3.MatchVariant,
            variantInfo: S3.Dynamic
          });
        }
      };
      return Ae3;
    }
    let T3 = /* @__PURE__ */ new WeakMap();
    function U2(Y3) {
      return T3.has(Y3) || T3.set(Y3, /* @__PURE__ */ new Map()), T3.get(Y3);
    }
    function j3(Y3, G3) {
      let te2 = false, Z3 = /* @__PURE__ */ new Map();
      for (let se3 of Y3) {
        var ee3;
        if (!se3) continue;
        let ue = p.default.parse(se3), xe3 = ue.hash ? ue.href.replace(ue.hash, "") : ue.href;
        xe3 = ue.search ? xe3.replace(ue.search, "") : xe3;
        let ce3 = (ee3 = h2.default.statSync(decodeURIComponent(xe3), {
          throwIfNoEntry: false
        })) === null || ee3 === void 0 ? void 0 : ee3.mtimeMs;
        ce3 && ((!G3.has(se3) || ce3 > G3.get(se3)) && (te2 = true), Z3.set(se3, ce3));
      }
      return [
        te2,
        Z3
      ];
    }
    function H3(Y3) {
      Y3.walkAtRules((G3) => {
        [
          "responsive",
          "variants"
        ].includes(G3.name) && (H3(G3), G3.before(G3.nodes), G3.remove());
      });
    }
    function V4(Y3) {
      let G3 = [];
      return Y3.each((te2) => {
        te2.type === "atrule" && [
          "responsive",
          "variants"
        ].includes(te2.name) && (te2.name = "layer", te2.params = "utilities");
      }), Y3.walkAtRules("layer", (te2) => {
        if (H3(te2), te2.params === "base") {
          for (let Z3 of te2.nodes)
            G3.push(function({ addBase: ee3 }) {
              ee3(Z3, {
                respectPrefix: false
              });
            });
          te2.remove();
        } else if (te2.params === "components") {
          for (let Z3 of te2.nodes)
            G3.push(function({ addComponents: ee3 }) {
              ee3(Z3, {
                respectPrefix: false,
                preserveSource: true
              });
            });
          te2.remove();
        } else if (te2.params === "utilities") {
          for (let Z3 of te2.nodes)
            G3.push(function({ addUtilities: ee3 }) {
              ee3(Z3, {
                respectPrefix: false,
                preserveSource: true
              });
            });
          te2.remove();
        }
      }), G3;
    }
    function K3(Y3, G3) {
      let te2 = Object.entries({
        ...m.variantPlugins,
        ...m.corePlugins
      }).map(([ce3, Te3]) => Y3.tailwindConfig.corePlugins.includes(ce3) ? Te3 : null).filter(Boolean), Z3 = Y3.tailwindConfig.plugins.map((ce3) => (ce3.__isOptionsFunction && (ce3 = ce3()), typeof ce3 == "function" ? ce3 : ce3.handler)), ee3 = V4(G3), se3 = [
        m.variantPlugins.childVariant,
        m.variantPlugins.pseudoElementVariants,
        m.variantPlugins.pseudoClassVariants,
        m.variantPlugins.hasVariants,
        m.variantPlugins.ariaVariants,
        m.variantPlugins.dataVariants
      ], ue = [
        m.variantPlugins.supportsVariants,
        m.variantPlugins.reducedMotionVariants,
        m.variantPlugins.prefersContrastVariants,
        m.variantPlugins.screenVariants,
        m.variantPlugins.orientationVariants,
        m.variantPlugins.directionVariants,
        m.variantPlugins.darkVariants,
        m.variantPlugins.forcedColorsVariants,
        m.variantPlugins.printVariant
      ];
      return (Y3.tailwindConfig.darkMode === "class" || Array.isArray(Y3.tailwindConfig.darkMode) && Y3.tailwindConfig.darkMode[0] === "class") && (ue = [
        m.variantPlugins.supportsVariants,
        m.variantPlugins.reducedMotionVariants,
        m.variantPlugins.prefersContrastVariants,
        m.variantPlugins.darkVariants,
        m.variantPlugins.screenVariants,
        m.variantPlugins.orientationVariants,
        m.variantPlugins.directionVariants,
        m.variantPlugins.forcedColorsVariants,
        m.variantPlugins.printVariant
      ]), [
        ...te2,
        ...se3,
        ...Z3,
        ...ue,
        ...ee3
      ];
    }
    function X3(Y3, G3) {
      let te2 = [], Z3 = /* @__PURE__ */ new Map();
      G3.variantMap = Z3;
      let ee3 = new O3.Offsets();
      G3.offsets = ee3;
      let se3 = /* @__PURE__ */ new Set(), ue = J3(G3.tailwindConfig, G3, {
        variantList: te2,
        variantMap: Z3,
        offsets: ee3,
        classList: se3
      });
      for (let re3 of Y3)
        if (Array.isArray(re3))
          for (let fe3 of re3)
            fe3(ue);
        else
          re3 == null || re3(ue);
      ee3.recordVariants(te2, (re3) => Z3.get(re3).length);
      for (let [re3, fe3] of Z3.entries())
        G3.variantMap.set(re3, fe3.map((we3, ye2) => [
          ee3.forVariant(re3, ye2),
          we3
        ]));
      var xe3;
      let ce3 = ((xe3 = G3.tailwindConfig.safelist) !== null && xe3 !== void 0 ? xe3 : []).filter(Boolean);
      if (ce3.length > 0) {
        let re3 = [];
        for (let fe3 of ce3) {
          if (typeof fe3 == "string") {
            G3.changedContent.push({
              content: fe3,
              extension: "html"
            });
            continue;
          }
          if (fe3 instanceof RegExp) {
            _3.default.warn("root-regex", [
              "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
              "Update your `safelist` configuration to eliminate this warning.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
            continue;
          }
          re3.push(fe3);
        }
        if (re3.length > 0) {
          let fe3 = /* @__PURE__ */ new Map(), we3 = G3.tailwindConfig.prefix.length, ye2 = re3.some((he3) => he3.pattern.source.includes("!"));
          for (let he3 of se3) {
            let Ce3 = Array.isArray(he3) ? (() => {
              let [qe3, ge3] = he3;
              var Se3;
              let pe3 = Object.keys((Se3 = ge3 == null ? void 0 : ge3.values) !== null && Se3 !== void 0 ? Se3 : {}).map((Oe3) => (0, o2.formatClass)(qe3, Oe3));
              return ge3 != null && ge3.supportsNegativeValues && (pe3 = [
                ...pe3,
                ...pe3.map((Oe3) => "-" + Oe3)
              ], pe3 = [
                ...pe3,
                ...pe3.map((Oe3) => Oe3.slice(0, we3) + "-" + Oe3.slice(we3))
              ]), ge3.types.some(({ type: Oe3 }) => Oe3 === "color") && (pe3 = [
                ...pe3,
                ...pe3.flatMap((Oe3) => Object.keys(G3.tailwindConfig.theme.opacity).map((Ue3) => `${Oe3}/${Ue3}`))
              ]), ye2 && (ge3 != null && ge3.respectImportant) && (pe3 = [
                ...pe3,
                ...pe3.map((Oe3) => "!" + Oe3)
              ]), pe3;
            })() : [
              he3
            ];
            for (let qe3 of Ce3)
              for (let { pattern: ge3, variants: Se3 = [] } of re3)
                if (ge3.lastIndex = 0, fe3.has(ge3) || fe3.set(ge3, 0), !!ge3.test(qe3)) {
                  fe3.set(ge3, fe3.get(ge3) + 1), G3.changedContent.push({
                    content: qe3,
                    extension: "html"
                  });
                  for (let me3 of Se3)
                    G3.changedContent.push({
                      content: me3 + G3.tailwindConfig.separator + qe3,
                      extension: "html"
                    });
                }
          }
          for (let [he3, Ce3] of fe3.entries())
            Ce3 === 0 && _3.default.warn([
              `The safelist pattern \`${he3}\` doesn't match any Tailwind CSS classes.`,
              "Fix this pattern or remove it from your `safelist` configuration.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
        }
      }
      var Te3, ve3;
      let Ae3 = (ve3 = [].concat((Te3 = G3.tailwindConfig.darkMode) !== null && Te3 !== void 0 ? Te3 : "media")[1]) !== null && ve3 !== void 0 ? ve3 : "dark", ae3 = [
        P3(G3, Ae3),
        P3(G3, "group"),
        P3(G3, "peer")
      ];
      G3.getClassOrder = function(fe3) {
        let we3 = [
          ...fe3
        ].sort((ge3, Se3) => ge3 === Se3 ? 0 : ge3 < Se3 ? -1 : 1), ye2 = new Map(we3.map((ge3) => [
          ge3,
          null
        ])), he3 = (0, x.generateRules)(new Set(we3), G3, true);
        he3 = G3.offsets.sort(he3);
        let Ce3 = BigInt(ae3.length);
        for (const [, ge3] of he3) {
          let Se3 = ge3.raws.tailwind.candidate;
          var qe3;
          ye2.set(Se3, (qe3 = ye2.get(Se3)) !== null && qe3 !== void 0 ? qe3 : Ce3++);
        }
        return fe3.map((ge3) => {
          var Se3;
          let me3 = (Se3 = ye2.get(ge3)) !== null && Se3 !== void 0 ? Se3 : null, pe3 = ae3.indexOf(ge3);
          return me3 === null && pe3 !== -1 && (me3 = BigInt(pe3)), [
            ge3,
            me3
          ];
        });
      }, G3.getClassList = function(fe3 = {}) {
        let we3 = [];
        for (let ge3 of se3)
          if (Array.isArray(ge3)) {
            var ye2;
            let [Se3, me3] = ge3, pe3 = [];
            var he3;
            let Oe3 = Object.keys((he3 = me3 == null ? void 0 : me3.modifiers) !== null && he3 !== void 0 ? he3 : {});
            if (!(me3 == null || (ye2 = me3.types) === null || ye2 === void 0) && ye2.some(({ type: ze3 }) => ze3 === "color")) {
              var Ce3;
              Oe3.push(...Object.keys((Ce3 = G3.tailwindConfig.theme.opacity) !== null && Ce3 !== void 0 ? Ce3 : {}));
            }
            let Ue3 = {
              modifiers: Oe3
            }, Xe3 = fe3.includeMetadata && Oe3.length > 0;
            var qe3;
            for (let [ze3, Ze3] of Object.entries((qe3 = me3 == null ? void 0 : me3.values) !== null && qe3 !== void 0 ? qe3 : {})) {
              if (Ze3 == null)
                continue;
              let We2 = (0, o2.formatClass)(Se3, ze3);
              if (we3.push(Xe3 ? [
                We2,
                Ue3
              ] : We2), me3 != null && me3.supportsNegativeValues && (0, w3.default)(Ze3)) {
                let Je3 = (0, o2.formatClass)(Se3, `-${ze3}`);
                pe3.push(Xe3 ? [
                  Je3,
                  Ue3
                ] : Je3);
              }
            }
            we3.push(...pe3);
          } else
            we3.push(ge3);
        return we3;
      }, G3.getVariants = function() {
        let fe3 = Math.random().toString(36).substring(7).toUpperCase(), we3 = [];
        for (let [he3, Ce3] of G3.variantOptions.entries())
          if (Ce3.variantInfo !== S3.Base) {
            var ye2;
            we3.push({
              name: he3,
              isArbitrary: Ce3.type === Symbol.for("MATCH_VARIANT"),
              values: Object.keys((ye2 = Ce3.values) !== null && ye2 !== void 0 ? ye2 : {}),
              hasDash: he3 !== "@",
              selectors({ modifier: qe3, value: ge3 } = {}) {
                let Se3 = `TAILWINDPLACEHOLDER${fe3}`, me3 = l2.default.rule({
                  selector: `.${Se3}`
                }), pe3 = l2.default.root({
                  nodes: [
                    me3.clone()
                  ]
                }), Oe3 = pe3.toString();
                var Ue3;
                let Xe3 = ((Ue3 = G3.variantMap.get(he3)) !== null && Ue3 !== void 0 ? Ue3 : []).flatMap(([Ve3, je3]) => je3), ze3 = [];
                for (let Ve3 of Xe3) {
                  var Ze3;
                  let je3 = [];
                  var We2;
                  let ct3 = {
                    args: {
                      modifier: qe3,
                      value: (We2 = (Ze3 = Ce3.values) === null || Ze3 === void 0 ? void 0 : Ze3[ge3]) !== null && We2 !== void 0 ? We2 : ge3
                    },
                    separator: G3.tailwindConfig.separator,
                    modifySelectors(Ge4) {
                      return pe3.each((xr3) => {
                        xr3.type === "rule" && (xr3.selectors = xr3.selectors.map((ea2) => Ge4({
                          get className() {
                            return (0, x.getClassNameFromSelector)(ea2);
                          },
                          selector: ea2
                        })));
                      }), pe3;
                    },
                    format(Ge4) {
                      je3.push(Ge4);
                    },
                    wrap(Ge4) {
                      je3.push(`@${Ge4.name} ${Ge4.params} { & }`);
                    },
                    container: pe3
                  }, dt2 = Ve3(ct3);
                  if (je3.length > 0 && ze3.push(je3), Array.isArray(dt2))
                    for (let Ge4 of dt2)
                      je3 = [], Ge4(ct3), ze3.push(je3);
                }
                let Je3 = [], ou3 = pe3.toString();
                Oe3 !== ou3 && (pe3.walkRules((Ve3) => {
                  let je3 = Ve3.selector, ct3 = (0, s2.default)((dt2) => {
                    dt2.walkClasses((Ge4) => {
                      Ge4.value = `${he3}${G3.tailwindConfig.separator}${Ge4.value}`;
                    });
                  }).processSync(je3);
                  Je3.push(je3.replace(ct3, "&").replace(Se3, "&"));
                }), pe3.walkAtRules((Ve3) => {
                  Je3.push(`@${Ve3.name} (${Ve3.params}) { & }`);
                }));
                var br3;
                let lu = !(ge3 in ((br3 = Ce3.values) !== null && br3 !== void 0 ? br3 : {}));
                var _r3;
                let uu3 = (_r3 = Ce3[M2]) !== null && _r3 !== void 0 ? _r3 : {}, Xi2 = !(lu || uu3.respectPrefix === false);
                ze3 = ze3.map((Ve3) => Ve3.map((je3) => ({
                  format: je3,
                  respectPrefix: Xi2
                }))), Je3 = Je3.map((Ve3) => ({
                  format: Ve3,
                  respectPrefix: Xi2
                }));
                let Sr3 = {
                  candidate: Se3,
                  context: G3
                }, Zi2 = ze3.map((Ve3) => (0, E2.finalizeSelector)(`.${Se3}`, (0, E2.formatVariantSelector)(Ve3, Sr3), Sr3).replace(`.${Se3}`, "&").replace("{ & }", "").trim());
                return Je3.length > 0 && Zi2.push((0, E2.formatVariantSelector)(Je3, Sr3).toString().replace(`.${Se3}`, "&")), Zi2;
              }
            });
          }
        return we3;
      };
    }
    function Q3(Y3, G3) {
      Y3.classCache.has(G3) && (Y3.notClassCache.add(G3), Y3.classCache.delete(G3), Y3.applyClassCache.delete(G3), Y3.candidateRuleMap.delete(G3), Y3.candidateRuleCache.delete(G3), Y3.stylesheetCache = null);
    }
    function ne3(Y3, G3) {
      let te2 = G3.raws.tailwind.candidate;
      if (te2) {
        for (const Z3 of Y3.ruleCache)
          Z3[1].raws.tailwind.candidate === te2 && Y3.ruleCache.delete(Z3);
        Q3(Y3, te2);
      }
    }
    function de3(Y3, G3 = [], te2 = l2.default.root()) {
      var Z3;
      let ee3 = {
        disposables: [],
        ruleCache: /* @__PURE__ */ new Set(),
        candidateRuleCache: /* @__PURE__ */ new Map(),
        classCache: /* @__PURE__ */ new Map(),
        applyClassCache: /* @__PURE__ */ new Map(),
        // Seed the not class cache with the blocklist (which is only strings)
        notClassCache: new Set((Z3 = Y3.blocklist) !== null && Z3 !== void 0 ? Z3 : []),
        postCssNodeCache: /* @__PURE__ */ new Map(),
        candidateRuleMap: /* @__PURE__ */ new Map(),
        tailwindConfig: Y3,
        changedContent: G3,
        variantMap: /* @__PURE__ */ new Map(),
        stylesheetCache: null,
        variantOptions: /* @__PURE__ */ new Map(),
        markInvalidUtilityCandidate: (ue) => Q3(ee3, ue),
        markInvalidUtilityNode: (ue) => ne3(ee3, ue)
      }, se3 = K3(ee3, te2);
      return X3(se3, ee3), ee3;
    }
    let _e3 = n2.contextMap, be3 = n2.configContextMap, ie3 = n2.contextSourcesMap;
    function ke3(Y3, G3, te2, Z3, ee3, se3) {
      let ue = G3.opts.from, xe3 = Z3 !== null;
      n2.env.DEBUG && console.log("Source path:", ue);
      let ce3;
      if (xe3 && _e3.has(ue))
        ce3 = _e3.get(ue);
      else if (be3.has(ee3)) {
        let ae3 = be3.get(ee3);
        ie3.get(ae3).add(ue), _e3.set(ue, ae3), ce3 = ae3;
      }
      let Te3 = (0, g2.hasContentChanged)(ue, Y3);
      if (ce3) {
        let [ae3, re3] = j3([
          ...se3
        ], U2(ce3));
        if (!ae3 && !Te3)
          return [
            ce3,
            false,
            re3
          ];
      }
      if (_e3.has(ue)) {
        let ae3 = _e3.get(ue);
        if (ie3.has(ae3) && (ie3.get(ae3).delete(ue), ie3.get(ae3).size === 0)) {
          ie3.delete(ae3);
          for (let [re3, fe3] of be3)
            fe3 === ae3 && be3.delete(re3);
          for (let re3 of ae3.disposables.splice(0))
            re3(ae3);
        }
      }
      n2.env.DEBUG && console.log("Setting up new context...");
      let ve3 = de3(te2, [], Y3);
      Object.assign(ve3, {
        userConfigPath: Z3
      });
      let [, Ae3] = j3([
        ...se3
      ], U2(ve3));
      return be3.set(ee3, ve3), _e3.set(ue, ve3), ie3.has(ve3) || ie3.set(ve3, /* @__PURE__ */ new Set()), ie3.get(ve3).add(ue), [
        ve3,
        true,
        Ae3
      ];
    }
  })(Jn3)), Jn3;
}
var li2 = {};
var Vo3;
function su3() {
  return Vo3 || (Vo3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "applyImportantSelector", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = /* @__PURE__ */ p(Ke3()), h2 = Ji2();
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l2(f, s2) {
      let c2 = (0, a.default)().astSync(f);
      return c2.each((t8) => {
        t8.nodes.some((r2) => r2.type === "combinator") && (t8.nodes = [
          a.default.pseudo({
            value: ":is",
            nodes: [
              t8.clone()
            ]
          })
        ]), (0, h2.movePseudos)(t8);
      }), `${s2} ${c2.toString()}`;
    }
  })(li2)), li2;
}
var jo3;
function wr3() {
  return jo3 || (jo3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(T3, U2) {
      for (var j3 in U2) Object.defineProperty(T3, j3, {
        enumerable: true,
        get: U2[j3]
      });
    }
    a(u, {
      getClassNameFromSelector: function() {
        return O3;
      },
      resolveMatches: function() {
        return L3;
      },
      generateRules: function() {
        return N3;
      }
    });
    const h2 = /* @__PURE__ */ w3(Be2()), p = /* @__PURE__ */ w3(Ke3()), l2 = /* @__PURE__ */ w3(tu3()), f = /* @__PURE__ */ w3(ut3()), s2 = /* @__PURE__ */ w3(Hi2()), c2 = gr3(), t8 = /* @__PURE__ */ w3(tt3()), e2 = /* @__PURE__ */ x(yr3()), r2 = ru3(), i = nu3(), o2 = vr3(), v3 = Ki2(), m = /* @__PURE__ */ w3(au3()), n2 = st3(), d2 = it3(), _3 = su3();
    function w3(T3) {
      return T3 && T3.__esModule ? T3 : {
        default: T3
      };
    }
    function y2(T3) {
      if (typeof WeakMap != "function") return null;
      var U2 = /* @__PURE__ */ new WeakMap(), j3 = /* @__PURE__ */ new WeakMap();
      return (y2 = function(H3) {
        return H3 ? j3 : U2;
      })(T3);
    }
    function x(T3, U2) {
      if (T3 && T3.__esModule)
        return T3;
      if (T3 === null || typeof T3 != "object" && typeof T3 != "function")
        return {
          default: T3
        };
      var j3 = y2(U2);
      if (j3 && j3.has(T3))
        return j3.get(T3);
      var H3 = {}, V4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var K3 in T3)
        if (K3 !== "default" && Object.prototype.hasOwnProperty.call(T3, K3)) {
          var X3 = V4 ? Object.getOwnPropertyDescriptor(T3, K3) : null;
          X3 && (X3.get || X3.set) ? Object.defineProperty(H3, K3, X3) : H3[K3] = T3[K3];
        }
      return H3.default = T3, j3 && j3.set(T3, H3), H3;
    }
    let g2 = (0, p.default)((T3) => T3.first.filter(({ type: U2 }) => U2 === "class").pop().value);
    function O3(T3) {
      return g2.transformSync(T3);
    }
    function* A(T3) {
      let U2 = 1 / 0;
      for (; U2 >= 0; ) {
        let j3, H3 = false;
        if (U2 === 1 / 0 && T3.endsWith("]")) {
          let X3 = T3.indexOf("[");
          T3[X3 - 1] === "-" ? j3 = X3 - 1 : T3[X3 - 1] === "/" ? (j3 = X3 - 1, H3 = true) : j3 = -1;
        } else U2 === 1 / 0 && T3.includes("/") ? (j3 = T3.lastIndexOf("/"), H3 = true) : j3 = T3.lastIndexOf("-", U2);
        if (j3 < 0)
          break;
        let V4 = T3.slice(0, j3), K3 = T3.slice(H3 ? j3 : j3 + 1);
        U2 = j3 - 1, !(V4 === "" || K3 === "/") && (yield [
          V4,
          K3
        ]);
      }
    }
    function E2(T3, U2) {
      if (T3.length === 0 || U2.tailwindConfig.prefix === "")
        return T3;
      for (let j3 of T3) {
        let [H3] = j3;
        if (H3.options.respectPrefix) {
          let V4 = h2.default.root({
            nodes: [
              j3[1].clone()
            ]
          }), K3 = j3[1].raws.tailwind.classCandidate;
          V4.walkRules((X3) => {
            let Q3 = K3.startsWith("-");
            X3.selector = (0, s2.default)(U2.tailwindConfig.prefix, X3.selector, Q3);
          }), j3[1] = V4.nodes[0];
        }
      }
      return T3;
    }
    function b3(T3, U2) {
      if (T3.length === 0)
        return T3;
      let j3 = [];
      function H3(V4) {
        return V4.parent && V4.parent.type === "atrule" && V4.parent.name === "keyframes";
      }
      for (let [V4, K3] of T3) {
        let X3 = h2.default.root({
          nodes: [
            K3.clone()
          ]
        });
        X3.walkRules((Q3) => {
          if (H3(Q3))
            return;
          let ne3 = (0, p.default)().astSync(Q3.selector);
          ne3.each((de3) => (0, r2.eliminateIrrelevantSelectors)(de3, U2)), (0, c2.updateAllClasses)(ne3, (de3) => de3 === U2 ? `!${de3}` : de3), Q3.selector = ne3.toString(), Q3.walkDecls((de3) => de3.important = true);
        }), j3.push([
          {
            ...V4,
            important: true
          },
          X3.nodes[0]
        ]);
      }
      return j3;
    }
    function k3(T3, U2, j3) {
      if (U2.length === 0)
        return U2;
      let H3 = {
        modifier: null,
        value: e2.NONE
      };
      {
        let [Q3, ...ne3] = (0, n2.splitAtTopLevelOnly)(T3, "/");
        if (ne3.length > 1 && (Q3 = Q3 + "/" + ne3.slice(0, -1).join("/"), ne3 = ne3.slice(-1)), ne3.length && !j3.variantMap.has(T3) && (T3 = Q3, H3.modifier = ne3[0], !(0, d2.flagEnabled)(j3.tailwindConfig, "generalizedModifiers")))
          return [];
      }
      if (T3.endsWith("]") && !T3.startsWith("[")) {
        let Q3 = /(.)(-?)\[(.*)\]/g.exec(T3);
        if (Q3) {
          let [, ne3, de3, _e3] = Q3;
          if (ne3 === "@" && de3 === "-") return [];
          if (ne3 !== "@" && de3 === "") return [];
          T3 = T3.replace(`${de3}[${_e3}]`, ""), H3.value = _e3;
        }
      }
      if (J3(T3) && !j3.variantMap.has(T3)) {
        let Q3 = j3.offsets.recordVariant(T3), ne3 = (0, o2.normalize)(T3.slice(1, -1)), de3 = (0, n2.splitAtTopLevelOnly)(ne3, ",");
        if (de3.length > 1)
          return [];
        if (!de3.every(v3.isValidVariantFormatString))
          return [];
        let _e3 = de3.map((be3, ie3) => [
          j3.offsets.applyParallelOffset(Q3, ie3),
          (0, v3.parseVariant)(be3.trim())
        ]);
        j3.variantMap.set(T3, _e3);
      }
      if (j3.variantMap.has(T3)) {
        var V4;
        let Q3 = J3(T3);
        var K3;
        let ne3 = (K3 = (V4 = j3.variantOptions.get(T3)) === null || V4 === void 0 ? void 0 : V4[v3.INTERNAL_FEATURES]) !== null && K3 !== void 0 ? K3 : {}, de3 = j3.variantMap.get(T3).slice(), _e3 = [], be3 = !(Q3 || ne3.respectPrefix === false);
        for (let [ie3, ke3] of U2) {
          if (ie3.layer === "user")
            continue;
          let Y3 = h2.default.root({
            nodes: [
              ke3.clone()
            ]
          });
          for (let [G3, te2, Z3] of de3) {
            let ue = function() {
              ee3.raws.neededBackup || (ee3.raws.neededBackup = true, ee3.walkRules((ve3) => ve3.raws.originalSelector = ve3.selector));
            }, xe3 = function(ve3) {
              return ue(), ee3.each((Ae3) => {
                Ae3.type === "rule" && (Ae3.selectors = Ae3.selectors.map((ae3) => ve3({
                  get className() {
                    return O3(ae3);
                  },
                  selector: ae3
                })));
              }), ee3;
            }, ee3 = (Z3 ?? Y3).clone(), se3 = [], ce3 = te2({
              // Public API
              get container() {
                return ue(), ee3;
              },
              separator: j3.tailwindConfig.separator,
              modifySelectors: xe3,
              // Private API for now
              wrap(ve3) {
                let Ae3 = ee3.nodes;
                ee3.removeAll(), ve3.append(Ae3), ee3.append(ve3);
              },
              format(ve3) {
                se3.push({
                  format: ve3,
                  respectPrefix: be3
                });
              },
              args: H3
            });
            if (Array.isArray(ce3)) {
              for (let [ve3, Ae3] of ce3.entries())
                de3.push([
                  j3.offsets.applyParallelOffset(G3, ve3),
                  Ae3,
                  // If the clone has been modified we have to pass that back
                  // though so each rule can use the modified container
                  ee3.clone()
                ]);
              continue;
            }
            if (typeof ce3 == "string" && se3.push({
              format: ce3,
              respectPrefix: be3
            }), ce3 === null)
              continue;
            ee3.raws.neededBackup && (delete ee3.raws.neededBackup, ee3.walkRules((ve3) => {
              let Ae3 = ve3.raws.originalSelector;
              if (!Ae3 || (delete ve3.raws.originalSelector, Ae3 === ve3.selector)) return;
              let ae3 = ve3.selector, re3 = (0, p.default)((fe3) => {
                fe3.walkClasses((we3) => {
                  we3.value = `${T3}${j3.tailwindConfig.separator}${we3.value}`;
                });
              }).processSync(Ae3);
              se3.push({
                format: ae3.replace(re3, "&"),
                respectPrefix: be3
              }), ve3.selector = Ae3;
            })), ee3.nodes[0].raws.tailwind = {
              ...ee3.nodes[0].raws.tailwind,
              parentLayer: ie3.layer
            };
            var X3;
            let Te3 = [
              {
                ...ie3,
                sort: j3.offsets.applyVariantOffset(ie3.sort, G3, Object.assign(H3, j3.variantOptions.get(T3))),
                collectedFormats: ((X3 = ie3.collectedFormats) !== null && X3 !== void 0 ? X3 : []).concat(se3)
              },
              ee3.nodes[0]
            ];
            _e3.push(Te3);
          }
        }
        return _e3;
      }
      return [];
    }
    function q2(T3, U2, j3 = {}) {
      return !(0, f.default)(T3) && !Array.isArray(T3) ? [
        [
          T3
        ],
        j3
      ] : Array.isArray(T3) ? q2(T3[0], U2, T3[1]) : (U2.has(T3) || U2.set(T3, (0, l2.default)(T3)), [
        U2.get(T3),
        j3
      ]);
    }
    const M2 = /^[a-z_-]/;
    function W3(T3) {
      return M2.test(T3);
    }
    function S3(T3) {
      if (!T3.includes("://"))
        return false;
      try {
        const U2 = new URL(T3);
        return U2.scheme !== "" && U2.host !== "";
      } catch {
        return false;
      }
    }
    function P3(T3) {
      let U2 = true;
      return T3.walkDecls((j3) => {
        if (!C(j3.prop, j3.value))
          return U2 = false, false;
      }), U2;
    }
    function C(T3, U2) {
      if (S3(`${T3}:${U2}`))
        return false;
      try {
        return h2.default.parse(`a{${T3}:${U2}}`).toResult(), true;
      } catch {
        return false;
      }
    }
    function R3(T3, U2) {
      var j3;
      let [, H3, V4] = (j3 = T3.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) !== null && j3 !== void 0 ? j3 : [];
      if (V4 === void 0 || !W3(H3) || !(0, m.default)(V4))
        return null;
      let K3 = (0, o2.normalize)(V4, {
        property: H3
      });
      return C(H3, K3) ? [
        [
          {
            sort: U2.offsets.arbitraryProperty(T3),
            layer: "utilities",
            options: {
              respectImportant: true
            }
          },
          () => ({
            [(0, i.asClass)(T3)]: {
              [H3]: K3
            }
          })
        ]
      ] : null;
    }
    function* $2(T3, U2) {
      U2.candidateRuleMap.has(T3) && (yield [
        U2.candidateRuleMap.get(T3),
        "DEFAULT"
      ]), yield* (function* (Q3) {
        Q3 !== null && (yield [
          Q3,
          "DEFAULT"
        ]);
      })(R3(T3, U2));
      let j3 = T3, H3 = false;
      const V4 = U2.tailwindConfig.prefix, K3 = V4.length, X3 = j3.startsWith(V4) || j3.startsWith(`-${V4}`);
      j3[K3] === "-" && X3 && (H3 = true, j3 = V4 + j3.slice(K3 + 1)), H3 && U2.candidateRuleMap.has(j3) && (yield [
        U2.candidateRuleMap.get(j3),
        "-DEFAULT"
      ]);
      for (let [Q3, ne3] of A(j3))
        U2.candidateRuleMap.has(Q3) && (yield [
          U2.candidateRuleMap.get(Q3),
          H3 ? `-${ne3}` : ne3
        ]);
    }
    function B3(T3, U2) {
      return T3 === e2.NOT_ON_DEMAND ? [
        e2.NOT_ON_DEMAND
      ] : (0, n2.splitAtTopLevelOnly)(T3, U2);
    }
    function* z3(T3, U2) {
      for (const V4 of T3) {
        var j3, H3;
        V4[1].raws.tailwind = {
          ...V4[1].raws.tailwind,
          classCandidate: U2,
          preserveSource: (H3 = (j3 = V4[0].options) === null || j3 === void 0 ? void 0 : j3.preserveSource) !== null && H3 !== void 0 ? H3 : false
        }, yield V4;
      }
    }
    function* L3(T3, U2) {
      let j3 = U2.tailwindConfig.separator, [H3, ...V4] = B3(T3, j3).reverse(), K3 = false;
      H3.startsWith("!") && (K3 = true, H3 = H3.slice(1));
      for (let be3 of $2(H3, U2)) {
        let ie3 = [], ke3 = /* @__PURE__ */ new Map(), [Y3, G3] = be3, te2 = Y3.length === 1;
        for (let [Z3, ee3] of Y3) {
          let se3 = [];
          if (typeof ee3 == "function")
            for (let ue of [].concat(ee3(G3, {
              isOnlyPlugin: te2
            }))) {
              let [xe3, ce3] = q2(ue, U2.postCssNodeCache);
              for (let Te3 of xe3)
                se3.push([
                  {
                    ...Z3,
                    options: {
                      ...Z3.options,
                      ...ce3
                    }
                  },
                  Te3
                ]);
            }
          else if (G3 === "DEFAULT" || G3 === "-DEFAULT") {
            let ue = ee3, [xe3, ce3] = q2(ue, U2.postCssNodeCache);
            for (let Te3 of xe3)
              se3.push([
                {
                  ...Z3,
                  options: {
                    ...Z3.options,
                    ...ce3
                  }
                },
                Te3
              ]);
          }
          if (se3.length > 0) {
            var X3, Q3, ne3;
            let ue = Array.from((0, c2.getMatchingTypes)((Q3 = (X3 = Z3.options) === null || X3 === void 0 ? void 0 : X3.types) !== null && Q3 !== void 0 ? Q3 : [], G3, (ne3 = Z3.options) !== null && ne3 !== void 0 ? ne3 : {}, U2.tailwindConfig)).map(([xe3, ce3]) => ce3);
            ue.length > 0 && ke3.set(se3, ue), ie3.push(se3);
          }
        }
        if (J3(G3)) {
          if (ie3.length > 1) {
            let se3 = function(xe3) {
              return xe3.length === 1 ? xe3[0] : xe3.find((ce3) => {
                let Te3 = ke3.get(ce3);
                return ce3.some(([{ options: ve3 }, Ae3]) => P3(Ae3) ? ve3.types.some(({ type: ae3, preferOnConflict: re3 }) => Te3.includes(ae3) && re3) : false);
              });
            }, [Z3, ee3] = ie3.reduce((xe3, ce3) => (ce3.some(([{ options: ve3 }]) => ve3.types.some(({ type: Ae3 }) => Ae3 === "any")) ? xe3[0].push(ce3) : xe3[1].push(ce3), xe3), [
              [],
              []
            ]);
            var de3;
            let ue = (de3 = se3(ee3)) !== null && de3 !== void 0 ? de3 : se3(Z3);
            if (ue)
              ie3 = [
                ue
              ];
            else {
              var _e3;
              let xe3 = ie3.map((Te3) => /* @__PURE__ */ new Set([
                ...(_e3 = ke3.get(Te3)) !== null && _e3 !== void 0 ? _e3 : []
              ]));
              for (let Te3 of xe3)
                for (let ve3 of Te3) {
                  let Ae3 = false;
                  for (let ae3 of xe3)
                    Te3 !== ae3 && ae3.has(ve3) && (ae3.delete(ve3), Ae3 = true);
                  Ae3 && Te3.delete(ve3);
                }
              let ce3 = [];
              for (let [Te3, ve3] of xe3.entries())
                for (let Ae3 of ve3) {
                  let ae3 = ie3[Te3].map(([, re3]) => re3).flat().map((re3) => re3.toString().split(`
`).slice(1, -1).map((fe3) => fe3.trim()).map((fe3) => `      ${fe3}`).join(`
`)).join(`

`);
                  ce3.push(`  Use \`${T3.replace("[", `[${Ae3}:`)}\` for \`${ae3.trim()}\``);
                  break;
                }
              t8.default.warn([
                `The class \`${T3}\` is ambiguous and matches multiple utilities.`,
                ...ce3,
                `If this is content and not a class, replace it with \`${T3.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
              ]);
              continue;
            }
          }
          ie3 = ie3.map((Z3) => Z3.filter((ee3) => P3(ee3[1])));
        }
        ie3 = ie3.flat(), ie3 = Array.from(z3(ie3, H3)), ie3 = E2(ie3, U2), K3 && (ie3 = b3(ie3, H3));
        for (let Z3 of V4)
          ie3 = k3(Z3, ie3, U2);
        for (let Z3 of ie3)
          Z3[1].raws.tailwind = {
            ...Z3[1].raws.tailwind,
            candidate: T3
          }, Z3 = F(Z3, {
            context: U2,
            candidate: T3
          }), Z3 !== null && (yield Z3);
      }
    }
    function F(T3, { context: U2, candidate: j3 }) {
      if (!T3[0].collectedFormats)
        return T3;
      let H3 = true, V4;
      try {
        V4 = (0, r2.formatVariantSelector)(T3[0].collectedFormats, {
          context: U2,
          candidate: j3
        });
      } catch {
        return null;
      }
      let K3 = h2.default.root({
        nodes: [
          T3[1].clone()
        ]
      });
      return K3.walkRules((X3) => {
        if (!D(X3))
          try {
            let Q3 = (0, r2.finalizeSelector)(X3.selector, V4, {
              candidate: j3,
              context: U2
            });
            if (Q3 === null) {
              X3.remove();
              return;
            }
            X3.selector = Q3;
          } catch {
            return H3 = false, false;
          }
      }), !H3 || K3.nodes.length === 0 ? null : (T3[1] = K3.nodes[0], T3);
    }
    function D(T3) {
      return T3.parent && T3.parent.type === "atrule" && T3.parent.name === "keyframes";
    }
    function I3(T3) {
      if (T3 === true)
        return (U2) => {
          D(U2) || U2.walkDecls((j3) => {
            j3.parent.type === "rule" && !D(j3.parent) && (j3.important = true);
          });
        };
      if (typeof T3 == "string")
        return (U2) => {
          D(U2) || (U2.selectors = U2.selectors.map((j3) => (0, _3.applyImportantSelector)(j3, T3)));
        };
    }
    function N3(T3, U2, j3 = false) {
      let H3 = [], V4 = I3(U2.tailwindConfig.important);
      for (let X3 of T3) {
        if (U2.notClassCache.has(X3))
          continue;
        if (U2.candidateRuleCache.has(X3)) {
          H3 = H3.concat(Array.from(U2.candidateRuleCache.get(X3)));
          continue;
        }
        let Q3 = Array.from(L3(X3, U2));
        if (Q3.length === 0) {
          U2.notClassCache.add(X3);
          continue;
        }
        U2.classCache.set(X3, Q3);
        var K3;
        let ne3 = (K3 = U2.candidateRuleCache.get(X3)) !== null && K3 !== void 0 ? K3 : /* @__PURE__ */ new Set();
        U2.candidateRuleCache.set(X3, ne3);
        for (const de3 of Q3) {
          let [{ sort: _e3, options: be3 }, ie3] = de3;
          if (be3.respectImportant && V4) {
            let Y3 = h2.default.root({
              nodes: [
                ie3.clone()
              ]
            });
            Y3.walkRules(V4), ie3 = Y3.nodes[0];
          }
          let ke3 = [
            _e3,
            j3 ? ie3.clone() : ie3
          ];
          ne3.add(ke3), U2.ruleCache.add(ke3), H3.push(ke3);
        }
      }
      return H3;
    }
    function J3(T3) {
      return T3.startsWith("[") && T3.endsWith("]");
    }
  })(qn3)), qn3;
}
var Bo2;
function Nf() {
  return Bo2 || (Bo2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return O3;
      }
    });
    const a = /* @__PURE__ */ c2(Be2()), h2 = /* @__PURE__ */ c2(Ke3()), p = wr3(), l2 = /* @__PURE__ */ c2(ft3()), f = su3(), s2 = Ji2();
    function c2(A) {
      return A && A.__esModule ? A : {
        default: A
      };
    }
    function t8(A) {
      let E2 = /* @__PURE__ */ new Map();
      a.default.root({
        nodes: [
          A.clone()
        ]
      }).walkRules((M2) => {
        (0, h2.default)((W3) => {
          W3.walkClasses((S3) => {
            let P3 = S3.parent.toString(), C = E2.get(P3);
            C || E2.set(P3, C = /* @__PURE__ */ new Set()), C.add(S3.value);
          });
        }).processSync(M2.selector);
      });
      let k3 = Array.from(E2.values(), (M2) => Array.from(M2)), q2 = k3.flat();
      return Object.assign(q2, {
        groups: k3
      });
    }
    let e2 = (0, h2.default)();
    function r2(A) {
      return e2.astSync(A);
    }
    function i(A, E2) {
      let b3 = /* @__PURE__ */ new Set();
      for (let k3 of A)
        b3.add(k3.split(E2).pop());
      return Array.from(b3);
    }
    function o2(A, E2) {
      let b3 = A.tailwindConfig.prefix;
      return typeof b3 == "function" ? b3(E2) : b3 + E2;
    }
    function* v3(A) {
      for (yield A; A.parent; )
        yield A.parent, A = A.parent;
    }
    function m(A, E2 = {}) {
      let b3 = A.nodes;
      A.nodes = [];
      let k3 = A.clone(E2);
      return A.nodes = b3, k3;
    }
    function n2(A) {
      for (let E2 of v3(A))
        if (A !== E2) {
          if (E2.type === "root")
            break;
          A = m(E2, {
            nodes: [
              A
            ]
          });
        }
      return A;
    }
    function d2(A, E2) {
      let b3 = /* @__PURE__ */ new Map();
      return A.walkRules((k3) => {
        for (let S3 of v3(k3)) {
          var q2;
          if (((q2 = S3.raws.tailwind) === null || q2 === void 0 ? void 0 : q2.layer) !== void 0)
            return;
        }
        let M2 = n2(k3), W3 = E2.offsets.create("user");
        for (let S3 of t8(k3)) {
          let P3 = b3.get(S3) || [];
          b3.set(S3, P3), P3.push([
            {
              layer: "user",
              sort: W3,
              important: false
            },
            M2
          ]);
        }
      }), b3;
    }
    function _3(A, E2) {
      for (let b3 of A) {
        if (E2.notClassCache.has(b3) || E2.applyClassCache.has(b3))
          continue;
        if (E2.classCache.has(b3)) {
          E2.applyClassCache.set(b3, E2.classCache.get(b3).map(([q2, M2]) => [
            q2,
            M2.clone()
          ]));
          continue;
        }
        let k3 = Array.from((0, p.resolveMatches)(b3, E2));
        if (k3.length === 0) {
          E2.notClassCache.add(b3);
          continue;
        }
        E2.applyClassCache.set(b3, k3);
      }
      return E2.applyClassCache;
    }
    function w3(A) {
      let E2 = null;
      return {
        get: (b3) => (E2 = E2 || A(), E2.get(b3)),
        has: (b3) => (E2 = E2 || A(), E2.has(b3))
      };
    }
    function y2(A) {
      return {
        get: (E2) => A.flatMap((b3) => b3.get(E2) || []),
        has: (E2) => A.some((b3) => b3.has(E2))
      };
    }
    function x(A) {
      let E2 = A.split(/[\s\t\n]+/g);
      return E2[E2.length - 1] === "!important" ? [
        E2.slice(0, -1),
        true
      ] : [
        E2,
        false
      ];
    }
    function g2(A, E2, b3) {
      let k3 = /* @__PURE__ */ new Set(), q2 = [];
      if (A.walkAtRules("apply", (P3) => {
        let [C] = x(P3.params);
        for (let R3 of C)
          k3.add(R3);
        q2.push(P3);
      }), q2.length === 0)
        return;
      let M2 = y2([
        b3,
        _3(k3, E2)
      ]);
      function W3(P3, C, R3) {
        let $2 = r2(P3), B3 = r2(C), L3 = r2(`.${(0, l2.default)(R3)}`).nodes[0].nodes[0];
        return $2.each((F) => {
          let D = /* @__PURE__ */ new Set();
          B3.each((I3) => {
            let N3 = false;
            I3 = I3.clone(), I3.walkClasses((J3) => {
              J3.value === L3.value && (N3 || (J3.replaceWith(...F.nodes.map((T3) => T3.clone())), D.add(I3), N3 = true));
            });
          });
          for (let I3 of D) {
            let N3 = [
              []
            ];
            for (let J3 of I3.nodes)
              J3.type === "combinator" ? (N3.push(J3), N3.push([])) : N3[N3.length - 1].push(J3);
            I3.nodes = [];
            for (let J3 of N3)
              Array.isArray(J3) && J3.sort((T3, U2) => T3.type === "tag" && U2.type === "class" ? -1 : T3.type === "class" && U2.type === "tag" ? 1 : T3.type === "class" && U2.type === "pseudo" && U2.value.startsWith("::") ? -1 : T3.type === "pseudo" && T3.value.startsWith("::") && U2.type === "class" ? 1 : 0), I3.nodes = I3.nodes.concat(J3);
          }
          F.replaceWith(...D);
        }), $2.toString();
      }
      let S3 = /* @__PURE__ */ new Map();
      for (let P3 of q2) {
        let [C] = S3.get(P3.parent) || [
          [],
          P3.source
        ];
        S3.set(P3.parent, [
          C,
          P3.source
        ]);
        let [R3, $2] = x(P3.params);
        if (P3.parent.type === "atrule") {
          if (P3.parent.name === "screen") {
            let B3 = P3.parent.params;
            throw P3.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${R3.map((z3) => `${B3}:${z3}`).join(" ")} instead.`);
          }
          throw P3.error(`@apply is not supported within nested at-rules like @${P3.parent.name}. You can fix this by un-nesting @${P3.parent.name}.`);
        }
        for (let B3 of R3) {
          if ([
            o2(E2, "group"),
            o2(E2, "peer")
          ].includes(B3))
            throw P3.error(`@apply should not be used with the '${B3}' utility`);
          if (!M2.has(B3))
            throw P3.error(`The \`${B3}\` class does not exist. If \`${B3}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
          let z3 = M2.get(B3);
          for (let [, L3] of z3)
            L3.type !== "atrule" && L3.walkRules(() => {
              throw P3.error([
                `The \`${B3}\` class cannot be used with \`@apply\` because \`@apply\` does not currently support nested CSS.`,
                "Rewrite the selector without nesting or configure the `tailwindcss/nesting` plugin:",
                "https://tailwindcss.com/docs/using-with-preprocessors#nesting"
              ].join(`
`));
            });
          C.push([
            B3,
            $2,
            z3
          ]);
        }
      }
      for (let [P3, [C, R3]] of S3) {
        let $2 = [];
        for (let [z3, L3, F] of C) {
          let D = [
            z3,
            ...i([
              z3
            ], E2.tailwindConfig.separator)
          ];
          for (let [I3, N3] of F) {
            let J3 = t8(P3), T3 = t8(N3);
            if (T3 = T3.groups.filter((V4) => V4.some((K3) => D.includes(K3))).flat(), T3 = T3.concat(i(T3, E2.tailwindConfig.separator)), J3.some((V4) => T3.includes(V4)))
              throw N3.error(`You cannot \`@apply\` the \`${z3}\` utility here because it creates a circular dependency.`);
            let j3 = a.default.root({
              nodes: [
                N3.clone()
              ]
            });
            j3.walk((V4) => {
              V4.source = R3;
            }), (N3.type !== "atrule" || N3.type === "atrule" && N3.name !== "keyframes") && j3.walkRules((V4) => {
              if (!t8(V4).some((de3) => de3 === z3)) {
                V4.remove();
                return;
              }
              let K3 = typeof E2.tailwindConfig.important == "string" ? E2.tailwindConfig.important : null, Q3 = P3.raws.tailwind !== void 0 && K3 && P3.selector.indexOf(K3) === 0 ? P3.selector.slice(K3.length) : P3.selector;
              Q3 === "" && (Q3 = P3.selector), V4.selector = W3(Q3, V4.selector, z3), K3 && Q3 !== P3.selector && (V4.selector = (0, f.applyImportantSelector)(V4.selector, K3)), V4.walkDecls((de3) => {
                de3.important = I3.important || L3;
              });
              let ne3 = (0, h2.default)().astSync(V4.selector);
              ne3.each((de3) => (0, s2.movePseudos)(de3)), V4.selector = ne3.toString();
            }), j3.nodes[0] && $2.push([
              I3.sort,
              j3.nodes[0]
            ]);
          }
        }
        let B3 = E2.offsets.sort($2).map((z3) => z3[1]);
        P3.after(B3);
      }
      for (let P3 of q2)
        P3.parent.nodes.length > 1 ? P3.remove() : P3.parent.remove();
      g2(A, E2, b3);
    }
    function O3(A) {
      return (E2) => {
        let b3 = w3(() => d2(E2, A));
        g2(E2, A, b3);
      };
    }
  })(Rn3)), Rn3;
}
var Ff = Nf();
var $f = /* @__PURE__ */ He3(Ff);
var ui2 = {};
var fi2;
var Go3;
function Uf() {
  if (Go3) return fi2;
  Go3 = 1;
  class u {
    constructor(h2 = {}) {
      if (!(h2.maxSize && h2.maxSize > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      if (typeof h2.maxAge == "number" && h2.maxAge === 0)
        throw new TypeError("`maxAge` must be a number greater than 0");
      this.maxSize = h2.maxSize, this.maxAge = h2.maxAge || 1 / 0, this.onEviction = h2.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
    }
    _emitEvictions(h2) {
      if (typeof this.onEviction == "function")
        for (const [p, l2] of h2)
          this.onEviction(p, l2.value);
    }
    _deleteIfExpired(h2, p) {
      return typeof p.expiry == "number" && p.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(h2, p.value), this.delete(h2)) : false;
    }
    _getOrDeleteIfExpired(h2, p) {
      if (this._deleteIfExpired(h2, p) === false)
        return p.value;
    }
    _getItemValue(h2, p) {
      return p.expiry ? this._getOrDeleteIfExpired(h2, p) : p.value;
    }
    _peek(h2, p) {
      const l2 = p.get(h2);
      return this._getItemValue(h2, l2);
    }
    _set(h2, p) {
      this.cache.set(h2, p), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
    }
    _moveToRecent(h2, p) {
      this.oldCache.delete(h2), this._set(h2, p);
    }
    *_entriesAscending() {
      for (const h2 of this.oldCache) {
        const [p, l2] = h2;
        this.cache.has(p) || this._deleteIfExpired(p, l2) === false && (yield h2);
      }
      for (const h2 of this.cache) {
        const [p, l2] = h2;
        this._deleteIfExpired(p, l2) === false && (yield h2);
      }
    }
    get(h2) {
      if (this.cache.has(h2)) {
        const p = this.cache.get(h2);
        return this._getItemValue(h2, p);
      }
      if (this.oldCache.has(h2)) {
        const p = this.oldCache.get(h2);
        if (this._deleteIfExpired(h2, p) === false)
          return this._moveToRecent(h2, p), p.value;
      }
    }
    set(h2, p, { maxAge: l2 = this.maxAge === 1 / 0 ? void 0 : Date.now() + this.maxAge } = {}) {
      this.cache.has(h2) ? this.cache.set(h2, {
        value: p,
        maxAge: l2
      }) : this._set(h2, { value: p, expiry: l2 });
    }
    has(h2) {
      return this.cache.has(h2) ? !this._deleteIfExpired(h2, this.cache.get(h2)) : this.oldCache.has(h2) ? !this._deleteIfExpired(h2, this.oldCache.get(h2)) : false;
    }
    peek(h2) {
      if (this.cache.has(h2))
        return this._peek(h2, this.cache);
      if (this.oldCache.has(h2))
        return this._peek(h2, this.oldCache);
    }
    delete(h2) {
      const p = this.cache.delete(h2);
      return p && this._size--, this.oldCache.delete(h2) || p;
    }
    clear() {
      this.cache.clear(), this.oldCache.clear(), this._size = 0;
    }
    resize(h2) {
      if (!(h2 && h2 > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      const p = [...this._entriesAscending()], l2 = p.length - h2;
      l2 < 0 ? (this.cache = new Map(p), this.oldCache = /* @__PURE__ */ new Map(), this._size = p.length) : (l2 > 0 && this._emitEvictions(p.slice(0, l2)), this.oldCache = new Map(p.slice(l2)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = h2;
    }
    *keys() {
      for (const [h2] of this)
        yield h2;
    }
    *values() {
      for (const [, h2] of this)
        yield h2;
    }
    *[Symbol.iterator]() {
      for (const h2 of this.cache) {
        const [p, l2] = h2;
        this._deleteIfExpired(p, l2) === false && (yield [p, l2.value]);
      }
      for (const h2 of this.oldCache) {
        const [p, l2] = h2;
        this.cache.has(p) || this._deleteIfExpired(p, l2) === false && (yield [p, l2.value]);
      }
    }
    *entriesDescending() {
      let h2 = [...this.cache];
      for (let p = h2.length - 1; p >= 0; --p) {
        const l2 = h2[p], [f, s2] = l2;
        this._deleteIfExpired(f, s2) === false && (yield [f, s2.value]);
      }
      h2 = [...this.oldCache];
      for (let p = h2.length - 1; p >= 0; --p) {
        const l2 = h2[p], [f, s2] = l2;
        this.cache.has(f) || this._deleteIfExpired(f, s2) === false && (yield [f, s2.value]);
      }
    }
    *entriesAscending() {
      for (const [h2, p] of this._entriesAscending())
        yield [h2, p.value];
    }
    get size() {
      if (!this._size)
        return this.oldCache.size;
      let h2 = 0;
      for (const p of this.oldCache.keys())
        this.cache.has(p) || h2++;
      return Math.min(this._size + h2, this.maxSize);
    }
  }
  return fi2 = u, fi2;
}
var ci2 = {};
var Yo3;
function zf() {
  return Yo3 || (Yo3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(p, l2 = void 0, f = void 0) {
      return p.map((s2) => {
        let c2 = s2.clone();
        return f !== void 0 && (c2.raws.tailwind = {
          ...c2.raws.tailwind,
          ...f
        }), l2 !== void 0 && h2(c2, (t8) => {
          var e2;
          if (((e2 = t8.raws.tailwind) === null || e2 === void 0 ? void 0 : e2.preserveSource) === true && t8.source)
            return false;
          t8.source = l2;
        }), c2;
      });
    }
    function h2(p, l2) {
      if (l2(p) !== false) {
        var f;
        (f = p.each) === null || f === void 0 || f.call(p, (s2) => h2(s2, l2));
      }
    }
  })(ci2)), ci2;
}
var di2 = {};
var pi2 = {};
var Qo3;
function Wf() {
  return Qo3 || (Qo3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(o2, v3) {
      for (var m in v3) Object.defineProperty(o2, m, {
        enumerable: true,
        get: v3[m]
      });
    }
    a(u, {
      pattern: function() {
        return f;
      },
      withoutCapturing: function() {
        return s2;
      },
      any: function() {
        return c2;
      },
      optional: function() {
        return t8;
      },
      zeroOrMore: function() {
        return e2;
      },
      nestedBrackets: function() {
        return r2;
      },
      escape: function() {
        return i;
      }
    });
    const h2 = /[\\^$.*+?()[\]{}|]/g, p = RegExp(h2.source);
    function l2(o2) {
      return o2 = Array.isArray(o2) ? o2 : [
        o2
      ], o2 = o2.map((v3) => v3 instanceof RegExp ? v3.source : v3), o2.join("");
    }
    function f(o2) {
      return new RegExp(l2(o2), "g");
    }
    function s2(o2) {
      return new RegExp(`(?:${l2(o2)})`, "g");
    }
    function c2(o2) {
      return `(?:${o2.map(l2).join("|")})`;
    }
    function t8(o2) {
      return `(?:${l2(o2)})?`;
    }
    function e2(o2) {
      return `(?:${l2(o2)})*`;
    }
    function r2(o2, v3, m = 1) {
      return s2([
        i(o2),
        /[^\s]*/,
        m === 1 ? `[^${i(o2)}${i(v3)}s]*` : c2([
          `[^${i(o2)}${i(v3)}s]*`,
          r2(o2, v3, m - 1)
        ]),
        /[^\s]*/,
        i(v3)
      ]);
    }
    function i(o2) {
      return o2 && p.test(o2) ? o2.replace(h2, "\\$&") : o2 || "";
    }
  })(pi2)), pi2;
}
var Ho3;
function Vf() {
  return Ho3 || (Ho3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "defaultExtractor", {
      enumerable: true,
      get: function() {
        return f;
      }
    });
    const a = /* @__PURE__ */ l2(Wf()), h2 = st3();
    function p(r2) {
      if (typeof WeakMap != "function") return null;
      var i = /* @__PURE__ */ new WeakMap(), o2 = /* @__PURE__ */ new WeakMap();
      return (p = function(v3) {
        return v3 ? o2 : i;
      })(r2);
    }
    function l2(r2, i) {
      if (r2 && r2.__esModule)
        return r2;
      if (r2 === null || typeof r2 != "object" && typeof r2 != "function")
        return {
          default: r2
        };
      var o2 = p(i);
      if (o2 && o2.has(r2))
        return o2.get(r2);
      var v3 = {}, m = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var n2 in r2)
        if (n2 !== "default" && Object.prototype.hasOwnProperty.call(r2, n2)) {
          var d2 = m ? Object.getOwnPropertyDescriptor(r2, n2) : null;
          d2 && (d2.get || d2.set) ? Object.defineProperty(v3, n2, d2) : v3[n2] = r2[n2];
        }
      return v3.default = r2, o2 && o2.set(r2, v3), v3;
    }
    function f(r2) {
      let i = Array.from(s2(r2));
      return (o2) => {
        let v3 = [];
        for (let n2 of i) {
          var m;
          for (let d2 of (m = o2.match(n2)) !== null && m !== void 0 ? m : [])
            v3.push(e2(d2));
        }
        for (let n2 of v3.slice()) {
          let d2 = (0, h2.splitAtTopLevelOnly)(n2, ".");
          for (let _3 = 0; _3 < d2.length; _3++) {
            let w3 = d2[_3];
            if (_3 >= d2.length - 1) {
              v3.push(w3);
              continue;
            }
            let y2 = Number(d2[_3 + 1]);
            isNaN(y2) ? v3.push(w3) : _3++;
          }
        }
        return v3;
      };
    }
    function* s2(r2) {
      let i = r2.tailwindConfig.separator, o2 = r2.tailwindConfig.prefix !== "" ? a.optional(a.pattern([
        /-?/,
        a.escape(r2.tailwindConfig.prefix)
      ])) : "", v3 = a.any([
        // Arbitrary properties (without square brackets)
        /\[[^\s:'"`]+:[^\s\[\]]+\]/,
        // Arbitrary properties with balanced square brackets
        // This is a targeted fix to continue to allow theme()
        // with square brackets to work in arbitrary properties
        // while fixing a problem with the regex matching too much
        /\[[^\s:'"`\]]+:[^\s]+?\[[^\s]+\][^\s]+?\]/,
        // Utilities
        a.pattern([
          // Utility Name / Group Name
          a.any([
            /-?(?:\w+)/,
            // This is here to make sure @container supports everything that other utilities do
            /@(?:\w+)/
          ]),
          // Normal/Arbitrary values
          a.optional(a.any([
            a.pattern([
              // Arbitrary values
              a.any([
                /-(?:\w+-)*\['[^\s]+'\]/,
                /-(?:\w+-)*\["[^\s]+"\]/,
                /-(?:\w+-)*\[`[^\s]+`\]/,
                /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s:\[\]]+\]/
              ]),
              // Not immediately followed by an `{[(`
              /(?![{([]])/,
              // optionally followed by an opacity modifier
              /(?:\/[^\s'"`\\><$]*)?/
            ]),
            a.pattern([
              // Arbitrary values
              a.any([
                /-(?:\w+-)*\['[^\s]+'\]/,
                /-(?:\w+-)*\["[^\s]+"\]/,
                /-(?:\w+-)*\[`[^\s]+`\]/,
                /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s\[\]]+\]/
              ]),
              // Not immediately followed by an `{[(`
              /(?![{([]])/,
              // optionally followed by an opacity modifier
              /(?:\/[^\s'"`\\$]*)?/
            ]),
            // Normal values w/o quotes — may include an opacity modifier
            /[-\/][^\s'"`\\$={><]*/
          ]))
        ])
      ]), m = [
        // Without quotes
        a.any([
          // This is here to provide special support for the `@` variant
          a.pattern([
            /@\[[^\s"'`]+\](\/[^\s"'`]+)?/,
            i
          ]),
          // With variant modifier (e.g.: group-[..]/modifier)
          a.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]\/[\w_-]+/,
            i
          ]),
          a.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/,
            i
          ]),
          a.pattern([
            /[^\s"'`\[\\]+/,
            i
          ])
        ]),
        // With quotes allowed
        a.any([
          // With variant modifier (e.g.: group-[..]/modifier)
          a.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s`]+\]\/[\w_-]+/,
            i
          ]),
          a.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s`]+\]/,
            i
          ]),
          a.pattern([
            /[^\s`\[\\]+/,
            i
          ])
        ])
      ];
      for (const n2 of m)
        yield a.pattern([
          // Variants
          "((?=((",
          n2,
          ")+))\\2)?",
          // Important (optional)
          /!?/,
          o2,
          v3
        ]);
      yield /[^<>"'`\s.(){}[\]#=%$][^<>"'`\s(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
    }
    let c2 = /([\[\]'"`])([^\[\]'"`])?/g, t8 = /[^"'`\s<>\]]+/;
    function e2(r2) {
      if (!r2.includes("-["))
        return r2;
      let i = 0, o2 = [], v3 = r2.matchAll(c2);
      v3 = Array.from(v3).flatMap((m) => {
        const [, ...n2] = m;
        return n2.map((d2, _3) => Object.assign([], m, {
          index: m.index + _3,
          0: d2
        }));
      });
      for (let m of v3) {
        let n2 = m[0], d2 = o2[o2.length - 1];
        if (n2 === d2 ? o2.pop() : (n2 === "'" || n2 === '"' || n2 === "`") && o2.push(n2), !d2) {
          if (n2 === "[") {
            i++;
            continue;
          } else if (n2 === "]") {
            i--;
            continue;
          }
          if (i < 0)
            return r2.substring(0, m.index - 1);
          if (i === 0 && !t8.test(n2))
            return r2.substring(0, m.index);
        }
      }
      return r2;
    }
  })(di2)), di2;
}
var Jo3;
function jf() {
  return Jo3 || (Jo3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return y2;
      }
    });
    const a = /* @__PURE__ */ t8(Ne3), h2 = /* @__PURE__ */ t8(Uf()), p = /* @__PURE__ */ r2(yr3()), l2 = wr3(), f = /* @__PURE__ */ t8(tt3()), s2 = /* @__PURE__ */ t8(zf()), c2 = Vf();
    function t8(x) {
      return x && x.__esModule ? x : {
        default: x
      };
    }
    function e2(x) {
      if (typeof WeakMap != "function") return null;
      var g2 = /* @__PURE__ */ new WeakMap(), O3 = /* @__PURE__ */ new WeakMap();
      return (e2 = function(A) {
        return A ? O3 : g2;
      })(x);
    }
    function r2(x, g2) {
      if (x && x.__esModule)
        return x;
      if (x === null || typeof x != "object" && typeof x != "function")
        return {
          default: x
        };
      var O3 = e2(g2);
      if (O3 && O3.has(x))
        return O3.get(x);
      var A = {}, E2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var b3 in x)
        if (b3 !== "default" && Object.prototype.hasOwnProperty.call(x, b3)) {
          var k3 = E2 ? Object.getOwnPropertyDescriptor(x, b3) : null;
          k3 && (k3.get || k3.set) ? Object.defineProperty(A, b3, k3) : A[b3] = x[b3];
        }
      return A.default = x, O3 && O3.set(x, A), A;
    }
    let i = p.env;
    const o2 = {
      DEFAULT: c2.defaultExtractor
    }, v3 = {
      DEFAULT: (x) => x,
      svelte: (x) => x.replace(/(?:^|\s)class:/g, " ")
    };
    function m(x, g2) {
      let O3 = x.tailwindConfig.content.extract;
      return O3[g2] || O3.DEFAULT || o2[g2] || o2.DEFAULT(x);
    }
    function n2(x, g2) {
      let O3 = x.content.transform;
      return O3[g2] || O3.DEFAULT || v3[g2] || v3.DEFAULT;
    }
    let d2 = /* @__PURE__ */ new WeakMap();
    function _3(x, g2, O3, A) {
      d2.has(g2) || d2.set(g2, new h2.default({
        maxSize: 25e3
      }));
      for (let E2 of x.split(`
`))
        if (E2 = E2.trim(), !A.has(E2))
          if (A.add(E2), d2.get(g2).has(E2))
            for (let b3 of d2.get(g2).get(E2))
              O3.add(b3);
          else {
            let b3 = g2(E2).filter((q2) => q2 !== "!*"), k3 = new Set(b3);
            for (let q2 of k3)
              O3.add(q2);
            d2.get(g2).set(E2, k3);
          }
    }
    function w3(x, g2) {
      let O3 = g2.offsets.sort(x), A = {
        base: /* @__PURE__ */ new Set(),
        defaults: /* @__PURE__ */ new Set(),
        components: /* @__PURE__ */ new Set(),
        utilities: /* @__PURE__ */ new Set(),
        variants: /* @__PURE__ */ new Set()
      };
      for (let [E2, b3] of O3)
        A[E2.layer].add(b3);
      return A;
    }
    function y2(x) {
      return async (g2) => {
        let O3 = {
          base: null,
          components: null,
          utilities: null,
          variants: null
        };
        if (g2.walkAtRules((F) => {
          F.name === "tailwind" && Object.keys(O3).includes(F.params) && (O3[F.params] = F);
        }), Object.values(O3).every((F) => F === null))
          return g2;
        var A;
        let E2 = /* @__PURE__ */ new Set([
          ...(A = x.candidates) !== null && A !== void 0 ? A : [],
          p.NOT_ON_DEMAND
        ]), b3 = /* @__PURE__ */ new Set();
        i.DEBUG && console.time("Reading changed files");
        let k3 = [];
        for (let F of x.changedContent) {
          let D = n2(x.tailwindConfig, F.extension), I3 = m(x, F.extension);
          k3.push([
            F,
            {
              transformer: D,
              extractor: I3
            }
          ]);
        }
        const q2 = 500;
        for (let F = 0; F < k3.length; F += q2) {
          let D = k3.slice(F, F + q2);
          await Promise.all(D.map(async ([{ file: I3, content: N3 }, { transformer: J3, extractor: T3 }]) => {
            N3 = I3 ? await a.default.promises.readFile(I3, "utf8") : N3, _3(J3(N3), T3, E2, b3);
          }));
        }
        i.DEBUG && console.timeEnd("Reading changed files");
        let M2 = x.classCache.size;
        i.DEBUG && console.time("Generate rules"), i.DEBUG && console.time("Sorting candidates");
        let W3 = new Set([
          ...E2
        ].sort((F, D) => F === D ? 0 : F < D ? -1 : 1));
        i.DEBUG && console.timeEnd("Sorting candidates"), (0, l2.generateRules)(W3, x), i.DEBUG && console.timeEnd("Generate rules"), i.DEBUG && console.time("Build stylesheet"), (x.stylesheetCache === null || x.classCache.size !== M2) && (x.stylesheetCache = w3([
          ...x.ruleCache
        ], x)), i.DEBUG && console.timeEnd("Build stylesheet");
        let { defaults: S3, base: P3, components: C, utilities: R3, variants: $2 } = x.stylesheetCache;
        O3.base && (O3.base.before((0, s2.default)([
          ...P3,
          ...S3
        ], O3.base.source, {
          layer: "base"
        })), O3.base.remove()), O3.components && (O3.components.before((0, s2.default)([
          ...C
        ], O3.components.source, {
          layer: "components"
        })), O3.components.remove()), O3.utilities && (O3.utilities.before((0, s2.default)([
          ...R3
        ], O3.utilities.source, {
          layer: "utilities"
        })), O3.utilities.remove());
        const B3 = Array.from($2).filter((F) => {
          var D;
          const I3 = (D = F.raws.tailwind) === null || D === void 0 ? void 0 : D.parentLayer;
          return I3 === "components" ? O3.components !== null : I3 === "utilities" ? O3.utilities !== null : true;
        });
        O3.variants ? (O3.variants.before((0, s2.default)(B3, O3.variants.source, {
          layer: "variants"
        })), O3.variants.remove()) : B3.length > 0 && g2.append((0, s2.default)(B3, g2.source, {
          layer: "variants"
        }));
        var z3;
        g2.source.end = (z3 = g2.source.end) !== null && z3 !== void 0 ? z3 : g2.source.start;
        const L3 = B3.some((F) => {
          var D;
          return ((D = F.raws.tailwind) === null || D === void 0 ? void 0 : D.parentLayer) === "utilities";
        });
        O3.utilities && R3.size === 0 && !L3 && f.default.warn("content-problems", [
          "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
          "https://tailwindcss.com/docs/content-configuration"
        ]), i.DEBUG && (console.log("Potential classes: ", E2.size), console.log("Active contexts: ", p.contextSourcesMap.size)), x.changedContent = [], g2.walkAtRules("layer", (F) => {
          Object.keys(O3).includes(F.params) && F.remove();
        });
      };
    }
  })(ui2)), ui2;
}
var Bf = jf();
var Gf = /* @__PURE__ */ He3(Bf);
var Yf = wr3();
var hi2 = {};
var Ko3;
function Qf() {
  return Ko3 || (Ko3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return h2;
      }
    });
    function a(p) {
      if (!p.walkAtRules) return;
      let l2 = /* @__PURE__ */ new Set();
      if (p.walkAtRules("apply", (f) => {
        l2.add(f.parent);
      }), l2.size !== 0)
        for (let f of l2) {
          let s2 = [], c2 = [];
          for (let t8 of f.nodes)
            t8.type === "atrule" && t8.name === "apply" ? (c2.length > 0 && (s2.push(c2), c2 = []), s2.push([
              t8
            ])) : c2.push(t8);
          if (c2.length > 0 && s2.push(c2), s2.length !== 1) {
            for (let t8 of [
              ...s2
            ].reverse()) {
              let e2 = f.clone({
                nodes: []
              });
              e2.append(t8), f.after(e2);
            }
            f.remove();
          }
        }
    }
    function h2() {
      return (p) => {
        a(p);
      };
    }
  })(hi2)), hi2;
}
var Hf = Qf();
var Xo3 = /* @__PURE__ */ He3(Hf);
var vi2 = {};
var Zo3;
function Jf() {
  return Zo3 || (Zo3 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(o2, v3) {
      for (var m in v3) Object.defineProperty(o2, m, {
        enumerable: true,
        get: v3[m]
      });
    }
    a(u, {
      elementSelectorParser: function() {
        return t8;
      },
      default: function() {
        return i;
      }
    });
    const h2 = /* @__PURE__ */ f(Be2()), p = /* @__PURE__ */ f(Ke3()), l2 = it3();
    function f(o2) {
      return o2 && o2.__esModule ? o2 : {
        default: o2
      };
    }
    let s2 = {
      id(o2) {
        return p.default.attribute({
          attribute: "id",
          operator: "=",
          value: o2.value,
          quoteMark: '"'
        });
      }
    };
    function c2(o2) {
      let v3 = o2.filter((y2) => y2.type !== "pseudo" || y2.nodes.length > 0 ? true : y2.value.startsWith("::") || [
        ":before",
        ":after",
        ":first-line",
        ":first-letter"
      ].includes(y2.value)).reverse(), m = /* @__PURE__ */ new Set([
        "tag",
        "class",
        "id",
        "attribute"
      ]), n2 = v3.findIndex((y2) => m.has(y2.type));
      if (n2 === -1) return v3.reverse().join("").trim();
      let d2 = v3[n2], _3 = s2[d2.type] ? s2[d2.type](d2) : d2;
      v3 = v3.slice(0, n2);
      let w3 = v3.findIndex((y2) => y2.type === "combinator" && y2.value === ">");
      return w3 !== -1 && (v3.splice(0, w3), v3.unshift(p.default.universal())), [
        _3,
        ...v3.reverse()
      ].join("").trim();
    }
    let t8 = (0, p.default)((o2) => o2.map((v3) => {
      let m = v3.split((n2) => n2.type === "combinator" && n2.value === " ").pop();
      return c2(m);
    })), e2 = /* @__PURE__ */ new Map();
    function r2(o2) {
      return e2.has(o2) || e2.set(o2, t8.transformSync(o2)), e2.get(o2);
    }
    function i({ tailwindConfig: o2 }) {
      return (v3) => {
        let m = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Set();
        if (v3.walkAtRules("defaults", (w3) => {
          if (w3.nodes && w3.nodes.length > 0) {
            n2.add(w3);
            return;
          }
          let y2 = w3.params;
          m.has(y2) || m.set(y2, /* @__PURE__ */ new Set()), m.get(y2).add(w3.parent), w3.remove();
        }), (0, l2.flagEnabled)(o2, "optimizeUniversalDefaults"))
          for (let w3 of n2) {
            let y2 = /* @__PURE__ */ new Map();
            var d2;
            let x = (d2 = m.get(w3.params)) !== null && d2 !== void 0 ? d2 : [];
            for (let g2 of x)
              for (let O3 of r2(g2.selector)) {
                let A = O3.includes(":-") || O3.includes("::-") || O3.includes(":has") ? O3 : "__DEFAULT__";
                var _3;
                let E2 = (_3 = y2.get(A)) !== null && _3 !== void 0 ? _3 : /* @__PURE__ */ new Set();
                y2.set(A, E2), E2.add(O3);
              }
            if ((0, l2.flagEnabled)(o2, "optimizeUniversalDefaults")) {
              if (y2.size === 0) {
                w3.remove();
                continue;
              }
              for (let [, g2] of y2) {
                let O3 = h2.default.rule({
                  source: w3.source
                });
                O3.selectors = [
                  ...g2
                ], O3.append(w3.nodes.map((A) => A.clone())), w3.before(O3);
              }
            }
            w3.remove();
          }
        else if (n2.size) {
          let w3 = h2.default.rule({
            selectors: [
              "*",
              "::before",
              "::after"
            ]
          });
          for (let x of n2)
            w3.append(x.nodes), w3.parent || x.before(w3), w3.source || (w3.source = x.source), x.remove();
          let y2 = w3.clone({
            selectors: [
              "::backdrop"
            ]
          });
          w3.after(y2);
        }
      };
    }
  })(vi2)), vi2;
}
var Kf = Jf();
var Xf = /* @__PURE__ */ He3(Kf);
var gi2 = {};
var el;
function Zf() {
  return el || (el = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = Ui2(), h2 = /* @__PURE__ */ p(zi2());
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l2({ tailwindConfig: { theme: f } }) {
      return function(s2) {
        s2.walkAtRules("screen", (c2) => {
          let t8 = c2.params, r2 = (0, a.normalizeScreens)(f.screens).find(({ name: i }) => i === t8);
          if (!r2)
            throw c2.error(`No \`${t8}\` screen found.`);
          c2.name = "media", c2.params = (0, h2.default)(r2);
        });
      };
    }
  })(gi2)), gi2;
}
var ec = Zf();
var tc = /* @__PURE__ */ He3(ec);
var rc = (u, a) => u instanceof Ra2 && a instanceof Ra2 ? u.selector === a.selector || a.selector.includes("*") || a.selector.includes(":root") : u === a;
var nc = (u) => (u.walkRules((a) => {
  const h2 = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Set();
  a.walkDecls((l2) => {
    if (/var\(--[^\s)]+\)/.test(l2.value)) {
      const f = [
        ...l2.value.matchAll(/var\(--[^\s)]+\)/gm)
      ].map((s2) => s2.toString());
      u.walkDecls((s2) => {
        var c2;
        if (/--[^\s]+/.test(s2.prop)) {
          const t8 = `var(${s2.prop})`;
          if (f != null && f.includes(t8) && rc(l2.parent, s2.parent)) {
            if (((c2 = s2.parent) == null ? void 0 : c2.parent) instanceof wl && s2.parent !== l2.parent) {
              const e2 = s2.parent.parent, r2 = xu2();
              r2.prop = l2.prop, r2.value = l2.value.replaceAll(
                t8,
                s2.value
              ), r2.important = l2.important;
              const i = h2.get(e2);
              i ? i.add(r2) : h2.set(
                s2.parent.parent,
                /* @__PURE__ */ new Set([r2])
              );
              return;
            }
            p.add({
              declaration: l2,
              replacing: t8,
              replacement: s2.value
            });
          }
        }
      });
    }
  });
  for (const {
    declaration: l2,
    replacing: f,
    replacement: s2
  } of p)
    l2.value = l2.value.replaceAll(f, s2);
  for (const [l2, f] of h2.entries()) {
    const s2 = Su2();
    s2.selector = a.selector, s2.append(...f), l2.append(s2);
  }
}), u.walkDecls((a) => {
  if (/--[^\s]+/.test(a.prop)) {
    const h2 = a.parent;
    a.remove(), h2 && Li2(h2);
  }
}), u);
var ic = Ki2();
var mi2 = {};
var yi2 = {};
var wi2 = {};
var tl;
function ac() {
  return tl || (tl = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    const a = [
      "preflight",
      "container",
      "accessibility",
      "pointerEvents",
      "visibility",
      "position",
      "inset",
      "isolation",
      "zIndex",
      "order",
      "gridColumn",
      "gridColumnStart",
      "gridColumnEnd",
      "gridRow",
      "gridRowStart",
      "gridRowEnd",
      "float",
      "clear",
      "margin",
      "boxSizing",
      "lineClamp",
      "display",
      "aspectRatio",
      "size",
      "height",
      "maxHeight",
      "minHeight",
      "width",
      "minWidth",
      "maxWidth",
      "flex",
      "flexShrink",
      "flexGrow",
      "flexBasis",
      "tableLayout",
      "captionSide",
      "borderCollapse",
      "borderSpacing",
      "transformOrigin",
      "translate",
      "rotate",
      "skew",
      "scale",
      "transform",
      "animation",
      "cursor",
      "touchAction",
      "userSelect",
      "resize",
      "scrollSnapType",
      "scrollSnapAlign",
      "scrollSnapStop",
      "scrollMargin",
      "scrollPadding",
      "listStylePosition",
      "listStyleType",
      "listStyleImage",
      "appearance",
      "columns",
      "breakBefore",
      "breakInside",
      "breakAfter",
      "gridAutoColumns",
      "gridAutoFlow",
      "gridAutoRows",
      "gridTemplateColumns",
      "gridTemplateRows",
      "flexDirection",
      "flexWrap",
      "placeContent",
      "placeItems",
      "alignContent",
      "alignItems",
      "justifyContent",
      "justifyItems",
      "gap",
      "space",
      "divideWidth",
      "divideStyle",
      "divideColor",
      "divideOpacity",
      "placeSelf",
      "alignSelf",
      "justifySelf",
      "overflow",
      "overscrollBehavior",
      "scrollBehavior",
      "textOverflow",
      "hyphens",
      "whitespace",
      "textWrap",
      "wordBreak",
      "borderRadius",
      "borderWidth",
      "borderStyle",
      "borderColor",
      "borderOpacity",
      "backgroundColor",
      "backgroundOpacity",
      "backgroundImage",
      "gradientColorStops",
      "boxDecorationBreak",
      "backgroundSize",
      "backgroundAttachment",
      "backgroundClip",
      "backgroundPosition",
      "backgroundRepeat",
      "backgroundOrigin",
      "fill",
      "stroke",
      "strokeWidth",
      "objectFit",
      "objectPosition",
      "padding",
      "textAlign",
      "textIndent",
      "verticalAlign",
      "fontFamily",
      "fontSize",
      "fontWeight",
      "textTransform",
      "fontStyle",
      "fontVariantNumeric",
      "lineHeight",
      "letterSpacing",
      "textColor",
      "textOpacity",
      "textDecoration",
      "textDecorationColor",
      "textDecorationStyle",
      "textDecorationThickness",
      "textUnderlineOffset",
      "fontSmoothing",
      "placeholderColor",
      "placeholderOpacity",
      "caretColor",
      "accentColor",
      "opacity",
      "backgroundBlendMode",
      "mixBlendMode",
      "boxShadow",
      "boxShadowColor",
      "outlineStyle",
      "outlineWidth",
      "outlineOffset",
      "outlineColor",
      "ringWidth",
      "ringColor",
      "ringOpacity",
      "ringOffsetWidth",
      "ringOffsetColor",
      "blur",
      "brightness",
      "contrast",
      "dropShadow",
      "grayscale",
      "hueRotate",
      "invert",
      "saturate",
      "sepia",
      "filter",
      "backdropBlur",
      "backdropBrightness",
      "backdropContrast",
      "backdropGrayscale",
      "backdropHueRotate",
      "backdropInvert",
      "backdropOpacity",
      "backdropSaturate",
      "backdropSepia",
      "backdropFilter",
      "transitionProperty",
      "transitionDelay",
      "transitionDuration",
      "transitionTimingFunction",
      "willChange",
      "contain",
      "content",
      "forcedColorAdjust"
    ];
  })(wi2)), wi2;
}
var bi2 = {};
var rl;
function sc() {
  return rl || (rl = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2, p) {
      return h2 === void 0 ? p : Array.isArray(h2) ? h2 : [
        ...new Set(p.filter((f) => h2 !== false && h2[f] !== false).concat(Object.keys(h2).filter((f) => h2[f] !== false)))
      ];
    }
  })(bi2)), bi2;
}
var _i2 = {};
var nl2;
function oc() {
  return nl2 || (nl2 = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = /* @__PURE__ */ h2(tt3());
    function h2(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function p({ version: f, from: s2, to: c2 }) {
      a.default.warn(`${s2}-color-renamed`, [
        `As of Tailwind CSS ${f}, \`${s2}\` has been renamed to \`${c2}\`.`,
        "Update your configuration file to silence this warning."
      ]);
    }
    const l2 = {
      inherit: "inherit",
      current: "currentColor",
      transparent: "transparent",
      black: "#000",
      white: "#fff",
      slate: {
        50: "#f8fafc",
        100: "#f1f5f9",
        200: "#e2e8f0",
        300: "#cbd5e1",
        400: "#94a3b8",
        500: "#64748b",
        600: "#475569",
        700: "#334155",
        800: "#1e293b",
        900: "#0f172a",
        950: "#020617"
      },
      gray: {
        50: "#f9fafb",
        100: "#f3f4f6",
        200: "#e5e7eb",
        300: "#d1d5db",
        400: "#9ca3af",
        500: "#6b7280",
        600: "#4b5563",
        700: "#374151",
        800: "#1f2937",
        900: "#111827",
        950: "#030712"
      },
      zinc: {
        50: "#fafafa",
        100: "#f4f4f5",
        200: "#e4e4e7",
        300: "#d4d4d8",
        400: "#a1a1aa",
        500: "#71717a",
        600: "#52525b",
        700: "#3f3f46",
        800: "#27272a",
        900: "#18181b",
        950: "#09090b"
      },
      neutral: {
        50: "#fafafa",
        100: "#f5f5f5",
        200: "#e5e5e5",
        300: "#d4d4d4",
        400: "#a3a3a3",
        500: "#737373",
        600: "#525252",
        700: "#404040",
        800: "#262626",
        900: "#171717",
        950: "#0a0a0a"
      },
      stone: {
        50: "#fafaf9",
        100: "#f5f5f4",
        200: "#e7e5e4",
        300: "#d6d3d1",
        400: "#a8a29e",
        500: "#78716c",
        600: "#57534e",
        700: "#44403c",
        800: "#292524",
        900: "#1c1917",
        950: "#0c0a09"
      },
      red: {
        50: "#fef2f2",
        100: "#fee2e2",
        200: "#fecaca",
        300: "#fca5a5",
        400: "#f87171",
        500: "#ef4444",
        600: "#dc2626",
        700: "#b91c1c",
        800: "#991b1b",
        900: "#7f1d1d",
        950: "#450a0a"
      },
      orange: {
        50: "#fff7ed",
        100: "#ffedd5",
        200: "#fed7aa",
        300: "#fdba74",
        400: "#fb923c",
        500: "#f97316",
        600: "#ea580c",
        700: "#c2410c",
        800: "#9a3412",
        900: "#7c2d12",
        950: "#431407"
      },
      amber: {
        50: "#fffbeb",
        100: "#fef3c7",
        200: "#fde68a",
        300: "#fcd34d",
        400: "#fbbf24",
        500: "#f59e0b",
        600: "#d97706",
        700: "#b45309",
        800: "#92400e",
        900: "#78350f",
        950: "#451a03"
      },
      yellow: {
        50: "#fefce8",
        100: "#fef9c3",
        200: "#fef08a",
        300: "#fde047",
        400: "#facc15",
        500: "#eab308",
        600: "#ca8a04",
        700: "#a16207",
        800: "#854d0e",
        900: "#713f12",
        950: "#422006"
      },
      lime: {
        50: "#f7fee7",
        100: "#ecfccb",
        200: "#d9f99d",
        300: "#bef264",
        400: "#a3e635",
        500: "#84cc16",
        600: "#65a30d",
        700: "#4d7c0f",
        800: "#3f6212",
        900: "#365314",
        950: "#1a2e05"
      },
      green: {
        50: "#f0fdf4",
        100: "#dcfce7",
        200: "#bbf7d0",
        300: "#86efac",
        400: "#4ade80",
        500: "#22c55e",
        600: "#16a34a",
        700: "#15803d",
        800: "#166534",
        900: "#14532d",
        950: "#052e16"
      },
      emerald: {
        50: "#ecfdf5",
        100: "#d1fae5",
        200: "#a7f3d0",
        300: "#6ee7b7",
        400: "#34d399",
        500: "#10b981",
        600: "#059669",
        700: "#047857",
        800: "#065f46",
        900: "#064e3b",
        950: "#022c22"
      },
      teal: {
        50: "#f0fdfa",
        100: "#ccfbf1",
        200: "#99f6e4",
        300: "#5eead4",
        400: "#2dd4bf",
        500: "#14b8a6",
        600: "#0d9488",
        700: "#0f766e",
        800: "#115e59",
        900: "#134e4a",
        950: "#042f2e"
      },
      cyan: {
        50: "#ecfeff",
        100: "#cffafe",
        200: "#a5f3fc",
        300: "#67e8f9",
        400: "#22d3ee",
        500: "#06b6d4",
        600: "#0891b2",
        700: "#0e7490",
        800: "#155e75",
        900: "#164e63",
        950: "#083344"
      },
      sky: {
        50: "#f0f9ff",
        100: "#e0f2fe",
        200: "#bae6fd",
        300: "#7dd3fc",
        400: "#38bdf8",
        500: "#0ea5e9",
        600: "#0284c7",
        700: "#0369a1",
        800: "#075985",
        900: "#0c4a6e",
        950: "#082f49"
      },
      blue: {
        50: "#eff6ff",
        100: "#dbeafe",
        200: "#bfdbfe",
        300: "#93c5fd",
        400: "#60a5fa",
        500: "#3b82f6",
        600: "#2563eb",
        700: "#1d4ed8",
        800: "#1e40af",
        900: "#1e3a8a",
        950: "#172554"
      },
      indigo: {
        50: "#eef2ff",
        100: "#e0e7ff",
        200: "#c7d2fe",
        300: "#a5b4fc",
        400: "#818cf8",
        500: "#6366f1",
        600: "#4f46e5",
        700: "#4338ca",
        800: "#3730a3",
        900: "#312e81",
        950: "#1e1b4b"
      },
      violet: {
        50: "#f5f3ff",
        100: "#ede9fe",
        200: "#ddd6fe",
        300: "#c4b5fd",
        400: "#a78bfa",
        500: "#8b5cf6",
        600: "#7c3aed",
        700: "#6d28d9",
        800: "#5b21b6",
        900: "#4c1d95",
        950: "#2e1065"
      },
      purple: {
        50: "#faf5ff",
        100: "#f3e8ff",
        200: "#e9d5ff",
        300: "#d8b4fe",
        400: "#c084fc",
        500: "#a855f7",
        600: "#9333ea",
        700: "#7e22ce",
        800: "#6b21a8",
        900: "#581c87",
        950: "#3b0764"
      },
      fuchsia: {
        50: "#fdf4ff",
        100: "#fae8ff",
        200: "#f5d0fe",
        300: "#f0abfc",
        400: "#e879f9",
        500: "#d946ef",
        600: "#c026d3",
        700: "#a21caf",
        800: "#86198f",
        900: "#701a75",
        950: "#4a044e"
      },
      pink: {
        50: "#fdf2f8",
        100: "#fce7f3",
        200: "#fbcfe8",
        300: "#f9a8d4",
        400: "#f472b6",
        500: "#ec4899",
        600: "#db2777",
        700: "#be185d",
        800: "#9d174d",
        900: "#831843",
        950: "#500724"
      },
      rose: {
        50: "#fff1f2",
        100: "#ffe4e6",
        200: "#fecdd3",
        300: "#fda4af",
        400: "#fb7185",
        500: "#f43f5e",
        600: "#e11d48",
        700: "#be123c",
        800: "#9f1239",
        900: "#881337",
        950: "#4c0519"
      },
      get lightBlue() {
        return p({
          version: "v2.2",
          from: "lightBlue",
          to: "sky"
        }), this.sky;
      },
      get warmGray() {
        return p({
          version: "v3.0",
          from: "warmGray",
          to: "stone"
        }), this.stone;
      },
      get trueGray() {
        return p({
          version: "v3.0",
          from: "trueGray",
          to: "neutral"
        }), this.neutral;
      },
      get coolGray() {
        return p({
          version: "v3.0",
          from: "coolGray",
          to: "gray"
        }), this.gray;
      },
      get blueGray() {
        return p({
          version: "v3.0",
          from: "blueGray",
          to: "slate"
        }), this.slate;
      }
    };
  })(_i2)), _i2;
}
var Si2 = {};
var il;
function lc() {
  return il || (il = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "defaults", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2, ...p) {
      for (let s2 of p) {
        for (let c2 in s2) {
          var l2;
          !(h2 == null || (l2 = h2.hasOwnProperty) === null || l2 === void 0) && l2.call(h2, c2) || (h2[c2] = s2[c2]);
        }
        for (let c2 of Object.getOwnPropertySymbols(s2)) {
          var f;
          !(h2 == null || (f = h2.hasOwnProperty) === null || f === void 0) && f.call(h2, c2) || (h2[c2] = s2[c2]);
        }
      }
      return h2;
    }
  })(Si2)), Si2;
}
var xi2 = {};
var al;
function uc() {
  return al || (al = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "normalizeConfig", {
      enumerable: true,
      get: function() {
        return f;
      }
    });
    const a = it3(), h2 = /* @__PURE__ */ l2(tt3());
    function p(s2) {
      if (typeof WeakMap != "function") return null;
      var c2 = /* @__PURE__ */ new WeakMap(), t8 = /* @__PURE__ */ new WeakMap();
      return (p = function(e2) {
        return e2 ? t8 : c2;
      })(s2);
    }
    function l2(s2, c2) {
      if (s2 && s2.__esModule)
        return s2;
      if (s2 === null || typeof s2 != "object" && typeof s2 != "function")
        return {
          default: s2
        };
      var t8 = p(c2);
      if (t8 && t8.has(s2))
        return t8.get(s2);
      var e2 = {}, r2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var i in s2)
        if (i !== "default" && Object.prototype.hasOwnProperty.call(s2, i)) {
          var o2 = r2 ? Object.getOwnPropertyDescriptor(s2, i) : null;
          o2 && (o2.get || o2.set) ? Object.defineProperty(e2, i, o2) : e2[i] = s2[i];
        }
      return e2.default = s2, t8 && t8.set(s2, e2), e2;
    }
    function f(s2) {
      if ((() => {
        if (s2.purge || !s2.content || !Array.isArray(s2.content) && !(typeof s2.content == "object" && s2.content !== null))
          return false;
        if (Array.isArray(s2.content))
          return s2.content.every((e2) => typeof e2 == "string" ? true : !(typeof (e2 == null ? void 0 : e2.raw) != "string" || e2 != null && e2.extension && typeof (e2 == null ? void 0 : e2.extension) != "string"));
        if (typeof s2.content == "object" && s2.content !== null) {
          if (Object.keys(s2.content).some((e2) => ![
            "files",
            "relative",
            "extract",
            "transform"
          ].includes(e2)))
            return false;
          if (Array.isArray(s2.content.files)) {
            if (!s2.content.files.every((e2) => typeof e2 == "string" ? true : !(typeof (e2 == null ? void 0 : e2.raw) != "string" || e2 != null && e2.extension && typeof (e2 == null ? void 0 : e2.extension) != "string")))
              return false;
            if (typeof s2.content.extract == "object") {
              for (let e2 of Object.values(s2.content.extract))
                if (typeof e2 != "function")
                  return false;
            } else if (!(s2.content.extract === void 0 || typeof s2.content.extract == "function"))
              return false;
            if (typeof s2.content.transform == "object") {
              for (let e2 of Object.values(s2.content.transform))
                if (typeof e2 != "function")
                  return false;
            } else if (!(s2.content.transform === void 0 || typeof s2.content.transform == "function"))
              return false;
            if (typeof s2.content.relative != "boolean" && typeof s2.content.relative < "u")
              return false;
          }
          return true;
        }
        return false;
      })() || h2.default.warn("purge-deprecation", [
        "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
        "Update your configuration file to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
      ]), s2.safelist = (() => {
        var e2;
        let { content: r2, purge: i, safelist: o2 } = s2;
        return Array.isArray(o2) ? o2 : Array.isArray(r2 == null ? void 0 : r2.safelist) ? r2.safelist : Array.isArray(i == null ? void 0 : i.safelist) ? i.safelist : Array.isArray(i == null || (e2 = i.options) === null || e2 === void 0 ? void 0 : e2.safelist) ? i.options.safelist : [];
      })(), s2.blocklist = (() => {
        let { blocklist: e2 } = s2;
        if (Array.isArray(e2)) {
          if (e2.every((r2) => typeof r2 == "string"))
            return e2;
          h2.default.warn("blocklist-invalid", [
            "The `blocklist` option must be an array of strings.",
            "https://tailwindcss.com/docs/content-configuration#discarding-classes"
          ]);
        }
        return [];
      })(), typeof s2.prefix == "function")
        h2.default.warn("prefix-function", [
          "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
          "Update `prefix` in your configuration to be a string to eliminate this warning.",
          "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
        ]), s2.prefix = "";
      else {
        var t8;
        s2.prefix = (t8 = s2.prefix) !== null && t8 !== void 0 ? t8 : "";
      }
      s2.content = {
        relative: (() => {
          let { content: e2 } = s2;
          return e2 != null && e2.relative ? e2.relative : (0, a.flagEnabled)(s2, "relativeContentPathsByDefault");
        })(),
        files: (() => {
          let { content: e2, purge: r2 } = s2;
          return Array.isArray(r2) ? r2 : Array.isArray(r2 == null ? void 0 : r2.content) ? r2.content : Array.isArray(e2) ? e2 : Array.isArray(e2 == null ? void 0 : e2.content) ? e2.content : Array.isArray(e2 == null ? void 0 : e2.files) ? e2.files : [];
        })(),
        extract: (() => {
          let e2 = (() => {
            var o2, v3, m, n2, d2, _3, w3, y2, x, g2;
            return !((o2 = s2.purge) === null || o2 === void 0) && o2.extract ? s2.purge.extract : !((v3 = s2.content) === null || v3 === void 0) && v3.extract ? s2.content.extract : !((m = s2.purge) === null || m === void 0 || (n2 = m.extract) === null || n2 === void 0) && n2.DEFAULT ? s2.purge.extract.DEFAULT : !((d2 = s2.content) === null || d2 === void 0 || (_3 = d2.extract) === null || _3 === void 0) && _3.DEFAULT ? s2.content.extract.DEFAULT : !((w3 = s2.purge) === null || w3 === void 0 || (y2 = w3.options) === null || y2 === void 0) && y2.extractors ? s2.purge.options.extractors : !((x = s2.content) === null || x === void 0 || (g2 = x.options) === null || g2 === void 0) && g2.extractors ? s2.content.options.extractors : {};
          })(), r2 = {}, i = (() => {
            var o2, v3, m, n2;
            if (!((o2 = s2.purge) === null || o2 === void 0 || (v3 = o2.options) === null || v3 === void 0) && v3.defaultExtractor)
              return s2.purge.options.defaultExtractor;
            if (!((m = s2.content) === null || m === void 0 || (n2 = m.options) === null || n2 === void 0) && n2.defaultExtractor)
              return s2.content.options.defaultExtractor;
          })();
          if (i !== void 0 && (r2.DEFAULT = i), typeof e2 == "function")
            r2.DEFAULT = e2;
          else if (Array.isArray(e2))
            for (let { extensions: o2, extractor: v3 } of e2 ?? [])
              for (let m of o2)
                r2[m] = v3;
          else typeof e2 == "object" && e2 !== null && Object.assign(r2, e2);
          return r2;
        })(),
        transform: (() => {
          let e2 = (() => {
            var i, o2, v3, m, n2, d2;
            return !((i = s2.purge) === null || i === void 0) && i.transform ? s2.purge.transform : !((o2 = s2.content) === null || o2 === void 0) && o2.transform ? s2.content.transform : !((v3 = s2.purge) === null || v3 === void 0 || (m = v3.transform) === null || m === void 0) && m.DEFAULT ? s2.purge.transform.DEFAULT : !((n2 = s2.content) === null || n2 === void 0 || (d2 = n2.transform) === null || d2 === void 0) && d2.DEFAULT ? s2.content.transform.DEFAULT : {};
          })(), r2 = {};
          return typeof e2 == "function" ? r2.DEFAULT = e2 : typeof e2 == "object" && e2 !== null && Object.assign(r2, e2), r2;
        })()
      };
      for (let e2 of s2.content.files)
        if (typeof e2 == "string" && /{([^,]*?)}/g.test(e2)) {
          h2.default.warn("invalid-glob-braces", [
            `The glob pattern ${(0, h2.dim)(e2)} in your Tailwind CSS configuration is invalid.`,
            `Update it to ${(0, h2.dim)(e2.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
          ]);
          break;
        }
      return s2;
    }
  })(xi2)), xi2;
}
var Oi2 = {};
var sl;
function fc() {
  return sl || (sl = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "cloneDeep", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      return Array.isArray(h2) ? h2.map((p) => a(p)) : typeof h2 == "object" && h2 !== null ? Object.fromEntries(Object.entries(h2).map(([p, l2]) => [
        p,
        a(l2)
      ])) : h2;
    }
  })(Oi2)), Oi2;
}
var ol;
function cc() {
  return ol || (ol = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return q2;
      }
    });
    const a = /* @__PURE__ */ v3(ji2()), h2 = /* @__PURE__ */ v3(ac()), p = /* @__PURE__ */ v3(sc()), l2 = /* @__PURE__ */ v3(oc()), f = lc(), s2 = Wi2(), c2 = uc(), t8 = /* @__PURE__ */ v3(ut3()), e2 = fc(), r2 = gr3(), i = hr3(), o2 = /* @__PURE__ */ v3(iu3());
    function v3(M2) {
      return M2 && M2.__esModule ? M2 : {
        default: M2
      };
    }
    function m(M2) {
      return typeof M2 == "function";
    }
    function n2(M2, ...W3) {
      let S3 = W3.pop();
      for (let P3 of W3)
        for (let C in P3) {
          let R3 = S3(M2[C], P3[C]);
          R3 === void 0 ? (0, t8.default)(M2[C]) && (0, t8.default)(P3[C]) ? M2[C] = n2({}, M2[C], P3[C], S3) : M2[C] = P3[C] : M2[C] = R3;
        }
      return M2;
    }
    const d2 = {
      colors: l2.default,
      negative(M2) {
        return Object.keys(M2).filter((W3) => M2[W3] !== "0").reduce((W3, S3) => {
          let P3 = (0, a.default)(M2[S3]);
          return P3 !== void 0 && (W3[`-${S3}`] = P3), W3;
        }, {});
      },
      breakpoints(M2) {
        return Object.keys(M2).filter((W3) => typeof M2[W3] == "string").reduce((W3, S3) => ({
          ...W3,
          [`screen-${S3}`]: M2[S3]
        }), {});
      }
    };
    function _3(M2, ...W3) {
      return m(M2) ? M2(...W3) : M2;
    }
    function w3(M2) {
      return M2.reduce((W3, { extend: S3 }) => n2(W3, S3, (P3, C) => P3 === void 0 ? [
        C
      ] : Array.isArray(P3) ? [
        C,
        ...P3
      ] : [
        C,
        P3
      ]), {});
    }
    function y2(M2) {
      return {
        ...M2.reduce((W3, S3) => (0, f.defaults)(W3, S3), {}),
        // In order to resolve n config objects, we combine all of their `extend` properties
        // into arrays instead of objects so they aren't overridden.
        extend: w3(M2)
      };
    }
    function x(M2, W3) {
      if (Array.isArray(M2) && (0, t8.default)(M2[0]))
        return M2.concat(W3);
      if (Array.isArray(W3) && (0, t8.default)(W3[0]) && (0, t8.default)(M2))
        return [
          M2,
          ...W3
        ];
      if (Array.isArray(W3))
        return W3;
    }
    function g2({ extend: M2, ...W3 }) {
      return n2(W3, M2, (S3, P3) => !m(S3) && !P3.some(m) ? n2({}, S3, ...P3, x) : (C, R3) => n2({}, ...[
        S3,
        ...P3
      ].map(($2) => _3($2, C, R3)), x));
    }
    function* O3(M2) {
      let W3 = (0, s2.toPath)(M2);
      if (W3.length === 0 || (yield W3, Array.isArray(M2)))
        return;
      let S3 = /^(.*?)\s*\/\s*([^/]+)$/, P3 = M2.match(S3);
      if (P3 !== null) {
        let [, C, R3] = P3, $2 = (0, s2.toPath)(C);
        $2.alpha = R3, yield $2;
      }
    }
    function A(M2) {
      const W3 = (S3, P3) => {
        for (const C of O3(S3)) {
          let R3 = 0, $2 = M2;
          for (; $2 != null && R3 < C.length; )
            $2 = $2[C[R3++]], $2 = m($2) && (C.alpha === void 0 || R3 <= C.length - 1) ? $2(W3, d2) : $2;
          if ($2 !== void 0) {
            if (C.alpha !== void 0) {
              let B3 = (0, r2.parseColorFormat)($2);
              return (0, i.withAlphaValue)(B3, C.alpha, (0, o2.default)(B3));
            }
            return (0, t8.default)($2) ? (0, e2.cloneDeep)($2) : $2;
          }
        }
        return P3;
      };
      return Object.assign(W3, {
        theme: W3,
        ...d2
      }), Object.keys(M2).reduce((S3, P3) => (S3[P3] = m(M2[P3]) ? M2[P3](W3, d2) : M2[P3], S3), {});
    }
    function E2(M2) {
      let W3 = [];
      return M2.forEach((S3) => {
        W3 = [
          ...W3,
          S3
        ];
        var P3;
        const C = (P3 = S3 == null ? void 0 : S3.plugins) !== null && P3 !== void 0 ? P3 : [];
        C.length !== 0 && C.forEach((R3) => {
          R3.__isOptionsFunction && (R3 = R3());
          var $2;
          W3 = [
            ...W3,
            ...E2([
              ($2 = R3 == null ? void 0 : R3.config) !== null && $2 !== void 0 ? $2 : {}
            ])
          ];
        });
      }), W3;
    }
    function b3(M2) {
      return [
        ...M2
      ].reduceRight((S3, P3) => m(P3) ? P3({
        corePlugins: S3
      }) : (0, p.default)(P3, S3), h2.default);
    }
    function k3(M2) {
      return [
        ...M2
      ].reduceRight((S3, P3) => [
        ...S3,
        ...P3
      ], []);
    }
    function q2(M2) {
      let W3 = [
        ...E2(M2),
        {
          prefix: "",
          important: false,
          separator: ":"
        }
      ];
      var S3, P3;
      return (0, c2.normalizeConfig)((0, f.defaults)({
        theme: A(g2(y2(W3.map((C) => (S3 = C == null ? void 0 : C.theme) !== null && S3 !== void 0 ? S3 : {})))),
        corePlugins: b3(W3.map((C) => C.corePlugins)),
        plugins: k3(M2.map((C) => (P3 = C == null ? void 0 : C.plugins) !== null && P3 !== void 0 ? P3 : []))
      }, ...W3));
    }
  })(yi2)), yi2;
}
var ki2 = {};
var Pi2;
var ll;
function dc() {
  return ll || (ll = 1, Pi2 = {
    content: [],
    presets: [],
    darkMode: "media",
    // or 'class'
    theme: {
      accentColor: ({ theme: u }) => ({
        ...u("colors"),
        auto: "auto"
      }),
      animation: {
        none: "none",
        spin: "spin 1s linear infinite",
        ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
        pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
        bounce: "bounce 1s infinite"
      },
      aria: {
        busy: 'busy="true"',
        checked: 'checked="true"',
        disabled: 'disabled="true"',
        expanded: 'expanded="true"',
        hidden: 'hidden="true"',
        pressed: 'pressed="true"',
        readonly: 'readonly="true"',
        required: 'required="true"',
        selected: 'selected="true"'
      },
      aspectRatio: {
        auto: "auto",
        square: "1 / 1",
        video: "16 / 9"
      },
      backdropBlur: ({ theme: u }) => u("blur"),
      backdropBrightness: ({ theme: u }) => u("brightness"),
      backdropContrast: ({ theme: u }) => u("contrast"),
      backdropGrayscale: ({ theme: u }) => u("grayscale"),
      backdropHueRotate: ({ theme: u }) => u("hueRotate"),
      backdropInvert: ({ theme: u }) => u("invert"),
      backdropOpacity: ({ theme: u }) => u("opacity"),
      backdropSaturate: ({ theme: u }) => u("saturate"),
      backdropSepia: ({ theme: u }) => u("sepia"),
      backgroundColor: ({ theme: u }) => u("colors"),
      backgroundImage: {
        none: "none",
        "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
        "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
        "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
        "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
        "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
        "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
        "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
        "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
      },
      backgroundOpacity: ({ theme: u }) => u("opacity"),
      backgroundPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
      },
      backgroundSize: {
        auto: "auto",
        cover: "cover",
        contain: "contain"
      },
      blur: {
        0: "0",
        none: "",
        sm: "4px",
        DEFAULT: "8px",
        md: "12px",
        lg: "16px",
        xl: "24px",
        "2xl": "40px",
        "3xl": "64px"
      },
      borderColor: ({ theme: u }) => ({
        ...u("colors"),
        DEFAULT: u("colors.gray.200", "currentColor")
      }),
      borderOpacity: ({ theme: u }) => u("opacity"),
      borderRadius: {
        none: "0px",
        sm: "0.125rem",
        DEFAULT: "0.25rem",
        md: "0.375rem",
        lg: "0.5rem",
        xl: "0.75rem",
        "2xl": "1rem",
        "3xl": "1.5rem",
        full: "9999px"
      },
      borderSpacing: ({ theme: u }) => ({
        ...u("spacing")
      }),
      borderWidth: {
        DEFAULT: "1px",
        0: "0px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      boxShadow: {
        sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
        DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
        md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
        lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
        xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
        "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
        inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
        none: "none"
      },
      boxShadowColor: ({ theme: u }) => u("colors"),
      brightness: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        200: "2"
      },
      caretColor: ({ theme: u }) => u("colors"),
      colors: ({ colors: u }) => ({
        inherit: u.inherit,
        current: u.current,
        transparent: u.transparent,
        black: u.black,
        white: u.white,
        slate: u.slate,
        gray: u.gray,
        zinc: u.zinc,
        neutral: u.neutral,
        stone: u.stone,
        red: u.red,
        orange: u.orange,
        amber: u.amber,
        yellow: u.yellow,
        lime: u.lime,
        green: u.green,
        emerald: u.emerald,
        teal: u.teal,
        cyan: u.cyan,
        sky: u.sky,
        blue: u.blue,
        indigo: u.indigo,
        violet: u.violet,
        purple: u.purple,
        fuchsia: u.fuchsia,
        pink: u.pink,
        rose: u.rose
      }),
      columns: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        "3xs": "16rem",
        "2xs": "18rem",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem"
      },
      container: {},
      content: {
        none: "none"
      },
      contrast: {
        0: "0",
        50: ".5",
        75: ".75",
        100: "1",
        125: "1.25",
        150: "1.5",
        200: "2"
      },
      cursor: {
        auto: "auto",
        default: "default",
        pointer: "pointer",
        wait: "wait",
        text: "text",
        move: "move",
        help: "help",
        "not-allowed": "not-allowed",
        none: "none",
        "context-menu": "context-menu",
        progress: "progress",
        cell: "cell",
        crosshair: "crosshair",
        "vertical-text": "vertical-text",
        alias: "alias",
        copy: "copy",
        "no-drop": "no-drop",
        grab: "grab",
        grabbing: "grabbing",
        "all-scroll": "all-scroll",
        "col-resize": "col-resize",
        "row-resize": "row-resize",
        "n-resize": "n-resize",
        "e-resize": "e-resize",
        "s-resize": "s-resize",
        "w-resize": "w-resize",
        "ne-resize": "ne-resize",
        "nw-resize": "nw-resize",
        "se-resize": "se-resize",
        "sw-resize": "sw-resize",
        "ew-resize": "ew-resize",
        "ns-resize": "ns-resize",
        "nesw-resize": "nesw-resize",
        "nwse-resize": "nwse-resize",
        "zoom-in": "zoom-in",
        "zoom-out": "zoom-out"
      },
      divideColor: ({ theme: u }) => u("borderColor"),
      divideOpacity: ({ theme: u }) => u("borderOpacity"),
      divideWidth: ({ theme: u }) => u("borderWidth"),
      dropShadow: {
        sm: "0 1px 1px rgb(0 0 0 / 0.05)",
        DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
        md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
        lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
        xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
        "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
        none: "0 0 #0000"
      },
      fill: ({ theme: u }) => ({
        none: "none",
        ...u("colors")
      }),
      flex: {
        1: "1 1 0%",
        auto: "1 1 auto",
        initial: "0 1 auto",
        none: "none"
      },
      flexBasis: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        "1/12": "8.333333%",
        "2/12": "16.666667%",
        "3/12": "25%",
        "4/12": "33.333333%",
        "5/12": "41.666667%",
        "6/12": "50%",
        "7/12": "58.333333%",
        "8/12": "66.666667%",
        "9/12": "75%",
        "10/12": "83.333333%",
        "11/12": "91.666667%",
        full: "100%"
      }),
      flexGrow: {
        0: "0",
        DEFAULT: "1"
      },
      flexShrink: {
        0: "0",
        DEFAULT: "1"
      },
      fontFamily: {
        sans: [
          "ui-sans-serif",
          "system-ui",
          "sans-serif",
          '"Apple Color Emoji"',
          '"Segoe UI Emoji"',
          '"Segoe UI Symbol"',
          '"Noto Color Emoji"'
        ],
        serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
        mono: [
          "ui-monospace",
          "SFMono-Regular",
          "Menlo",
          "Monaco",
          "Consolas",
          '"Liberation Mono"',
          '"Courier New"',
          "monospace"
        ]
      },
      fontSize: {
        xs: ["0.75rem", { lineHeight: "1rem" }],
        sm: ["0.875rem", { lineHeight: "1.25rem" }],
        base: ["1rem", { lineHeight: "1.5rem" }],
        lg: ["1.125rem", { lineHeight: "1.75rem" }],
        xl: ["1.25rem", { lineHeight: "1.75rem" }],
        "2xl": ["1.5rem", { lineHeight: "2rem" }],
        "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
        "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
        "5xl": ["3rem", { lineHeight: "1" }],
        "6xl": ["3.75rem", { lineHeight: "1" }],
        "7xl": ["4.5rem", { lineHeight: "1" }],
        "8xl": ["6rem", { lineHeight: "1" }],
        "9xl": ["8rem", { lineHeight: "1" }]
      },
      fontWeight: {
        thin: "100",
        extralight: "200",
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700",
        extrabold: "800",
        black: "900"
      },
      gap: ({ theme: u }) => u("spacing"),
      gradientColorStops: ({ theme: u }) => u("colors"),
      gradientColorStopPositions: {
        "0%": "0%",
        "5%": "5%",
        "10%": "10%",
        "15%": "15%",
        "20%": "20%",
        "25%": "25%",
        "30%": "30%",
        "35%": "35%",
        "40%": "40%",
        "45%": "45%",
        "50%": "50%",
        "55%": "55%",
        "60%": "60%",
        "65%": "65%",
        "70%": "70%",
        "75%": "75%",
        "80%": "80%",
        "85%": "85%",
        "90%": "90%",
        "95%": "95%",
        "100%": "100%"
      },
      grayscale: {
        0: "0",
        DEFAULT: "100%"
      },
      gridAutoColumns: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
      },
      gridAutoRows: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
      },
      gridColumn: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
      },
      gridColumnEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridColumnStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridRow: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
      },
      gridRowEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridRowStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridTemplateColumns: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))"
      },
      gridTemplateRows: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))"
      },
      height: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        full: "100%",
        screen: "100vh",
        svh: "100svh",
        lvh: "100lvh",
        dvh: "100dvh",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      hueRotate: {
        0: "0deg",
        15: "15deg",
        30: "30deg",
        60: "60deg",
        90: "90deg",
        180: "180deg"
      },
      inset: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        full: "100%"
      }),
      invert: {
        0: "0",
        DEFAULT: "100%"
      },
      keyframes: {
        spin: {
          to: {
            transform: "rotate(360deg)"
          }
        },
        ping: {
          "75%, 100%": {
            transform: "scale(2)",
            opacity: "0"
          }
        },
        pulse: {
          "50%": {
            opacity: ".5"
          }
        },
        bounce: {
          "0%, 100%": {
            transform: "translateY(-25%)",
            animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
          },
          "50%": {
            transform: "none",
            animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
          }
        }
      },
      letterSpacing: {
        tighter: "-0.05em",
        tight: "-0.025em",
        normal: "0em",
        wide: "0.025em",
        wider: "0.05em",
        widest: "0.1em"
      },
      lineHeight: {
        none: "1",
        tight: "1.25",
        snug: "1.375",
        normal: "1.5",
        relaxed: "1.625",
        loose: "2",
        3: ".75rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem"
      },
      listStyleType: {
        none: "none",
        disc: "disc",
        decimal: "decimal"
      },
      listStyleImage: {
        none: "none"
      },
      margin: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing")
      }),
      lineClamp: {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6"
      },
      maxHeight: ({ theme: u }) => ({
        ...u("spacing"),
        none: "none",
        full: "100%",
        screen: "100vh",
        svh: "100svh",
        lvh: "100lvh",
        dvh: "100dvh",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      maxWidth: ({ theme: u, breakpoints: a }) => ({
        ...u("spacing"),
        none: "none",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem",
        full: "100%",
        min: "min-content",
        max: "max-content",
        fit: "fit-content",
        prose: "65ch",
        ...a(u("screens"))
      }),
      minHeight: ({ theme: u }) => ({
        ...u("spacing"),
        full: "100%",
        screen: "100vh",
        svh: "100svh",
        lvh: "100lvh",
        dvh: "100dvh",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      minWidth: ({ theme: u }) => ({
        ...u("spacing"),
        full: "100%",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      objectPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
      },
      opacity: {
        0: "0",
        5: "0.05",
        10: "0.1",
        15: "0.15",
        20: "0.2",
        25: "0.25",
        30: "0.3",
        35: "0.35",
        40: "0.4",
        45: "0.45",
        50: "0.5",
        55: "0.55",
        60: "0.6",
        65: "0.65",
        70: "0.7",
        75: "0.75",
        80: "0.8",
        85: "0.85",
        90: "0.9",
        95: "0.95",
        100: "1"
      },
      order: {
        first: "-9999",
        last: "9999",
        none: "0",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12"
      },
      outlineColor: ({ theme: u }) => u("colors"),
      outlineOffset: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      outlineWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      padding: ({ theme: u }) => u("spacing"),
      placeholderColor: ({ theme: u }) => u("colors"),
      placeholderOpacity: ({ theme: u }) => u("opacity"),
      ringColor: ({ theme: u }) => ({
        DEFAULT: u("colors.blue.500", "#3b82f6"),
        ...u("colors")
      }),
      ringOffsetColor: ({ theme: u }) => u("colors"),
      ringOffsetWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      ringOpacity: ({ theme: u }) => ({
        DEFAULT: "0.5",
        ...u("opacity")
      }),
      ringWidth: {
        DEFAULT: "3px",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      rotate: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        45: "45deg",
        90: "90deg",
        180: "180deg"
      },
      saturate: {
        0: "0",
        50: ".5",
        100: "1",
        150: "1.5",
        200: "2"
      },
      scale: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5"
      },
      screens: {
        sm: "640px",
        md: "768px",
        lg: "1024px",
        xl: "1280px",
        "2xl": "1536px"
      },
      scrollMargin: ({ theme: u }) => ({
        ...u("spacing")
      }),
      scrollPadding: ({ theme: u }) => u("spacing"),
      sepia: {
        0: "0",
        DEFAULT: "100%"
      },
      skew: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg"
      },
      space: ({ theme: u }) => ({
        ...u("spacing")
      }),
      spacing: {
        px: "1px",
        0: "0px",
        0.5: "0.125rem",
        1: "0.25rem",
        1.5: "0.375rem",
        2: "0.5rem",
        2.5: "0.625rem",
        3: "0.75rem",
        3.5: "0.875rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem",
        11: "2.75rem",
        12: "3rem",
        14: "3.5rem",
        16: "4rem",
        20: "5rem",
        24: "6rem",
        28: "7rem",
        32: "8rem",
        36: "9rem",
        40: "10rem",
        44: "11rem",
        48: "12rem",
        52: "13rem",
        56: "14rem",
        60: "15rem",
        64: "16rem",
        72: "18rem",
        80: "20rem",
        96: "24rem"
      },
      stroke: ({ theme: u }) => ({
        none: "none",
        ...u("colors")
      }),
      strokeWidth: {
        0: "0",
        1: "1",
        2: "2"
      },
      supports: {},
      data: {},
      textColor: ({ theme: u }) => u("colors"),
      textDecorationColor: ({ theme: u }) => u("colors"),
      textDecorationThickness: {
        auto: "auto",
        "from-font": "from-font",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      textIndent: ({ theme: u }) => ({
        ...u("spacing")
      }),
      textOpacity: ({ theme: u }) => u("opacity"),
      textUnderlineOffset: {
        auto: "auto",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      transformOrigin: {
        center: "center",
        top: "top",
        "top-right": "top right",
        right: "right",
        "bottom-right": "bottom right",
        bottom: "bottom",
        "bottom-left": "bottom left",
        left: "left",
        "top-left": "top left"
      },
      transitionDelay: {
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms"
      },
      transitionDuration: {
        DEFAULT: "150ms",
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms"
      },
      transitionProperty: {
        none: "none",
        all: "all",
        DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
        colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
        opacity: "opacity",
        shadow: "box-shadow",
        transform: "transform"
      },
      transitionTimingFunction: {
        DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
        linear: "linear",
        in: "cubic-bezier(0.4, 0, 1, 1)",
        out: "cubic-bezier(0, 0, 0.2, 1)",
        "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
      },
      translate: ({ theme: u }) => ({
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        full: "100%"
      }),
      size: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        "1/12": "8.333333%",
        "2/12": "16.666667%",
        "3/12": "25%",
        "4/12": "33.333333%",
        "5/12": "41.666667%",
        "6/12": "50%",
        "7/12": "58.333333%",
        "8/12": "66.666667%",
        "9/12": "75%",
        "10/12": "83.333333%",
        "11/12": "91.666667%",
        full: "100%",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      width: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        "1/12": "8.333333%",
        "2/12": "16.666667%",
        "3/12": "25%",
        "4/12": "33.333333%",
        "5/12": "41.666667%",
        "6/12": "50%",
        "7/12": "58.333333%",
        "8/12": "66.666667%",
        "9/12": "75%",
        "10/12": "83.333333%",
        "11/12": "91.666667%",
        full: "100%",
        screen: "100vw",
        svw: "100svw",
        lvw: "100lvw",
        dvw: "100dvw",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      willChange: {
        auto: "auto",
        scroll: "scroll-position",
        contents: "contents",
        transform: "transform"
      },
      zIndex: {
        auto: "auto",
        0: "0",
        10: "10",
        20: "20",
        30: "30",
        40: "40",
        50: "50"
      }
    },
    plugins: []
  }), Pi2;
}
var ul;
function pc() {
  return ul || (ul = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = /* @__PURE__ */ p(dc()), h2 = it3();
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l2(f) {
      var s2;
      const c2 = ((s2 = f == null ? void 0 : f.presets) !== null && s2 !== void 0 ? s2 : [
        a.default
      ]).slice().reverse().flatMap((r2) => l2(r2 instanceof Function ? r2() : r2)), t8 = {
        // Add experimental configs here...
        respectDefaultRingColorOpacity: {
          theme: {
            ringColor: ({ theme: r2 }) => ({
              DEFAULT: "#3b82f67f",
              ...r2("colors")
            })
          }
        },
        disableColorOpacityUtilitiesByDefault: {
          corePlugins: {
            backgroundOpacity: false,
            borderOpacity: false,
            divideOpacity: false,
            placeholderOpacity: false,
            ringOpacity: false,
            textOpacity: false
          }
        }
      }, e2 = Object.keys(t8).filter((r2) => (0, h2.flagEnabled)(f, r2)).map((r2) => t8[r2]);
      return [
        f,
        ...e2,
        ...c2
      ];
    }
  })(ki2)), ki2;
}
var fl;
function hc() {
  return fl || (fl = 1, (function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l2;
      }
    });
    const a = /* @__PURE__ */ p(cc()), h2 = /* @__PURE__ */ p(pc());
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l2(...f) {
      let [, ...s2] = (0, h2.default)(f[0]);
      return (0, a.default)([
        ...f,
        ...s2
      ]);
    }
  })(mi2)), mi2;
}
var Ei;
var cl;
function vc() {
  if (cl) return Ei;
  cl = 1;
  let u = hc();
  return Ei = (u.__esModule ? u : { default: u }).default, Ei;
}
var gc = vc();
var mc = /* @__PURE__ */ He3(gc);
var yc = (u) => ic.createContext(
  mc({
    ...u,
    content: [],
    corePlugins: {
      preflight: false
    }
  })
);
var wc = _u2(
  `
  @tailwind base;
  @tailwind components;
`
).root();
function bc(u) {
  "safelist" in u && (console.warn(
    "The `safelist` option is not supported in the `Tailwind` component, it will not change any behavior."
  ), delete u.safelist);
  const a = yc(u);
  return {
    generateRootForClasses: (h2) => {
      a.candidateRuleCache = /* @__PURE__ */ new Map();
      const p = Yf.generateRules(
        new Set(h2),
        a
      ), l2 = wc.clone().append(...p.map(([, f]) => f));
      return Xo3()(l2), Gf(a)(l2), Xo3()(l2), $f(a)(l2), ff(a)(l2), tc(a)(l2), Xf(a)(l2), Hu2()(l2), Xu2()(l2), nc(l2), l2;
    }
  };
}
var Oc = ({ children: u, config: a }) => {
  const h2 = bc(a ?? {}), p = new Ou2();
  let l2 = [], f = false, s2 = sr3(u, (c2) => {
    if (Or3.isValidElement(c2)) {
      const {
        elementWithInlinedStyles: t8,
        nonInlinableClasses: e2,
        nonInlineStyleNodes: r2
      } = Gu2(c2, h2);
      return l2 = l2.concat(e2), p.append(r2), e2.length > 0 && !f && (f = true), t8;
    }
    return c2;
  });
  if (Pu2(p), f) {
    let c2 = false;
    if (s2 = sr3(s2, (t8) => {
      if (c2)
        return t8;
      if (Or3.isValidElement(t8) && t8.type === "head") {
        c2 = true;
        const e2 = /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("style", { children: ku2(p.toString().trim()) });
        return Or3.cloneElement(
          t8,
          t8.props,
          t8.props.children,
          e2
        );
      }
      return t8;
    }), !c2)
      throw new Error(
        `You are trying to use the following Tailwind classes that cannot be inlined: ${l2.join(
          " "
        )}.
For the media queries to work properly on rendering, they need to be added into a <style> tag inside of a <head> tag,
the Tailwind component tried finding a <head> element but just wasn't able to find it.

Make sure that you have a <head> element at some point inside of the <Tailwind> component at any depth. 
This can also be our <Head> component.

If you do already have a <head> element at some depth, 
please file a bug https://github.com/resend/react-email/issues/new?assignees=&labels=Type%3A+Bug&projects=&template=1.bug_report.yml.`
      );
  }
  return s2;
};

// node_modules/@react-email/text/dist/index.mjs
var React10 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var __defProp12 = Object.defineProperty;
var __defProps11 = Object.defineProperties;
var __getOwnPropDescs11 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols11 = Object.getOwnPropertySymbols;
var __hasOwnProp12 = Object.prototype.hasOwnProperty;
var __propIsEnum11 = Object.prototype.propertyIsEnumerable;
var __defNormalProp11 = (obj, key, value) => key in obj ? __defProp12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues11 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp12.call(b3, prop))
      __defNormalProp11(a, prop, b3[prop]);
  if (__getOwnPropSymbols11)
    for (var prop of __getOwnPropSymbols11(b3)) {
      if (__propIsEnum11.call(b3, prop))
        __defNormalProp11(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps11 = (a, b3) => __defProps11(a, __getOwnPropDescs11(b3));
var __objRest10 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp12.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols11)
    for (var prop of __getOwnPropSymbols11(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum11.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function parseMarginValue(value) {
  if (typeof value === "number")
    return {
      marginTop: value,
      marginBottom: value,
      marginLeft: value,
      marginRight: value
    };
  if (typeof value === "string") {
    const values = value.toString().trim().split(/\s+/);
    if (values.length === 1) {
      return {
        marginTop: values[0],
        marginBottom: values[0],
        marginLeft: values[0],
        marginRight: values[0]
      };
    }
    if (values.length === 2) {
      return {
        marginTop: values[0],
        marginRight: values[1],
        marginBottom: values[0],
        marginLeft: values[1]
      };
    }
    if (values.length === 3) {
      return {
        marginTop: values[0],
        marginRight: values[1],
        marginBottom: values[2],
        marginLeft: values[1]
      };
    }
    if (values.length === 4) {
      return {
        marginTop: values[0],
        marginRight: values[1],
        marginBottom: values[2],
        marginLeft: values[3]
      };
    }
  }
  return {
    marginTop: void 0,
    marginBottom: void 0,
    marginLeft: void 0,
    marginRight: void 0
  };
}
function computeMargins(properties) {
  let result = {
    marginTop: void 0,
    marginRight: void 0,
    marginBottom: void 0,
    marginLeft: void 0
  };
  for (const [key, value] of Object.entries(properties)) {
    if (key === "margin") {
      result = parseMarginValue(value);
    } else if (key === "marginTop") {
      result.marginTop = value;
    } else if (key === "marginRight") {
      result.marginRight = value;
    } else if (key === "marginBottom") {
      result.marginBottom = value;
    } else if (key === "marginLeft") {
      result.marginLeft = value;
    }
  }
  return result;
}
var Text3 = React10.forwardRef(
  (_a4, ref) => {
    var _b = _a4, { style } = _b, props = __objRest10(_b, ["style"]);
    const defaultMargins = {};
    if ((style == null ? void 0 : style.marginTop) === void 0) {
      defaultMargins.marginTop = "16px";
    }
    if ((style == null ? void 0 : style.marginBottom) === void 0) {
      defaultMargins.marginBottom = "16px";
    }
    const margins = computeMargins(__spreadValues11(__spreadValues11({}, defaultMargins), style));
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
      "p",
      __spreadProps11(__spreadValues11({}, props), {
        ref,
        style: __spreadValues11(__spreadValues11({
          fontSize: "14px",
          lineHeight: "24px"
        }, style), margins)
      })
    );
  }
);
Text3.displayName = "Text";

// emails/Farcaster.jsx
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
function FarcasterEmail({ story = { metadata: { farcasterCast: { author: {} } } } }) {
  const {
    href,
    metadata,
    displayName
  } = story;
  const extractedDomain = "farcaster.xyz";
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(Html, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(Head, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("meta", { name: "viewport", content: "width=device-width, initial-scale=1.0" }),
      /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("link", { rel: "preconnect", href: "https://fonts.googleapis.com" }),
      /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("link", { rel: "stylesheet", href: "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Oc, { children: /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(Body, { style: main, children: [
      /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Container, { style: container, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(Column, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Section, { style: { ...farcasterEmbedContainer, backgroundColor: "#ffffff", borderBottom: "1px solid #e6e6df" }, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(Link, { href, style: { ...previewContainer, color: "#000000 !important", textDecoration: "none" }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(Row, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Column, { width: "30", children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
              Img,
              {
                src: metadata.farcasterCast.author.pfp,
                alt: metadata.farcasterCast.author.username || "Author",
                width: "20",
                height: "20",
                style: { borderRadius: "9999px", marginRight: "8px" }
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Column, { children: /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(Text3, { style: { fontWeight: 600, color: "#12212b", fontSize: "14px" }, children: [
              "@",
              metadata.farcasterCast.author.username || "farcaster"
            ] }) })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Text3, { children: metadata.farcasterCast.text }),
          metadata.farcasterCast.embeds[0] && /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
            Img,
            {
              src: metadata.farcasterCast.embeds[0].url,
              alt: "Farcaster image",
              width: "100%",
              style: { marginTop: "12px", objectFit: "cover" }
            }
          )
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Section, { style: { padding: "12px 20px 10px 12px", backgroundColor: "#f6f6ef" }, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(Text3, { style: { fontSize: "9pt", marginTop: "3px", marginBottom: "0", lineHeight: "1.4", color: "#666" }, children: [
          "submitted by ",
          /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Link, { href: `https://news.kiwistand.com/upvotes?address=${story.identity}`, style: { fontWeight: 600, color: "#000000 !important", textDecoration: "none" }, children: displayName }),
          " \u2022 ",
          /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Link, { href, style: { color: "#000000 !important", textDecoration: "none" }, children: extractedDomain })
        ] }) })
      ] }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Container, { style: { margin: "0 auto", maxWidth: "580px" }, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Section, { style: { padding: "12px 0" }, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Link, { href, style: buttonStyle, children: "GO TO STORY" }) }) })
    ] }) })
  ] });
}
var main = {
  backgroundColor: "#fffffa",
  fontFamily: "'Inter', Verdana, Geneva, sans-serif"
};
var container = {
  margin: "0 auto",
  padding: "0",
  maxWidth: "580px",
  border: "1px solid #e6e6df",
  borderRadius: "3px",
  backgroundColor: "#f6f6ef"
};
var previewContainer = {
  textDecoration: "none",
  color: "inherit",
  display: "block"
};
var farcasterEmbedContainer = {
  padding: "12px",
  backgroundColor: "#ffffff"
};
var buttonStyle = {
  backgroundColor: "#000000",
  color: "#ffffff !important",
  padding: "10px 20px",
  borderRadius: "0",
  textDecoration: "none",
  display: "inline-block",
  fontSize: "14px"
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  reactEmailCreateReactElement,
  render
});
/*! Bundled license information:

react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.js:
  (**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server-legacy.node.production.js:
  (**
   * @license React
   * react-dom-server-legacy.node.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.node.production.js:
  (**
   * @license React
   * react-dom-server.node.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server-legacy.node.development.js:
  (**
   * @license React
   * react-dom-server-legacy.node.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.node.development.js:
  (**
   * @license React
   * react-dom-server.node.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@react-email/tailwind/dist/index.mjs:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)
*/
